Unity Editor version:    2021.3.16f1 (4016570cf34f)
Branch:                  2021.3/staging
Build type:              Release
Batch mode:              YES
macOS version:           Version 10.15.7 (Build 19H2026)
Darwin version:          19.6.0
Architecture:            x86_64
Running under Rosetta:   NO
Available memory:        8192 MB
Using pre-set license
Pro License: YES

COMMAND LINE ARGUMENTS:
/Applications/Unity/Hub/Editor/2021.3.16f1/Unity.app/Contents/MacOS/Unity
-adb2
-batchMode
-noUpm
-name
AssetImportWorker6
-projectPath
/Users/kamilaamendolagine/Desktop/Staugen Raug v2 - Prefab - Map 1.01
-logFile
Logs/AssetImportWorker6.log
-srvPort
52963
Successfully changed project path to: /Users/kamilaamendolagine/Desktop/Staugen Raug v2 - Prefab - Map 1.01
/Users/kamilaamendolagine/Desktop/Staugen Raug v2 - Prefab - Map 1.01
[UnityMemory] Configuration Parameters - Can be set up in boot.config
    "memorysetup-bucket-allocator-granularity=16"
    "memorysetup-bucket-allocator-bucket-count=8"
    "memorysetup-bucket-allocator-block-size=33554432"
    "memorysetup-bucket-allocator-block-count=8"
    "memorysetup-main-allocator-block-size=16777216"
    "memorysetup-thread-allocator-block-size=16777216"
    "memorysetup-gfx-main-allocator-block-size=16777216"
    "memorysetup-gfx-thread-allocator-block-size=16777216"
    "memorysetup-cache-allocator-block-size=4194304"
    "memorysetup-typetree-allocator-block-size=2097152"
    "memorysetup-profiler-bucket-allocator-granularity=16"
    "memorysetup-profiler-bucket-allocator-bucket-count=8"
    "memorysetup-profiler-bucket-allocator-block-size=33554432"
    "memorysetup-profiler-bucket-allocator-block-count=8"
    "memorysetup-profiler-allocator-block-size=16777216"
    "memorysetup-profiler-editor-allocator-block-size=1048576"
    "memorysetup-temp-allocator-size-main=16777216"
    "memorysetup-job-temp-allocator-block-size=2097152"
    "memorysetup-job-temp-allocator-block-size-background=1048576"
    "memorysetup-job-temp-allocator-reduction-small-platforms=262144"
    "memorysetup-temp-allocator-size-background-worker=32768"
    "memorysetup-temp-allocator-size-job-worker=262144"
    "memorysetup-temp-allocator-size-preload-manager=33554432"
    "memorysetup-temp-allocator-size-nav-mesh-worker=65536"
    "memorysetup-temp-allocator-size-audio-worker=65536"
    "memorysetup-temp-allocator-size-cloud-worker=32768"
    "memorysetup-temp-allocator-size-gi-baking-worker=262144"
    "memorysetup-temp-allocator-size-gfx=262144"
Player connection [4849929664] Host "[IP] 192.168.1.66 [Port] 0 [Flags] 2 [Guid] 2414905912 [EditorId] 2414905912 [Version] 1048832 [Id] OSXEditor(0,Kamilas-MacBook-Pro.local) [Debug] 1 [PackageName] OSXEditor [ProjectName] Editor" joined multi-casting on [225.0.0.222:54997]...

Player connection [4849929664] Host "[IP] 192.168.1.66 [Port] 0 [Flags] 2 [Guid] 2414905912 [EditorId] 2414905912 [Version] 1048832 [Id] OSXEditor(0,Kamilas-MacBook-Pro.local) [Debug] 1 [PackageName] OSXEditor [ProjectName] Editor" joined alternative multi-casting on [225.0.0.222:34997]...

Refreshing native plugins compatible for Editor in 145.38 ms, found 2 plugins.
Preloading 0 native plugins for Editor in 0.00 ms.
Initialize engine version: 2021.3.16f1 (4016570cf34f)
[Subsystems] Discovering subsystems at path /Applications/Unity/Hub/Editor/2021.3.16f1/Unity.app/Contents/Resources/UnitySubsystems
[Subsystems] Discovering subsystems at path /Users/kamilaamendolagine/Desktop/Staugen Raug v2 - Prefab - Map 1.01/Assets
GfxDevice: creating device client; threaded=0; jobified=0
Color LCD preferred device: NVIDIA GeForce GT 650M (high power)
Metal devices available: 2
0: NVIDIA GeForce GT 650M (high power)
1: Intel HD Graphics 4000 (low power)
Using device NVIDIA GeForce GT 650M (high power)
Initializing Metal device caps: NVIDIA GeForce GT 650M
Initialize mono
Mono path[0] = '/Applications/Unity/Hub/Editor/2021.3.16f1/Unity.app/Contents/Managed'
Mono path[1] = '/Applications/Unity/Hub/Editor/2021.3.16f1/Unity.app/Contents/MonoBleedingEdge/lib/mono/unityjit-macos'
Mono config path = '/Applications/Unity/Hub/Editor/2021.3.16f1/Unity.app/Contents/MonoBleedingEdge/etc'
Using monoOptions --debugger-agent=transport=dt_socket,embedding=1,server=y,suspend=n,address=127.0.0.1:56199
Begin MonoManager ReloadAssembly
Registering precompiled unity dll's ...
Register platform support module: /Applications/Unity/Hub/Editor/2021.3.16f1/PlaybackEngines/WebGLSupport/UnityEditor.WebGL.Extensions.dll
Register platform support module: /Applications/Unity/Hub/Editor/2021.3.16f1/Unity.app/Contents/PlaybackEngines/MacStandaloneSupport/UnityEditor.OSXStandalone.Extensions.dll
Registered in 0.002550 seconds.
Native extension for OSXStandalone target not found
Native extension for WebGL target not found
Refreshing native plugins compatible for Editor in 104.57 ms, found 2 plugins.
Preloading 0 native plugins for Editor in 0.00 ms.
Mono: successfully reloaded assembly
- Completed reload, in  1.160 seconds
Domain Reload Profiling:
	ReloadAssembly (1161ms)
		BeginReloadAssembly (83ms)
			ExecutionOrderSort (0ms)
			DisableScriptedObjects (0ms)
			BackupInstance (0ms)
			ReleaseScriptingObjects (0ms)
			CreateAndSetChildDomain (1ms)
		EndReloadAssembly (851ms)
			LoadAssemblies (82ms)
			RebuildTransferFunctionScriptingTraits (0ms)
			SetupTypeCache (209ms)
			ReleaseScriptCaches (0ms)
			RebuildScriptCaches (51ms)
			SetupLoadedEditorAssemblies (514ms)
				LogAssemblyErrors (0ms)
				InitializePlatformSupportModulesInManaged (11ms)
				SetLoadedEditorAssemblies (0ms)
				RefreshPlugins (105ms)
				BeforeProcessingInitializeOnLoad (2ms)
				ProcessInitializeOnLoadAttributes (318ms)
				ProcessInitializeOnLoadMethodAttributes (78ms)
				AfterProcessingInitializeOnLoad (0ms)
				EditorAssembliesLoaded (0ms)
			ExecutionOrderSort2 (0ms)
			AwakeInstancesAfterBackupRestoration (0ms)
Platform modules already initialized, skipping
Registering precompiled user dll's ...
Registered in 0.022960 seconds.
Begin MonoManager ReloadAssembly
Symbol file LoadedFromMemory doesn't match image /Users/kamilaamendolagine/Desktop/Staugen Raug v2 - Prefab - Map 1.01/Library/PackageCache/com.unity.visualscripting@1.7.8/Editor/VisualScripting.Core/Dependencies/YamlDotNet/Unity.VisualScripting.YamlDotNet.dll
Symbol file LoadedFromMemory doesn't match image /Users/kamilaamendolagine/Desktop/Staugen Raug v2 - Prefab - Map 1.01/Library/PackageCache/com.unity.visualscripting@1.7.8/Editor/VisualScripting.Core/Dependencies/DotNetZip/Unity.VisualScripting.IonicZip.dll
Native extension for OSXStandalone target not found
Native extension for WebGL target not found
Refreshing native plugins compatible for Editor in 0.76 ms, found 2 plugins.
Preloading 0 native plugins for Editor in 0.00 ms.
Mono: successfully reloaded assembly
- Completed reload, in  1.961 seconds
Domain Reload Profiling:
	ReloadAssembly (1966ms)
		BeginReloadAssembly (161ms)
			ExecutionOrderSort (0ms)
			DisableScriptedObjects (11ms)
			BackupInstance (0ms)
			ReleaseScriptingObjects (0ms)
			CreateAndSetChildDomain (44ms)
		EndReloadAssembly (1608ms)
			LoadAssemblies (91ms)
			RebuildTransferFunctionScriptingTraits (0ms)
			SetupTypeCache (632ms)
			ReleaseScriptCaches (1ms)
			RebuildScriptCaches (90ms)
			SetupLoadedEditorAssemblies (708ms)
				LogAssemblyErrors (0ms)
				InitializePlatformSupportModulesInManaged (8ms)
				SetLoadedEditorAssemblies (1ms)
				RefreshPlugins (1ms)
				BeforeProcessingInitializeOnLoad (115ms)
				ProcessInitializeOnLoadAttributes (540ms)
				ProcessInitializeOnLoadMethodAttributes (41ms)
				AfterProcessingInitializeOnLoad (3ms)
				EditorAssembliesLoaded (0ms)
			ExecutionOrderSort2 (0ms)
			AwakeInstancesAfterBackupRestoration (6ms)
Platform modules already initialized, skipping
========================================================================
Worker process is ready to serve import requests
Launching external process: /Applications/Unity/Hub/Editor/2021.3.16f1/Unity.app/Contents/Tools/UnityShaderCompiler
Launched and connected shader compiler UnityShaderCompiler after 0.69 seconds
Compilation succeeded with: 

program_source:299:53: warning: writable resources in non-void post-tessellation vertex function
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
                                                    ^
program_source:305:30: note: writable buffer defined here
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
                             ^
program_source:306:48: note: writable buffer defined here
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
                                               ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float4 TEXCOORD0 [[ attribute(3) ]] ;
    float4 TEXCOORD1 [[ attribute(4) ]] ;
    float4 TEXCOORD2 [[ attribute(5) ]] ;
    float4 TEXCOORD3 [[ attribute(6) ]] ;
    float4 COLOR0 [[ attribute(7) ]] ;
};
struct Mtl_VertexOut
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float4 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float4 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float4 TEXCOORD3 [[ user(TEXCOORD3) ]];
    float4 COLOR0 [[ user(COLOR0) ]];
};
static Mtl_VertexOut vertexFunction(
    Mtl_VertexIn input)
{
    Mtl_VertexOut output;
    output.INTERNALTESSPOS0 = input.POSITION0;
    output.TANGENT0 = input.TANGENT0;
    output.NORMAL0.xyz = input.NORMAL0.xyz;
    output.TEXCOORD0 = input.TEXCOORD0;
    output.TEXCOORD1 = input.TEXCOORD1;
    output.TEXCOORD2 = input.TEXCOORD2;
    output.TEXCOORD3 = input.TEXCOORD3;
    output.COLOR0 = input.COLOR0;
    return output;
}
// SHADER_STAGE_HULL_begin
struct Mtl_ControlPoint
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float4 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float4 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float4 TEXCOORD3 [[ user(TEXCOORD3) ]];
    float4 COLOR0 [[ user(COLOR0) ]];
};
struct Mtl_ControlPointIn
{
    float4 INTERNALTESSPOS0 [[ attribute(8) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float4 TEXCOORD0 [[ attribute(3) ]] ;
    float4 TEXCOORD1 [[ attribute(4) ]] ;
    float4 TEXCOORD2 [[ attribute(5) ]] ;
    float4 TEXCOORD3 [[ attribute(6) ]] ;
    float4 COLOR0 [[ attribute(7) ]] ;
};
struct Mtl_KernelPatchInfo
{
    uint numPatches;
    ushort numControlPointsPerPatch;
};
struct VGlobals_Type
{
    float4 _Time;
    float4 _SinTime;
    float4 _CosTime;
    float4 unity_DeltaTime;
    float3 _WorldSpaceCameraPos;
    float4 _ProjectionParams;
    float4 _ScreenParams;
    float4 _ZBufferParams;
    float4 unity_OrthoParams;
    float4 unity_CameraWorldClipPlanes[6];
    float4 hlslcc_mtx4x4unity_CameraProjection[4];
    float4 hlslcc_mtx4x4unity_CameraInvProjection[4];
    float4 hlslcc_mtx4x4unity_WorldToCamera[4];
    float4 hlslcc_mtx4x4unity_CameraToWorld[4];
    float4 _WorldSpaceLightPos0;
    float4 _LightPositionRange;
    float4 _LightProjectionParams;
    float4 unity_4LightPosX0;
    float4 unity_4LightPosY0;
    float4 unity_4LightPosZ0;
    float4 unity_4LightAtten0;
    float4 unity_LightColor[8];
    float4 unity_LightPosition[8];
    float4 unity_LightAtten[8];
    float4 unity_SpotDirection[8];
    float4 unity_SHAr;
    float4 unity_SHAg;
    float4 unity_SHAb;
    float4 unity_SHBr;
    float4 unity_SHBg;
    float4 unity_SHBb;
    float4 unity_SHC;
    float4 unity_OcclusionMaskSelector;
    float4 unity_ProbesOcclusion;
    float3 unity_LightColor0;
    float3 unity_LightColor1;
    float3 unity_LightColor2;
    float3 unity_LightColor3;
    float4 unity_ShadowSplitSpheres[4];
    float4 unity_ShadowSplitSqRadii;
    float4 unity_LightShadowBias;
    float4 _LightSplitsNear;
    float4 _LightSplitsFar;
    float4 hlslcc_mtx4x4unity_WorldToShadow[16];
    float4 _LightShadowData;
    float4 unity_ShadowFadeCenterAndType;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 unity_LODFade;
    float4 unity_WorldTransformParams;
    float4 unity_RenderingLayer;
    float4 hlslcc_mtx4x4glstate_matrix_transpose_modelview0[4];
    float4 glstate_lightmodel_ambient;
    float4 unity_AmbientSky;
    float4 unity_AmbientEquator;
    float4 unity_AmbientGround;
    float4 unity_IndirectSpecColor;
    float4 hlslcc_mtx4x4glstate_matrix_projection[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixInvV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    int unity_StereoEyeIndex;
    float4 unity_ShadowColor;
    float4 unity_FogColor;
    float4 unity_FogParams;
    float4 unity_LightmapST;
    float4 unity_DynamicLightmapST;
    float4 unity_SpecCube0_BoxMax;
    float4 unity_SpecCube0_BoxMin;
    float4 unity_SpecCube0_ProbePosition;
    float4 unity_SpecCube0_HDR;
    float4 unity_SpecCube1_BoxMax;
    float4 unity_SpecCube1_BoxMin;
    float4 unity_SpecCube1_ProbePosition;
    float4 unity_SpecCube1_HDR;
    float4 unity_ProbeVolumeParams;
    float4 hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[4];
    float3 unity_ProbeVolumeSizeInv;
    float3 unity_ProbeVolumeMin;
    float4 unity_Lightmap_HDR;
    float4 unity_DynamicLightmap_HDR;
    float4 _LightColor0;
    float4 _SpecColor;
    float _Tile;
    float _HeightDisplacement;
    float _NormalScale;
    float4 _ColorTint;
    float _MetallicStrength;
    float _SmoothnessStrength;
    float _EdgeLength;
    float4 _texcoord_ST;
};
struct Mtl_HullIn
{
    Mtl_VertexOut cp[3];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
kernel void patchKernel(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn vertexInput [[ stage_in ]],
    uint2 tID [[ thread_position_in_grid ]],
    ushort2 groupID [[ threadgroup_position_in_grid ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    constant Mtl_KernelPatchInfo &patchInfo [[ buffer(3) ]])
{
#pragma clang diagnostic pop
    Mtl_ControlPoint output;
    const uint numPatchesInThreadGroup = 10;
    const uint patchID = (tID.x / patchInfo.numControlPointsPerPatch);
    const bool patchValid = (patchID < patchInfo.numPatches);
    const uint mtl_BaseInstance = 0;
    const uint mtl_InstanceID = groupID.y - mtl_BaseInstance;
    const uint internalPatchID = mtl_InstanceID * patchInfo.numPatches + patchID;
    const uint patchIDInThreadGroup = (patchID % numPatchesInThreadGroup);
    const uint controlPointID = (tID.x % patchInfo.numControlPointsPerPatch);
    const uint mtl_BaseVertex = 0;
    const uint mtl_VertexID = ((mtl_InstanceID * (patchInfo.numControlPointsPerPatch * patchInfo.numPatches)) + tID.x) - mtl_BaseVertex;
    threadgroup Mtl_HullIn inputGroup[numPatchesInThreadGroup];
    threadgroup Mtl_HullIn &input = inputGroup[patchIDInThreadGroup];
    MTLTriangleTessellationFactorsHalf tessFactor;
    if (patchValid) {
        input.cp[controlPointID] = vertexFunction(vertexInput);
        output.INTERNALTESSPOS0 = input.cp[controlPointID].INTERNALTESSPOS0;
        output.TANGENT0 = input.cp[controlPointID].TANGENT0;
        output.NORMAL0 = input.cp[controlPointID].NORMAL0;
        output.TEXCOORD0 = input.cp[controlPointID].TEXCOORD0;
        output.TEXCOORD1 = input.cp[controlPointID].TEXCOORD1;
        output.TEXCOORD2 = input.cp[controlPointID].TEXCOORD2;
        output.TEXCOORD3 = input.cp[controlPointID].TEXCOORD3;
        output.COLOR0 = input.cp[controlPointID].COLOR0;
    }
    threadgroup_barrier(mem_flags::mem_threadgroup);
    if (!patchValid) {
        return;
    }
    float3 u_xlat0;
    float3 u_xlat1;
    float3 u_xlat2;
    float3 u_xlat3;
    float3 u_xlat4;
    float u_xlat12;
    float u_xlat13;
    // fork_phase2
    {
        u_xlat0.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[1].INTERNALTESSPOS0.yyy;
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[1].INTERNALTESSPOS0.xxx, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[1].INTERNALTESSPOS0.zzz, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[1].INTERNALTESSPOS0.www, u_xlat0.xyz);
        u_xlat1.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[2].INTERNALTESSPOS0.yyy;
        u_xlat1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[2].INTERNALTESSPOS0.xxx, u_xlat1.xyz);
        u_xlat1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[2].INTERNALTESSPOS0.zzz, u_xlat1.xyz);
        u_xlat1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[2].INTERNALTESSPOS0.www, u_xlat1.xyz);
        u_xlat2.xyz = u_xlat0.xyz + u_xlat1.xyz;
        u_xlat2.xyz = fma(u_xlat2.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat12 = dot(u_xlat2.xyz, u_xlat2.xyz);
        u_xlat12 = sqrt(u_xlat12);
        u_xlat12 = u_xlat12 * VGlobals._EdgeLength;
        u_xlat2.xyz = u_xlat0.xyz + (-u_xlat1.xyz);
        u_xlat13 = dot(u_xlat2.xyz, u_xlat2.xyz);
        u_xlat13 = sqrt(u_xlat13);
        u_xlat13 = u_xlat13 * VGlobals._ScreenParams.y;
        u_xlat12 = u_xlat13 / u_xlat12;
        tessFactor.edgeTessellationFactor[0] = max(u_xlat12, 1.0);
        u_xlat2.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[0].INTERNALTESSPOS0.yyy;
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[0].INTERNALTESSPOS0.xxx, u_xlat2.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[0].INTERNALTESSPOS0.zzz, u_xlat2.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[0].INTERNALTESSPOS0.www, u_xlat2.xyz);
        u_xlat3.xyz = u_xlat1.xyz + u_xlat2.xyz;
        u_xlat1.xyz = u_xlat1.xyz + (-u_xlat2.xyz);
        u_xlat12 = dot(u_xlat1.xyz, u_xlat1.xyz);
        u_xlat12 = sqrt(u_xlat12);
        u_xlat12 = u_xlat12 * VGlobals._ScreenParams.y;
        u_xlat1.xyz = fma(u_xlat3.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat1.x = dot(u_xlat1.xyz, u_xlat1.xyz);
        u_xlat1.x = sqrt(u_xlat1.x);
        u_xlat1.x = u_xlat1.x * VGlobals._EdgeLength;
        u_xlat12 = u_xlat12 / u_xlat1.x;
        tessFactor.edgeTessellationFactor[1] = max(u_xlat12, 1.0);
        u_xlat1.xyz = u_xlat0.xyz + u_xlat2.xyz;
        u_xlat0.xyz = (-u_xlat0.xyz) + u_xlat2.xyz;
        u_xlat0.x = dot(u_xlat0.xyz, u_xlat0.xyz);
        u_xlat0.x = sqrt(u_xlat0.x);
        u_xlat0.x = u_xlat0.x * VGlobals._ScreenParams.y;
        u_xlat4.xyz = fma(u_xlat1.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat4.x = dot(u_xlat4.xyz, u_xlat4.xyz);
        u_xlat4.x = sqrt(u_xlat4.x);
        u_xlat4.x = u_xlat4.x * VGlobals._EdgeLength;
        u_xlat0.x = u_xlat0.x / u_xlat4.x;
        tessFactor.edgeTessellationFactor[2] = max(u_xlat0.x, 1.0);
    }
    // join_phase3
    {
        u_xlat0.x = tessFactor.edgeTessellationFactor[0] + tessFactor.edgeTessellationFactor[1];
        u_xlat0.x = u_xlat0.x + tessFactor.edgeTessellationFactor[2];
        tessFactor.insideTessellationFactor = u_xlat0.x * 0.333333343;
    }
    controlPoints[mtl_VertexID] = output;
    tessFactors[internalPatchID] = tessFactor;
}
// SHADER_STAGE_HULL_end
// SHADER_STAGE_DOMAIN_begin
struct Mtl_VertexInPostTess
{
    patch_control_point<Mtl_ControlPointIn> cp;
};
struct Mtl_VertexOutPostTess
{
    float4 mtl_Position [[ position ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float4 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float4 TEXCOORD3 [[ user(TEXCOORD3) ]];
    float4 TEXCOORD6 [[ user(TEXCOORD6) ]];
    float4 TEXCOORD7 [[ user(TEXCOORD7) ]];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    sampler sampler_Height [[ sampler (0) ]],
    texture2d<float, access::sample > _Height [[ texture(0) ]] ,
    float3 mtl_TessCoord [[ position_in_patch ]],
    uint patchID [[ patch_id ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    Mtl_VertexInPostTess input [[ stage_in ]])
{
#pragma clang diagnostic pop
    Mtl_VertexOutPostTess output;
    MTLTriangleTessellationFactorsHalf tessFactor;
    tessFactor = tessFactors[patchID];
    float4 u_xlat0;
    float4 u_xlat1;
    float4 u_xlat2;
    float4 u_xlat3;
    float2 u_xlat9;
    float u_xlat12;
    float u_xlat13;
    u_xlat0 = mtl_TessCoord.yyyy * input.cp[1].INTERNALTESSPOS0;
    u_xlat0 = fma(input.cp[0].INTERNALTESSPOS0, mtl_TessCoord.xxxx, u_xlat0);
    u_xlat0 = fma(input.cp[2].INTERNALTESSPOS0, mtl_TessCoord.zzzz, u_xlat0);
    u_xlat1.xy = mtl_TessCoord.yy * input.cp[1].TEXCOORD0.xy;
    u_xlat1.xy = fma(input.cp[0].TEXCOORD0.xy, mtl_TessCoord.xx, u_xlat1.xy);
    u_xlat1.xy = fma(input.cp[2].TEXCOORD0.xy, mtl_TessCoord.zz, u_xlat1.xy);
    u_xlat9.xy = u_xlat1.xy * float2(VGlobals._Tile);
    output.TEXCOORD0.xy = fma(u_xlat1.xy, VGlobals._texcoord_ST.xy, VGlobals._texcoord_ST.zw);
    u_xlat1.xyz = _Height.sample(sampler_Height, u_xlat9.xy, level(1.0)).xyz;
    u_xlat2.xyz = mtl_TessCoord.yyy * input.cp[1].NORMAL0.xyz;
    u_xlat2.xyz = fma(input.cp[0].NORMAL0.xyz, mtl_TessCoord.xxx, u_xlat2.xyz);
    u_xlat2.xyz = fma(input.cp[2].NORMAL0.xyz, mtl_TessCoord.zzz, u_xlat2.xyz);
    u_xlat1.xyz = u_xlat1.xyz * u_xlat2.xyz;
    u_xlat0.xyz = fma(u_xlat1.xyz, float3(VGlobals._HeightDisplacement), u_xlat0.xyz);
    u_xlat1 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], u_xlat0.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], u_xlat0.zzzz, u_xlat1);
    u_xlat3 = u_xlat1 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, u_xlat0.www, u_xlat1.xyz);
    u_xlat1 = u_xlat3.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat3.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat3.zzzz, u_xlat1);
    output.mtl_Position = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat3.wwww, u_xlat1);
    u_xlat1.y = dot(u_xlat2.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat1.z = dot(u_xlat2.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat1.x = dot(u_xlat2.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat12 = dot(u_xlat1.xyz, u_xlat1.xyz);
    u_xlat12 = rsqrt(u_xlat12);
    u_xlat1.xyz = float3(u_xlat12) * u_xlat1.xyz;
    output.TEXCOORD1.z = u_xlat1.y;
    u_xlat2 = mtl_TessCoord.yyyy * input.cp[1].TANGENT0;
    u_xlat2 = fma(input.cp[0].TANGENT0, mtl_TessCoord.xxxx, u_xlat2);
    u_xlat2 = fma(input.cp[2].TANGENT0, mtl_TessCoord.zzzz, u_xlat2);
    u_xlat3.xyz = u_xlat2.yyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].yzx;
    u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].yzx, u_xlat2.xxx, u_xlat3.xyz);
    u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].yzx, u_xlat2.zzz, u_xlat3.xyz);
    u_xlat12 = u_xlat2.w * VGlobals.unity_WorldTransformParams.w;
    u_xlat13 = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat13 = rsqrt(u_xlat13);
    u_xlat2.xyz = float3(u_xlat13) * u_xlat2.xyz;
    u_xlat3.xyz = u_xlat1.xyz * u_xlat2.xyz;
    u_xlat3.xyz = fma(u_xlat1.zxy, u_xlat2.yzx, (-u_xlat3.xyz));
    u_xlat3.xyz = float3(u_xlat12) * u_xlat3.xyz;
    output.TEXCOORD1.y = u_xlat3.x;
    output.TEXCOORD1.w = u_xlat0.x;
    output.TEXCOORD1.x = u_xlat2.z;
    output.TEXCOORD2.w = u_xlat0.y;
    output.TEXCOORD3.w = u_xlat0.z;
    output.TEXCOORD2.x = u_xlat2.x;
    output.TEXCOORD3.x = u_xlat2.y;
    output.TEXCOORD2.z = u_xlat1.z;
    output.TEXCOORD3.z = u_xlat1.x;
    output.TEXCOORD2.y = u_xlat3.y;
    output.TEXCOORD3.y = u_xlat3.z;
    output.TEXCOORD6 = float4(0.0, 0.0, 0.0, 0.0);
    output.TEXCOORD7 = float4(0.0, 0.0, 0.0, 0.0);
    return output;
}
// SHADER_STAGE_DOMAIN_end
Compilation succeeded with: 

program_source:301:53: warning: writable resources in non-void post-tessellation vertex function
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
                                                    ^
program_source:307:30: note: writable buffer defined here
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
                             ^
program_source:308:48: note: writable buffer defined here
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
                                               ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float4 TEXCOORD0 [[ attribute(3) ]] ;
    float4 TEXCOORD1 [[ attribute(4) ]] ;
    float4 TEXCOORD2 [[ attribute(5) ]] ;
    float4 TEXCOORD3 [[ attribute(6) ]] ;
    float4 COLOR0 [[ attribute(7) ]] ;
};
struct Mtl_VertexOut
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float4 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float4 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float4 TEXCOORD3 [[ user(TEXCOORD3) ]];
    float4 COLOR0 [[ user(COLOR0) ]];
};
static Mtl_VertexOut vertexFunction(
    Mtl_VertexIn input)
{
    Mtl_VertexOut output;
    output.INTERNALTESSPOS0 = input.POSITION0;
    output.TANGENT0 = input.TANGENT0;
    output.NORMAL0.xyz = input.NORMAL0.xyz;
    output.TEXCOORD0 = input.TEXCOORD0;
    output.TEXCOORD1 = input.TEXCOORD1;
    output.TEXCOORD2 = input.TEXCOORD2;
    output.TEXCOORD3 = input.TEXCOORD3;
    output.COLOR0 = input.COLOR0;
    return output;
}
// SHADER_STAGE_HULL_begin
struct Mtl_ControlPoint
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float4 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float4 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float4 TEXCOORD3 [[ user(TEXCOORD3) ]];
    float4 COLOR0 [[ user(COLOR0) ]];
};
struct Mtl_ControlPointIn
{
    float4 INTERNALTESSPOS0 [[ attribute(8) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float4 TEXCOORD0 [[ attribute(3) ]] ;
    float4 TEXCOORD1 [[ attribute(4) ]] ;
    float4 TEXCOORD2 [[ attribute(5) ]] ;
    float4 TEXCOORD3 [[ attribute(6) ]] ;
    float4 COLOR0 [[ attribute(7) ]] ;
};
struct Mtl_KernelPatchInfo
{
    uint numPatches;
    ushort numControlPointsPerPatch;
};
struct VGlobals_Type
{
    float4 _Time;
    float4 _SinTime;
    float4 _CosTime;
    float4 unity_DeltaTime;
    float3 _WorldSpaceCameraPos;
    float4 _ProjectionParams;
    float4 _ScreenParams;
    float4 _ZBufferParams;
    float4 unity_OrthoParams;
    float4 unity_CameraWorldClipPlanes[6];
    float4 hlslcc_mtx4x4unity_CameraProjection[4];
    float4 hlslcc_mtx4x4unity_CameraInvProjection[4];
    float4 hlslcc_mtx4x4unity_WorldToCamera[4];
    float4 hlslcc_mtx4x4unity_CameraToWorld[4];
    float4 _WorldSpaceLightPos0;
    float4 _LightPositionRange;
    float4 _LightProjectionParams;
    float4 unity_4LightPosX0;
    float4 unity_4LightPosY0;
    float4 unity_4LightPosZ0;
    float4 unity_4LightAtten0;
    float4 unity_LightColor[8];
    float4 unity_LightPosition[8];
    float4 unity_LightAtten[8];
    float4 unity_SpotDirection[8];
    float4 unity_SHAr;
    float4 unity_SHAg;
    float4 unity_SHAb;
    float4 unity_SHBr;
    float4 unity_SHBg;
    float4 unity_SHBb;
    float4 unity_SHC;
    float4 unity_OcclusionMaskSelector;
    float4 unity_ProbesOcclusion;
    float3 unity_LightColor0;
    float3 unity_LightColor1;
    float3 unity_LightColor2;
    float3 unity_LightColor3;
    float4 unity_ShadowSplitSpheres[4];
    float4 unity_ShadowSplitSqRadii;
    float4 unity_LightShadowBias;
    float4 _LightSplitsNear;
    float4 _LightSplitsFar;
    float4 hlslcc_mtx4x4unity_WorldToShadow[16];
    float4 _LightShadowData;
    float4 unity_ShadowFadeCenterAndType;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 unity_LODFade;
    float4 unity_WorldTransformParams;
    float4 unity_RenderingLayer;
    float4 hlslcc_mtx4x4glstate_matrix_transpose_modelview0[4];
    float4 glstate_lightmodel_ambient;
    float4 unity_AmbientSky;
    float4 unity_AmbientEquator;
    float4 unity_AmbientGround;
    float4 unity_IndirectSpecColor;
    float4 hlslcc_mtx4x4glstate_matrix_projection[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixInvV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    int unity_StereoEyeIndex;
    float4 unity_ShadowColor;
    float4 unity_FogColor;
    float4 unity_FogParams;
    float4 unity_LightmapST;
    float4 unity_DynamicLightmapST;
    float4 unity_SpecCube0_BoxMax;
    float4 unity_SpecCube0_BoxMin;
    float4 unity_SpecCube0_ProbePosition;
    float4 unity_SpecCube0_HDR;
    float4 unity_SpecCube1_BoxMax;
    float4 unity_SpecCube1_BoxMin;
    float4 unity_SpecCube1_ProbePosition;
    float4 unity_SpecCube1_HDR;
    float4 unity_ProbeVolumeParams;
    float4 hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[4];
    float3 unity_ProbeVolumeSizeInv;
    float3 unity_ProbeVolumeMin;
    float4 unity_Lightmap_HDR;
    float4 unity_DynamicLightmap_HDR;
    float4 _LightColor0;
    float4 _SpecColor;
    float4 hlslcc_mtx4x4unity_WorldToLight[4];
    float _Tile;
    float _HeightDisplacement;
    float _NormalScale;
    float4 _ColorTint;
    float _MetallicStrength;
    float _SmoothnessStrength;
    float _EdgeLength;
    float4 _texcoord_ST;
};
struct Mtl_HullIn
{
    Mtl_VertexOut cp[3];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
kernel void patchKernel(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn vertexInput [[ stage_in ]],
    uint2 tID [[ thread_position_in_grid ]],
    ushort2 groupID [[ threadgroup_position_in_grid ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    constant Mtl_KernelPatchInfo &patchInfo [[ buffer(3) ]])
{
#pragma clang diagnostic pop
    Mtl_ControlPoint output;
    const uint numPatchesInThreadGroup = 10;
    const uint patchID = (tID.x / patchInfo.numControlPointsPerPatch);
    const bool patchValid = (patchID < patchInfo.numPatches);
    const uint mtl_BaseInstance = 0;
    const uint mtl_InstanceID = groupID.y - mtl_BaseInstance;
    const uint internalPatchID = mtl_InstanceID * patchInfo.numPatches + patchID;
    const uint patchIDInThreadGroup = (patchID % numPatchesInThreadGroup);
    const uint controlPointID = (tID.x % patchInfo.numControlPointsPerPatch);
    const uint mtl_BaseVertex = 0;
    const uint mtl_VertexID = ((mtl_InstanceID * (patchInfo.numControlPointsPerPatch * patchInfo.numPatches)) + tID.x) - mtl_BaseVertex;
    threadgroup Mtl_HullIn inputGroup[numPatchesInThreadGroup];
    threadgroup Mtl_HullIn &input = inputGroup[patchIDInThreadGroup];
    MTLTriangleTessellationFactorsHalf tessFactor;
    if (patchValid) {
        input.cp[controlPointID] = vertexFunction(vertexInput);
        output.INTERNALTESSPOS0 = input.cp[controlPointID].INTERNALTESSPOS0;
        output.TANGENT0 = input.cp[controlPointID].TANGENT0;
        output.NORMAL0 = input.cp[controlPointID].NORMAL0;
        output.TEXCOORD0 = input.cp[controlPointID].TEXCOORD0;
        output.TEXCOORD1 = input.cp[controlPointID].TEXCOORD1;
        output.TEXCOORD2 = input.cp[controlPointID].TEXCOORD2;
        output.TEXCOORD3 = input.cp[controlPointID].TEXCOORD3;
        output.COLOR0 = input.cp[controlPointID].COLOR0;
    }
    threadgroup_barrier(mem_flags::mem_threadgroup);
    if (!patchValid) {
        return;
    }
    float3 u_xlat0;
    float3 u_xlat1;
    float3 u_xlat2;
    float3 u_xlat3;
    float3 u_xlat4;
    float u_xlat12;
    float u_xlat13;
    // fork_phase2
    {
        u_xlat0.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[1].INTERNALTESSPOS0.yyy;
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[1].INTERNALTESSPOS0.xxx, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[1].INTERNALTESSPOS0.zzz, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[1].INTERNALTESSPOS0.www, u_xlat0.xyz);
        u_xlat1.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[2].INTERNALTESSPOS0.yyy;
        u_xlat1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[2].INTERNALTESSPOS0.xxx, u_xlat1.xyz);
        u_xlat1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[2].INTERNALTESSPOS0.zzz, u_xlat1.xyz);
        u_xlat1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[2].INTERNALTESSPOS0.www, u_xlat1.xyz);
        u_xlat2.xyz = u_xlat0.xyz + u_xlat1.xyz;
        u_xlat2.xyz = fma(u_xlat2.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat12 = dot(u_xlat2.xyz, u_xlat2.xyz);
        u_xlat12 = sqrt(u_xlat12);
        u_xlat12 = u_xlat12 * VGlobals._EdgeLength;
        u_xlat2.xyz = u_xlat0.xyz + (-u_xlat1.xyz);
        u_xlat13 = dot(u_xlat2.xyz, u_xlat2.xyz);
        u_xlat13 = sqrt(u_xlat13);
        u_xlat13 = u_xlat13 * VGlobals._ScreenParams.y;
        u_xlat12 = u_xlat13 / u_xlat12;
        tessFactor.edgeTessellationFactor[0] = max(u_xlat12, 1.0);
        u_xlat2.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[0].INTERNALTESSPOS0.yyy;
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[0].INTERNALTESSPOS0.xxx, u_xlat2.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[0].INTERNALTESSPOS0.zzz, u_xlat2.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[0].INTERNALTESSPOS0.www, u_xlat2.xyz);
        u_xlat3.xyz = u_xlat1.xyz + u_xlat2.xyz;
        u_xlat1.xyz = u_xlat1.xyz + (-u_xlat2.xyz);
        u_xlat12 = dot(u_xlat1.xyz, u_xlat1.xyz);
        u_xlat12 = sqrt(u_xlat12);
        u_xlat12 = u_xlat12 * VGlobals._ScreenParams.y;
        u_xlat1.xyz = fma(u_xlat3.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat1.x = dot(u_xlat1.xyz, u_xlat1.xyz);
        u_xlat1.x = sqrt(u_xlat1.x);
        u_xlat1.x = u_xlat1.x * VGlobals._EdgeLength;
        u_xlat12 = u_xlat12 / u_xlat1.x;
        tessFactor.edgeTessellationFactor[1] = max(u_xlat12, 1.0);
        u_xlat1.xyz = u_xlat0.xyz + u_xlat2.xyz;
        u_xlat0.xyz = (-u_xlat0.xyz) + u_xlat2.xyz;
        u_xlat0.x = dot(u_xlat0.xyz, u_xlat0.xyz);
        u_xlat0.x = sqrt(u_xlat0.x);
        u_xlat0.x = u_xlat0.x * VGlobals._ScreenParams.y;
        u_xlat4.xyz = fma(u_xlat1.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat4.x = dot(u_xlat4.xyz, u_xlat4.xyz);
        u_xlat4.x = sqrt(u_xlat4.x);
        u_xlat4.x = u_xlat4.x * VGlobals._EdgeLength;
        u_xlat0.x = u_xlat0.x / u_xlat4.x;
        tessFactor.edgeTessellationFactor[2] = max(u_xlat0.x, 1.0);
    }
    // join_phase3
    {
        u_xlat0.x = tessFactor.edgeTessellationFactor[0] + tessFactor.edgeTessellationFactor[1];
        u_xlat0.x = u_xlat0.x + tessFactor.edgeTessellationFactor[2];
        tessFactor.insideTessellationFactor = u_xlat0.x * 0.333333343;
    }
    controlPoints[mtl_VertexID] = output;
    tessFactors[internalPatchID] = tessFactor;
}
// SHADER_STAGE_HULL_end
// SHADER_STAGE_DOMAIN_begin
struct Mtl_VertexInPostTess
{
    patch_control_point<Mtl_ControlPointIn> cp;
};
struct Mtl_VertexOutPostTess
{
    float4 mtl_Position [[ position ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float3 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float3 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float3 TEXCOORD3 [[ user(TEXCOORD3) ]];
    float3 TEXCOORD4 [[ user(TEXCOORD4) ]];
    float3 TEXCOORD5 [[ user(TEXCOORD5) ]];
    float4 TEXCOORD6 [[ user(TEXCOORD6) ]];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    sampler sampler_Height [[ sampler (0) ]],
    texture2d<float, access::sample > _Height [[ texture(0) ]] ,
    float3 mtl_TessCoord [[ position_in_patch ]],
    uint patchID [[ patch_id ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    Mtl_VertexInPostTess input [[ stage_in ]])
{
#pragma clang diagnostic pop
    Mtl_VertexOutPostTess output;
    MTLTriangleTessellationFactorsHalf tessFactor;
    tessFactor = tessFactors[patchID];
    float4 u_xlat0;
    float3 u_xlat1;
    float4 u_xlat2;
    float4 u_xlat3;
    float4 u_xlat4;
    float2 u_xlat10;
    float u_xlat16;
    u_xlat0.xy = mtl_TessCoord.yy * input.cp[1].TEXCOORD0.xy;
    u_xlat0.xy = fma(input.cp[0].TEXCOORD0.xy, mtl_TessCoord.xx, u_xlat0.xy);
    u_xlat0.xy = fma(input.cp[2].TEXCOORD0.xy, mtl_TessCoord.zz, u_xlat0.xy);
    u_xlat10.xy = u_xlat0.xy * float2(VGlobals._Tile);
    output.TEXCOORD0.xy = fma(u_xlat0.xy, VGlobals._texcoord_ST.xy, VGlobals._texcoord_ST.zw);
    u_xlat0.xyz = _Height.sample(sampler_Height, u_xlat10.xy, level(1.0)).xyz;
    u_xlat1.xyz = mtl_TessCoord.yyy * input.cp[1].NORMAL0.xyz;
    u_xlat1.xyz = fma(input.cp[0].NORMAL0.xyz, mtl_TessCoord.xxx, u_xlat1.xyz);
    u_xlat1.xyz = fma(input.cp[2].NORMAL0.xyz, mtl_TessCoord.zzz, u_xlat1.xyz);
    u_xlat0.xyz = u_xlat0.xyz * u_xlat1.xyz;
    u_xlat2 = mtl_TessCoord.yyyy * input.cp[1].INTERNALTESSPOS0;
    u_xlat2 = fma(input.cp[0].INTERNALTESSPOS0, mtl_TessCoord.xxxx, u_xlat2);
    u_xlat2 = fma(input.cp[2].INTERNALTESSPOS0, mtl_TessCoord.zzzz, u_xlat2);
    u_xlat0.xyz = fma(u_xlat0.xyz, float3(VGlobals._HeightDisplacement), u_xlat2.xyz);
    u_xlat3 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], u_xlat0.xxxx, u_xlat3);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], u_xlat0.zzzz, u_xlat3);
    u_xlat3 = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat4 = u_xlat3.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat4 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat3.xxxx, u_xlat4);
    u_xlat4 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat3.zzzz, u_xlat4);
    output.mtl_Position = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat3.wwww, u_xlat4);
    u_xlat2.y = dot(u_xlat1.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat2.z = dot(u_xlat1.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat2.x = dot(u_xlat1.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat1.x = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat1.x = rsqrt(u_xlat1.x);
    u_xlat1.xyz = u_xlat1.xxx * u_xlat2.xyz;
    output.TEXCOORD1.z = u_xlat1.y;
    u_xlat3 = mtl_TessCoord.yyyy * input.cp[1].TANGENT0;
    u_xlat3 = fma(input.cp[0].TANGENT0, mtl_TessCoord.xxxx, u_xlat3);
    u_xlat3 = fma(input.cp[2].TANGENT0, mtl_TessCoord.zzzz, u_xlat3);
    u_xlat2.xyz = u_xlat3.yyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].yzx;
    u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].yzx, u_xlat3.xxx, u_xlat2.xyz);
    u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].yzx, u_xlat3.zzz, u_xlat2.xyz);
    u_xlat16 = u_xlat3.w * VGlobals.unity_WorldTransformParams.w;
    u_xlat3.x = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat3.x = rsqrt(u_xlat3.x);
    u_xlat2.xyz = u_xlat2.xyz * u_xlat3.xxx;
    u_xlat3.xyz = u_xlat1.xyz * u_xlat2.xyz;
    u_xlat3.xyz = fma(u_xlat1.zxy, u_xlat2.yzx, (-u_xlat3.xyz));
    u_xlat3.xyz = float3(u_xlat16) * u_xlat3.xyz;
    output.TEXCOORD1.y = u_xlat3.x;
    output.TEXCOORD1.x = u_xlat2.z;
    output.TEXCOORD2.x = u_xlat2.x;
    output.TEXCOORD3.x = u_xlat2.y;
    output.TEXCOORD2.z = u_xlat1.z;
    output.TEXCOORD3.z = u_xlat1.x;
    output.TEXCOORD2.y = u_xlat3.y;
    output.TEXCOORD3.y = u_xlat3.z;
    output.TEXCOORD4.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, u_xlat2.www, u_xlat0.xyz);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3], u_xlat2.wwww, u_xlat0);
    u_xlat1.xyz = u_xlat0.yyy * VGlobals.hlslcc_mtx4x4unity_WorldToLight[1].xyz;
    u_xlat1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_WorldToLight[0].xyz, u_xlat0.xxx, u_xlat1.xyz);
    u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_WorldToLight[2].xyz, u_xlat0.zzz, u_xlat1.xyz);
    output.TEXCOORD5.xyz = fma(VGlobals.hlslcc_mtx4x4unity_WorldToLight[3].xyz, u_xlat0.www, u_xlat0.xyz);
    output.TEXCOORD6 = float4(0.0, 0.0, 0.0, 0.0);
    return output;
}
// SHADER_STAGE_DOMAIN_end
Compilation succeeded with: 

program_source:293:53: warning: writable resources in non-void post-tessellation vertex function
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
                                                    ^
program_source:299:30: note: writable buffer defined here
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
                             ^
program_source:300:48: note: writable buffer defined here
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
                                               ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float4 TEXCOORD0 [[ attribute(3) ]] ;
    float4 TEXCOORD1 [[ attribute(4) ]] ;
    float4 TEXCOORD2 [[ attribute(5) ]] ;
    float4 TEXCOORD3 [[ attribute(6) ]] ;
    float4 COLOR0 [[ attribute(7) ]] ;
};
struct Mtl_VertexOut
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float4 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float4 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float4 TEXCOORD3 [[ user(TEXCOORD3) ]];
    float4 COLOR0 [[ user(COLOR0) ]];
};
static Mtl_VertexOut vertexFunction(
    Mtl_VertexIn input)
{
    Mtl_VertexOut output;
    output.INTERNALTESSPOS0 = input.POSITION0;
    output.TANGENT0 = input.TANGENT0;
    output.NORMAL0.xyz = input.NORMAL0.xyz;
    output.TEXCOORD0 = input.TEXCOORD0;
    output.TEXCOORD1 = input.TEXCOORD1;
    output.TEXCOORD2 = input.TEXCOORD2;
    output.TEXCOORD3 = input.TEXCOORD3;
    output.COLOR0 = input.COLOR0;
    return output;
}
// SHADER_STAGE_HULL_begin
struct Mtl_ControlPoint
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float4 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float4 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float4 TEXCOORD3 [[ user(TEXCOORD3) ]];
    float4 COLOR0 [[ user(COLOR0) ]];
};
struct Mtl_ControlPointIn
{
    float4 INTERNALTESSPOS0 [[ attribute(8) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float4 TEXCOORD0 [[ attribute(3) ]] ;
    float4 TEXCOORD1 [[ attribute(4) ]] ;
    float4 TEXCOORD2 [[ attribute(5) ]] ;
    float4 TEXCOORD3 [[ attribute(6) ]] ;
    float4 COLOR0 [[ attribute(7) ]] ;
};
struct Mtl_KernelPatchInfo
{
    uint numPatches;
    ushort numControlPointsPerPatch;
};
struct VGlobals_Type
{
    float4 _Time;
    float4 _SinTime;
    float4 _CosTime;
    float4 unity_DeltaTime;
    float3 _WorldSpaceCameraPos;
    float4 _ProjectionParams;
    float4 _ScreenParams;
    float4 _ZBufferParams;
    float4 unity_OrthoParams;
    float4 unity_CameraWorldClipPlanes[6];
    float4 hlslcc_mtx4x4unity_CameraProjection[4];
    float4 hlslcc_mtx4x4unity_CameraInvProjection[4];
    float4 hlslcc_mtx4x4unity_WorldToCamera[4];
    float4 hlslcc_mtx4x4unity_CameraToWorld[4];
    float4 _WorldSpaceLightPos0;
    float4 _LightPositionRange;
    float4 _LightProjectionParams;
    float4 unity_4LightPosX0;
    float4 unity_4LightPosY0;
    float4 unity_4LightPosZ0;
    float4 unity_4LightAtten0;
    float4 unity_LightColor[8];
    float4 unity_LightPosition[8];
    float4 unity_LightAtten[8];
    float4 unity_SpotDirection[8];
    float4 unity_SHAr;
    float4 unity_SHAg;
    float4 unity_SHAb;
    float4 unity_SHBr;
    float4 unity_SHBg;
    float4 unity_SHBb;
    float4 unity_SHC;
    float4 unity_OcclusionMaskSelector;
    float4 unity_ProbesOcclusion;
    float3 unity_LightColor0;
    float3 unity_LightColor1;
    float3 unity_LightColor2;
    float3 unity_LightColor3;
    float4 unity_ShadowSplitSpheres[4];
    float4 unity_ShadowSplitSqRadii;
    float4 unity_LightShadowBias;
    float4 _LightSplitsNear;
    float4 _LightSplitsFar;
    float4 hlslcc_mtx4x4unity_WorldToShadow[16];
    float4 _LightShadowData;
    float4 unity_ShadowFadeCenterAndType;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 unity_LODFade;
    float4 unity_WorldTransformParams;
    float4 unity_RenderingLayer;
    float4 hlslcc_mtx4x4glstate_matrix_transpose_modelview0[4];
    float4 glstate_lightmodel_ambient;
    float4 unity_AmbientSky;
    float4 unity_AmbientEquator;
    float4 unity_AmbientGround;
    float4 unity_IndirectSpecColor;
    float4 hlslcc_mtx4x4glstate_matrix_projection[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixInvV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    int unity_StereoEyeIndex;
    float4 unity_ShadowColor;
    float4 unity_FogColor;
    float4 unity_FogParams;
    float4 unity_LightmapST;
    float4 unity_DynamicLightmapST;
    float4 unity_SpecCube0_BoxMax;
    float4 unity_SpecCube0_BoxMin;
    float4 unity_SpecCube0_ProbePosition;
    float4 unity_SpecCube0_HDR;
    float4 unity_SpecCube1_BoxMax;
    float4 unity_SpecCube1_BoxMin;
    float4 unity_SpecCube1_ProbePosition;
    float4 unity_SpecCube1_HDR;
    float4 unity_ProbeVolumeParams;
    float4 hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[4];
    float3 unity_ProbeVolumeSizeInv;
    float3 unity_ProbeVolumeMin;
    float4 unity_Lightmap_HDR;
    float4 unity_DynamicLightmap_HDR;
    float4 _LightColor0;
    float4 _SpecColor;
    float _Tile;
    float _HeightDisplacement;
    float _NormalScale;
    float4 _ColorTint;
    float _MetallicStrength;
    float _SmoothnessStrength;
    float _EdgeLength;
};
struct Mtl_HullIn
{
    Mtl_VertexOut cp[3];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
kernel void patchKernel(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn vertexInput [[ stage_in ]],
    uint2 tID [[ thread_position_in_grid ]],
    ushort2 groupID [[ threadgroup_position_in_grid ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    constant Mtl_KernelPatchInfo &patchInfo [[ buffer(3) ]])
{
#pragma clang diagnostic pop
    Mtl_ControlPoint output;
    const uint numPatchesInThreadGroup = 10;
    const uint patchID = (tID.x / patchInfo.numControlPointsPerPatch);
    const bool patchValid = (patchID < patchInfo.numPatches);
    const uint mtl_BaseInstance = 0;
    const uint mtl_InstanceID = groupID.y - mtl_BaseInstance;
    const uint internalPatchID = mtl_InstanceID * patchInfo.numPatches + patchID;
    const uint patchIDInThreadGroup = (patchID % numPatchesInThreadGroup);
    const uint controlPointID = (tID.x % patchInfo.numControlPointsPerPatch);
    const uint mtl_BaseVertex = 0;
    const uint mtl_VertexID = ((mtl_InstanceID * (patchInfo.numControlPointsPerPatch * patchInfo.numPatches)) + tID.x) - mtl_BaseVertex;
    threadgroup Mtl_HullIn inputGroup[numPatchesInThreadGroup];
    threadgroup Mtl_HullIn &input = inputGroup[patchIDInThreadGroup];
    MTLTriangleTessellationFactorsHalf tessFactor;
    if (patchValid) {
        input.cp[controlPointID] = vertexFunction(vertexInput);
        output.INTERNALTESSPOS0 = input.cp[controlPointID].INTERNALTESSPOS0;
        output.TANGENT0 = input.cp[controlPointID].TANGENT0;
        output.NORMAL0 = input.cp[controlPointID].NORMAL0;
        output.TEXCOORD0 = input.cp[controlPointID].TEXCOORD0;
        output.TEXCOORD1 = input.cp[controlPointID].TEXCOORD1;
        output.TEXCOORD2 = input.cp[controlPointID].TEXCOORD2;
        output.TEXCOORD3 = input.cp[controlPointID].TEXCOORD3;
        output.COLOR0 = input.cp[controlPointID].COLOR0;
    }
    threadgroup_barrier(mem_flags::mem_threadgroup);
    if (!patchValid) {
        return;
    }
    float3 u_xlat0;
    float3 u_xlat1;
    float3 u_xlat2;
    float3 u_xlat3;
    float3 u_xlat4;
    float u_xlat12;
    float u_xlat13;
    // fork_phase2
    {
        u_xlat0.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[1].INTERNALTESSPOS0.yyy;
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[1].INTERNALTESSPOS0.xxx, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[1].INTERNALTESSPOS0.zzz, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[1].INTERNALTESSPOS0.www, u_xlat0.xyz);
        u_xlat1.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[2].INTERNALTESSPOS0.yyy;
        u_xlat1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[2].INTERNALTESSPOS0.xxx, u_xlat1.xyz);
        u_xlat1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[2].INTERNALTESSPOS0.zzz, u_xlat1.xyz);
        u_xlat1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[2].INTERNALTESSPOS0.www, u_xlat1.xyz);
        u_xlat2.xyz = u_xlat0.xyz + u_xlat1.xyz;
        u_xlat2.xyz = fma(u_xlat2.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat12 = dot(u_xlat2.xyz, u_xlat2.xyz);
        u_xlat12 = sqrt(u_xlat12);
        u_xlat12 = u_xlat12 * VGlobals._EdgeLength;
        u_xlat2.xyz = u_xlat0.xyz + (-u_xlat1.xyz);
        u_xlat13 = dot(u_xlat2.xyz, u_xlat2.xyz);
        u_xlat13 = sqrt(u_xlat13);
        u_xlat13 = u_xlat13 * VGlobals._ScreenParams.y;
        u_xlat12 = u_xlat13 / u_xlat12;
        tessFactor.edgeTessellationFactor[0] = max(u_xlat12, 1.0);
        u_xlat2.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[0].INTERNALTESSPOS0.yyy;
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[0].INTERNALTESSPOS0.xxx, u_xlat2.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[0].INTERNALTESSPOS0.zzz, u_xlat2.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[0].INTERNALTESSPOS0.www, u_xlat2.xyz);
        u_xlat3.xyz = u_xlat1.xyz + u_xlat2.xyz;
        u_xlat1.xyz = u_xlat1.xyz + (-u_xlat2.xyz);
        u_xlat12 = dot(u_xlat1.xyz, u_xlat1.xyz);
        u_xlat12 = sqrt(u_xlat12);
        u_xlat12 = u_xlat12 * VGlobals._ScreenParams.y;
        u_xlat1.xyz = fma(u_xlat3.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat1.x = dot(u_xlat1.xyz, u_xlat1.xyz);
        u_xlat1.x = sqrt(u_xlat1.x);
        u_xlat1.x = u_xlat1.x * VGlobals._EdgeLength;
        u_xlat12 = u_xlat12 / u_xlat1.x;
        tessFactor.edgeTessellationFactor[1] = max(u_xlat12, 1.0);
        u_xlat1.xyz = u_xlat0.xyz + u_xlat2.xyz;
        u_xlat0.xyz = (-u_xlat0.xyz) + u_xlat2.xyz;
        u_xlat0.x = dot(u_xlat0.xyz, u_xlat0.xyz);
        u_xlat0.x = sqrt(u_xlat0.x);
        u_xlat0.x = u_xlat0.x * VGlobals._ScreenParams.y;
        u_xlat4.xyz = fma(u_xlat1.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat4.x = dot(u_xlat4.xyz, u_xlat4.xyz);
        u_xlat4.x = sqrt(u_xlat4.x);
        u_xlat4.x = u_xlat4.x * VGlobals._EdgeLength;
        u_xlat0.x = u_xlat0.x / u_xlat4.x;
        tessFactor.edgeTessellationFactor[2] = max(u_xlat0.x, 1.0);
    }
    // join_phase3
    {
        u_xlat0.x = tessFactor.edgeTessellationFactor[0] + tessFactor.edgeTessellationFactor[1];
        u_xlat0.x = u_xlat0.x + tessFactor.edgeTessellationFactor[2];
        tessFactor.insideTessellationFactor = u_xlat0.x * 0.333333343;
    }
    controlPoints[mtl_VertexID] = output;
    tessFactors[internalPatchID] = tessFactor;
}
// SHADER_STAGE_HULL_end
// SHADER_STAGE_DOMAIN_begin
struct Mtl_VertexInPostTess
{
    patch_control_point<Mtl_ControlPointIn> cp;
};
struct Mtl_VertexOutPostTess
{
    float4 mtl_Position [[ position ]];
    float3 TEXCOORD1 [[ user(TEXCOORD1) ]];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    sampler sampler_Height [[ sampler (0) ]],
    texture2d<float, access::sample > _Height [[ texture(0) ]] ,
    float3 mtl_TessCoord [[ position_in_patch ]],
    uint patchID [[ patch_id ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    Mtl_VertexInPostTess input [[ stage_in ]])
{
#pragma clang diagnostic pop
    Mtl_VertexOutPostTess output;
    MTLTriangleTessellationFactorsHalf tessFactor;
    tessFactor = tessFactors[patchID];
    float4 u_xlat0;
    float4 u_xlat1;
    float4 u_xlat2;
    float4 u_xlat3;
    float4 u_xlat4;
    float u_xlat11;
    float u_xlat15;
    bool u_xlatb15;
    u_xlat0.xyz = mtl_TessCoord.yyy * input.cp[1].NORMAL0.xyz;
    u_xlat0.xyz = fma(input.cp[0].NORMAL0.xyz, mtl_TessCoord.xxx, u_xlat0.xyz);
    u_xlat0.xyz = fma(input.cp[2].NORMAL0.xyz, mtl_TessCoord.zzz, u_xlat0.xyz);
    u_xlat1.x = dot(u_xlat0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat1.y = dot(u_xlat0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat1.z = dot(u_xlat0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat15 = dot(u_xlat1.xyz, u_xlat1.xyz);
    u_xlat15 = rsqrt(u_xlat15);
    u_xlat1.xyz = float3(u_xlat15) * u_xlat1.xyz;
    u_xlat2.xy = mtl_TessCoord.yy * input.cp[1].TEXCOORD0.xy;
    u_xlat2.xy = fma(input.cp[0].TEXCOORD0.xy, mtl_TessCoord.xx, u_xlat2.xy);
    u_xlat2.xy = fma(input.cp[2].TEXCOORD0.xy, mtl_TessCoord.zz, u_xlat2.xy);
    u_xlat2.xy = u_xlat2.xy * float2(VGlobals._Tile);
    u_xlat2.xyz = _Height.sample(sampler_Height, u_xlat2.xy, level(1.0)).xyz;
    u_xlat0.xyz = u_xlat0.xyz * u_xlat2.xyz;
    u_xlat2 = mtl_TessCoord.yyyy * input.cp[1].INTERNALTESSPOS0;
    u_xlat2 = fma(input.cp[0].INTERNALTESSPOS0, mtl_TessCoord.xxxx, u_xlat2);
    u_xlat2 = fma(input.cp[2].INTERNALTESSPOS0, mtl_TessCoord.zzzz, u_xlat2);
    u_xlat0.xyz = fma(u_xlat0.xyz, float3(VGlobals._HeightDisplacement), u_xlat2.xyz);
    u_xlat3 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], u_xlat0.xxxx, u_xlat3);
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], u_xlat0.zzzz, u_xlat3);
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3], u_xlat2.wwww, u_xlat3);
    u_xlat2.xyz = fma((-u_xlat3.xyz), VGlobals._WorldSpaceLightPos0.www, VGlobals._WorldSpaceLightPos0.xyz);
    u_xlat15 = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat15 = rsqrt(u_xlat15);
    u_xlat2.xyz = float3(u_xlat15) * u_xlat2.xyz;
    u_xlat15 = dot(u_xlat1.xyz, u_xlat2.xyz);
    u_xlat15 = fma((-u_xlat15), u_xlat15, 1.0);
    u_xlat15 = sqrt(u_xlat15);
    u_xlat15 = u_xlat15 * VGlobals.unity_LightShadowBias.z;
    u_xlat1.xyz = fma((-u_xlat1.xyz), float3(u_xlat15), u_xlat3.xyz);
    u_xlatb15 = VGlobals.unity_LightShadowBias.z!=0.0;
    u_xlat1.xyz = (bool(u_xlatb15)) ? u_xlat1.xyz : u_xlat3.xyz;
    u_xlat4 = u_xlat1.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat4 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat1.xxxx, u_xlat4);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat1.zzzz, u_xlat4);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat3.wwww, u_xlat1);
    u_xlat15 = VGlobals.unity_LightShadowBias.x / u_xlat1.w;
    u_xlat15 = min(u_xlat15, 0.0);
    u_xlat15 = max(u_xlat15, -1.0);
    u_xlat15 = u_xlat15 + u_xlat1.z;
    u_xlat11 = min(u_xlat1.w, u_xlat15);
    output.mtl_Position.xyw = u_xlat1.xyw;
    u_xlat1.x = (-u_xlat15) + u_xlat11;
    output.mtl_Position.z = fma(VGlobals.unity_LightShadowBias.y, u_xlat1.x, u_xlat15);
    u_xlat1.xyz = u_xlat0.yyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz;
    u_xlat0.xyw = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, u_xlat0.xxx, u_xlat1.xyz);
    u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, u_xlat0.zzz, u_xlat0.xyw);
    output.TEXCOORD1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, u_xlat2.www, u_xlat0.xyz);
    return output;
}
// SHADER_STAGE_DOMAIN_end
Compilation succeeded with: 

program_source:299:53: warning: writable resources in non-void post-tessellation vertex function
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
                                                    ^
program_source:305:30: note: writable buffer defined here
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
                             ^
program_source:306:48: note: writable buffer defined here
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
                                               ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float4 TEXCOORD0 [[ attribute(3) ]] ;
    float4 TEXCOORD1 [[ attribute(4) ]] ;
    float4 TEXCOORD2 [[ attribute(5) ]] ;
    float4 TEXCOORD3 [[ attribute(6) ]] ;
    float4 COLOR0 [[ attribute(7) ]] ;
};
struct Mtl_VertexOut
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float4 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float4 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float4 TEXCOORD3 [[ user(TEXCOORD3) ]];
    float4 COLOR0 [[ user(COLOR0) ]];
};
static Mtl_VertexOut vertexFunction(
    Mtl_VertexIn input)
{
    Mtl_VertexOut output;
    output.INTERNALTESSPOS0 = input.POSITION0;
    output.TANGENT0 = input.TANGENT0;
    output.NORMAL0.xyz = input.NORMAL0.xyz;
    output.TEXCOORD0 = input.TEXCOORD0;
    output.TEXCOORD1 = input.TEXCOORD1;
    output.TEXCOORD2 = input.TEXCOORD2;
    output.TEXCOORD3 = input.TEXCOORD3;
    output.COLOR0 = input.COLOR0;
    return output;
}
// SHADER_STAGE_HULL_begin
struct Mtl_ControlPoint
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float4 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float4 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float4 TEXCOORD3 [[ user(TEXCOORD3) ]];
    float4 COLOR0 [[ user(COLOR0) ]];
};
struct Mtl_ControlPointIn
{
    float4 INTERNALTESSPOS0 [[ attribute(8) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float4 TEXCOORD0 [[ attribute(3) ]] ;
    float4 TEXCOORD1 [[ attribute(4) ]] ;
    float4 TEXCOORD2 [[ attribute(5) ]] ;
    float4 TEXCOORD3 [[ attribute(6) ]] ;
    float4 COLOR0 [[ attribute(7) ]] ;
};
struct Mtl_KernelPatchInfo
{
    uint numPatches;
    ushort numControlPointsPerPatch;
};
struct VGlobals_Type
{
    float4 _Time;
    float4 _SinTime;
    float4 _CosTime;
    float4 unity_DeltaTime;
    float3 _WorldSpaceCameraPos;
    float4 _ProjectionParams;
    float4 _ScreenParams;
    float4 _ZBufferParams;
    float4 unity_OrthoParams;
    float4 unity_CameraWorldClipPlanes[6];
    float4 hlslcc_mtx4x4unity_CameraProjection[4];
    float4 hlslcc_mtx4x4unity_CameraInvProjection[4];
    float4 hlslcc_mtx4x4unity_WorldToCamera[4];
    float4 hlslcc_mtx4x4unity_CameraToWorld[4];
    float4 _WorldSpaceLightPos0;
    float4 _LightPositionRange;
    float4 _LightProjectionParams;
    float4 unity_4LightPosX0;
    float4 unity_4LightPosY0;
    float4 unity_4LightPosZ0;
    float4 unity_4LightAtten0;
    float4 unity_LightColor[8];
    float4 unity_LightPosition[8];
    float4 unity_LightAtten[8];
    float4 unity_SpotDirection[8];
    float4 unity_SHAr;
    float4 unity_SHAg;
    float4 unity_SHAb;
    float4 unity_SHBr;
    float4 unity_SHBg;
    float4 unity_SHBb;
    float4 unity_SHC;
    float4 unity_OcclusionMaskSelector;
    float4 unity_ProbesOcclusion;
    float3 unity_LightColor0;
    float3 unity_LightColor1;
    float3 unity_LightColor2;
    float3 unity_LightColor3;
    float4 unity_ShadowSplitSpheres[4];
    float4 unity_ShadowSplitSqRadii;
    float4 unity_LightShadowBias;
    float4 _LightSplitsNear;
    float4 _LightSplitsFar;
    float4 hlslcc_mtx4x4unity_WorldToShadow[16];
    float4 _LightShadowData;
    float4 unity_ShadowFadeCenterAndType;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 unity_LODFade;
    float4 unity_WorldTransformParams;
    float4 unity_RenderingLayer;
    float4 hlslcc_mtx4x4glstate_matrix_transpose_modelview0[4];
    float4 glstate_lightmodel_ambient;
    float4 unity_AmbientSky;
    float4 unity_AmbientEquator;
    float4 unity_AmbientGround;
    float4 unity_IndirectSpecColor;
    float4 hlslcc_mtx4x4glstate_matrix_projection[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixInvV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    int unity_StereoEyeIndex;
    float4 unity_ShadowColor;
    float4 unity_FogColor;
    float4 unity_FogParams;
    float4 unity_LightmapST;
    float4 unity_DynamicLightmapST;
    float4 unity_SpecCube0_BoxMax;
    float4 unity_SpecCube0_BoxMin;
    float4 unity_SpecCube0_ProbePosition;
    float4 unity_SpecCube0_HDR;
    float4 unity_SpecCube1_BoxMax;
    float4 unity_SpecCube1_BoxMin;
    float4 unity_SpecCube1_ProbePosition;
    float4 unity_SpecCube1_HDR;
    float4 unity_ProbeVolumeParams;
    float4 hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[4];
    float3 unity_ProbeVolumeSizeInv;
    float3 unity_ProbeVolumeMin;
    float4 unity_Lightmap_HDR;
    float4 unity_DynamicLightmap_HDR;
    float4 _LightColor0;
    float4 _SpecColor;
    float _Tile;
    float _HeightDisplacement;
    float _NormalScale;
    float4 _ColorTint;
    float _MetallicStrength;
    float _SmoothnessStrength;
    float _EdgeLength;
    float4 _texcoord_ST;
    float4 unity_Ambient;
};
struct Mtl_HullIn
{
    Mtl_VertexOut cp[3];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
kernel void patchKernel(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn vertexInput [[ stage_in ]],
    uint2 tID [[ thread_position_in_grid ]],
    ushort2 groupID [[ threadgroup_position_in_grid ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    constant Mtl_KernelPatchInfo &patchInfo [[ buffer(3) ]])
{
#pragma clang diagnostic pop
    Mtl_ControlPoint output;
    const uint numPatchesInThreadGroup = 10;
    const uint patchID = (tID.x / patchInfo.numControlPointsPerPatch);
    const bool patchValid = (patchID < patchInfo.numPatches);
    const uint mtl_BaseInstance = 0;
    const uint mtl_InstanceID = groupID.y - mtl_BaseInstance;
    const uint internalPatchID = mtl_InstanceID * patchInfo.numPatches + patchID;
    const uint patchIDInThreadGroup = (patchID % numPatchesInThreadGroup);
    const uint controlPointID = (tID.x % patchInfo.numControlPointsPerPatch);
    const uint mtl_BaseVertex = 0;
    const uint mtl_VertexID = ((mtl_InstanceID * (patchInfo.numControlPointsPerPatch * patchInfo.numPatches)) + tID.x) - mtl_BaseVertex;
    threadgroup Mtl_HullIn inputGroup[numPatchesInThreadGroup];
    threadgroup Mtl_HullIn &input = inputGroup[patchIDInThreadGroup];
    MTLTriangleTessellationFactorsHalf tessFactor;
    if (patchValid) {
        input.cp[controlPointID] = vertexFunction(vertexInput);
        output.INTERNALTESSPOS0 = input.cp[controlPointID].INTERNALTESSPOS0;
        output.TANGENT0 = input.cp[controlPointID].TANGENT0;
        output.NORMAL0 = input.cp[controlPointID].NORMAL0;
        output.TEXCOORD0 = input.cp[controlPointID].TEXCOORD0;
        output.TEXCOORD1 = input.cp[controlPointID].TEXCOORD1;
        output.TEXCOORD2 = input.cp[controlPointID].TEXCOORD2;
        output.TEXCOORD3 = input.cp[controlPointID].TEXCOORD3;
        output.COLOR0 = input.cp[controlPointID].COLOR0;
    }
    threadgroup_barrier(mem_flags::mem_threadgroup);
    if (!patchValid) {
        return;
    }
    float3 u_xlat0;
    float3 u_xlat1;
    float3 u_xlat2;
    float3 u_xlat3;
    float3 u_xlat4;
    float u_xlat12;
    float u_xlat13;
    // fork_phase2
    {
        u_xlat0.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[1].INTERNALTESSPOS0.yyy;
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[1].INTERNALTESSPOS0.xxx, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[1].INTERNALTESSPOS0.zzz, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[1].INTERNALTESSPOS0.www, u_xlat0.xyz);
        u_xlat1.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[2].INTERNALTESSPOS0.yyy;
        u_xlat1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[2].INTERNALTESSPOS0.xxx, u_xlat1.xyz);
        u_xlat1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[2].INTERNALTESSPOS0.zzz, u_xlat1.xyz);
        u_xlat1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[2].INTERNALTESSPOS0.www, u_xlat1.xyz);
        u_xlat2.xyz = u_xlat0.xyz + u_xlat1.xyz;
        u_xlat2.xyz = fma(u_xlat2.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat12 = dot(u_xlat2.xyz, u_xlat2.xyz);
        u_xlat12 = sqrt(u_xlat12);
        u_xlat12 = u_xlat12 * VGlobals._EdgeLength;
        u_xlat2.xyz = u_xlat0.xyz + (-u_xlat1.xyz);
        u_xlat13 = dot(u_xlat2.xyz, u_xlat2.xyz);
        u_xlat13 = sqrt(u_xlat13);
        u_xlat13 = u_xlat13 * VGlobals._ScreenParams.y;
        u_xlat12 = u_xlat13 / u_xlat12;
        tessFactor.edgeTessellationFactor[0] = max(u_xlat12, 1.0);
        u_xlat2.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[0].INTERNALTESSPOS0.yyy;
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[0].INTERNALTESSPOS0.xxx, u_xlat2.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[0].INTERNALTESSPOS0.zzz, u_xlat2.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[0].INTERNALTESSPOS0.www, u_xlat2.xyz);
        u_xlat3.xyz = u_xlat1.xyz + u_xlat2.xyz;
        u_xlat1.xyz = u_xlat1.xyz + (-u_xlat2.xyz);
        u_xlat12 = dot(u_xlat1.xyz, u_xlat1.xyz);
        u_xlat12 = sqrt(u_xlat12);
        u_xlat12 = u_xlat12 * VGlobals._ScreenParams.y;
        u_xlat1.xyz = fma(u_xlat3.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat1.x = dot(u_xlat1.xyz, u_xlat1.xyz);
        u_xlat1.x = sqrt(u_xlat1.x);
        u_xlat1.x = u_xlat1.x * VGlobals._EdgeLength;
        u_xlat12 = u_xlat12 / u_xlat1.x;
        tessFactor.edgeTessellationFactor[1] = max(u_xlat12, 1.0);
        u_xlat1.xyz = u_xlat0.xyz + u_xlat2.xyz;
        u_xlat0.xyz = (-u_xlat0.xyz) + u_xlat2.xyz;
        u_xlat0.x = dot(u_xlat0.xyz, u_xlat0.xyz);
        u_xlat0.x = sqrt(u_xlat0.x);
        u_xlat0.x = u_xlat0.x * VGlobals._ScreenParams.y;
        u_xlat4.xyz = fma(u_xlat1.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat4.x = dot(u_xlat4.xyz, u_xlat4.xyz);
        u_xlat4.x = sqrt(u_xlat4.x);
        u_xlat4.x = u_xlat4.x * VGlobals._EdgeLength;
        u_xlat0.x = u_xlat0.x / u_xlat4.x;
        tessFactor.edgeTessellationFactor[2] = max(u_xlat0.x, 1.0);
    }
    // join_phase3
    {
        u_xlat0.x = tessFactor.edgeTessellationFactor[0] + tessFactor.edgeTessellationFactor[1];
        u_xlat0.x = u_xlat0.x + tessFactor.edgeTessellationFactor[2];
        tessFactor.insideTessellationFactor = u_xlat0.x * 0.333333343;
    }
    controlPoints[mtl_VertexID] = output;
    tessFactors[internalPatchID] = tessFactor;
}
// SHADER_STAGE_HULL_end
// SHADER_STAGE_DOMAIN_begin
struct Mtl_VertexInPostTess
{
    patch_control_point<Mtl_ControlPointIn> cp;
};
struct Mtl_VertexOutPostTess
{
    float4 mtl_Position [[ position ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float4 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float4 TEXCOORD3 [[ user(TEXCOORD3) ]];
    float4 TEXCOORD5 [[ user(TEXCOORD5) ]];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    sampler sampler_Height [[ sampler (0) ]],
    texture2d<float, access::sample > _Height [[ texture(0) ]] ,
    float3 mtl_TessCoord [[ position_in_patch ]],
    uint patchID [[ patch_id ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    Mtl_VertexInPostTess input [[ stage_in ]])
{
#pragma clang diagnostic pop
    Mtl_VertexOutPostTess output;
    MTLTriangleTessellationFactorsHalf tessFactor;
    tessFactor = tessFactors[patchID];
    float4 u_xlat0;
    float4 u_xlat1;
    float4 u_xlat2;
    float4 u_xlat3;
    float2 u_xlat9;
    float u_xlat12;
    float u_xlat13;
    u_xlat0 = mtl_TessCoord.yyyy * input.cp[1].INTERNALTESSPOS0;
    u_xlat0 = fma(input.cp[0].INTERNALTESSPOS0, mtl_TessCoord.xxxx, u_xlat0);
    u_xlat0 = fma(input.cp[2].INTERNALTESSPOS0, mtl_TessCoord.zzzz, u_xlat0);
    u_xlat1.xy = mtl_TessCoord.yy * input.cp[1].TEXCOORD0.xy;
    u_xlat1.xy = fma(input.cp[0].TEXCOORD0.xy, mtl_TessCoord.xx, u_xlat1.xy);
    u_xlat1.xy = fma(input.cp[2].TEXCOORD0.xy, mtl_TessCoord.zz, u_xlat1.xy);
    u_xlat9.xy = u_xlat1.xy * float2(VGlobals._Tile);
    output.TEXCOORD0.xy = fma(u_xlat1.xy, VGlobals._texcoord_ST.xy, VGlobals._texcoord_ST.zw);
    u_xlat1.xyz = _Height.sample(sampler_Height, u_xlat9.xy, level(1.0)).xyz;
    u_xlat2.xyz = mtl_TessCoord.yyy * input.cp[1].NORMAL0.xyz;
    u_xlat2.xyz = fma(input.cp[0].NORMAL0.xyz, mtl_TessCoord.xxx, u_xlat2.xyz);
    u_xlat2.xyz = fma(input.cp[2].NORMAL0.xyz, mtl_TessCoord.zzz, u_xlat2.xyz);
    u_xlat1.xyz = u_xlat1.xyz * u_xlat2.xyz;
    u_xlat0.xyz = fma(u_xlat1.xyz, float3(VGlobals._HeightDisplacement), u_xlat0.xyz);
    u_xlat1 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], u_xlat0.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], u_xlat0.zzzz, u_xlat1);
    u_xlat3 = u_xlat1 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, u_xlat0.www, u_xlat1.xyz);
    u_xlat1 = u_xlat3.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat3.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat3.zzzz, u_xlat1);
    output.mtl_Position = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat3.wwww, u_xlat1);
    u_xlat1.y = dot(u_xlat2.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat1.z = dot(u_xlat2.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat1.x = dot(u_xlat2.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat12 = dot(u_xlat1.xyz, u_xlat1.xyz);
    u_xlat12 = rsqrt(u_xlat12);
    u_xlat1.xyz = float3(u_xlat12) * u_xlat1.xyz;
    output.TEXCOORD1.z = u_xlat1.y;
    u_xlat2 = mtl_TessCoord.yyyy * input.cp[1].TANGENT0;
    u_xlat2 = fma(input.cp[0].TANGENT0, mtl_TessCoord.xxxx, u_xlat2);
    u_xlat2 = fma(input.cp[2].TANGENT0, mtl_TessCoord.zzzz, u_xlat2);
    u_xlat3.xyz = u_xlat2.yyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].yzx;
    u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].yzx, u_xlat2.xxx, u_xlat3.xyz);
    u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].yzx, u_xlat2.zzz, u_xlat3.xyz);
    u_xlat12 = u_xlat2.w * VGlobals.unity_WorldTransformParams.w;
    u_xlat13 = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat13 = rsqrt(u_xlat13);
    u_xlat2.xyz = float3(u_xlat13) * u_xlat2.xyz;
    u_xlat3.xyz = u_xlat1.xyz * u_xlat2.xyz;
    u_xlat3.xyz = fma(u_xlat1.zxy, u_xlat2.yzx, (-u_xlat3.xyz));
    u_xlat3.xyz = float3(u_xlat12) * u_xlat3.xyz;
    output.TEXCOORD1.y = u_xlat3.x;
    output.TEXCOORD1.w = u_xlat0.x;
    output.TEXCOORD1.x = u_xlat2.z;
    output.TEXCOORD2.w = u_xlat0.y;
    output.TEXCOORD3.w = u_xlat0.z;
    output.TEXCOORD2.x = u_xlat2.x;
    output.TEXCOORD3.x = u_xlat2.y;
    output.TEXCOORD2.z = u_xlat1.z;
    output.TEXCOORD3.z = u_xlat1.x;
    output.TEXCOORD2.y = u_xlat3.y;
    output.TEXCOORD3.y = u_xlat3.z;
    output.TEXCOORD5 = float4(0.0, 0.0, 0.0, 0.0);
    return output;
}
// SHADER_STAGE_DOMAIN_end
Compilation succeeded with: 

program_source:303:53: warning: writable resources in non-void post-tessellation vertex function
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
                                                    ^
program_source:309:30: note: writable buffer defined here
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
                             ^
program_source:310:48: note: writable buffer defined here
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
                                               ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float4 TEXCOORD0 [[ attribute(3) ]] ;
    float4 TEXCOORD1 [[ attribute(4) ]] ;
    float4 TEXCOORD2 [[ attribute(5) ]] ;
    float4 TEXCOORD3 [[ attribute(6) ]] ;
    float4 COLOR0 [[ attribute(7) ]] ;
};
struct Mtl_VertexOut
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float4 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float4 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float4 TEXCOORD3 [[ user(TEXCOORD3) ]];
    float4 COLOR0 [[ user(COLOR0) ]];
};
static Mtl_VertexOut vertexFunction(
    Mtl_VertexIn input)
{
    Mtl_VertexOut output;
    output.INTERNALTESSPOS0 = input.POSITION0;
    output.TANGENT0 = input.TANGENT0;
    output.NORMAL0.xyz = input.NORMAL0.xyz;
    output.TEXCOORD0 = input.TEXCOORD0;
    output.TEXCOORD1 = input.TEXCOORD1;
    output.TEXCOORD2 = input.TEXCOORD2;
    output.TEXCOORD3 = input.TEXCOORD3;
    output.COLOR0 = input.COLOR0;
    return output;
}
// SHADER_STAGE_HULL_begin
struct Mtl_ControlPoint
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float4 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float4 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float4 TEXCOORD3 [[ user(TEXCOORD3) ]];
    float4 COLOR0 [[ user(COLOR0) ]];
};
struct Mtl_ControlPointIn
{
    float4 INTERNALTESSPOS0 [[ attribute(8) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float4 TEXCOORD0 [[ attribute(3) ]] ;
    float4 TEXCOORD1 [[ attribute(4) ]] ;
    float4 TEXCOORD2 [[ attribute(5) ]] ;
    float4 TEXCOORD3 [[ attribute(6) ]] ;
    float4 COLOR0 [[ attribute(7) ]] ;
};
struct Mtl_KernelPatchInfo
{
    uint numPatches;
    ushort numControlPointsPerPatch;
};
struct VGlobals_Type
{
    float4 _Time;
    float4 _SinTime;
    float4 _CosTime;
    float4 unity_DeltaTime;
    float3 _WorldSpaceCameraPos;
    float4 _ProjectionParams;
    float4 _ScreenParams;
    float4 _ZBufferParams;
    float4 unity_OrthoParams;
    float4 unity_CameraWorldClipPlanes[6];
    float4 hlslcc_mtx4x4unity_CameraProjection[4];
    float4 hlslcc_mtx4x4unity_CameraInvProjection[4];
    float4 hlslcc_mtx4x4unity_WorldToCamera[4];
    float4 hlslcc_mtx4x4unity_CameraToWorld[4];
    float4 _WorldSpaceLightPos0;
    float4 _LightPositionRange;
    float4 _LightProjectionParams;
    float4 unity_4LightPosX0;
    float4 unity_4LightPosY0;
    float4 unity_4LightPosZ0;
    float4 unity_4LightAtten0;
    float4 unity_LightColor[8];
    float4 unity_LightPosition[8];
    float4 unity_LightAtten[8];
    float4 unity_SpotDirection[8];
    float4 unity_SHAr;
    float4 unity_SHAg;
    float4 unity_SHAb;
    float4 unity_SHBr;
    float4 unity_SHBg;
    float4 unity_SHBb;
    float4 unity_SHC;
    float4 unity_OcclusionMaskSelector;
    float4 unity_ProbesOcclusion;
    float3 unity_LightColor0;
    float3 unity_LightColor1;
    float3 unity_LightColor2;
    float3 unity_LightColor3;
    float4 unity_ShadowSplitSpheres[4];
    float4 unity_ShadowSplitSqRadii;
    float4 unity_LightShadowBias;
    float4 _LightSplitsNear;
    float4 _LightSplitsFar;
    float4 hlslcc_mtx4x4unity_WorldToShadow[16];
    float4 _LightShadowData;
    float4 unity_ShadowFadeCenterAndType;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 unity_LODFade;
    float4 unity_WorldTransformParams;
    float4 unity_RenderingLayer;
    float4 hlslcc_mtx4x4glstate_matrix_transpose_modelview0[4];
    float4 glstate_lightmodel_ambient;
    float4 unity_AmbientSky;
    float4 unity_AmbientEquator;
    float4 unity_AmbientGround;
    float4 unity_IndirectSpecColor;
    float4 hlslcc_mtx4x4glstate_matrix_projection[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixInvV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    int unity_StereoEyeIndex;
    float4 unity_ShadowColor;
    float4 unity_FogColor;
    float4 unity_FogParams;
    float4 unity_LightmapST;
    float4 unity_DynamicLightmapST;
    float4 unity_SpecCube0_BoxMax;
    float4 unity_SpecCube0_BoxMin;
    float4 unity_SpecCube0_ProbePosition;
    float4 unity_SpecCube0_HDR;
    float4 unity_SpecCube1_BoxMax;
    float4 unity_SpecCube1_BoxMin;
    float4 unity_SpecCube1_ProbePosition;
    float4 unity_SpecCube1_HDR;
    float4 unity_ProbeVolumeParams;
    float4 hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[4];
    float3 unity_ProbeVolumeSizeInv;
    float3 unity_ProbeVolumeMin;
    float4 unity_Lightmap_HDR;
    float4 unity_DynamicLightmap_HDR;
    float4 _LightColor0;
    float4 _SpecColor;
    float _Tile;
    float _HeightDisplacement;
    float _NormalScale;
    float4 _ColorTint;
    float _MetallicStrength;
    float _SmoothnessStrength;
    float _EdgeLength;
    bool4 unity_MetaVertexControl;
    bool4 unity_MetaFragmentControl;
    int unity_VisualizationMode;
    float unity_OneOverOutputBoost;
    float unity_MaxOutputValue;
    float unity_UseLinearSpace;
    float4 _texcoord_ST;
};
struct Mtl_HullIn
{
    Mtl_VertexOut cp[3];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
kernel void patchKernel(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn vertexInput [[ stage_in ]],
    uint2 tID [[ thread_position_in_grid ]],
    ushort2 groupID [[ threadgroup_position_in_grid ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    constant Mtl_KernelPatchInfo &patchInfo [[ buffer(3) ]])
{
#pragma clang diagnostic pop
    Mtl_ControlPoint output;
    const uint numPatchesInThreadGroup = 10;
    const uint patchID = (tID.x / patchInfo.numControlPointsPerPatch);
    const bool patchValid = (patchID < patchInfo.numPatches);
    const uint mtl_BaseInstance = 0;
    const uint mtl_InstanceID = groupID.y - mtl_BaseInstance;
    const uint internalPatchID = mtl_InstanceID * patchInfo.numPatches + patchID;
    const uint patchIDInThreadGroup = (patchID % numPatchesInThreadGroup);
    const uint controlPointID = (tID.x % patchInfo.numControlPointsPerPatch);
    const uint mtl_BaseVertex = 0;
    const uint mtl_VertexID = ((mtl_InstanceID * (patchInfo.numControlPointsPerPatch * patchInfo.numPatches)) + tID.x) - mtl_BaseVertex;
    threadgroup Mtl_HullIn inputGroup[numPatchesInThreadGroup];
    threadgroup Mtl_HullIn &input = inputGroup[patchIDInThreadGroup];
    MTLTriangleTessellationFactorsHalf tessFactor;
    if (patchValid) {
        input.cp[controlPointID] = vertexFunction(vertexInput);
        output.INTERNALTESSPOS0 = input.cp[controlPointID].INTERNALTESSPOS0;
        output.TANGENT0 = input.cp[controlPointID].TANGENT0;
        output.NORMAL0 = input.cp[controlPointID].NORMAL0;
        output.TEXCOORD0 = input.cp[controlPointID].TEXCOORD0;
        output.TEXCOORD1 = input.cp[controlPointID].TEXCOORD1;
        output.TEXCOORD2 = input.cp[controlPointID].TEXCOORD2;
        output.TEXCOORD3 = input.cp[controlPointID].TEXCOORD3;
        output.COLOR0 = input.cp[controlPointID].COLOR0;
    }
    threadgroup_barrier(mem_flags::mem_threadgroup);
    if (!patchValid) {
        return;
    }
    float3 u_xlat0;
    float3 u_xlat1;
    float3 u_xlat2;
    float3 u_xlat3;
    float3 u_xlat4;
    float u_xlat12;
    float u_xlat13;
    // fork_phase2
    {
        u_xlat0.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[1].INTERNALTESSPOS0.yyy;
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[1].INTERNALTESSPOS0.xxx, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[1].INTERNALTESSPOS0.zzz, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[1].INTERNALTESSPOS0.www, u_xlat0.xyz);
        u_xlat1.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[2].INTERNALTESSPOS0.yyy;
        u_xlat1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[2].INTERNALTESSPOS0.xxx, u_xlat1.xyz);
        u_xlat1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[2].INTERNALTESSPOS0.zzz, u_xlat1.xyz);
        u_xlat1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[2].INTERNALTESSPOS0.www, u_xlat1.xyz);
        u_xlat2.xyz = u_xlat0.xyz + u_xlat1.xyz;
        u_xlat2.xyz = fma(u_xlat2.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat12 = dot(u_xlat2.xyz, u_xlat2.xyz);
        u_xlat12 = sqrt(u_xlat12);
        u_xlat12 = u_xlat12 * VGlobals._EdgeLength;
        u_xlat2.xyz = u_xlat0.xyz + (-u_xlat1.xyz);
        u_xlat13 = dot(u_xlat2.xyz, u_xlat2.xyz);
        u_xlat13 = sqrt(u_xlat13);
        u_xlat13 = u_xlat13 * VGlobals._ScreenParams.y;
        u_xlat12 = u_xlat13 / u_xlat12;
        tessFactor.edgeTessellationFactor[0] = max(u_xlat12, 1.0);
        u_xlat2.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[0].INTERNALTESSPOS0.yyy;
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[0].INTERNALTESSPOS0.xxx, u_xlat2.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[0].INTERNALTESSPOS0.zzz, u_xlat2.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[0].INTERNALTESSPOS0.www, u_xlat2.xyz);
        u_xlat3.xyz = u_xlat1.xyz + u_xlat2.xyz;
        u_xlat1.xyz = u_xlat1.xyz + (-u_xlat2.xyz);
        u_xlat12 = dot(u_xlat1.xyz, u_xlat1.xyz);
        u_xlat12 = sqrt(u_xlat12);
        u_xlat12 = u_xlat12 * VGlobals._ScreenParams.y;
        u_xlat1.xyz = fma(u_xlat3.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat1.x = dot(u_xlat1.xyz, u_xlat1.xyz);
        u_xlat1.x = sqrt(u_xlat1.x);
        u_xlat1.x = u_xlat1.x * VGlobals._EdgeLength;
        u_xlat12 = u_xlat12 / u_xlat1.x;
        tessFactor.edgeTessellationFactor[1] = max(u_xlat12, 1.0);
        u_xlat1.xyz = u_xlat0.xyz + u_xlat2.xyz;
        u_xlat0.xyz = (-u_xlat0.xyz) + u_xlat2.xyz;
        u_xlat0.x = dot(u_xlat0.xyz, u_xlat0.xyz);
        u_xlat0.x = sqrt(u_xlat0.x);
        u_xlat0.x = u_xlat0.x * VGlobals._ScreenParams.y;
        u_xlat4.xyz = fma(u_xlat1.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat4.x = dot(u_xlat4.xyz, u_xlat4.xyz);
        u_xlat4.x = sqrt(u_xlat4.x);
        u_xlat4.x = u_xlat4.x * VGlobals._EdgeLength;
        u_xlat0.x = u_xlat0.x / u_xlat4.x;
        tessFactor.edgeTessellationFactor[2] = max(u_xlat0.x, 1.0);
    }
    // join_phase3
    {
        u_xlat0.x = tessFactor.edgeTessellationFactor[0] + tessFactor.edgeTessellationFactor[1];
        u_xlat0.x = u_xlat0.x + tessFactor.edgeTessellationFactor[2];
        tessFactor.insideTessellationFactor = u_xlat0.x * 0.333333343;
    }
    controlPoints[mtl_VertexID] = output;
    tessFactors[internalPatchID] = tessFactor;
}
// SHADER_STAGE_HULL_end
// SHADER_STAGE_DOMAIN_begin
struct Mtl_VertexInPostTess
{
    patch_control_point<Mtl_ControlPointIn> cp;
};
struct Mtl_VertexOutPostTess
{
    float4 mtl_Position [[ position ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float4 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float4 TEXCOORD3 [[ user(TEXCOORD3) ]];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    sampler sampler_Height [[ sampler (0) ]],
    texture2d<float, access::sample > _Height [[ texture(0) ]] ,
    float3 mtl_TessCoord [[ position_in_patch ]],
    uint patchID [[ patch_id ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    Mtl_VertexInPostTess input [[ stage_in ]])
{
#pragma clang diagnostic pop
    Mtl_VertexOutPostTess output;
    MTLTriangleTessellationFactorsHalf tessFactor;
    tessFactor = tessFactors[patchID];
    float4 u_xlat0;
    float4 u_xlat1;
    float4 u_xlat2;
    float3 u_xlat3;
    float3 u_xlat4;
    float2 u_xlat13;
    float u_xlat15;
    bool u_xlatb15;
    u_xlat0.xy = mtl_TessCoord.yy * input.cp[1].TEXCOORD2.xy;
    u_xlat0.xy = fma(input.cp[0].TEXCOORD2.xy, mtl_TessCoord.xx, u_xlat0.xy);
    u_xlat0.xy = fma(input.cp[2].TEXCOORD2.xy, mtl_TessCoord.zz, u_xlat0.xy);
    u_xlat0.xy = fma(u_xlat0.xy, VGlobals.unity_DynamicLightmapST.xy, VGlobals.unity_DynamicLightmapST.zw);
    u_xlat1.xy = mtl_TessCoord.yy * input.cp[1].TEXCOORD1.xy;
    u_xlat1.xy = fma(input.cp[0].TEXCOORD1.xy, mtl_TessCoord.xx, u_xlat1.xy);
    u_xlat1.xy = fma(input.cp[2].TEXCOORD1.xy, mtl_TessCoord.zz, u_xlat1.xy);
    u_xlat1.xy = fma(u_xlat1.xy, VGlobals.unity_LightmapST.xy, VGlobals.unity_LightmapST.zw);
    u_xlat2 = mtl_TessCoord.yyyy * input.cp[1].INTERNALTESSPOS0;
    u_xlat2 = fma(input.cp[0].INTERNALTESSPOS0, mtl_TessCoord.xxxx, u_xlat2);
    u_xlat2 = fma(input.cp[2].INTERNALTESSPOS0, mtl_TessCoord.zzzz, u_xlat2);
    u_xlat3.xy = mtl_TessCoord.yy * input.cp[1].TEXCOORD0.xy;
    u_xlat3.xy = fma(input.cp[0].TEXCOORD0.xy, mtl_TessCoord.xx, u_xlat3.xy);
    u_xlat3.xy = fma(input.cp[2].TEXCOORD0.xy, mtl_TessCoord.zz, u_xlat3.xy);
    u_xlat13.xy = u_xlat3.xy * float2(VGlobals._Tile);
    output.TEXCOORD0.xy = fma(u_xlat3.xy, VGlobals._texcoord_ST.xy, VGlobals._texcoord_ST.zw);
    u_xlat3.xyz = _Height.sample(sampler_Height, u_xlat13.xy, level(1.0)).xyz;
    u_xlat4.xyz = mtl_TessCoord.yyy * input.cp[1].NORMAL0.xyz;
    u_xlat4.xyz = fma(input.cp[0].NORMAL0.xyz, mtl_TessCoord.xxx, u_xlat4.xyz);
    u_xlat4.xyz = fma(input.cp[2].NORMAL0.xyz, mtl_TessCoord.zzz, u_xlat4.xyz);
    u_xlat3.xyz = u_xlat3.xyz * u_xlat4.xyz;
    u_xlat2.xyz = fma(u_xlat3.xyz, float3(VGlobals._HeightDisplacement), u_xlat2.xyz);
    u_xlatb15 = 0.0<u_xlat2.z;
    u_xlat1.z = u_xlatb15 ? 9.99999975e-05 : float(0.0);
    u_xlat1.xyz = (VGlobals.unity_MetaVertexControl.x) ? u_xlat1.xyz : u_xlat2.xyz;
    u_xlatb15 = 0.0<u_xlat1.z;
    u_xlat0.z = u_xlatb15 ? 9.99999975e-05 : float(0.0);
    u_xlat0.xyz = (VGlobals.unity_MetaVertexControl.y) ? u_xlat0.xyz : u_xlat1.xyz;
    u_xlat1 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat0.xxxx, u_xlat1);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat0.zzzz, u_xlat1);
    output.mtl_Position = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_MatrixVP[3];
    u_xlat0.xyz = u_xlat2.yyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz;
    u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, u_xlat2.xxx, u_xlat0.xyz);
    u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, u_xlat2.zzz, u_xlat0.xyz);
    u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, u_xlat2.www, u_xlat0.xyz);
    output.TEXCOORD1.w = u_xlat0.x;
    u_xlat1.y = dot(u_xlat4.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat1.z = dot(u_xlat4.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat1.x = dot(u_xlat4.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat0.x = dot(u_xlat1.xyz, u_xlat1.xyz);
    u_xlat0.x = rsqrt(u_xlat0.x);
    u_xlat1.xyz = u_xlat0.xxx * u_xlat1.xyz;
    output.TEXCOORD1.z = u_xlat1.y;
    u_xlat2 = mtl_TessCoord.yyyy * input.cp[1].TANGENT0;
    u_xlat2 = fma(input.cp[0].TANGENT0, mtl_TessCoord.xxxx, u_xlat2);
    u_xlat2 = fma(input.cp[2].TANGENT0, mtl_TessCoord.zzzz, u_xlat2);
    u_xlat3.xyz = u_xlat2.yyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].yzx;
    u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].yzx, u_xlat2.xxx, u_xlat3.xyz);
    u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].yzx, u_xlat2.zzz, u_xlat3.xyz);
    u_xlat0.x = u_xlat2.w * VGlobals.unity_WorldTransformParams.w;
    u_xlat15 = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat15 = rsqrt(u_xlat15);
    u_xlat2.xyz = float3(u_xlat15) * u_xlat2.xyz;
    u_xlat3.xyz = u_xlat1.xyz * u_xlat2.xyz;
    u_xlat3.xyz = fma(u_xlat1.zxy, u_xlat2.yzx, (-u_xlat3.xyz));
    u_xlat3.xyz = u_xlat0.xxx * u_xlat3.xyz;
    output.TEXCOORD1.y = u_xlat3.x;
    output.TEXCOORD1.x = u_xlat2.z;
    output.TEXCOORD2.w = u_xlat0.y;
    output.TEXCOORD3.w = u_xlat0.z;
    output.TEXCOORD2.x = u_xlat2.x;
    output.TEXCOORD3.x = u_xlat2.y;
    output.TEXCOORD2.z = u_xlat1.z;
    output.TEXCOORD3.z = u_xlat1.x;
    output.TEXCOORD2.y = u_xlat3.y;
    output.TEXCOORD3.y = u_xlat3.z;
    return output;
}
// SHADER_STAGE_DOMAIN_end
Refreshing native plugins compatible for Editor in 0.75 ms, found 2 plugins.
Preloading 0 native plugins for Editor in 0.00 ms.
Unloading 3397 Unused Serialized files (Serialized files now loaded: 0)
Unloading 27 unused Assets / (0.6 MB). Loaded Objects now: 3869.
Memory consumption went from 127.7 MB to 127.1 MB.
Total: 4.654680 ms (FindLiveObjects: 0.376428 ms CreateObjectMapping: 0.172637 ms MarkObjects: 3.675598 ms  DeleteObjects: 0.428833 ms)

AssetImportParameters requested are different than current active one (requested -> active):
  custom:video-decoder-ogg-theora: a1e56fd34408186e4bbccfd4996cb3dc -> 
  custom:container-muxer-webm: aa71ff27fc2769a1b78a27578f13a17b -> 
  custom:container-demuxer-webm: 4f35f7cbe854078d1ac9338744f61a02 -> 
  custom:video-encoder-webm-vp8: eb34c28f22e8b96e1ab97ce403110664 -> 
  custom:framework-osx-AVFoundation: b23960f63f64bdc6ff669e2cdcee2391 -> 
  custom:audio-encoder-webm-vorbis: bf7c407c2cedff20999df2af8eb42d56 -> 
  custom:container-demuxer-ogg: 62fdf1f143b41e24485cea50d1cbac27 -> 
  custom:video-decoder-webm-vp8: 9c59270c3fd7afecdb556c50c9e8de78 -> 
  custom:audio-decoder-ogg-vorbis: bf7c407c2cedff20999df2af8eb42d56 -> 
========================================================================
Received Import Request.
  Time since last request: 50403.401312 seconds.
  path: Assets/Player_01.controller
  artifactKey: Guid(2867e02a07c634f94ade831cf6ecdced) Importer(815301076,1909f56bfc062723c751e8b465ee728b)
Start importing Assets/Player_01.controller using Guid(2867e02a07c634f94ade831cf6ecdced) Importer(815301076,1909f56bfc062723c751e8b465ee728b)  -> (artifact id: 'f6c7e71614a75b6f266edcb5f627bcfb') in 0.834294 seconds 
========================================================================
Received Prepare
Registering precompiled user dll's ...
Registered in 0.003761 seconds.
Begin MonoManager ReloadAssembly
Symbol file LoadedFromMemory doesn't match image /Users/kamilaamendolagine/Desktop/Staugen Raug v2 - Prefab - Map 1.01/Library/PackageCache/com.unity.visualscripting@1.7.8/Editor/VisualScripting.Core/Dependencies/YamlDotNet/Unity.VisualScripting.YamlDotNet.dll
Symbol file LoadedFromMemory doesn't match image /Users/kamilaamendolagine/Desktop/Staugen Raug v2 - Prefab - Map 1.01/Library/PackageCache/com.unity.visualscripting@1.7.8/Editor/VisualScripting.Core/Dependencies/DotNetZip/Unity.VisualScripting.IonicZip.dll
Native extension for OSXStandalone target not found
Native extension for WebGL target not found
Refreshing native plugins compatible for Editor in 0.93 ms, found 2 plugins.
Preloading 0 native plugins for Editor in 0.00 ms.
Mono: successfully reloaded assembly
- Completed reload, in  1.837 seconds
Domain Reload Profiling:
	ReloadAssembly (1839ms)
		BeginReloadAssembly (207ms)
			ExecutionOrderSort (0ms)
			DisableScriptedObjects (10ms)
			BackupInstance (0ms)
			ReleaseScriptingObjects (0ms)
			CreateAndSetChildDomain (91ms)
		EndReloadAssembly (1463ms)
			LoadAssemblies (93ms)
			RebuildTransferFunctionScriptingTraits (0ms)
			SetupTypeCache (498ms)
			ReleaseScriptCaches (2ms)
			RebuildScriptCaches (88ms)
			SetupLoadedEditorAssemblies (665ms)
				LogAssemblyErrors (0ms)
				InitializePlatformSupportModulesInManaged (19ms)
				SetLoadedEditorAssemblies (1ms)
				RefreshPlugins (1ms)
				BeforeProcessingInitializeOnLoad (104ms)
				ProcessInitializeOnLoadAttributes (488ms)
				ProcessInitializeOnLoadMethodAttributes (48ms)
				AfterProcessingInitializeOnLoad (3ms)
				EditorAssembliesLoaded (0ms)
			ExecutionOrderSort2 (0ms)
			AwakeInstancesAfterBackupRestoration (9ms)
Platform modules already initialized, skipping
Compilation succeeded with: 

program_source:299:53: warning: writable resources in non-void post-tessellation vertex function
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
                                                    ^
program_source:305:30: note: writable buffer defined here
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
                             ^
program_source:306:48: note: writable buffer defined here
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
                                               ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float4 TEXCOORD0 [[ attribute(3) ]] ;
    float4 TEXCOORD1 [[ attribute(4) ]] ;
    float4 TEXCOORD2 [[ attribute(5) ]] ;
    float4 TEXCOORD3 [[ attribute(6) ]] ;
    float4 COLOR0 [[ attribute(7) ]] ;
};
struct Mtl_VertexOut
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float4 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float4 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float4 TEXCOORD3 [[ user(TEXCOORD3) ]];
    float4 COLOR0 [[ user(COLOR0) ]];
};
static Mtl_VertexOut vertexFunction(
    Mtl_VertexIn input)
{
    Mtl_VertexOut output;
    output.INTERNALTESSPOS0 = input.POSITION0;
    output.TANGENT0 = input.TANGENT0;
    output.NORMAL0.xyz = input.NORMAL0.xyz;
    output.TEXCOORD0 = input.TEXCOORD0;
    output.TEXCOORD1 = input.TEXCOORD1;
    output.TEXCOORD2 = input.TEXCOORD2;
    output.TEXCOORD3 = input.TEXCOORD3;
    output.COLOR0 = input.COLOR0;
    return output;
}
// SHADER_STAGE_HULL_begin
struct Mtl_ControlPoint
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float4 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float4 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float4 TEXCOORD3 [[ user(TEXCOORD3) ]];
    float4 COLOR0 [[ user(COLOR0) ]];
};
struct Mtl_ControlPointIn
{
    float4 INTERNALTESSPOS0 [[ attribute(8) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float4 TEXCOORD0 [[ attribute(3) ]] ;
    float4 TEXCOORD1 [[ attribute(4) ]] ;
    float4 TEXCOORD2 [[ attribute(5) ]] ;
    float4 TEXCOORD3 [[ attribute(6) ]] ;
    float4 COLOR0 [[ attribute(7) ]] ;
};
struct Mtl_KernelPatchInfo
{
    uint numPatches;
    ushort numControlPointsPerPatch;
};
struct VGlobals_Type
{
    float4 _Time;
    float4 _SinTime;
    float4 _CosTime;
    float4 unity_DeltaTime;
    float3 _WorldSpaceCameraPos;
    float4 _ProjectionParams;
    float4 _ScreenParams;
    float4 _ZBufferParams;
    float4 unity_OrthoParams;
    float4 unity_CameraWorldClipPlanes[6];
    float4 hlslcc_mtx4x4unity_CameraProjection[4];
    float4 hlslcc_mtx4x4unity_CameraInvProjection[4];
    float4 hlslcc_mtx4x4unity_WorldToCamera[4];
    float4 hlslcc_mtx4x4unity_CameraToWorld[4];
    float4 _WorldSpaceLightPos0;
    float4 _LightPositionRange;
    float4 _LightProjectionParams;
    float4 unity_4LightPosX0;
    float4 unity_4LightPosY0;
    float4 unity_4LightPosZ0;
    float4 unity_4LightAtten0;
    float4 unity_LightColor[8];
    float4 unity_LightPosition[8];
    float4 unity_LightAtten[8];
    float4 unity_SpotDirection[8];
    float4 unity_SHAr;
    float4 unity_SHAg;
    float4 unity_SHAb;
    float4 unity_SHBr;
    float4 unity_SHBg;
    float4 unity_SHBb;
    float4 unity_SHC;
    float4 unity_OcclusionMaskSelector;
    float4 unity_ProbesOcclusion;
    float3 unity_LightColor0;
    float3 unity_LightColor1;
    float3 unity_LightColor2;
    float3 unity_LightColor3;
    float4 unity_ShadowSplitSpheres[4];
    float4 unity_ShadowSplitSqRadii;
    float4 unity_LightShadowBias;
    float4 _LightSplitsNear;
    float4 _LightSplitsFar;
    float4 hlslcc_mtx4x4unity_WorldToShadow[16];
    float4 _LightShadowData;
    float4 unity_ShadowFadeCenterAndType;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 unity_LODFade;
    float4 unity_WorldTransformParams;
    float4 unity_RenderingLayer;
    float4 hlslcc_mtx4x4glstate_matrix_transpose_modelview0[4];
    float4 glstate_lightmodel_ambient;
    float4 unity_AmbientSky;
    float4 unity_AmbientEquator;
    float4 unity_AmbientGround;
    float4 unity_IndirectSpecColor;
    float4 hlslcc_mtx4x4glstate_matrix_projection[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixInvV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    int unity_StereoEyeIndex;
    float4 unity_ShadowColor;
    float4 unity_FogColor;
    float4 unity_FogParams;
    float4 unity_LightmapST;
    float4 unity_DynamicLightmapST;
    float4 unity_SpecCube0_BoxMax;
    float4 unity_SpecCube0_BoxMin;
    float4 unity_SpecCube0_ProbePosition;
    float4 unity_SpecCube0_HDR;
    float4 unity_SpecCube1_BoxMax;
    float4 unity_SpecCube1_BoxMin;
    float4 unity_SpecCube1_ProbePosition;
    float4 unity_SpecCube1_HDR;
    float4 unity_ProbeVolumeParams;
    float4 hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[4];
    float3 unity_ProbeVolumeSizeInv;
    float3 unity_ProbeVolumeMin;
    float4 unity_Lightmap_HDR;
    float4 unity_DynamicLightmap_HDR;
    float4 _LightColor0;
    float4 _SpecColor;
    float _Tile;
    float _HeightDisplacement;
    float _NormalScale;
    float4 _ColorTint;
    float _MetallicStrength;
    float _SmoothnessStrength;
    float _EdgeLength;
    float4 _texcoord_ST;
};
struct Mtl_HullIn
{
    Mtl_VertexOut cp[3];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
kernel void patchKernel(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn vertexInput [[ stage_in ]],
    uint2 tID [[ thread_position_in_grid ]],
    ushort2 groupID [[ threadgroup_position_in_grid ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    constant Mtl_KernelPatchInfo &patchInfo [[ buffer(3) ]])
{
#pragma clang diagnostic pop
    Mtl_ControlPoint output;
    const uint numPatchesInThreadGroup = 10;
    const uint patchID = (tID.x / patchInfo.numControlPointsPerPatch);
    const bool patchValid = (patchID < patchInfo.numPatches);
    const uint mtl_BaseInstance = 0;
    const uint mtl_InstanceID = groupID.y - mtl_BaseInstance;
    const uint internalPatchID = mtl_InstanceID * patchInfo.numPatches + patchID;
    const uint patchIDInThreadGroup = (patchID % numPatchesInThreadGroup);
    const uint controlPointID = (tID.x % patchInfo.numControlPointsPerPatch);
    const uint mtl_BaseVertex = 0;
    const uint mtl_VertexID = ((mtl_InstanceID * (patchInfo.numControlPointsPerPatch * patchInfo.numPatches)) + tID.x) - mtl_BaseVertex;
    threadgroup Mtl_HullIn inputGroup[numPatchesInThreadGroup];
    threadgroup Mtl_HullIn &input = inputGroup[patchIDInThreadGroup];
    MTLTriangleTessellationFactorsHalf tessFactor;
    if (patchValid) {
        input.cp[controlPointID] = vertexFunction(vertexInput);
        output.INTERNALTESSPOS0 = input.cp[controlPointID].INTERNALTESSPOS0;
        output.TANGENT0 = input.cp[controlPointID].TANGENT0;
        output.NORMAL0 = input.cp[controlPointID].NORMAL0;
        output.TEXCOORD0 = input.cp[controlPointID].TEXCOORD0;
        output.TEXCOORD1 = input.cp[controlPointID].TEXCOORD1;
        output.TEXCOORD2 = input.cp[controlPointID].TEXCOORD2;
        output.TEXCOORD3 = input.cp[controlPointID].TEXCOORD3;
        output.COLOR0 = input.cp[controlPointID].COLOR0;
    }
    threadgroup_barrier(mem_flags::mem_threadgroup);
    if (!patchValid) {
        return;
    }
    float3 u_xlat0;
    float3 u_xlat1;
    float3 u_xlat2;
    float3 u_xlat3;
    float3 u_xlat4;
    float u_xlat12;
    float u_xlat13;
    // fork_phase2
    {
        u_xlat0.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[1].INTERNALTESSPOS0.yyy;
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[1].INTERNALTESSPOS0.xxx, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[1].INTERNALTESSPOS0.zzz, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[1].INTERNALTESSPOS0.www, u_xlat0.xyz);
        u_xlat1.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[2].INTERNALTESSPOS0.yyy;
        u_xlat1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[2].INTERNALTESSPOS0.xxx, u_xlat1.xyz);
        u_xlat1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[2].INTERNALTESSPOS0.zzz, u_xlat1.xyz);
        u_xlat1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[2].INTERNALTESSPOS0.www, u_xlat1.xyz);
        u_xlat2.xyz = u_xlat0.xyz + u_xlat1.xyz;
        u_xlat2.xyz = fma(u_xlat2.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat12 = dot(u_xlat2.xyz, u_xlat2.xyz);
        u_xlat12 = sqrt(u_xlat12);
        u_xlat12 = u_xlat12 * VGlobals._EdgeLength;
        u_xlat2.xyz = u_xlat0.xyz + (-u_xlat1.xyz);
        u_xlat13 = dot(u_xlat2.xyz, u_xlat2.xyz);
        u_xlat13 = sqrt(u_xlat13);
        u_xlat13 = u_xlat13 * VGlobals._ScreenParams.y;
        u_xlat12 = u_xlat13 / u_xlat12;
        tessFactor.edgeTessellationFactor[0] = max(u_xlat12, 1.0);
        u_xlat2.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[0].INTERNALTESSPOS0.yyy;
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[0].INTERNALTESSPOS0.xxx, u_xlat2.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[0].INTERNALTESSPOS0.zzz, u_xlat2.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[0].INTERNALTESSPOS0.www, u_xlat2.xyz);
        u_xlat3.xyz = u_xlat1.xyz + u_xlat2.xyz;
        u_xlat1.xyz = u_xlat1.xyz + (-u_xlat2.xyz);
        u_xlat12 = dot(u_xlat1.xyz, u_xlat1.xyz);
        u_xlat12 = sqrt(u_xlat12);
        u_xlat12 = u_xlat12 * VGlobals._ScreenParams.y;
        u_xlat1.xyz = fma(u_xlat3.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat1.x = dot(u_xlat1.xyz, u_xlat1.xyz);
        u_xlat1.x = sqrt(u_xlat1.x);
        u_xlat1.x = u_xlat1.x * VGlobals._EdgeLength;
        u_xlat12 = u_xlat12 / u_xlat1.x;
        tessFactor.edgeTessellationFactor[1] = max(u_xlat12, 1.0);
        u_xlat1.xyz = u_xlat0.xyz + u_xlat2.xyz;
        u_xlat0.xyz = (-u_xlat0.xyz) + u_xlat2.xyz;
        u_xlat0.x = dot(u_xlat0.xyz, u_xlat0.xyz);
        u_xlat0.x = sqrt(u_xlat0.x);
        u_xlat0.x = u_xlat0.x * VGlobals._ScreenParams.y;
        u_xlat4.xyz = fma(u_xlat1.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat4.x = dot(u_xlat4.xyz, u_xlat4.xyz);
        u_xlat4.x = sqrt(u_xlat4.x);
        u_xlat4.x = u_xlat4.x * VGlobals._EdgeLength;
        u_xlat0.x = u_xlat0.x / u_xlat4.x;
        tessFactor.edgeTessellationFactor[2] = max(u_xlat0.x, 1.0);
    }
    // join_phase3
    {
        u_xlat0.x = tessFactor.edgeTessellationFactor[0] + tessFactor.edgeTessellationFactor[1];
        u_xlat0.x = u_xlat0.x + tessFactor.edgeTessellationFactor[2];
        tessFactor.insideTessellationFactor = u_xlat0.x * 0.333333343;
    }
    controlPoints[mtl_VertexID] = output;
    tessFactors[internalPatchID] = tessFactor;
}
// SHADER_STAGE_HULL_end
// SHADER_STAGE_DOMAIN_begin
struct Mtl_VertexInPostTess
{
    patch_control_point<Mtl_ControlPointIn> cp;
};
struct Mtl_VertexOutPostTess
{
    float4 mtl_Position [[ position ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float4 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float4 TEXCOORD3 [[ user(TEXCOORD3) ]];
    float4 TEXCOORD6 [[ user(TEXCOORD6) ]];
    float4 TEXCOORD7 [[ user(TEXCOORD7) ]];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    sampler sampler_Height [[ sampler (0) ]],
    texture2d<float, access::sample > _Height [[ texture(0) ]] ,
    float3 mtl_TessCoord [[ position_in_patch ]],
    uint patchID [[ patch_id ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    Mtl_VertexInPostTess input [[ stage_in ]])
{
#pragma clang diagnostic pop
    Mtl_VertexOutPostTess output;
    MTLTriangleTessellationFactorsHalf tessFactor;
    tessFactor = tessFactors[patchID];
    float4 u_xlat0;
    float4 u_xlat1;
    float4 u_xlat2;
    float4 u_xlat3;
    float2 u_xlat9;
    float u_xlat12;
    float u_xlat13;
    u_xlat0 = mtl_TessCoord.yyyy * input.cp[1].INTERNALTESSPOS0;
    u_xlat0 = fma(input.cp[0].INTERNALTESSPOS0, mtl_TessCoord.xxxx, u_xlat0);
    u_xlat0 = fma(input.cp[2].INTERNALTESSPOS0, mtl_TessCoord.zzzz, u_xlat0);
    u_xlat1.xy = mtl_TessCoord.yy * input.cp[1].TEXCOORD0.xy;
    u_xlat1.xy = fma(input.cp[0].TEXCOORD0.xy, mtl_TessCoord.xx, u_xlat1.xy);
    u_xlat1.xy = fma(input.cp[2].TEXCOORD0.xy, mtl_TessCoord.zz, u_xlat1.xy);
    u_xlat9.xy = u_xlat1.xy * float2(VGlobals._Tile);
    output.TEXCOORD0.xy = fma(u_xlat1.xy, VGlobals._texcoord_ST.xy, VGlobals._texcoord_ST.zw);
    u_xlat1.xyz = _Height.sample(sampler_Height, u_xlat9.xy, level(1.0)).xyz;
    u_xlat2.xyz = mtl_TessCoord.yyy * input.cp[1].NORMAL0.xyz;
    u_xlat2.xyz = fma(input.cp[0].NORMAL0.xyz, mtl_TessCoord.xxx, u_xlat2.xyz);
    u_xlat2.xyz = fma(input.cp[2].NORMAL0.xyz, mtl_TessCoord.zzz, u_xlat2.xyz);
    u_xlat1.xyz = u_xlat1.xyz * u_xlat2.xyz;
    u_xlat0.xyz = fma(u_xlat1.xyz, float3(VGlobals._HeightDisplacement), u_xlat0.xyz);
    u_xlat1 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], u_xlat0.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], u_xlat0.zzzz, u_xlat1);
    u_xlat3 = u_xlat1 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, u_xlat0.www, u_xlat1.xyz);
    u_xlat1 = u_xlat3.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat3.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat3.zzzz, u_xlat1);
    output.mtl_Position = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat3.wwww, u_xlat1);
    u_xlat1.y = dot(u_xlat2.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat1.z = dot(u_xlat2.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat1.x = dot(u_xlat2.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat12 = dot(u_xlat1.xyz, u_xlat1.xyz);
    u_xlat12 = rsqrt(u_xlat12);
    u_xlat1.xyz = float3(u_xlat12) * u_xlat1.xyz;
    output.TEXCOORD1.z = u_xlat1.y;
    u_xlat2 = mtl_TessCoord.yyyy * input.cp[1].TANGENT0;
    u_xlat2 = fma(input.cp[0].TANGENT0, mtl_TessCoord.xxxx, u_xlat2);
    u_xlat2 = fma(input.cp[2].TANGENT0, mtl_TessCoord.zzzz, u_xlat2);
    u_xlat3.xyz = u_xlat2.yyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].yzx;
    u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].yzx, u_xlat2.xxx, u_xlat3.xyz);
    u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].yzx, u_xlat2.zzz, u_xlat3.xyz);
    u_xlat12 = u_xlat2.w * VGlobals.unity_WorldTransformParams.w;
    u_xlat13 = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat13 = rsqrt(u_xlat13);
    u_xlat2.xyz = float3(u_xlat13) * u_xlat2.xyz;
    u_xlat3.xyz = u_xlat1.xyz * u_xlat2.xyz;
    u_xlat3.xyz = fma(u_xlat1.zxy, u_xlat2.yzx, (-u_xlat3.xyz));
    u_xlat3.xyz = float3(u_xlat12) * u_xlat3.xyz;
    output.TEXCOORD1.y = u_xlat3.x;
    output.TEXCOORD1.w = u_xlat0.x;
    output.TEXCOORD1.x = u_xlat2.z;
    output.TEXCOORD2.w = u_xlat0.y;
    output.TEXCOORD3.w = u_xlat0.z;
    output.TEXCOORD2.x = u_xlat2.x;
    output.TEXCOORD3.x = u_xlat2.y;
    output.TEXCOORD2.z = u_xlat1.z;
    output.TEXCOORD3.z = u_xlat1.x;
    output.TEXCOORD2.y = u_xlat3.y;
    output.TEXCOORD3.y = u_xlat3.z;
    output.TEXCOORD6 = float4(0.0, 0.0, 0.0, 0.0);
    output.TEXCOORD7 = float4(0.0, 0.0, 0.0, 0.0);
    return output;
}
// SHADER_STAGE_DOMAIN_end
Compilation succeeded with: 

program_source:301:53: warning: writable resources in non-void post-tessellation vertex function
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
                                                    ^
program_source:307:30: note: writable buffer defined here
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
                             ^
program_source:308:48: note: writable buffer defined here
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
                                               ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float4 TEXCOORD0 [[ attribute(3) ]] ;
    float4 TEXCOORD1 [[ attribute(4) ]] ;
    float4 TEXCOORD2 [[ attribute(5) ]] ;
    float4 TEXCOORD3 [[ attribute(6) ]] ;
    float4 COLOR0 [[ attribute(7) ]] ;
};
struct Mtl_VertexOut
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float4 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float4 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float4 TEXCOORD3 [[ user(TEXCOORD3) ]];
    float4 COLOR0 [[ user(COLOR0) ]];
};
static Mtl_VertexOut vertexFunction(
    Mtl_VertexIn input)
{
    Mtl_VertexOut output;
    output.INTERNALTESSPOS0 = input.POSITION0;
    output.TANGENT0 = input.TANGENT0;
    output.NORMAL0.xyz = input.NORMAL0.xyz;
    output.TEXCOORD0 = input.TEXCOORD0;
    output.TEXCOORD1 = input.TEXCOORD1;
    output.TEXCOORD2 = input.TEXCOORD2;
    output.TEXCOORD3 = input.TEXCOORD3;
    output.COLOR0 = input.COLOR0;
    return output;
}
// SHADER_STAGE_HULL_begin
struct Mtl_ControlPoint
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float4 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float4 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float4 TEXCOORD3 [[ user(TEXCOORD3) ]];
    float4 COLOR0 [[ user(COLOR0) ]];
};
struct Mtl_ControlPointIn
{
    float4 INTERNALTESSPOS0 [[ attribute(8) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float4 TEXCOORD0 [[ attribute(3) ]] ;
    float4 TEXCOORD1 [[ attribute(4) ]] ;
    float4 TEXCOORD2 [[ attribute(5) ]] ;
    float4 TEXCOORD3 [[ attribute(6) ]] ;
    float4 COLOR0 [[ attribute(7) ]] ;
};
struct Mtl_KernelPatchInfo
{
    uint numPatches;
    ushort numControlPointsPerPatch;
};
struct VGlobals_Type
{
    float4 _Time;
    float4 _SinTime;
    float4 _CosTime;
    float4 unity_DeltaTime;
    float3 _WorldSpaceCameraPos;
    float4 _ProjectionParams;
    float4 _ScreenParams;
    float4 _ZBufferParams;
    float4 unity_OrthoParams;
    float4 unity_CameraWorldClipPlanes[6];
    float4 hlslcc_mtx4x4unity_CameraProjection[4];
    float4 hlslcc_mtx4x4unity_CameraInvProjection[4];
    float4 hlslcc_mtx4x4unity_WorldToCamera[4];
    float4 hlslcc_mtx4x4unity_CameraToWorld[4];
    float4 _WorldSpaceLightPos0;
    float4 _LightPositionRange;
    float4 _LightProjectionParams;
    float4 unity_4LightPosX0;
    float4 unity_4LightPosY0;
    float4 unity_4LightPosZ0;
    float4 unity_4LightAtten0;
    float4 unity_LightColor[8];
    float4 unity_LightPosition[8];
    float4 unity_LightAtten[8];
    float4 unity_SpotDirection[8];
    float4 unity_SHAr;
    float4 unity_SHAg;
    float4 unity_SHAb;
    float4 unity_SHBr;
    float4 unity_SHBg;
    float4 unity_SHBb;
    float4 unity_SHC;
    float4 unity_OcclusionMaskSelector;
    float4 unity_ProbesOcclusion;
    float3 unity_LightColor0;
    float3 unity_LightColor1;
    float3 unity_LightColor2;
    float3 unity_LightColor3;
    float4 unity_ShadowSplitSpheres[4];
    float4 unity_ShadowSplitSqRadii;
    float4 unity_LightShadowBias;
    float4 _LightSplitsNear;
    float4 _LightSplitsFar;
    float4 hlslcc_mtx4x4unity_WorldToShadow[16];
    float4 _LightShadowData;
    float4 unity_ShadowFadeCenterAndType;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 unity_LODFade;
    float4 unity_WorldTransformParams;
    float4 unity_RenderingLayer;
    float4 hlslcc_mtx4x4glstate_matrix_transpose_modelview0[4];
    float4 glstate_lightmodel_ambient;
    float4 unity_AmbientSky;
    float4 unity_AmbientEquator;
    float4 unity_AmbientGround;
    float4 unity_IndirectSpecColor;
    float4 hlslcc_mtx4x4glstate_matrix_projection[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixInvV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    int unity_StereoEyeIndex;
    float4 unity_ShadowColor;
    float4 unity_FogColor;
    float4 unity_FogParams;
    float4 unity_LightmapST;
    float4 unity_DynamicLightmapST;
    float4 unity_SpecCube0_BoxMax;
    float4 unity_SpecCube0_BoxMin;
    float4 unity_SpecCube0_ProbePosition;
    float4 unity_SpecCube0_HDR;
    float4 unity_SpecCube1_BoxMax;
    float4 unity_SpecCube1_BoxMin;
    float4 unity_SpecCube1_ProbePosition;
    float4 unity_SpecCube1_HDR;
    float4 unity_ProbeVolumeParams;
    float4 hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[4];
    float3 unity_ProbeVolumeSizeInv;
    float3 unity_ProbeVolumeMin;
    float4 unity_Lightmap_HDR;
    float4 unity_DynamicLightmap_HDR;
    float4 _LightColor0;
    float4 _SpecColor;
    float4 hlslcc_mtx4x4unity_WorldToLight[4];
    float _Tile;
    float _HeightDisplacement;
    float _NormalScale;
    float4 _ColorTint;
    float _MetallicStrength;
    float _SmoothnessStrength;
    float _EdgeLength;
    float4 _texcoord_ST;
};
struct Mtl_HullIn
{
    Mtl_VertexOut cp[3];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
kernel void patchKernel(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn vertexInput [[ stage_in ]],
    uint2 tID [[ thread_position_in_grid ]],
    ushort2 groupID [[ threadgroup_position_in_grid ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    constant Mtl_KernelPatchInfo &patchInfo [[ buffer(3) ]])
{
#pragma clang diagnostic pop
    Mtl_ControlPoint output;
    const uint numPatchesInThreadGroup = 10;
    const uint patchID = (tID.x / patchInfo.numControlPointsPerPatch);
    const bool patchValid = (patchID < patchInfo.numPatches);
    const uint mtl_BaseInstance = 0;
    const uint mtl_InstanceID = groupID.y - mtl_BaseInstance;
    const uint internalPatchID = mtl_InstanceID * patchInfo.numPatches + patchID;
    const uint patchIDInThreadGroup = (patchID % numPatchesInThreadGroup);
    const uint controlPointID = (tID.x % patchInfo.numControlPointsPerPatch);
    const uint mtl_BaseVertex = 0;
    const uint mtl_VertexID = ((mtl_InstanceID * (patchInfo.numControlPointsPerPatch * patchInfo.numPatches)) + tID.x) - mtl_BaseVertex;
    threadgroup Mtl_HullIn inputGroup[numPatchesInThreadGroup];
    threadgroup Mtl_HullIn &input = inputGroup[patchIDInThreadGroup];
    MTLTriangleTessellationFactorsHalf tessFactor;
    if (patchValid) {
        input.cp[controlPointID] = vertexFunction(vertexInput);
        output.INTERNALTESSPOS0 = input.cp[controlPointID].INTERNALTESSPOS0;
        output.TANGENT0 = input.cp[controlPointID].TANGENT0;
        output.NORMAL0 = input.cp[controlPointID].NORMAL0;
        output.TEXCOORD0 = input.cp[controlPointID].TEXCOORD0;
        output.TEXCOORD1 = input.cp[controlPointID].TEXCOORD1;
        output.TEXCOORD2 = input.cp[controlPointID].TEXCOORD2;
        output.TEXCOORD3 = input.cp[controlPointID].TEXCOORD3;
        output.COLOR0 = input.cp[controlPointID].COLOR0;
    }
    threadgroup_barrier(mem_flags::mem_threadgroup);
    if (!patchValid) {
        return;
    }
    float3 u_xlat0;
    float3 u_xlat1;
    float3 u_xlat2;
    float3 u_xlat3;
    float3 u_xlat4;
    float u_xlat12;
    float u_xlat13;
    // fork_phase2
    {
        u_xlat0.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[1].INTERNALTESSPOS0.yyy;
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[1].INTERNALTESSPOS0.xxx, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[1].INTERNALTESSPOS0.zzz, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[1].INTERNALTESSPOS0.www, u_xlat0.xyz);
        u_xlat1.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[2].INTERNALTESSPOS0.yyy;
        u_xlat1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[2].INTERNALTESSPOS0.xxx, u_xlat1.xyz);
        u_xlat1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[2].INTERNALTESSPOS0.zzz, u_xlat1.xyz);
        u_xlat1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[2].INTERNALTESSPOS0.www, u_xlat1.xyz);
        u_xlat2.xyz = u_xlat0.xyz + u_xlat1.xyz;
        u_xlat2.xyz = fma(u_xlat2.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat12 = dot(u_xlat2.xyz, u_xlat2.xyz);
        u_xlat12 = sqrt(u_xlat12);
        u_xlat12 = u_xlat12 * VGlobals._EdgeLength;
        u_xlat2.xyz = u_xlat0.xyz + (-u_xlat1.xyz);
        u_xlat13 = dot(u_xlat2.xyz, u_xlat2.xyz);
        u_xlat13 = sqrt(u_xlat13);
        u_xlat13 = u_xlat13 * VGlobals._ScreenParams.y;
        u_xlat12 = u_xlat13 / u_xlat12;
        tessFactor.edgeTessellationFactor[0] = max(u_xlat12, 1.0);
        u_xlat2.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[0].INTERNALTESSPOS0.yyy;
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[0].INTERNALTESSPOS0.xxx, u_xlat2.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[0].INTERNALTESSPOS0.zzz, u_xlat2.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[0].INTERNALTESSPOS0.www, u_xlat2.xyz);
        u_xlat3.xyz = u_xlat1.xyz + u_xlat2.xyz;
        u_xlat1.xyz = u_xlat1.xyz + (-u_xlat2.xyz);
        u_xlat12 = dot(u_xlat1.xyz, u_xlat1.xyz);
        u_xlat12 = sqrt(u_xlat12);
        u_xlat12 = u_xlat12 * VGlobals._ScreenParams.y;
        u_xlat1.xyz = fma(u_xlat3.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat1.x = dot(u_xlat1.xyz, u_xlat1.xyz);
        u_xlat1.x = sqrt(u_xlat1.x);
        u_xlat1.x = u_xlat1.x * VGlobals._EdgeLength;
        u_xlat12 = u_xlat12 / u_xlat1.x;
        tessFactor.edgeTessellationFactor[1] = max(u_xlat12, 1.0);
        u_xlat1.xyz = u_xlat0.xyz + u_xlat2.xyz;
        u_xlat0.xyz = (-u_xlat0.xyz) + u_xlat2.xyz;
        u_xlat0.x = dot(u_xlat0.xyz, u_xlat0.xyz);
        u_xlat0.x = sqrt(u_xlat0.x);
        u_xlat0.x = u_xlat0.x * VGlobals._ScreenParams.y;
        u_xlat4.xyz = fma(u_xlat1.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat4.x = dot(u_xlat4.xyz, u_xlat4.xyz);
        u_xlat4.x = sqrt(u_xlat4.x);
        u_xlat4.x = u_xlat4.x * VGlobals._EdgeLength;
        u_xlat0.x = u_xlat0.x / u_xlat4.x;
        tessFactor.edgeTessellationFactor[2] = max(u_xlat0.x, 1.0);
    }
    // join_phase3
    {
        u_xlat0.x = tessFactor.edgeTessellationFactor[0] + tessFactor.edgeTessellationFactor[1];
        u_xlat0.x = u_xlat0.x + tessFactor.edgeTessellationFactor[2];
        tessFactor.insideTessellationFactor = u_xlat0.x * 0.333333343;
    }
    controlPoints[mtl_VertexID] = output;
    tessFactors[internalPatchID] = tessFactor;
}
// SHADER_STAGE_HULL_end
// SHADER_STAGE_DOMAIN_begin
struct Mtl_VertexInPostTess
{
    patch_control_point<Mtl_ControlPointIn> cp;
};
struct Mtl_VertexOutPostTess
{
    float4 mtl_Position [[ position ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float3 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float3 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float3 TEXCOORD3 [[ user(TEXCOORD3) ]];
    float3 TEXCOORD4 [[ user(TEXCOORD4) ]];
    float3 TEXCOORD5 [[ user(TEXCOORD5) ]];
    float4 TEXCOORD6 [[ user(TEXCOORD6) ]];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    sampler sampler_Height [[ sampler (0) ]],
    texture2d<float, access::sample > _Height [[ texture(0) ]] ,
    float3 mtl_TessCoord [[ position_in_patch ]],
    uint patchID [[ patch_id ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    Mtl_VertexInPostTess input [[ stage_in ]])
{
#pragma clang diagnostic pop
    Mtl_VertexOutPostTess output;
    MTLTriangleTessellationFactorsHalf tessFactor;
    tessFactor = tessFactors[patchID];
    float4 u_xlat0;
    float3 u_xlat1;
    float4 u_xlat2;
    float4 u_xlat3;
    float4 u_xlat4;
    float2 u_xlat10;
    float u_xlat16;
    u_xlat0.xy = mtl_TessCoord.yy * input.cp[1].TEXCOORD0.xy;
    u_xlat0.xy = fma(input.cp[0].TEXCOORD0.xy, mtl_TessCoord.xx, u_xlat0.xy);
    u_xlat0.xy = fma(input.cp[2].TEXCOORD0.xy, mtl_TessCoord.zz, u_xlat0.xy);
    u_xlat10.xy = u_xlat0.xy * float2(VGlobals._Tile);
    output.TEXCOORD0.xy = fma(u_xlat0.xy, VGlobals._texcoord_ST.xy, VGlobals._texcoord_ST.zw);
    u_xlat0.xyz = _Height.sample(sampler_Height, u_xlat10.xy, level(1.0)).xyz;
    u_xlat1.xyz = mtl_TessCoord.yyy * input.cp[1].NORMAL0.xyz;
    u_xlat1.xyz = fma(input.cp[0].NORMAL0.xyz, mtl_TessCoord.xxx, u_xlat1.xyz);
    u_xlat1.xyz = fma(input.cp[2].NORMAL0.xyz, mtl_TessCoord.zzz, u_xlat1.xyz);
    u_xlat0.xyz = u_xlat0.xyz * u_xlat1.xyz;
    u_xlat2 = mtl_TessCoord.yyyy * input.cp[1].INTERNALTESSPOS0;
    u_xlat2 = fma(input.cp[0].INTERNALTESSPOS0, mtl_TessCoord.xxxx, u_xlat2);
    u_xlat2 = fma(input.cp[2].INTERNALTESSPOS0, mtl_TessCoord.zzzz, u_xlat2);
    u_xlat0.xyz = fma(u_xlat0.xyz, float3(VGlobals._HeightDisplacement), u_xlat2.xyz);
    u_xlat3 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], u_xlat0.xxxx, u_xlat3);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], u_xlat0.zzzz, u_xlat3);
    u_xlat3 = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat4 = u_xlat3.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat4 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat3.xxxx, u_xlat4);
    u_xlat4 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat3.zzzz, u_xlat4);
    output.mtl_Position = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat3.wwww, u_xlat4);
    u_xlat2.y = dot(u_xlat1.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat2.z = dot(u_xlat1.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat2.x = dot(u_xlat1.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat1.x = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat1.x = rsqrt(u_xlat1.x);
    u_xlat1.xyz = u_xlat1.xxx * u_xlat2.xyz;
    output.TEXCOORD1.z = u_xlat1.y;
    u_xlat3 = mtl_TessCoord.yyyy * input.cp[1].TANGENT0;
    u_xlat3 = fma(input.cp[0].TANGENT0, mtl_TessCoord.xxxx, u_xlat3);
    u_xlat3 = fma(input.cp[2].TANGENT0, mtl_TessCoord.zzzz, u_xlat3);
    u_xlat2.xyz = u_xlat3.yyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].yzx;
    u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].yzx, u_xlat3.xxx, u_xlat2.xyz);
    u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].yzx, u_xlat3.zzz, u_xlat2.xyz);
    u_xlat16 = u_xlat3.w * VGlobals.unity_WorldTransformParams.w;
    u_xlat3.x = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat3.x = rsqrt(u_xlat3.x);
    u_xlat2.xyz = u_xlat2.xyz * u_xlat3.xxx;
    u_xlat3.xyz = u_xlat1.xyz * u_xlat2.xyz;
    u_xlat3.xyz = fma(u_xlat1.zxy, u_xlat2.yzx, (-u_xlat3.xyz));
    u_xlat3.xyz = float3(u_xlat16) * u_xlat3.xyz;
    output.TEXCOORD1.y = u_xlat3.x;
    output.TEXCOORD1.x = u_xlat2.z;
    output.TEXCOORD2.x = u_xlat2.x;
    output.TEXCOORD3.x = u_xlat2.y;
    output.TEXCOORD2.z = u_xlat1.z;
    output.TEXCOORD3.z = u_xlat1.x;
    output.TEXCOORD2.y = u_xlat3.y;
    output.TEXCOORD3.y = u_xlat3.z;
    output.TEXCOORD4.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, u_xlat2.www, u_xlat0.xyz);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3], u_xlat2.wwww, u_xlat0);
    u_xlat1.xyz = u_xlat0.yyy * VGlobals.hlslcc_mtx4x4unity_WorldToLight[1].xyz;
    u_xlat1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_WorldToLight[0].xyz, u_xlat0.xxx, u_xlat1.xyz);
    u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_WorldToLight[2].xyz, u_xlat0.zzz, u_xlat1.xyz);
    output.TEXCOORD5.xyz = fma(VGlobals.hlslcc_mtx4x4unity_WorldToLight[3].xyz, u_xlat0.www, u_xlat0.xyz);
    output.TEXCOORD6 = float4(0.0, 0.0, 0.0, 0.0);
    return output;
}
// SHADER_STAGE_DOMAIN_end
Compilation succeeded with: 

program_source:293:53: warning: writable resources in non-void post-tessellation vertex function
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
                                                    ^
program_source:299:30: note: writable buffer defined here
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
                             ^
program_source:300:48: note: writable buffer defined here
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
                                               ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float4 TEXCOORD0 [[ attribute(3) ]] ;
    float4 TEXCOORD1 [[ attribute(4) ]] ;
    float4 TEXCOORD2 [[ attribute(5) ]] ;
    float4 TEXCOORD3 [[ attribute(6) ]] ;
    float4 COLOR0 [[ attribute(7) ]] ;
};
struct Mtl_VertexOut
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float4 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float4 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float4 TEXCOORD3 [[ user(TEXCOORD3) ]];
    float4 COLOR0 [[ user(COLOR0) ]];
};
static Mtl_VertexOut vertexFunction(
    Mtl_VertexIn input)
{
    Mtl_VertexOut output;
    output.INTERNALTESSPOS0 = input.POSITION0;
    output.TANGENT0 = input.TANGENT0;
    output.NORMAL0.xyz = input.NORMAL0.xyz;
    output.TEXCOORD0 = input.TEXCOORD0;
    output.TEXCOORD1 = input.TEXCOORD1;
    output.TEXCOORD2 = input.TEXCOORD2;
    output.TEXCOORD3 = input.TEXCOORD3;
    output.COLOR0 = input.COLOR0;
    return output;
}
// SHADER_STAGE_HULL_begin
struct Mtl_ControlPoint
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float4 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float4 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float4 TEXCOORD3 [[ user(TEXCOORD3) ]];
    float4 COLOR0 [[ user(COLOR0) ]];
};
struct Mtl_ControlPointIn
{
    float4 INTERNALTESSPOS0 [[ attribute(8) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float4 TEXCOORD0 [[ attribute(3) ]] ;
    float4 TEXCOORD1 [[ attribute(4) ]] ;
    float4 TEXCOORD2 [[ attribute(5) ]] ;
    float4 TEXCOORD3 [[ attribute(6) ]] ;
    float4 COLOR0 [[ attribute(7) ]] ;
};
struct Mtl_KernelPatchInfo
{
    uint numPatches;
    ushort numControlPointsPerPatch;
};
struct VGlobals_Type
{
    float4 _Time;
    float4 _SinTime;
    float4 _CosTime;
    float4 unity_DeltaTime;
    float3 _WorldSpaceCameraPos;
    float4 _ProjectionParams;
    float4 _ScreenParams;
    float4 _ZBufferParams;
    float4 unity_OrthoParams;
    float4 unity_CameraWorldClipPlanes[6];
    float4 hlslcc_mtx4x4unity_CameraProjection[4];
    float4 hlslcc_mtx4x4unity_CameraInvProjection[4];
    float4 hlslcc_mtx4x4unity_WorldToCamera[4];
    float4 hlslcc_mtx4x4unity_CameraToWorld[4];
    float4 _WorldSpaceLightPos0;
    float4 _LightPositionRange;
    float4 _LightProjectionParams;
    float4 unity_4LightPosX0;
    float4 unity_4LightPosY0;
    float4 unity_4LightPosZ0;
    float4 unity_4LightAtten0;
    float4 unity_LightColor[8];
    float4 unity_LightPosition[8];
    float4 unity_LightAtten[8];
    float4 unity_SpotDirection[8];
    float4 unity_SHAr;
    float4 unity_SHAg;
    float4 unity_SHAb;
    float4 unity_SHBr;
    float4 unity_SHBg;
    float4 unity_SHBb;
    float4 unity_SHC;
    float4 unity_OcclusionMaskSelector;
    float4 unity_ProbesOcclusion;
    float3 unity_LightColor0;
    float3 unity_LightColor1;
    float3 unity_LightColor2;
    float3 unity_LightColor3;
    float4 unity_ShadowSplitSpheres[4];
    float4 unity_ShadowSplitSqRadii;
    float4 unity_LightShadowBias;
    float4 _LightSplitsNear;
    float4 _LightSplitsFar;
    float4 hlslcc_mtx4x4unity_WorldToShadow[16];
    float4 _LightShadowData;
    float4 unity_ShadowFadeCenterAndType;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 unity_LODFade;
    float4 unity_WorldTransformParams;
    float4 unity_RenderingLayer;
    float4 hlslcc_mtx4x4glstate_matrix_transpose_modelview0[4];
    float4 glstate_lightmodel_ambient;
    float4 unity_AmbientSky;
    float4 unity_AmbientEquator;
    float4 unity_AmbientGround;
    float4 unity_IndirectSpecColor;
    float4 hlslcc_mtx4x4glstate_matrix_projection[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixInvV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    int unity_StereoEyeIndex;
    float4 unity_ShadowColor;
    float4 unity_FogColor;
    float4 unity_FogParams;
    float4 unity_LightmapST;
    float4 unity_DynamicLightmapST;
    float4 unity_SpecCube0_BoxMax;
    float4 unity_SpecCube0_BoxMin;
    float4 unity_SpecCube0_ProbePosition;
    float4 unity_SpecCube0_HDR;
    float4 unity_SpecCube1_BoxMax;
    float4 unity_SpecCube1_BoxMin;
    float4 unity_SpecCube1_ProbePosition;
    float4 unity_SpecCube1_HDR;
    float4 unity_ProbeVolumeParams;
    float4 hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[4];
    float3 unity_ProbeVolumeSizeInv;
    float3 unity_ProbeVolumeMin;
    float4 unity_Lightmap_HDR;
    float4 unity_DynamicLightmap_HDR;
    float4 _LightColor0;
    float4 _SpecColor;
    float _Tile;
    float _HeightDisplacement;
    float _NormalScale;
    float4 _ColorTint;
    float _MetallicStrength;
    float _SmoothnessStrength;
    float _EdgeLength;
};
struct Mtl_HullIn
{
    Mtl_VertexOut cp[3];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
kernel void patchKernel(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn vertexInput [[ stage_in ]],
    uint2 tID [[ thread_position_in_grid ]],
    ushort2 groupID [[ threadgroup_position_in_grid ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    constant Mtl_KernelPatchInfo &patchInfo [[ buffer(3) ]])
{
#pragma clang diagnostic pop
    Mtl_ControlPoint output;
    const uint numPatchesInThreadGroup = 10;
    const uint patchID = (tID.x / patchInfo.numControlPointsPerPatch);
    const bool patchValid = (patchID < patchInfo.numPatches);
    const uint mtl_BaseInstance = 0;
    const uint mtl_InstanceID = groupID.y - mtl_BaseInstance;
    const uint internalPatchID = mtl_InstanceID * patchInfo.numPatches + patchID;
    const uint patchIDInThreadGroup = (patchID % numPatchesInThreadGroup);
    const uint controlPointID = (tID.x % patchInfo.numControlPointsPerPatch);
    const uint mtl_BaseVertex = 0;
    const uint mtl_VertexID = ((mtl_InstanceID * (patchInfo.numControlPointsPerPatch * patchInfo.numPatches)) + tID.x) - mtl_BaseVertex;
    threadgroup Mtl_HullIn inputGroup[numPatchesInThreadGroup];
    threadgroup Mtl_HullIn &input = inputGroup[patchIDInThreadGroup];
    MTLTriangleTessellationFactorsHalf tessFactor;
    if (patchValid) {
        input.cp[controlPointID] = vertexFunction(vertexInput);
        output.INTERNALTESSPOS0 = input.cp[controlPointID].INTERNALTESSPOS0;
        output.TANGENT0 = input.cp[controlPointID].TANGENT0;
        output.NORMAL0 = input.cp[controlPointID].NORMAL0;
        output.TEXCOORD0 = input.cp[controlPointID].TEXCOORD0;
        output.TEXCOORD1 = input.cp[controlPointID].TEXCOORD1;
        output.TEXCOORD2 = input.cp[controlPointID].TEXCOORD2;
        output.TEXCOORD3 = input.cp[controlPointID].TEXCOORD3;
        output.COLOR0 = input.cp[controlPointID].COLOR0;
    }
    threadgroup_barrier(mem_flags::mem_threadgroup);
    if (!patchValid) {
        return;
    }
    float3 u_xlat0;
    float3 u_xlat1;
    float3 u_xlat2;
    float3 u_xlat3;
    float3 u_xlat4;
    float u_xlat12;
    float u_xlat13;
    // fork_phase2
    {
        u_xlat0.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[1].INTERNALTESSPOS0.yyy;
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[1].INTERNALTESSPOS0.xxx, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[1].INTERNALTESSPOS0.zzz, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[1].INTERNALTESSPOS0.www, u_xlat0.xyz);
        u_xlat1.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[2].INTERNALTESSPOS0.yyy;
        u_xlat1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[2].INTERNALTESSPOS0.xxx, u_xlat1.xyz);
        u_xlat1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[2].INTERNALTESSPOS0.zzz, u_xlat1.xyz);
        u_xlat1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[2].INTERNALTESSPOS0.www, u_xlat1.xyz);
        u_xlat2.xyz = u_xlat0.xyz + u_xlat1.xyz;
        u_xlat2.xyz = fma(u_xlat2.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat12 = dot(u_xlat2.xyz, u_xlat2.xyz);
        u_xlat12 = sqrt(u_xlat12);
        u_xlat12 = u_xlat12 * VGlobals._EdgeLength;
        u_xlat2.xyz = u_xlat0.xyz + (-u_xlat1.xyz);
        u_xlat13 = dot(u_xlat2.xyz, u_xlat2.xyz);
        u_xlat13 = sqrt(u_xlat13);
        u_xlat13 = u_xlat13 * VGlobals._ScreenParams.y;
        u_xlat12 = u_xlat13 / u_xlat12;
        tessFactor.edgeTessellationFactor[0] = max(u_xlat12, 1.0);
        u_xlat2.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[0].INTERNALTESSPOS0.yyy;
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[0].INTERNALTESSPOS0.xxx, u_xlat2.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[0].INTERNALTESSPOS0.zzz, u_xlat2.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[0].INTERNALTESSPOS0.www, u_xlat2.xyz);
        u_xlat3.xyz = u_xlat1.xyz + u_xlat2.xyz;
        u_xlat1.xyz = u_xlat1.xyz + (-u_xlat2.xyz);
        u_xlat12 = dot(u_xlat1.xyz, u_xlat1.xyz);
        u_xlat12 = sqrt(u_xlat12);
        u_xlat12 = u_xlat12 * VGlobals._ScreenParams.y;
        u_xlat1.xyz = fma(u_xlat3.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat1.x = dot(u_xlat1.xyz, u_xlat1.xyz);
        u_xlat1.x = sqrt(u_xlat1.x);
        u_xlat1.x = u_xlat1.x * VGlobals._EdgeLength;
        u_xlat12 = u_xlat12 / u_xlat1.x;
        tessFactor.edgeTessellationFactor[1] = max(u_xlat12, 1.0);
        u_xlat1.xyz = u_xlat0.xyz + u_xlat2.xyz;
        u_xlat0.xyz = (-u_xlat0.xyz) + u_xlat2.xyz;
        u_xlat0.x = dot(u_xlat0.xyz, u_xlat0.xyz);
        u_xlat0.x = sqrt(u_xlat0.x);
        u_xlat0.x = u_xlat0.x * VGlobals._ScreenParams.y;
        u_xlat4.xyz = fma(u_xlat1.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat4.x = dot(u_xlat4.xyz, u_xlat4.xyz);
        u_xlat4.x = sqrt(u_xlat4.x);
        u_xlat4.x = u_xlat4.x * VGlobals._EdgeLength;
        u_xlat0.x = u_xlat0.x / u_xlat4.x;
        tessFactor.edgeTessellationFactor[2] = max(u_xlat0.x, 1.0);
    }
    // join_phase3
    {
        u_xlat0.x = tessFactor.edgeTessellationFactor[0] + tessFactor.edgeTessellationFactor[1];
        u_xlat0.x = u_xlat0.x + tessFactor.edgeTessellationFactor[2];
        tessFactor.insideTessellationFactor = u_xlat0.x * 0.333333343;
    }
    controlPoints[mtl_VertexID] = output;
    tessFactors[internalPatchID] = tessFactor;
}
// SHADER_STAGE_HULL_end
// SHADER_STAGE_DOMAIN_begin
struct Mtl_VertexInPostTess
{
    patch_control_point<Mtl_ControlPointIn> cp;
};
struct Mtl_VertexOutPostTess
{
    float4 mtl_Position [[ position ]];
    float3 TEXCOORD1 [[ user(TEXCOORD1) ]];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    sampler sampler_Height [[ sampler (0) ]],
    texture2d<float, access::sample > _Height [[ texture(0) ]] ,
    float3 mtl_TessCoord [[ position_in_patch ]],
    uint patchID [[ patch_id ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    Mtl_VertexInPostTess input [[ stage_in ]])
{
#pragma clang diagnostic pop
    Mtl_VertexOutPostTess output;
    MTLTriangleTessellationFactorsHalf tessFactor;
    tessFactor = tessFactors[patchID];
    float4 u_xlat0;
    float4 u_xlat1;
    float4 u_xlat2;
    float4 u_xlat3;
    float4 u_xlat4;
    float u_xlat11;
    float u_xlat15;
    bool u_xlatb15;
    u_xlat0.xyz = mtl_TessCoord.yyy * input.cp[1].NORMAL0.xyz;
    u_xlat0.xyz = fma(input.cp[0].NORMAL0.xyz, mtl_TessCoord.xxx, u_xlat0.xyz);
    u_xlat0.xyz = fma(input.cp[2].NORMAL0.xyz, mtl_TessCoord.zzz, u_xlat0.xyz);
    u_xlat1.x = dot(u_xlat0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat1.y = dot(u_xlat0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat1.z = dot(u_xlat0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat15 = dot(u_xlat1.xyz, u_xlat1.xyz);
    u_xlat15 = rsqrt(u_xlat15);
    u_xlat1.xyz = float3(u_xlat15) * u_xlat1.xyz;
    u_xlat2.xy = mtl_TessCoord.yy * input.cp[1].TEXCOORD0.xy;
    u_xlat2.xy = fma(input.cp[0].TEXCOORD0.xy, mtl_TessCoord.xx, u_xlat2.xy);
    u_xlat2.xy = fma(input.cp[2].TEXCOORD0.xy, mtl_TessCoord.zz, u_xlat2.xy);
    u_xlat2.xy = u_xlat2.xy * float2(VGlobals._Tile);
    u_xlat2.xyz = _Height.sample(sampler_Height, u_xlat2.xy, level(1.0)).xyz;
    u_xlat0.xyz = u_xlat0.xyz * u_xlat2.xyz;
    u_xlat2 = mtl_TessCoord.yyyy * input.cp[1].INTERNALTESSPOS0;
    u_xlat2 = fma(input.cp[0].INTERNALTESSPOS0, mtl_TessCoord.xxxx, u_xlat2);
    u_xlat2 = fma(input.cp[2].INTERNALTESSPOS0, mtl_TessCoord.zzzz, u_xlat2);
    u_xlat0.xyz = fma(u_xlat0.xyz, float3(VGlobals._HeightDisplacement), u_xlat2.xyz);
    u_xlat3 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], u_xlat0.xxxx, u_xlat3);
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], u_xlat0.zzzz, u_xlat3);
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3], u_xlat2.wwww, u_xlat3);
    u_xlat2.xyz = fma((-u_xlat3.xyz), VGlobals._WorldSpaceLightPos0.www, VGlobals._WorldSpaceLightPos0.xyz);
    u_xlat15 = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat15 = rsqrt(u_xlat15);
    u_xlat2.xyz = float3(u_xlat15) * u_xlat2.xyz;
    u_xlat15 = dot(u_xlat1.xyz, u_xlat2.xyz);
    u_xlat15 = fma((-u_xlat15), u_xlat15, 1.0);
    u_xlat15 = sqrt(u_xlat15);
    u_xlat15 = u_xlat15 * VGlobals.unity_LightShadowBias.z;
    u_xlat1.xyz = fma((-u_xlat1.xyz), float3(u_xlat15), u_xlat3.xyz);
    u_xlatb15 = VGlobals.unity_LightShadowBias.z!=0.0;
    u_xlat1.xyz = (bool(u_xlatb15)) ? u_xlat1.xyz : u_xlat3.xyz;
    u_xlat4 = u_xlat1.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat4 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat1.xxxx, u_xlat4);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat1.zzzz, u_xlat4);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat3.wwww, u_xlat1);
    u_xlat15 = VGlobals.unity_LightShadowBias.x / u_xlat1.w;
    u_xlat15 = min(u_xlat15, 0.0);
    u_xlat15 = max(u_xlat15, -1.0);
    u_xlat15 = u_xlat15 + u_xlat1.z;
    u_xlat11 = min(u_xlat1.w, u_xlat15);
    output.mtl_Position.xyw = u_xlat1.xyw;
    u_xlat1.x = (-u_xlat15) + u_xlat11;
    output.mtl_Position.z = fma(VGlobals.unity_LightShadowBias.y, u_xlat1.x, u_xlat15);
    u_xlat1.xyz = u_xlat0.yyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz;
    u_xlat0.xyw = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, u_xlat0.xxx, u_xlat1.xyz);
    u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, u_xlat0.zzz, u_xlat0.xyw);
    output.TEXCOORD1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, u_xlat2.www, u_xlat0.xyz);
    return output;
}
// SHADER_STAGE_DOMAIN_end
Compilation succeeded with: 

program_source:299:53: warning: writable resources in non-void post-tessellation vertex function
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
                                                    ^
program_source:305:30: note: writable buffer defined here
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
                             ^
program_source:306:48: note: writable buffer defined here
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
                                               ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float4 TEXCOORD0 [[ attribute(3) ]] ;
    float4 TEXCOORD1 [[ attribute(4) ]] ;
    float4 TEXCOORD2 [[ attribute(5) ]] ;
    float4 TEXCOORD3 [[ attribute(6) ]] ;
    float4 COLOR0 [[ attribute(7) ]] ;
};
struct Mtl_VertexOut
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float4 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float4 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float4 TEXCOORD3 [[ user(TEXCOORD3) ]];
    float4 COLOR0 [[ user(COLOR0) ]];
};
static Mtl_VertexOut vertexFunction(
    Mtl_VertexIn input)
{
    Mtl_VertexOut output;
    output.INTERNALTESSPOS0 = input.POSITION0;
    output.TANGENT0 = input.TANGENT0;
    output.NORMAL0.xyz = input.NORMAL0.xyz;
    output.TEXCOORD0 = input.TEXCOORD0;
    output.TEXCOORD1 = input.TEXCOORD1;
    output.TEXCOORD2 = input.TEXCOORD2;
    output.TEXCOORD3 = input.TEXCOORD3;
    output.COLOR0 = input.COLOR0;
    return output;
}
// SHADER_STAGE_HULL_begin
struct Mtl_ControlPoint
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float4 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float4 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float4 TEXCOORD3 [[ user(TEXCOORD3) ]];
    float4 COLOR0 [[ user(COLOR0) ]];
};
struct Mtl_ControlPointIn
{
    float4 INTERNALTESSPOS0 [[ attribute(8) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float4 TEXCOORD0 [[ attribute(3) ]] ;
    float4 TEXCOORD1 [[ attribute(4) ]] ;
    float4 TEXCOORD2 [[ attribute(5) ]] ;
    float4 TEXCOORD3 [[ attribute(6) ]] ;
    float4 COLOR0 [[ attribute(7) ]] ;
};
struct Mtl_KernelPatchInfo
{
    uint numPatches;
    ushort numControlPointsPerPatch;
};
struct VGlobals_Type
{
    float4 _Time;
    float4 _SinTime;
    float4 _CosTime;
    float4 unity_DeltaTime;
    float3 _WorldSpaceCameraPos;
    float4 _ProjectionParams;
    float4 _ScreenParams;
    float4 _ZBufferParams;
    float4 unity_OrthoParams;
    float4 unity_CameraWorldClipPlanes[6];
    float4 hlslcc_mtx4x4unity_CameraProjection[4];
    float4 hlslcc_mtx4x4unity_CameraInvProjection[4];
    float4 hlslcc_mtx4x4unity_WorldToCamera[4];
    float4 hlslcc_mtx4x4unity_CameraToWorld[4];
    float4 _WorldSpaceLightPos0;
    float4 _LightPositionRange;
    float4 _LightProjectionParams;
    float4 unity_4LightPosX0;
    float4 unity_4LightPosY0;
    float4 unity_4LightPosZ0;
    float4 unity_4LightAtten0;
    float4 unity_LightColor[8];
    float4 unity_LightPosition[8];
    float4 unity_LightAtten[8];
    float4 unity_SpotDirection[8];
    float4 unity_SHAr;
    float4 unity_SHAg;
    float4 unity_SHAb;
    float4 unity_SHBr;
    float4 unity_SHBg;
    float4 unity_SHBb;
    float4 unity_SHC;
    float4 unity_OcclusionMaskSelector;
    float4 unity_ProbesOcclusion;
    float3 unity_LightColor0;
    float3 unity_LightColor1;
    float3 unity_LightColor2;
    float3 unity_LightColor3;
    float4 unity_ShadowSplitSpheres[4];
    float4 unity_ShadowSplitSqRadii;
    float4 unity_LightShadowBias;
    float4 _LightSplitsNear;
    float4 _LightSplitsFar;
    float4 hlslcc_mtx4x4unity_WorldToShadow[16];
    float4 _LightShadowData;
    float4 unity_ShadowFadeCenterAndType;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 unity_LODFade;
    float4 unity_WorldTransformParams;
    float4 unity_RenderingLayer;
    float4 hlslcc_mtx4x4glstate_matrix_transpose_modelview0[4];
    float4 glstate_lightmodel_ambient;
    float4 unity_AmbientSky;
    float4 unity_AmbientEquator;
    float4 unity_AmbientGround;
    float4 unity_IndirectSpecColor;
    float4 hlslcc_mtx4x4glstate_matrix_projection[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixInvV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    int unity_StereoEyeIndex;
    float4 unity_ShadowColor;
    float4 unity_FogColor;
    float4 unity_FogParams;
    float4 unity_LightmapST;
    float4 unity_DynamicLightmapST;
    float4 unity_SpecCube0_BoxMax;
    float4 unity_SpecCube0_BoxMin;
    float4 unity_SpecCube0_ProbePosition;
    float4 unity_SpecCube0_HDR;
    float4 unity_SpecCube1_BoxMax;
    float4 unity_SpecCube1_BoxMin;
    float4 unity_SpecCube1_ProbePosition;
    float4 unity_SpecCube1_HDR;
    float4 unity_ProbeVolumeParams;
    float4 hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[4];
    float3 unity_ProbeVolumeSizeInv;
    float3 unity_ProbeVolumeMin;
    float4 unity_Lightmap_HDR;
    float4 unity_DynamicLightmap_HDR;
    float4 _LightColor0;
    float4 _SpecColor;
    float _Tile;
    float _HeightDisplacement;
    float _NormalScale;
    float4 _ColorTint;
    float _MetallicStrength;
    float _SmoothnessStrength;
    float _EdgeLength;
    float4 _texcoord_ST;
    float4 unity_Ambient;
};
struct Mtl_HullIn
{
    Mtl_VertexOut cp[3];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
kernel void patchKernel(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn vertexInput [[ stage_in ]],
    uint2 tID [[ thread_position_in_grid ]],
    ushort2 groupID [[ threadgroup_position_in_grid ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    constant Mtl_KernelPatchInfo &patchInfo [[ buffer(3) ]])
{
#pragma clang diagnostic pop
    Mtl_ControlPoint output;
    const uint numPatchesInThreadGroup = 10;
    const uint patchID = (tID.x / patchInfo.numControlPointsPerPatch);
    const bool patchValid = (patchID < patchInfo.numPatches);
    const uint mtl_BaseInstance = 0;
    const uint mtl_InstanceID = groupID.y - mtl_BaseInstance;
    const uint internalPatchID = mtl_InstanceID * patchInfo.numPatches + patchID;
    const uint patchIDInThreadGroup = (patchID % numPatchesInThreadGroup);
    const uint controlPointID = (tID.x % patchInfo.numControlPointsPerPatch);
    const uint mtl_BaseVertex = 0;
    const uint mtl_VertexID = ((mtl_InstanceID * (patchInfo.numControlPointsPerPatch * patchInfo.numPatches)) + tID.x) - mtl_BaseVertex;
    threadgroup Mtl_HullIn inputGroup[numPatchesInThreadGroup];
    threadgroup Mtl_HullIn &input = inputGroup[patchIDInThreadGroup];
    MTLTriangleTessellationFactorsHalf tessFactor;
    if (patchValid) {
        input.cp[controlPointID] = vertexFunction(vertexInput);
        output.INTERNALTESSPOS0 = input.cp[controlPointID].INTERNALTESSPOS0;
        output.TANGENT0 = input.cp[controlPointID].TANGENT0;
        output.NORMAL0 = input.cp[controlPointID].NORMAL0;
        output.TEXCOORD0 = input.cp[controlPointID].TEXCOORD0;
        output.TEXCOORD1 = input.cp[controlPointID].TEXCOORD1;
        output.TEXCOORD2 = input.cp[controlPointID].TEXCOORD2;
        output.TEXCOORD3 = input.cp[controlPointID].TEXCOORD3;
        output.COLOR0 = input.cp[controlPointID].COLOR0;
    }
    threadgroup_barrier(mem_flags::mem_threadgroup);
    if (!patchValid) {
        return;
    }
    float3 u_xlat0;
    float3 u_xlat1;
    float3 u_xlat2;
    float3 u_xlat3;
    float3 u_xlat4;
    float u_xlat12;
    float u_xlat13;
    // fork_phase2
    {
        u_xlat0.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[1].INTERNALTESSPOS0.yyy;
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[1].INTERNALTESSPOS0.xxx, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[1].INTERNALTESSPOS0.zzz, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[1].INTERNALTESSPOS0.www, u_xlat0.xyz);
        u_xlat1.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[2].INTERNALTESSPOS0.yyy;
        u_xlat1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[2].INTERNALTESSPOS0.xxx, u_xlat1.xyz);
        u_xlat1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[2].INTERNALTESSPOS0.zzz, u_xlat1.xyz);
        u_xlat1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[2].INTERNALTESSPOS0.www, u_xlat1.xyz);
        u_xlat2.xyz = u_xlat0.xyz + u_xlat1.xyz;
        u_xlat2.xyz = fma(u_xlat2.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat12 = dot(u_xlat2.xyz, u_xlat2.xyz);
        u_xlat12 = sqrt(u_xlat12);
        u_xlat12 = u_xlat12 * VGlobals._EdgeLength;
        u_xlat2.xyz = u_xlat0.xyz + (-u_xlat1.xyz);
        u_xlat13 = dot(u_xlat2.xyz, u_xlat2.xyz);
        u_xlat13 = sqrt(u_xlat13);
        u_xlat13 = u_xlat13 * VGlobals._ScreenParams.y;
        u_xlat12 = u_xlat13 / u_xlat12;
        tessFactor.edgeTessellationFactor[0] = max(u_xlat12, 1.0);
        u_xlat2.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[0].INTERNALTESSPOS0.yyy;
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[0].INTERNALTESSPOS0.xxx, u_xlat2.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[0].INTERNALTESSPOS0.zzz, u_xlat2.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[0].INTERNALTESSPOS0.www, u_xlat2.xyz);
        u_xlat3.xyz = u_xlat1.xyz + u_xlat2.xyz;
        u_xlat1.xyz = u_xlat1.xyz + (-u_xlat2.xyz);
        u_xlat12 = dot(u_xlat1.xyz, u_xlat1.xyz);
        u_xlat12 = sqrt(u_xlat12);
        u_xlat12 = u_xlat12 * VGlobals._ScreenParams.y;
        u_xlat1.xyz = fma(u_xlat3.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat1.x = dot(u_xlat1.xyz, u_xlat1.xyz);
        u_xlat1.x = sqrt(u_xlat1.x);
        u_xlat1.x = u_xlat1.x * VGlobals._EdgeLength;
        u_xlat12 = u_xlat12 / u_xlat1.x;
        tessFactor.edgeTessellationFactor[1] = max(u_xlat12, 1.0);
        u_xlat1.xyz = u_xlat0.xyz + u_xlat2.xyz;
        u_xlat0.xyz = (-u_xlat0.xyz) + u_xlat2.xyz;
        u_xlat0.x = dot(u_xlat0.xyz, u_xlat0.xyz);
        u_xlat0.x = sqrt(u_xlat0.x);
        u_xlat0.x = u_xlat0.x * VGlobals._ScreenParams.y;
        u_xlat4.xyz = fma(u_xlat1.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat4.x = dot(u_xlat4.xyz, u_xlat4.xyz);
        u_xlat4.x = sqrt(u_xlat4.x);
        u_xlat4.x = u_xlat4.x * VGlobals._EdgeLength;
        u_xlat0.x = u_xlat0.x / u_xlat4.x;
        tessFactor.edgeTessellationFactor[2] = max(u_xlat0.x, 1.0);
    }
    // join_phase3
    {
        u_xlat0.x = tessFactor.edgeTessellationFactor[0] + tessFactor.edgeTessellationFactor[1];
        u_xlat0.x = u_xlat0.x + tessFactor.edgeTessellationFactor[2];
        tessFactor.insideTessellationFactor = u_xlat0.x * 0.333333343;
    }
    controlPoints[mtl_VertexID] = output;
    tessFactors[internalPatchID] = tessFactor;
}
// SHADER_STAGE_HULL_end
// SHADER_STAGE_DOMAIN_begin
struct Mtl_VertexInPostTess
{
    patch_control_point<Mtl_ControlPointIn> cp;
};
struct Mtl_VertexOutPostTess
{
    float4 mtl_Position [[ position ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float4 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float4 TEXCOORD3 [[ user(TEXCOORD3) ]];
    float4 TEXCOORD5 [[ user(TEXCOORD5) ]];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    sampler sampler_Height [[ sampler (0) ]],
    texture2d<float, access::sample > _Height [[ texture(0) ]] ,
    float3 mtl_TessCoord [[ position_in_patch ]],
    uint patchID [[ patch_id ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    Mtl_VertexInPostTess input [[ stage_in ]])
{
#pragma clang diagnostic pop
    Mtl_VertexOutPostTess output;
    MTLTriangleTessellationFactorsHalf tessFactor;
    tessFactor = tessFactors[patchID];
    float4 u_xlat0;
    float4 u_xlat1;
    float4 u_xlat2;
    float4 u_xlat3;
    float2 u_xlat9;
    float u_xlat12;
    float u_xlat13;
    u_xlat0 = mtl_TessCoord.yyyy * input.cp[1].INTERNALTESSPOS0;
    u_xlat0 = fma(input.cp[0].INTERNALTESSPOS0, mtl_TessCoord.xxxx, u_xlat0);
    u_xlat0 = fma(input.cp[2].INTERNALTESSPOS0, mtl_TessCoord.zzzz, u_xlat0);
    u_xlat1.xy = mtl_TessCoord.yy * input.cp[1].TEXCOORD0.xy;
    u_xlat1.xy = fma(input.cp[0].TEXCOORD0.xy, mtl_TessCoord.xx, u_xlat1.xy);
    u_xlat1.xy = fma(input.cp[2].TEXCOORD0.xy, mtl_TessCoord.zz, u_xlat1.xy);
    u_xlat9.xy = u_xlat1.xy * float2(VGlobals._Tile);
    output.TEXCOORD0.xy = fma(u_xlat1.xy, VGlobals._texcoord_ST.xy, VGlobals._texcoord_ST.zw);
    u_xlat1.xyz = _Height.sample(sampler_Height, u_xlat9.xy, level(1.0)).xyz;
    u_xlat2.xyz = mtl_TessCoord.yyy * input.cp[1].NORMAL0.xyz;
    u_xlat2.xyz = fma(input.cp[0].NORMAL0.xyz, mtl_TessCoord.xxx, u_xlat2.xyz);
    u_xlat2.xyz = fma(input.cp[2].NORMAL0.xyz, mtl_TessCoord.zzz, u_xlat2.xyz);
    u_xlat1.xyz = u_xlat1.xyz * u_xlat2.xyz;
    u_xlat0.xyz = fma(u_xlat1.xyz, float3(VGlobals._HeightDisplacement), u_xlat0.xyz);
    u_xlat1 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], u_xlat0.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], u_xlat0.zzzz, u_xlat1);
    u_xlat3 = u_xlat1 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, u_xlat0.www, u_xlat1.xyz);
    u_xlat1 = u_xlat3.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat3.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat3.zzzz, u_xlat1);
    output.mtl_Position = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat3.wwww, u_xlat1);
    u_xlat1.y = dot(u_xlat2.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat1.z = dot(u_xlat2.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat1.x = dot(u_xlat2.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat12 = dot(u_xlat1.xyz, u_xlat1.xyz);
    u_xlat12 = rsqrt(u_xlat12);
    u_xlat1.xyz = float3(u_xlat12) * u_xlat1.xyz;
    output.TEXCOORD1.z = u_xlat1.y;
    u_xlat2 = mtl_TessCoord.yyyy * input.cp[1].TANGENT0;
    u_xlat2 = fma(input.cp[0].TANGENT0, mtl_TessCoord.xxxx, u_xlat2);
    u_xlat2 = fma(input.cp[2].TANGENT0, mtl_TessCoord.zzzz, u_xlat2);
    u_xlat3.xyz = u_xlat2.yyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].yzx;
    u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].yzx, u_xlat2.xxx, u_xlat3.xyz);
    u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].yzx, u_xlat2.zzz, u_xlat3.xyz);
    u_xlat12 = u_xlat2.w * VGlobals.unity_WorldTransformParams.w;
    u_xlat13 = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat13 = rsqrt(u_xlat13);
    u_xlat2.xyz = float3(u_xlat13) * u_xlat2.xyz;
    u_xlat3.xyz = u_xlat1.xyz * u_xlat2.xyz;
    u_xlat3.xyz = fma(u_xlat1.zxy, u_xlat2.yzx, (-u_xlat3.xyz));
    u_xlat3.xyz = float3(u_xlat12) * u_xlat3.xyz;
    output.TEXCOORD1.y = u_xlat3.x;
    output.TEXCOORD1.w = u_xlat0.x;
    output.TEXCOORD1.x = u_xlat2.z;
    output.TEXCOORD2.w = u_xlat0.y;
    output.TEXCOORD3.w = u_xlat0.z;
    output.TEXCOORD2.x = u_xlat2.x;
    output.TEXCOORD3.x = u_xlat2.y;
    output.TEXCOORD2.z = u_xlat1.z;
    output.TEXCOORD3.z = u_xlat1.x;
    output.TEXCOORD2.y = u_xlat3.y;
    output.TEXCOORD3.y = u_xlat3.z;
    output.TEXCOORD5 = float4(0.0, 0.0, 0.0, 0.0);
    return output;
}
// SHADER_STAGE_DOMAIN_end
Compilation succeeded with: 

program_source:303:53: warning: writable resources in non-void post-tessellation vertex function
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
                                                    ^
program_source:309:30: note: writable buffer defined here
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
                             ^
program_source:310:48: note: writable buffer defined here
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
                                               ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float4 TEXCOORD0 [[ attribute(3) ]] ;
    float4 TEXCOORD1 [[ attribute(4) ]] ;
    float4 TEXCOORD2 [[ attribute(5) ]] ;
    float4 TEXCOORD3 [[ attribute(6) ]] ;
    float4 COLOR0 [[ attribute(7) ]] ;
};
struct Mtl_VertexOut
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float4 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float4 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float4 TEXCOORD3 [[ user(TEXCOORD3) ]];
    float4 COLOR0 [[ user(COLOR0) ]];
};
static Mtl_VertexOut vertexFunction(
    Mtl_VertexIn input)
{
    Mtl_VertexOut output;
    output.INTERNALTESSPOS0 = input.POSITION0;
    output.TANGENT0 = input.TANGENT0;
    output.NORMAL0.xyz = input.NORMAL0.xyz;
    output.TEXCOORD0 = input.TEXCOORD0;
    output.TEXCOORD1 = input.TEXCOORD1;
    output.TEXCOORD2 = input.TEXCOORD2;
    output.TEXCOORD3 = input.TEXCOORD3;
    output.COLOR0 = input.COLOR0;
    return output;
}
// SHADER_STAGE_HULL_begin
struct Mtl_ControlPoint
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float4 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float4 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float4 TEXCOORD3 [[ user(TEXCOORD3) ]];
    float4 COLOR0 [[ user(COLOR0) ]];
};
struct Mtl_ControlPointIn
{
    float4 INTERNALTESSPOS0 [[ attribute(8) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float4 TEXCOORD0 [[ attribute(3) ]] ;
    float4 TEXCOORD1 [[ attribute(4) ]] ;
    float4 TEXCOORD2 [[ attribute(5) ]] ;
    float4 TEXCOORD3 [[ attribute(6) ]] ;
    float4 COLOR0 [[ attribute(7) ]] ;
};
struct Mtl_KernelPatchInfo
{
    uint numPatches;
    ushort numControlPointsPerPatch;
};
struct VGlobals_Type
{
    float4 _Time;
    float4 _SinTime;
    float4 _CosTime;
    float4 unity_DeltaTime;
    float3 _WorldSpaceCameraPos;
    float4 _ProjectionParams;
    float4 _ScreenParams;
    float4 _ZBufferParams;
    float4 unity_OrthoParams;
    float4 unity_CameraWorldClipPlanes[6];
    float4 hlslcc_mtx4x4unity_CameraProjection[4];
    float4 hlslcc_mtx4x4unity_CameraInvProjection[4];
    float4 hlslcc_mtx4x4unity_WorldToCamera[4];
    float4 hlslcc_mtx4x4unity_CameraToWorld[4];
    float4 _WorldSpaceLightPos0;
    float4 _LightPositionRange;
    float4 _LightProjectionParams;
    float4 unity_4LightPosX0;
    float4 unity_4LightPosY0;
    float4 unity_4LightPosZ0;
    float4 unity_4LightAtten0;
    float4 unity_LightColor[8];
    float4 unity_LightPosition[8];
    float4 unity_LightAtten[8];
    float4 unity_SpotDirection[8];
    float4 unity_SHAr;
    float4 unity_SHAg;
    float4 unity_SHAb;
    float4 unity_SHBr;
    float4 unity_SHBg;
    float4 unity_SHBb;
    float4 unity_SHC;
    float4 unity_OcclusionMaskSelector;
    float4 unity_ProbesOcclusion;
    float3 unity_LightColor0;
    float3 unity_LightColor1;
    float3 unity_LightColor2;
    float3 unity_LightColor3;
    float4 unity_ShadowSplitSpheres[4];
    float4 unity_ShadowSplitSqRadii;
    float4 unity_LightShadowBias;
    float4 _LightSplitsNear;
    float4 _LightSplitsFar;
    float4 hlslcc_mtx4x4unity_WorldToShadow[16];
    float4 _LightShadowData;
    float4 unity_ShadowFadeCenterAndType;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 unity_LODFade;
    float4 unity_WorldTransformParams;
    float4 unity_RenderingLayer;
    float4 hlslcc_mtx4x4glstate_matrix_transpose_modelview0[4];
    float4 glstate_lightmodel_ambient;
    float4 unity_AmbientSky;
    float4 unity_AmbientEquator;
    float4 unity_AmbientGround;
    float4 unity_IndirectSpecColor;
    float4 hlslcc_mtx4x4glstate_matrix_projection[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixInvV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    int unity_StereoEyeIndex;
    float4 unity_ShadowColor;
    float4 unity_FogColor;
    float4 unity_FogParams;
    float4 unity_LightmapST;
    float4 unity_DynamicLightmapST;
    float4 unity_SpecCube0_BoxMax;
    float4 unity_SpecCube0_BoxMin;
    float4 unity_SpecCube0_ProbePosition;
    float4 unity_SpecCube0_HDR;
    float4 unity_SpecCube1_BoxMax;
    float4 unity_SpecCube1_BoxMin;
    float4 unity_SpecCube1_ProbePosition;
    float4 unity_SpecCube1_HDR;
    float4 unity_ProbeVolumeParams;
    float4 hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[4];
    float3 unity_ProbeVolumeSizeInv;
    float3 unity_ProbeVolumeMin;
    float4 unity_Lightmap_HDR;
    float4 unity_DynamicLightmap_HDR;
    float4 _LightColor0;
    float4 _SpecColor;
    float _Tile;
    float _HeightDisplacement;
    float _NormalScale;
    float4 _ColorTint;
    float _MetallicStrength;
    float _SmoothnessStrength;
    float _EdgeLength;
    bool4 unity_MetaVertexControl;
    bool4 unity_MetaFragmentControl;
    int unity_VisualizationMode;
    float unity_OneOverOutputBoost;
    float unity_MaxOutputValue;
    float unity_UseLinearSpace;
    float4 _texcoord_ST;
};
struct Mtl_HullIn
{
    Mtl_VertexOut cp[3];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
kernel void patchKernel(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn vertexInput [[ stage_in ]],
    uint2 tID [[ thread_position_in_grid ]],
    ushort2 groupID [[ threadgroup_position_in_grid ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    constant Mtl_KernelPatchInfo &patchInfo [[ buffer(3) ]])
{
#pragma clang diagnostic pop
    Mtl_ControlPoint output;
    const uint numPatchesInThreadGroup = 10;
    const uint patchID = (tID.x / patchInfo.numControlPointsPerPatch);
    const bool patchValid = (patchID < patchInfo.numPatches);
    const uint mtl_BaseInstance = 0;
    const uint mtl_InstanceID = groupID.y - mtl_BaseInstance;
    const uint internalPatchID = mtl_InstanceID * patchInfo.numPatches + patchID;
    const uint patchIDInThreadGroup = (patchID % numPatchesInThreadGroup);
    const uint controlPointID = (tID.x % patchInfo.numControlPointsPerPatch);
    const uint mtl_BaseVertex = 0;
    const uint mtl_VertexID = ((mtl_InstanceID * (patchInfo.numControlPointsPerPatch * patchInfo.numPatches)) + tID.x) - mtl_BaseVertex;
    threadgroup Mtl_HullIn inputGroup[numPatchesInThreadGroup];
    threadgroup Mtl_HullIn &input = inputGroup[patchIDInThreadGroup];
    MTLTriangleTessellationFactorsHalf tessFactor;
    if (patchValid) {
        input.cp[controlPointID] = vertexFunction(vertexInput);
        output.INTERNALTESSPOS0 = input.cp[controlPointID].INTERNALTESSPOS0;
        output.TANGENT0 = input.cp[controlPointID].TANGENT0;
        output.NORMAL0 = input.cp[controlPointID].NORMAL0;
        output.TEXCOORD0 = input.cp[controlPointID].TEXCOORD0;
        output.TEXCOORD1 = input.cp[controlPointID].TEXCOORD1;
        output.TEXCOORD2 = input.cp[controlPointID].TEXCOORD2;
        output.TEXCOORD3 = input.cp[controlPointID].TEXCOORD3;
        output.COLOR0 = input.cp[controlPointID].COLOR0;
    }
    threadgroup_barrier(mem_flags::mem_threadgroup);
    if (!patchValid) {
        return;
    }
    float3 u_xlat0;
    float3 u_xlat1;
    float3 u_xlat2;
    float3 u_xlat3;
    float3 u_xlat4;
    float u_xlat12;
    float u_xlat13;
    // fork_phase2
    {
        u_xlat0.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[1].INTERNALTESSPOS0.yyy;
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[1].INTERNALTESSPOS0.xxx, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[1].INTERNALTESSPOS0.zzz, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[1].INTERNALTESSPOS0.www, u_xlat0.xyz);
        u_xlat1.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[2].INTERNALTESSPOS0.yyy;
        u_xlat1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[2].INTERNALTESSPOS0.xxx, u_xlat1.xyz);
        u_xlat1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[2].INTERNALTESSPOS0.zzz, u_xlat1.xyz);
        u_xlat1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[2].INTERNALTESSPOS0.www, u_xlat1.xyz);
        u_xlat2.xyz = u_xlat0.xyz + u_xlat1.xyz;
        u_xlat2.xyz = fma(u_xlat2.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat12 = dot(u_xlat2.xyz, u_xlat2.xyz);
        u_xlat12 = sqrt(u_xlat12);
        u_xlat12 = u_xlat12 * VGlobals._EdgeLength;
        u_xlat2.xyz = u_xlat0.xyz + (-u_xlat1.xyz);
        u_xlat13 = dot(u_xlat2.xyz, u_xlat2.xyz);
        u_xlat13 = sqrt(u_xlat13);
        u_xlat13 = u_xlat13 * VGlobals._ScreenParams.y;
        u_xlat12 = u_xlat13 / u_xlat12;
        tessFactor.edgeTessellationFactor[0] = max(u_xlat12, 1.0);
        u_xlat2.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[0].INTERNALTESSPOS0.yyy;
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[0].INTERNALTESSPOS0.xxx, u_xlat2.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[0].INTERNALTESSPOS0.zzz, u_xlat2.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[0].INTERNALTESSPOS0.www, u_xlat2.xyz);
        u_xlat3.xyz = u_xlat1.xyz + u_xlat2.xyz;
        u_xlat1.xyz = u_xlat1.xyz + (-u_xlat2.xyz);
        u_xlat12 = dot(u_xlat1.xyz, u_xlat1.xyz);
        u_xlat12 = sqrt(u_xlat12);
        u_xlat12 = u_xlat12 * VGlobals._ScreenParams.y;
        u_xlat1.xyz = fma(u_xlat3.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat1.x = dot(u_xlat1.xyz, u_xlat1.xyz);
        u_xlat1.x = sqrt(u_xlat1.x);
        u_xlat1.x = u_xlat1.x * VGlobals._EdgeLength;
        u_xlat12 = u_xlat12 / u_xlat1.x;
        tessFactor.edgeTessellationFactor[1] = max(u_xlat12, 1.0);
        u_xlat1.xyz = u_xlat0.xyz + u_xlat2.xyz;
        u_xlat0.xyz = (-u_xlat0.xyz) + u_xlat2.xyz;
        u_xlat0.x = dot(u_xlat0.xyz, u_xlat0.xyz);
        u_xlat0.x = sqrt(u_xlat0.x);
        u_xlat0.x = u_xlat0.x * VGlobals._ScreenParams.y;
        u_xlat4.xyz = fma(u_xlat1.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat4.x = dot(u_xlat4.xyz, u_xlat4.xyz);
        u_xlat4.x = sqrt(u_xlat4.x);
        u_xlat4.x = u_xlat4.x * VGlobals._EdgeLength;
        u_xlat0.x = u_xlat0.x / u_xlat4.x;
        tessFactor.edgeTessellationFactor[2] = max(u_xlat0.x, 1.0);
    }
    // join_phase3
    {
        u_xlat0.x = tessFactor.edgeTessellationFactor[0] + tessFactor.edgeTessellationFactor[1];
        u_xlat0.x = u_xlat0.x + tessFactor.edgeTessellationFactor[2];
        tessFactor.insideTessellationFactor = u_xlat0.x * 0.333333343;
    }
    controlPoints[mtl_VertexID] = output;
    tessFactors[internalPatchID] = tessFactor;
}
// SHADER_STAGE_HULL_end
// SHADER_STAGE_DOMAIN_begin
struct Mtl_VertexInPostTess
{
    patch_control_point<Mtl_ControlPointIn> cp;
};
struct Mtl_VertexOutPostTess
{
    float4 mtl_Position [[ position ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float4 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float4 TEXCOORD3 [[ user(TEXCOORD3) ]];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    sampler sampler_Height [[ sampler (0) ]],
    texture2d<float, access::sample > _Height [[ texture(0) ]] ,
    float3 mtl_TessCoord [[ position_in_patch ]],
    uint patchID [[ patch_id ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    Mtl_VertexInPostTess input [[ stage_in ]])
{
#pragma clang diagnostic pop
    Mtl_VertexOutPostTess output;
    MTLTriangleTessellationFactorsHalf tessFactor;
    tessFactor = tessFactors[patchID];
    float4 u_xlat0;
    float4 u_xlat1;
    float4 u_xlat2;
    float3 u_xlat3;
    float3 u_xlat4;
    float2 u_xlat13;
    float u_xlat15;
    bool u_xlatb15;
    u_xlat0.xy = mtl_TessCoord.yy * input.cp[1].TEXCOORD2.xy;
    u_xlat0.xy = fma(input.cp[0].TEXCOORD2.xy, mtl_TessCoord.xx, u_xlat0.xy);
    u_xlat0.xy = fma(input.cp[2].TEXCOORD2.xy, mtl_TessCoord.zz, u_xlat0.xy);
    u_xlat0.xy = fma(u_xlat0.xy, VGlobals.unity_DynamicLightmapST.xy, VGlobals.unity_DynamicLightmapST.zw);
    u_xlat1.xy = mtl_TessCoord.yy * input.cp[1].TEXCOORD1.xy;
    u_xlat1.xy = fma(input.cp[0].TEXCOORD1.xy, mtl_TessCoord.xx, u_xlat1.xy);
    u_xlat1.xy = fma(input.cp[2].TEXCOORD1.xy, mtl_TessCoord.zz, u_xlat1.xy);
    u_xlat1.xy = fma(u_xlat1.xy, VGlobals.unity_LightmapST.xy, VGlobals.unity_LightmapST.zw);
    u_xlat2 = mtl_TessCoord.yyyy * input.cp[1].INTERNALTESSPOS0;
    u_xlat2 = fma(input.cp[0].INTERNALTESSPOS0, mtl_TessCoord.xxxx, u_xlat2);
    u_xlat2 = fma(input.cp[2].INTERNALTESSPOS0, mtl_TessCoord.zzzz, u_xlat2);
    u_xlat3.xy = mtl_TessCoord.yy * input.cp[1].TEXCOORD0.xy;
    u_xlat3.xy = fma(input.cp[0].TEXCOORD0.xy, mtl_TessCoord.xx, u_xlat3.xy);
    u_xlat3.xy = fma(input.cp[2].TEXCOORD0.xy, mtl_TessCoord.zz, u_xlat3.xy);
    u_xlat13.xy = u_xlat3.xy * float2(VGlobals._Tile);
    output.TEXCOORD0.xy = fma(u_xlat3.xy, VGlobals._texcoord_ST.xy, VGlobals._texcoord_ST.zw);
    u_xlat3.xyz = _Height.sample(sampler_Height, u_xlat13.xy, level(1.0)).xyz;
    u_xlat4.xyz = mtl_TessCoord.yyy * input.cp[1].NORMAL0.xyz;
    u_xlat4.xyz = fma(input.cp[0].NORMAL0.xyz, mtl_TessCoord.xxx, u_xlat4.xyz);
    u_xlat4.xyz = fma(input.cp[2].NORMAL0.xyz, mtl_TessCoord.zzz, u_xlat4.xyz);
    u_xlat3.xyz = u_xlat3.xyz * u_xlat4.xyz;
    u_xlat2.xyz = fma(u_xlat3.xyz, float3(VGlobals._HeightDisplacement), u_xlat2.xyz);
    u_xlatb15 = 0.0<u_xlat2.z;
    u_xlat1.z = u_xlatb15 ? 9.99999975e-05 : float(0.0);
    u_xlat1.xyz = (VGlobals.unity_MetaVertexControl.x) ? u_xlat1.xyz : u_xlat2.xyz;
    u_xlatb15 = 0.0<u_xlat1.z;
    u_xlat0.z = u_xlatb15 ? 9.99999975e-05 : float(0.0);
    u_xlat0.xyz = (VGlobals.unity_MetaVertexControl.y) ? u_xlat0.xyz : u_xlat1.xyz;
    u_xlat1 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat0.xxxx, u_xlat1);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat0.zzzz, u_xlat1);
    output.mtl_Position = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_MatrixVP[3];
    u_xlat0.xyz = u_xlat2.yyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz;
    u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, u_xlat2.xxx, u_xlat0.xyz);
    u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, u_xlat2.zzz, u_xlat0.xyz);
    u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, u_xlat2.www, u_xlat0.xyz);
    output.TEXCOORD1.w = u_xlat0.x;
    u_xlat1.y = dot(u_xlat4.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat1.z = dot(u_xlat4.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat1.x = dot(u_xlat4.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat0.x = dot(u_xlat1.xyz, u_xlat1.xyz);
    u_xlat0.x = rsqrt(u_xlat0.x);
    u_xlat1.xyz = u_xlat0.xxx * u_xlat1.xyz;
    output.TEXCOORD1.z = u_xlat1.y;
    u_xlat2 = mtl_TessCoord.yyyy * input.cp[1].TANGENT0;
    u_xlat2 = fma(input.cp[0].TANGENT0, mtl_TessCoord.xxxx, u_xlat2);
    u_xlat2 = fma(input.cp[2].TANGENT0, mtl_TessCoord.zzzz, u_xlat2);
    u_xlat3.xyz = u_xlat2.yyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].yzx;
    u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].yzx, u_xlat2.xxx, u_xlat3.xyz);
    u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].yzx, u_xlat2.zzz, u_xlat3.xyz);
    u_xlat0.x = u_xlat2.w * VGlobals.unity_WorldTransformParams.w;
    u_xlat15 = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat15 = rsqrt(u_xlat15);
    u_xlat2.xyz = float3(u_xlat15) * u_xlat2.xyz;
    u_xlat3.xyz = u_xlat1.xyz * u_xlat2.xyz;
    u_xlat3.xyz = fma(u_xlat1.zxy, u_xlat2.yzx, (-u_xlat3.xyz));
    u_xlat3.xyz = u_xlat0.xxx * u_xlat3.xyz;
    output.TEXCOORD1.y = u_xlat3.x;
    output.TEXCOORD1.x = u_xlat2.z;
    output.TEXCOORD2.w = u_xlat0.y;
    output.TEXCOORD3.w = u_xlat0.z;
    output.TEXCOORD2.x = u_xlat2.x;
    output.TEXCOORD3.x = u_xlat2.y;
    output.TEXCOORD2.z = u_xlat1.z;
    output.TEXCOORD3.z = u_xlat1.x;
    output.TEXCOORD2.y = u_xlat3.y;
    output.TEXCOORD3.y = u_xlat3.z;
    return output;
}
// SHADER_STAGE_DOMAIN_end
Refreshing native plugins compatible for Editor in 2.14 ms, found 2 plugins.
Preloading 0 native plugins for Editor in 0.00 ms.
Unloading 3375 Unused Serialized files (Serialized files now loaded: 0)
Unloading 20 unused Assets / (0.6 MB). Loaded Objects now: 3873.
Memory consumption went from 130.1 MB to 129.5 MB.
Total: 5.389136 ms (FindLiveObjects: 0.422535 ms CreateObjectMapping: 0.255372 ms MarkObjects: 4.069959 ms  DeleteObjects: 0.639839 ms)

AssetImportParameters requested are different than current active one (requested -> active):
  custom:video-decoder-ogg-theora: a1e56fd34408186e4bbccfd4996cb3dc -> 
  custom:container-muxer-webm: aa71ff27fc2769a1b78a27578f13a17b -> 
  custom:container-demuxer-webm: 4f35f7cbe854078d1ac9338744f61a02 -> 
  custom:video-encoder-webm-vp8: eb34c28f22e8b96e1ab97ce403110664 -> 
  custom:framework-osx-AVFoundation: b23960f63f64bdc6ff669e2cdcee2391 -> 
  custom:audio-encoder-webm-vorbis: bf7c407c2cedff20999df2af8eb42d56 -> 
  custom:container-demuxer-ogg: 62fdf1f143b41e24485cea50d1cbac27 -> 
  custom:video-decoder-webm-vp8: 9c59270c3fd7afecdb556c50c9e8de78 -> 
  custom:audio-decoder-ogg-vorbis: bf7c407c2cedff20999df2af8eb42d56 -> 
========================================================================
Received Import Request.
  Time since last request: 10866.941029 seconds.
  path: Assets/PreFabs/White Staug.prefab
  artifactKey: Guid(be68c97c6d2bf4f329837afb8a825a67) Importer(815301076,1909f56bfc062723c751e8b465ee728b)
Start importing Assets/PreFabs/White Staug.prefab using Guid(be68c97c6d2bf4f329837afb8a825a67) Importer(815301076,1909f56bfc062723c751e8b465ee728b)  -> (artifact id: 'f7766c312fbc79bde8369e8ec4e20eee') in 1.236843 seconds 
========================================================================
Received Prepare
Registering precompiled user dll's ...
Registered in 0.003756 seconds.
Begin MonoManager ReloadAssembly
Symbol file LoadedFromMemory doesn't match image /Users/kamilaamendolagine/Desktop/Staugen Raug v2 - Prefab - Map 1.01/Library/PackageCache/com.unity.visualscripting@1.7.8/Editor/VisualScripting.Core/Dependencies/YamlDotNet/Unity.VisualScripting.YamlDotNet.dll
Symbol file LoadedFromMemory doesn't match image /Users/kamilaamendolagine/Desktop/Staugen Raug v2 - Prefab - Map 1.01/Library/PackageCache/com.unity.visualscripting@1.7.8/Editor/VisualScripting.Core/Dependencies/DotNetZip/Unity.VisualScripting.IonicZip.dll
Native extension for OSXStandalone target not found
Native extension for WebGL target not found
Refreshing native plugins compatible for Editor in 0.83 ms, found 2 plugins.
Preloading 0 native plugins for Editor in 0.00 ms.
Mono: successfully reloaded assembly
- Completed reload, in  1.774 seconds
Domain Reload Profiling:
	ReloadAssembly (1775ms)
		BeginReloadAssembly (314ms)
			ExecutionOrderSort (0ms)
			DisableScriptedObjects (10ms)
			BackupInstance (0ms)
			ReleaseScriptingObjects (0ms)
			CreateAndSetChildDomain (161ms)
		EndReloadAssembly (1289ms)
			LoadAssemblies (120ms)
			RebuildTransferFunctionScriptingTraits (0ms)
			SetupTypeCache (519ms)
			ReleaseScriptCaches (2ms)
			RebuildScriptCaches (70ms)
			SetupLoadedEditorAssemblies (525ms)
				LogAssemblyErrors (0ms)
				InitializePlatformSupportModulesInManaged (15ms)
				SetLoadedEditorAssemblies (1ms)
				RefreshPlugins (1ms)
				BeforeProcessingInitializeOnLoad (82ms)
				ProcessInitializeOnLoadAttributes (386ms)
				ProcessInitializeOnLoadMethodAttributes (37ms)
				AfterProcessingInitializeOnLoad (3ms)
				EditorAssembliesLoaded (0ms)
			ExecutionOrderSort2 (0ms)
			AwakeInstancesAfterBackupRestoration (7ms)
Platform modules already initialized, skipping
Compilation succeeded with: 

program_source:299:53: warning: writable resources in non-void post-tessellation vertex function
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
                                                    ^
program_source:305:30: note: writable buffer defined here
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
                             ^
program_source:306:48: note: writable buffer defined here
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
                                               ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float4 TEXCOORD0 [[ attribute(3) ]] ;
    float4 TEXCOORD1 [[ attribute(4) ]] ;
    float4 TEXCOORD2 [[ attribute(5) ]] ;
    float4 TEXCOORD3 [[ attribute(6) ]] ;
    float4 COLOR0 [[ attribute(7) ]] ;
};
struct Mtl_VertexOut
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float4 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float4 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float4 TEXCOORD3 [[ user(TEXCOORD3) ]];
    float4 COLOR0 [[ user(COLOR0) ]];
};
static Mtl_VertexOut vertexFunction(
    Mtl_VertexIn input)
{
    Mtl_VertexOut output;
    output.INTERNALTESSPOS0 = input.POSITION0;
    output.TANGENT0 = input.TANGENT0;
    output.NORMAL0.xyz = input.NORMAL0.xyz;
    output.TEXCOORD0 = input.TEXCOORD0;
    output.TEXCOORD1 = input.TEXCOORD1;
    output.TEXCOORD2 = input.TEXCOORD2;
    output.TEXCOORD3 = input.TEXCOORD3;
    output.COLOR0 = input.COLOR0;
    return output;
}
// SHADER_STAGE_HULL_begin
struct Mtl_ControlPoint
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float4 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float4 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float4 TEXCOORD3 [[ user(TEXCOORD3) ]];
    float4 COLOR0 [[ user(COLOR0) ]];
};
struct Mtl_ControlPointIn
{
    float4 INTERNALTESSPOS0 [[ attribute(8) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float4 TEXCOORD0 [[ attribute(3) ]] ;
    float4 TEXCOORD1 [[ attribute(4) ]] ;
    float4 TEXCOORD2 [[ attribute(5) ]] ;
    float4 TEXCOORD3 [[ attribute(6) ]] ;
    float4 COLOR0 [[ attribute(7) ]] ;
};
struct Mtl_KernelPatchInfo
{
    uint numPatches;
    ushort numControlPointsPerPatch;
};
struct VGlobals_Type
{
    float4 _Time;
    float4 _SinTime;
    float4 _CosTime;
    float4 unity_DeltaTime;
    float3 _WorldSpaceCameraPos;
    float4 _ProjectionParams;
    float4 _ScreenParams;
    float4 _ZBufferParams;
    float4 unity_OrthoParams;
    float4 unity_CameraWorldClipPlanes[6];
    float4 hlslcc_mtx4x4unity_CameraProjection[4];
    float4 hlslcc_mtx4x4unity_CameraInvProjection[4];
    float4 hlslcc_mtx4x4unity_WorldToCamera[4];
    float4 hlslcc_mtx4x4unity_CameraToWorld[4];
    float4 _WorldSpaceLightPos0;
    float4 _LightPositionRange;
    float4 _LightProjectionParams;
    float4 unity_4LightPosX0;
    float4 unity_4LightPosY0;
    float4 unity_4LightPosZ0;
    float4 unity_4LightAtten0;
    float4 unity_LightColor[8];
    float4 unity_LightPosition[8];
    float4 unity_LightAtten[8];
    float4 unity_SpotDirection[8];
    float4 unity_SHAr;
    float4 unity_SHAg;
    float4 unity_SHAb;
    float4 unity_SHBr;
    float4 unity_SHBg;
    float4 unity_SHBb;
    float4 unity_SHC;
    float4 unity_OcclusionMaskSelector;
    float4 unity_ProbesOcclusion;
    float3 unity_LightColor0;
    float3 unity_LightColor1;
    float3 unity_LightColor2;
    float3 unity_LightColor3;
    float4 unity_ShadowSplitSpheres[4];
    float4 unity_ShadowSplitSqRadii;
    float4 unity_LightShadowBias;
    float4 _LightSplitsNear;
    float4 _LightSplitsFar;
    float4 hlslcc_mtx4x4unity_WorldToShadow[16];
    float4 _LightShadowData;
    float4 unity_ShadowFadeCenterAndType;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 unity_LODFade;
    float4 unity_WorldTransformParams;
    float4 unity_RenderingLayer;
    float4 hlslcc_mtx4x4glstate_matrix_transpose_modelview0[4];
    float4 glstate_lightmodel_ambient;
    float4 unity_AmbientSky;
    float4 unity_AmbientEquator;
    float4 unity_AmbientGround;
    float4 unity_IndirectSpecColor;
    float4 hlslcc_mtx4x4glstate_matrix_projection[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixInvV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    int unity_StereoEyeIndex;
    float4 unity_ShadowColor;
    float4 unity_FogColor;
    float4 unity_FogParams;
    float4 unity_LightmapST;
    float4 unity_DynamicLightmapST;
    float4 unity_SpecCube0_BoxMax;
    float4 unity_SpecCube0_BoxMin;
    float4 unity_SpecCube0_ProbePosition;
    float4 unity_SpecCube0_HDR;
    float4 unity_SpecCube1_BoxMax;
    float4 unity_SpecCube1_BoxMin;
    float4 unity_SpecCube1_ProbePosition;
    float4 unity_SpecCube1_HDR;
    float4 unity_ProbeVolumeParams;
    float4 hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[4];
    float3 unity_ProbeVolumeSizeInv;
    float3 unity_ProbeVolumeMin;
    float4 unity_Lightmap_HDR;
    float4 unity_DynamicLightmap_HDR;
    float4 _LightColor0;
    float4 _SpecColor;
    float _Tile;
    float _HeightDisplacement;
    float _NormalScale;
    float4 _ColorTint;
    float _MetallicStrength;
    float _SmoothnessStrength;
    float _EdgeLength;
    float4 _texcoord_ST;
};
struct Mtl_HullIn
{
    Mtl_VertexOut cp[3];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
kernel void patchKernel(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn vertexInput [[ stage_in ]],
    uint2 tID [[ thread_position_in_grid ]],
    ushort2 groupID [[ threadgroup_position_in_grid ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    constant Mtl_KernelPatchInfo &patchInfo [[ buffer(3) ]])
{
#pragma clang diagnostic pop
    Mtl_ControlPoint output;
    const uint numPatchesInThreadGroup = 10;
    const uint patchID = (tID.x / patchInfo.numControlPointsPerPatch);
    const bool patchValid = (patchID < patchInfo.numPatches);
    const uint mtl_BaseInstance = 0;
    const uint mtl_InstanceID = groupID.y - mtl_BaseInstance;
    const uint internalPatchID = mtl_InstanceID * patchInfo.numPatches + patchID;
    const uint patchIDInThreadGroup = (patchID % numPatchesInThreadGroup);
    const uint controlPointID = (tID.x % patchInfo.numControlPointsPerPatch);
    const uint mtl_BaseVertex = 0;
    const uint mtl_VertexID = ((mtl_InstanceID * (patchInfo.numControlPointsPerPatch * patchInfo.numPatches)) + tID.x) - mtl_BaseVertex;
    threadgroup Mtl_HullIn inputGroup[numPatchesInThreadGroup];
    threadgroup Mtl_HullIn &input = inputGroup[patchIDInThreadGroup];
    MTLTriangleTessellationFactorsHalf tessFactor;
    if (patchValid) {
        input.cp[controlPointID] = vertexFunction(vertexInput);
        output.INTERNALTESSPOS0 = input.cp[controlPointID].INTERNALTESSPOS0;
        output.TANGENT0 = input.cp[controlPointID].TANGENT0;
        output.NORMAL0 = input.cp[controlPointID].NORMAL0;
        output.TEXCOORD0 = input.cp[controlPointID].TEXCOORD0;
        output.TEXCOORD1 = input.cp[controlPointID].TEXCOORD1;
        output.TEXCOORD2 = input.cp[controlPointID].TEXCOORD2;
        output.TEXCOORD3 = input.cp[controlPointID].TEXCOORD3;
        output.COLOR0 = input.cp[controlPointID].COLOR0;
    }
    threadgroup_barrier(mem_flags::mem_threadgroup);
    if (!patchValid) {
        return;
    }
    float3 u_xlat0;
    float3 u_xlat1;
    float3 u_xlat2;
    float3 u_xlat3;
    float3 u_xlat4;
    float u_xlat12;
    float u_xlat13;
    // fork_phase2
    {
        u_xlat0.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[1].INTERNALTESSPOS0.yyy;
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[1].INTERNALTESSPOS0.xxx, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[1].INTERNALTESSPOS0.zzz, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[1].INTERNALTESSPOS0.www, u_xlat0.xyz);
        u_xlat1.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[2].INTERNALTESSPOS0.yyy;
        u_xlat1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[2].INTERNALTESSPOS0.xxx, u_xlat1.xyz);
        u_xlat1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[2].INTERNALTESSPOS0.zzz, u_xlat1.xyz);
        u_xlat1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[2].INTERNALTESSPOS0.www, u_xlat1.xyz);
        u_xlat2.xyz = u_xlat0.xyz + u_xlat1.xyz;
        u_xlat2.xyz = fma(u_xlat2.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat12 = dot(u_xlat2.xyz, u_xlat2.xyz);
        u_xlat12 = sqrt(u_xlat12);
        u_xlat12 = u_xlat12 * VGlobals._EdgeLength;
        u_xlat2.xyz = u_xlat0.xyz + (-u_xlat1.xyz);
        u_xlat13 = dot(u_xlat2.xyz, u_xlat2.xyz);
        u_xlat13 = sqrt(u_xlat13);
        u_xlat13 = u_xlat13 * VGlobals._ScreenParams.y;
        u_xlat12 = u_xlat13 / u_xlat12;
        tessFactor.edgeTessellationFactor[0] = max(u_xlat12, 1.0);
        u_xlat2.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[0].INTERNALTESSPOS0.yyy;
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[0].INTERNALTESSPOS0.xxx, u_xlat2.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[0].INTERNALTESSPOS0.zzz, u_xlat2.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[0].INTERNALTESSPOS0.www, u_xlat2.xyz);
        u_xlat3.xyz = u_xlat1.xyz + u_xlat2.xyz;
        u_xlat1.xyz = u_xlat1.xyz + (-u_xlat2.xyz);
        u_xlat12 = dot(u_xlat1.xyz, u_xlat1.xyz);
        u_xlat12 = sqrt(u_xlat12);
        u_xlat12 = u_xlat12 * VGlobals._ScreenParams.y;
        u_xlat1.xyz = fma(u_xlat3.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat1.x = dot(u_xlat1.xyz, u_xlat1.xyz);
        u_xlat1.x = sqrt(u_xlat1.x);
        u_xlat1.x = u_xlat1.x * VGlobals._EdgeLength;
        u_xlat12 = u_xlat12 / u_xlat1.x;
        tessFactor.edgeTessellationFactor[1] = max(u_xlat12, 1.0);
        u_xlat1.xyz = u_xlat0.xyz + u_xlat2.xyz;
        u_xlat0.xyz = (-u_xlat0.xyz) + u_xlat2.xyz;
        u_xlat0.x = dot(u_xlat0.xyz, u_xlat0.xyz);
        u_xlat0.x = sqrt(u_xlat0.x);
        u_xlat0.x = u_xlat0.x * VGlobals._ScreenParams.y;
        u_xlat4.xyz = fma(u_xlat1.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat4.x = dot(u_xlat4.xyz, u_xlat4.xyz);
        u_xlat4.x = sqrt(u_xlat4.x);
        u_xlat4.x = u_xlat4.x * VGlobals._EdgeLength;
        u_xlat0.x = u_xlat0.x / u_xlat4.x;
        tessFactor.edgeTessellationFactor[2] = max(u_xlat0.x, 1.0);
    }
    // join_phase3
    {
        u_xlat0.x = tessFactor.edgeTessellationFactor[0] + tessFactor.edgeTessellationFactor[1];
        u_xlat0.x = u_xlat0.x + tessFactor.edgeTessellationFactor[2];
        tessFactor.insideTessellationFactor = u_xlat0.x * 0.333333343;
    }
    controlPoints[mtl_VertexID] = output;
    tessFactors[internalPatchID] = tessFactor;
}
// SHADER_STAGE_HULL_end
// SHADER_STAGE_DOMAIN_begin
struct Mtl_VertexInPostTess
{
    patch_control_point<Mtl_ControlPointIn> cp;
};
struct Mtl_VertexOutPostTess
{
    float4 mtl_Position [[ position ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float4 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float4 TEXCOORD3 [[ user(TEXCOORD3) ]];
    float4 TEXCOORD6 [[ user(TEXCOORD6) ]];
    float4 TEXCOORD7 [[ user(TEXCOORD7) ]];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    sampler sampler_Height [[ sampler (0) ]],
    texture2d<float, access::sample > _Height [[ texture(0) ]] ,
    float3 mtl_TessCoord [[ position_in_patch ]],
    uint patchID [[ patch_id ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    Mtl_VertexInPostTess input [[ stage_in ]])
{
#pragma clang diagnostic pop
    Mtl_VertexOutPostTess output;
    MTLTriangleTessellationFactorsHalf tessFactor;
    tessFactor = tessFactors[patchID];
    float4 u_xlat0;
    float4 u_xlat1;
    float4 u_xlat2;
    float4 u_xlat3;
    float2 u_xlat9;
    float u_xlat12;
    float u_xlat13;
    u_xlat0 = mtl_TessCoord.yyyy * input.cp[1].INTERNALTESSPOS0;
    u_xlat0 = fma(input.cp[0].INTERNALTESSPOS0, mtl_TessCoord.xxxx, u_xlat0);
    u_xlat0 = fma(input.cp[2].INTERNALTESSPOS0, mtl_TessCoord.zzzz, u_xlat0);
    u_xlat1.xy = mtl_TessCoord.yy * input.cp[1].TEXCOORD0.xy;
    u_xlat1.xy = fma(input.cp[0].TEXCOORD0.xy, mtl_TessCoord.xx, u_xlat1.xy);
    u_xlat1.xy = fma(input.cp[2].TEXCOORD0.xy, mtl_TessCoord.zz, u_xlat1.xy);
    u_xlat9.xy = u_xlat1.xy * float2(VGlobals._Tile);
    output.TEXCOORD0.xy = fma(u_xlat1.xy, VGlobals._texcoord_ST.xy, VGlobals._texcoord_ST.zw);
    u_xlat1.xyz = _Height.sample(sampler_Height, u_xlat9.xy, level(1.0)).xyz;
    u_xlat2.xyz = mtl_TessCoord.yyy * input.cp[1].NORMAL0.xyz;
    u_xlat2.xyz = fma(input.cp[0].NORMAL0.xyz, mtl_TessCoord.xxx, u_xlat2.xyz);
    u_xlat2.xyz = fma(input.cp[2].NORMAL0.xyz, mtl_TessCoord.zzz, u_xlat2.xyz);
    u_xlat1.xyz = u_xlat1.xyz * u_xlat2.xyz;
    u_xlat0.xyz = fma(u_xlat1.xyz, float3(VGlobals._HeightDisplacement), u_xlat0.xyz);
    u_xlat1 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], u_xlat0.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], u_xlat0.zzzz, u_xlat1);
    u_xlat3 = u_xlat1 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, u_xlat0.www, u_xlat1.xyz);
    u_xlat1 = u_xlat3.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat3.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat3.zzzz, u_xlat1);
    output.mtl_Position = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat3.wwww, u_xlat1);
    u_xlat1.y = dot(u_xlat2.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat1.z = dot(u_xlat2.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat1.x = dot(u_xlat2.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat12 = dot(u_xlat1.xyz, u_xlat1.xyz);
    u_xlat12 = rsqrt(u_xlat12);
    u_xlat1.xyz = float3(u_xlat12) * u_xlat1.xyz;
    output.TEXCOORD1.z = u_xlat1.y;
    u_xlat2 = mtl_TessCoord.yyyy * input.cp[1].TANGENT0;
    u_xlat2 = fma(input.cp[0].TANGENT0, mtl_TessCoord.xxxx, u_xlat2);
    u_xlat2 = fma(input.cp[2].TANGENT0, mtl_TessCoord.zzzz, u_xlat2);
    u_xlat3.xyz = u_xlat2.yyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].yzx;
    u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].yzx, u_xlat2.xxx, u_xlat3.xyz);
    u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].yzx, u_xlat2.zzz, u_xlat3.xyz);
    u_xlat12 = u_xlat2.w * VGlobals.unity_WorldTransformParams.w;
    u_xlat13 = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat13 = rsqrt(u_xlat13);
    u_xlat2.xyz = float3(u_xlat13) * u_xlat2.xyz;
    u_xlat3.xyz = u_xlat1.xyz * u_xlat2.xyz;
    u_xlat3.xyz = fma(u_xlat1.zxy, u_xlat2.yzx, (-u_xlat3.xyz));
    u_xlat3.xyz = float3(u_xlat12) * u_xlat3.xyz;
    output.TEXCOORD1.y = u_xlat3.x;
    output.TEXCOORD1.w = u_xlat0.x;
    output.TEXCOORD1.x = u_xlat2.z;
    output.TEXCOORD2.w = u_xlat0.y;
    output.TEXCOORD3.w = u_xlat0.z;
    output.TEXCOORD2.x = u_xlat2.x;
    output.TEXCOORD3.x = u_xlat2.y;
    output.TEXCOORD2.z = u_xlat1.z;
    output.TEXCOORD3.z = u_xlat1.x;
    output.TEXCOORD2.y = u_xlat3.y;
    output.TEXCOORD3.y = u_xlat3.z;
    output.TEXCOORD6 = float4(0.0, 0.0, 0.0, 0.0);
    output.TEXCOORD7 = float4(0.0, 0.0, 0.0, 0.0);
    return output;
}
// SHADER_STAGE_DOMAIN_end
Compilation succeeded with: 

program_source:301:53: warning: writable resources in non-void post-tessellation vertex function
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
                                                    ^
program_source:307:30: note: writable buffer defined here
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
                             ^
program_source:308:48: note: writable buffer defined here
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
                                               ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float4 TEXCOORD0 [[ attribute(3) ]] ;
    float4 TEXCOORD1 [[ attribute(4) ]] ;
    float4 TEXCOORD2 [[ attribute(5) ]] ;
    float4 TEXCOORD3 [[ attribute(6) ]] ;
    float4 COLOR0 [[ attribute(7) ]] ;
};
struct Mtl_VertexOut
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float4 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float4 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float4 TEXCOORD3 [[ user(TEXCOORD3) ]];
    float4 COLOR0 [[ user(COLOR0) ]];
};
static Mtl_VertexOut vertexFunction(
    Mtl_VertexIn input)
{
    Mtl_VertexOut output;
    output.INTERNALTESSPOS0 = input.POSITION0;
    output.TANGENT0 = input.TANGENT0;
    output.NORMAL0.xyz = input.NORMAL0.xyz;
    output.TEXCOORD0 = input.TEXCOORD0;
    output.TEXCOORD1 = input.TEXCOORD1;
    output.TEXCOORD2 = input.TEXCOORD2;
    output.TEXCOORD3 = input.TEXCOORD3;
    output.COLOR0 = input.COLOR0;
    return output;
}
// SHADER_STAGE_HULL_begin
struct Mtl_ControlPoint
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float4 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float4 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float4 TEXCOORD3 [[ user(TEXCOORD3) ]];
    float4 COLOR0 [[ user(COLOR0) ]];
};
struct Mtl_ControlPointIn
{
    float4 INTERNALTESSPOS0 [[ attribute(8) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float4 TEXCOORD0 [[ attribute(3) ]] ;
    float4 TEXCOORD1 [[ attribute(4) ]] ;
    float4 TEXCOORD2 [[ attribute(5) ]] ;
    float4 TEXCOORD3 [[ attribute(6) ]] ;
    float4 COLOR0 [[ attribute(7) ]] ;
};
struct Mtl_KernelPatchInfo
{
    uint numPatches;
    ushort numControlPointsPerPatch;
};
struct VGlobals_Type
{
    float4 _Time;
    float4 _SinTime;
    float4 _CosTime;
    float4 unity_DeltaTime;
    float3 _WorldSpaceCameraPos;
    float4 _ProjectionParams;
    float4 _ScreenParams;
    float4 _ZBufferParams;
    float4 unity_OrthoParams;
    float4 unity_CameraWorldClipPlanes[6];
    float4 hlslcc_mtx4x4unity_CameraProjection[4];
    float4 hlslcc_mtx4x4unity_CameraInvProjection[4];
    float4 hlslcc_mtx4x4unity_WorldToCamera[4];
    float4 hlslcc_mtx4x4unity_CameraToWorld[4];
    float4 _WorldSpaceLightPos0;
    float4 _LightPositionRange;
    float4 _LightProjectionParams;
    float4 unity_4LightPosX0;
    float4 unity_4LightPosY0;
    float4 unity_4LightPosZ0;
    float4 unity_4LightAtten0;
    float4 unity_LightColor[8];
    float4 unity_LightPosition[8];
    float4 unity_LightAtten[8];
    float4 unity_SpotDirection[8];
    float4 unity_SHAr;
    float4 unity_SHAg;
    float4 unity_SHAb;
    float4 unity_SHBr;
    float4 unity_SHBg;
    float4 unity_SHBb;
    float4 unity_SHC;
    float4 unity_OcclusionMaskSelector;
    float4 unity_ProbesOcclusion;
    float3 unity_LightColor0;
    float3 unity_LightColor1;
    float3 unity_LightColor2;
    float3 unity_LightColor3;
    float4 unity_ShadowSplitSpheres[4];
    float4 unity_ShadowSplitSqRadii;
    float4 unity_LightShadowBias;
    float4 _LightSplitsNear;
    float4 _LightSplitsFar;
    float4 hlslcc_mtx4x4unity_WorldToShadow[16];
    float4 _LightShadowData;
    float4 unity_ShadowFadeCenterAndType;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 unity_LODFade;
    float4 unity_WorldTransformParams;
    float4 unity_RenderingLayer;
    float4 hlslcc_mtx4x4glstate_matrix_transpose_modelview0[4];
    float4 glstate_lightmodel_ambient;
    float4 unity_AmbientSky;
    float4 unity_AmbientEquator;
    float4 unity_AmbientGround;
    float4 unity_IndirectSpecColor;
    float4 hlslcc_mtx4x4glstate_matrix_projection[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixInvV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    int unity_StereoEyeIndex;
    float4 unity_ShadowColor;
    float4 unity_FogColor;
    float4 unity_FogParams;
    float4 unity_LightmapST;
    float4 unity_DynamicLightmapST;
    float4 unity_SpecCube0_BoxMax;
    float4 unity_SpecCube0_BoxMin;
    float4 unity_SpecCube0_ProbePosition;
    float4 unity_SpecCube0_HDR;
    float4 unity_SpecCube1_BoxMax;
    float4 unity_SpecCube1_BoxMin;
    float4 unity_SpecCube1_ProbePosition;
    float4 unity_SpecCube1_HDR;
    float4 unity_ProbeVolumeParams;
    float4 hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[4];
    float3 unity_ProbeVolumeSizeInv;
    float3 unity_ProbeVolumeMin;
    float4 unity_Lightmap_HDR;
    float4 unity_DynamicLightmap_HDR;
    float4 _LightColor0;
    float4 _SpecColor;
    float4 hlslcc_mtx4x4unity_WorldToLight[4];
    float _Tile;
    float _HeightDisplacement;
    float _NormalScale;
    float4 _ColorTint;
    float _MetallicStrength;
    float _SmoothnessStrength;
    float _EdgeLength;
    float4 _texcoord_ST;
};
struct Mtl_HullIn
{
    Mtl_VertexOut cp[3];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
kernel void patchKernel(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn vertexInput [[ stage_in ]],
    uint2 tID [[ thread_position_in_grid ]],
    ushort2 groupID [[ threadgroup_position_in_grid ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    constant Mtl_KernelPatchInfo &patchInfo [[ buffer(3) ]])
{
#pragma clang diagnostic pop
    Mtl_ControlPoint output;
    const uint numPatchesInThreadGroup = 10;
    const uint patchID = (tID.x / patchInfo.numControlPointsPerPatch);
    const bool patchValid = (patchID < patchInfo.numPatches);
    const uint mtl_BaseInstance = 0;
    const uint mtl_InstanceID = groupID.y - mtl_BaseInstance;
    const uint internalPatchID = mtl_InstanceID * patchInfo.numPatches + patchID;
    const uint patchIDInThreadGroup = (patchID % numPatchesInThreadGroup);
    const uint controlPointID = (tID.x % patchInfo.numControlPointsPerPatch);
    const uint mtl_BaseVertex = 0;
    const uint mtl_VertexID = ((mtl_InstanceID * (patchInfo.numControlPointsPerPatch * patchInfo.numPatches)) + tID.x) - mtl_BaseVertex;
    threadgroup Mtl_HullIn inputGroup[numPatchesInThreadGroup];
    threadgroup Mtl_HullIn &input = inputGroup[patchIDInThreadGroup];
    MTLTriangleTessellationFactorsHalf tessFactor;
    if (patchValid) {
        input.cp[controlPointID] = vertexFunction(vertexInput);
        output.INTERNALTESSPOS0 = input.cp[controlPointID].INTERNALTESSPOS0;
        output.TANGENT0 = input.cp[controlPointID].TANGENT0;
        output.NORMAL0 = input.cp[controlPointID].NORMAL0;
        output.TEXCOORD0 = input.cp[controlPointID].TEXCOORD0;
        output.TEXCOORD1 = input.cp[controlPointID].TEXCOORD1;
        output.TEXCOORD2 = input.cp[controlPointID].TEXCOORD2;
        output.TEXCOORD3 = input.cp[controlPointID].TEXCOORD3;
        output.COLOR0 = input.cp[controlPointID].COLOR0;
    }
    threadgroup_barrier(mem_flags::mem_threadgroup);
    if (!patchValid) {
        return;
    }
    float3 u_xlat0;
    float3 u_xlat1;
    float3 u_xlat2;
    float3 u_xlat3;
    float3 u_xlat4;
    float u_xlat12;
    float u_xlat13;
    // fork_phase2
    {
        u_xlat0.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[1].INTERNALTESSPOS0.yyy;
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[1].INTERNALTESSPOS0.xxx, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[1].INTERNALTESSPOS0.zzz, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[1].INTERNALTESSPOS0.www, u_xlat0.xyz);
        u_xlat1.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[2].INTERNALTESSPOS0.yyy;
        u_xlat1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[2].INTERNALTESSPOS0.xxx, u_xlat1.xyz);
        u_xlat1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[2].INTERNALTESSPOS0.zzz, u_xlat1.xyz);
        u_xlat1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[2].INTERNALTESSPOS0.www, u_xlat1.xyz);
        u_xlat2.xyz = u_xlat0.xyz + u_xlat1.xyz;
        u_xlat2.xyz = fma(u_xlat2.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat12 = dot(u_xlat2.xyz, u_xlat2.xyz);
        u_xlat12 = sqrt(u_xlat12);
        u_xlat12 = u_xlat12 * VGlobals._EdgeLength;
        u_xlat2.xyz = u_xlat0.xyz + (-u_xlat1.xyz);
        u_xlat13 = dot(u_xlat2.xyz, u_xlat2.xyz);
        u_xlat13 = sqrt(u_xlat13);
        u_xlat13 = u_xlat13 * VGlobals._ScreenParams.y;
        u_xlat12 = u_xlat13 / u_xlat12;
        tessFactor.edgeTessellationFactor[0] = max(u_xlat12, 1.0);
        u_xlat2.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[0].INTERNALTESSPOS0.yyy;
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[0].INTERNALTESSPOS0.xxx, u_xlat2.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[0].INTERNALTESSPOS0.zzz, u_xlat2.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[0].INTERNALTESSPOS0.www, u_xlat2.xyz);
        u_xlat3.xyz = u_xlat1.xyz + u_xlat2.xyz;
        u_xlat1.xyz = u_xlat1.xyz + (-u_xlat2.xyz);
        u_xlat12 = dot(u_xlat1.xyz, u_xlat1.xyz);
        u_xlat12 = sqrt(u_xlat12);
        u_xlat12 = u_xlat12 * VGlobals._ScreenParams.y;
        u_xlat1.xyz = fma(u_xlat3.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat1.x = dot(u_xlat1.xyz, u_xlat1.xyz);
        u_xlat1.x = sqrt(u_xlat1.x);
        u_xlat1.x = u_xlat1.x * VGlobals._EdgeLength;
        u_xlat12 = u_xlat12 / u_xlat1.x;
        tessFactor.edgeTessellationFactor[1] = max(u_xlat12, 1.0);
        u_xlat1.xyz = u_xlat0.xyz + u_xlat2.xyz;
        u_xlat0.xyz = (-u_xlat0.xyz) + u_xlat2.xyz;
        u_xlat0.x = dot(u_xlat0.xyz, u_xlat0.xyz);
        u_xlat0.x = sqrt(u_xlat0.x);
        u_xlat0.x = u_xlat0.x * VGlobals._ScreenParams.y;
        u_xlat4.xyz = fma(u_xlat1.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat4.x = dot(u_xlat4.xyz, u_xlat4.xyz);
        u_xlat4.x = sqrt(u_xlat4.x);
        u_xlat4.x = u_xlat4.x * VGlobals._EdgeLength;
        u_xlat0.x = u_xlat0.x / u_xlat4.x;
        tessFactor.edgeTessellationFactor[2] = max(u_xlat0.x, 1.0);
    }
    // join_phase3
    {
        u_xlat0.x = tessFactor.edgeTessellationFactor[0] + tessFactor.edgeTessellationFactor[1];
        u_xlat0.x = u_xlat0.x + tessFactor.edgeTessellationFactor[2];
        tessFactor.insideTessellationFactor = u_xlat0.x * 0.333333343;
    }
    controlPoints[mtl_VertexID] = output;
    tessFactors[internalPatchID] = tessFactor;
}
// SHADER_STAGE_HULL_end
// SHADER_STAGE_DOMAIN_begin
struct Mtl_VertexInPostTess
{
    patch_control_point<Mtl_ControlPointIn> cp;
};
struct Mtl_VertexOutPostTess
{
    float4 mtl_Position [[ position ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float3 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float3 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float3 TEXCOORD3 [[ user(TEXCOORD3) ]];
    float3 TEXCOORD4 [[ user(TEXCOORD4) ]];
    float3 TEXCOORD5 [[ user(TEXCOORD5) ]];
    float4 TEXCOORD6 [[ user(TEXCOORD6) ]];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    sampler sampler_Height [[ sampler (0) ]],
    texture2d<float, access::sample > _Height [[ texture(0) ]] ,
    float3 mtl_TessCoord [[ position_in_patch ]],
    uint patchID [[ patch_id ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    Mtl_VertexInPostTess input [[ stage_in ]])
{
#pragma clang diagnostic pop
    Mtl_VertexOutPostTess output;
    MTLTriangleTessellationFactorsHalf tessFactor;
    tessFactor = tessFactors[patchID];
    float4 u_xlat0;
    float3 u_xlat1;
    float4 u_xlat2;
    float4 u_xlat3;
    float4 u_xlat4;
    float2 u_xlat10;
    float u_xlat16;
    u_xlat0.xy = mtl_TessCoord.yy * input.cp[1].TEXCOORD0.xy;
    u_xlat0.xy = fma(input.cp[0].TEXCOORD0.xy, mtl_TessCoord.xx, u_xlat0.xy);
    u_xlat0.xy = fma(input.cp[2].TEXCOORD0.xy, mtl_TessCoord.zz, u_xlat0.xy);
    u_xlat10.xy = u_xlat0.xy * float2(VGlobals._Tile);
    output.TEXCOORD0.xy = fma(u_xlat0.xy, VGlobals._texcoord_ST.xy, VGlobals._texcoord_ST.zw);
    u_xlat0.xyz = _Height.sample(sampler_Height, u_xlat10.xy, level(1.0)).xyz;
    u_xlat1.xyz = mtl_TessCoord.yyy * input.cp[1].NORMAL0.xyz;
    u_xlat1.xyz = fma(input.cp[0].NORMAL0.xyz, mtl_TessCoord.xxx, u_xlat1.xyz);
    u_xlat1.xyz = fma(input.cp[2].NORMAL0.xyz, mtl_TessCoord.zzz, u_xlat1.xyz);
    u_xlat0.xyz = u_xlat0.xyz * u_xlat1.xyz;
    u_xlat2 = mtl_TessCoord.yyyy * input.cp[1].INTERNALTESSPOS0;
    u_xlat2 = fma(input.cp[0].INTERNALTESSPOS0, mtl_TessCoord.xxxx, u_xlat2);
    u_xlat2 = fma(input.cp[2].INTERNALTESSPOS0, mtl_TessCoord.zzzz, u_xlat2);
    u_xlat0.xyz = fma(u_xlat0.xyz, float3(VGlobals._HeightDisplacement), u_xlat2.xyz);
    u_xlat3 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], u_xlat0.xxxx, u_xlat3);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], u_xlat0.zzzz, u_xlat3);
    u_xlat3 = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat4 = u_xlat3.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat4 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat3.xxxx, u_xlat4);
    u_xlat4 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat3.zzzz, u_xlat4);
    output.mtl_Position = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat3.wwww, u_xlat4);
    u_xlat2.y = dot(u_xlat1.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat2.z = dot(u_xlat1.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat2.x = dot(u_xlat1.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat1.x = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat1.x = rsqrt(u_xlat1.x);
    u_xlat1.xyz = u_xlat1.xxx * u_xlat2.xyz;
    output.TEXCOORD1.z = u_xlat1.y;
    u_xlat3 = mtl_TessCoord.yyyy * input.cp[1].TANGENT0;
    u_xlat3 = fma(input.cp[0].TANGENT0, mtl_TessCoord.xxxx, u_xlat3);
    u_xlat3 = fma(input.cp[2].TANGENT0, mtl_TessCoord.zzzz, u_xlat3);
    u_xlat2.xyz = u_xlat3.yyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].yzx;
    u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].yzx, u_xlat3.xxx, u_xlat2.xyz);
    u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].yzx, u_xlat3.zzz, u_xlat2.xyz);
    u_xlat16 = u_xlat3.w * VGlobals.unity_WorldTransformParams.w;
    u_xlat3.x = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat3.x = rsqrt(u_xlat3.x);
    u_xlat2.xyz = u_xlat2.xyz * u_xlat3.xxx;
    u_xlat3.xyz = u_xlat1.xyz * u_xlat2.xyz;
    u_xlat3.xyz = fma(u_xlat1.zxy, u_xlat2.yzx, (-u_xlat3.xyz));
    u_xlat3.xyz = float3(u_xlat16) * u_xlat3.xyz;
    output.TEXCOORD1.y = u_xlat3.x;
    output.TEXCOORD1.x = u_xlat2.z;
    output.TEXCOORD2.x = u_xlat2.x;
    output.TEXCOORD3.x = u_xlat2.y;
    output.TEXCOORD2.z = u_xlat1.z;
    output.TEXCOORD3.z = u_xlat1.x;
    output.TEXCOORD2.y = u_xlat3.y;
    output.TEXCOORD3.y = u_xlat3.z;
    output.TEXCOORD4.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, u_xlat2.www, u_xlat0.xyz);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3], u_xlat2.wwww, u_xlat0);
    u_xlat1.xyz = u_xlat0.yyy * VGlobals.hlslcc_mtx4x4unity_WorldToLight[1].xyz;
    u_xlat1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_WorldToLight[0].xyz, u_xlat0.xxx, u_xlat1.xyz);
    u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_WorldToLight[2].xyz, u_xlat0.zzz, u_xlat1.xyz);
    output.TEXCOORD5.xyz = fma(VGlobals.hlslcc_mtx4x4unity_WorldToLight[3].xyz, u_xlat0.www, u_xlat0.xyz);
    output.TEXCOORD6 = float4(0.0, 0.0, 0.0, 0.0);
    return output;
}
// SHADER_STAGE_DOMAIN_end
Compilation succeeded with: 

program_source:293:53: warning: writable resources in non-void post-tessellation vertex function
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
                                                    ^
program_source:299:30: note: writable buffer defined here
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
                             ^
program_source:300:48: note: writable buffer defined here
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
                                               ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float4 TEXCOORD0 [[ attribute(3) ]] ;
    float4 TEXCOORD1 [[ attribute(4) ]] ;
    float4 TEXCOORD2 [[ attribute(5) ]] ;
    float4 TEXCOORD3 [[ attribute(6) ]] ;
    float4 COLOR0 [[ attribute(7) ]] ;
};
struct Mtl_VertexOut
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float4 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float4 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float4 TEXCOORD3 [[ user(TEXCOORD3) ]];
    float4 COLOR0 [[ user(COLOR0) ]];
};
static Mtl_VertexOut vertexFunction(
    Mtl_VertexIn input)
{
    Mtl_VertexOut output;
    output.INTERNALTESSPOS0 = input.POSITION0;
    output.TANGENT0 = input.TANGENT0;
    output.NORMAL0.xyz = input.NORMAL0.xyz;
    output.TEXCOORD0 = input.TEXCOORD0;
    output.TEXCOORD1 = input.TEXCOORD1;
    output.TEXCOORD2 = input.TEXCOORD2;
    output.TEXCOORD3 = input.TEXCOORD3;
    output.COLOR0 = input.COLOR0;
    return output;
}
// SHADER_STAGE_HULL_begin
struct Mtl_ControlPoint
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float4 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float4 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float4 TEXCOORD3 [[ user(TEXCOORD3) ]];
    float4 COLOR0 [[ user(COLOR0) ]];
};
struct Mtl_ControlPointIn
{
    float4 INTERNALTESSPOS0 [[ attribute(8) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float4 TEXCOORD0 [[ attribute(3) ]] ;
    float4 TEXCOORD1 [[ attribute(4) ]] ;
    float4 TEXCOORD2 [[ attribute(5) ]] ;
    float4 TEXCOORD3 [[ attribute(6) ]] ;
    float4 COLOR0 [[ attribute(7) ]] ;
};
struct Mtl_KernelPatchInfo
{
    uint numPatches;
    ushort numControlPointsPerPatch;
};
struct VGlobals_Type
{
    float4 _Time;
    float4 _SinTime;
    float4 _CosTime;
    float4 unity_DeltaTime;
    float3 _WorldSpaceCameraPos;
    float4 _ProjectionParams;
    float4 _ScreenParams;
    float4 _ZBufferParams;
    float4 unity_OrthoParams;
    float4 unity_CameraWorldClipPlanes[6];
    float4 hlslcc_mtx4x4unity_CameraProjection[4];
    float4 hlslcc_mtx4x4unity_CameraInvProjection[4];
    float4 hlslcc_mtx4x4unity_WorldToCamera[4];
    float4 hlslcc_mtx4x4unity_CameraToWorld[4];
    float4 _WorldSpaceLightPos0;
    float4 _LightPositionRange;
    float4 _LightProjectionParams;
    float4 unity_4LightPosX0;
    float4 unity_4LightPosY0;
    float4 unity_4LightPosZ0;
    float4 unity_4LightAtten0;
    float4 unity_LightColor[8];
    float4 unity_LightPosition[8];
    float4 unity_LightAtten[8];
    float4 unity_SpotDirection[8];
    float4 unity_SHAr;
    float4 unity_SHAg;
    float4 unity_SHAb;
    float4 unity_SHBr;
    float4 unity_SHBg;
    float4 unity_SHBb;
    float4 unity_SHC;
    float4 unity_OcclusionMaskSelector;
    float4 unity_ProbesOcclusion;
    float3 unity_LightColor0;
    float3 unity_LightColor1;
    float3 unity_LightColor2;
    float3 unity_LightColor3;
    float4 unity_ShadowSplitSpheres[4];
    float4 unity_ShadowSplitSqRadii;
    float4 unity_LightShadowBias;
    float4 _LightSplitsNear;
    float4 _LightSplitsFar;
    float4 hlslcc_mtx4x4unity_WorldToShadow[16];
    float4 _LightShadowData;
    float4 unity_ShadowFadeCenterAndType;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 unity_LODFade;
    float4 unity_WorldTransformParams;
    float4 unity_RenderingLayer;
    float4 hlslcc_mtx4x4glstate_matrix_transpose_modelview0[4];
    float4 glstate_lightmodel_ambient;
    float4 unity_AmbientSky;
    float4 unity_AmbientEquator;
    float4 unity_AmbientGround;
    float4 unity_IndirectSpecColor;
    float4 hlslcc_mtx4x4glstate_matrix_projection[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixInvV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    int unity_StereoEyeIndex;
    float4 unity_ShadowColor;
    float4 unity_FogColor;
    float4 unity_FogParams;
    float4 unity_LightmapST;
    float4 unity_DynamicLightmapST;
    float4 unity_SpecCube0_BoxMax;
    float4 unity_SpecCube0_BoxMin;
    float4 unity_SpecCube0_ProbePosition;
    float4 unity_SpecCube0_HDR;
    float4 unity_SpecCube1_BoxMax;
    float4 unity_SpecCube1_BoxMin;
    float4 unity_SpecCube1_ProbePosition;
    float4 unity_SpecCube1_HDR;
    float4 unity_ProbeVolumeParams;
    float4 hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[4];
    float3 unity_ProbeVolumeSizeInv;
    float3 unity_ProbeVolumeMin;
    float4 unity_Lightmap_HDR;
    float4 unity_DynamicLightmap_HDR;
    float4 _LightColor0;
    float4 _SpecColor;
    float _Tile;
    float _HeightDisplacement;
    float _NormalScale;
    float4 _ColorTint;
    float _MetallicStrength;
    float _SmoothnessStrength;
    float _EdgeLength;
};
struct Mtl_HullIn
{
    Mtl_VertexOut cp[3];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
kernel void patchKernel(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn vertexInput [[ stage_in ]],
    uint2 tID [[ thread_position_in_grid ]],
    ushort2 groupID [[ threadgroup_position_in_grid ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    constant Mtl_KernelPatchInfo &patchInfo [[ buffer(3) ]])
{
#pragma clang diagnostic pop
    Mtl_ControlPoint output;
    const uint numPatchesInThreadGroup = 10;
    const uint patchID = (tID.x / patchInfo.numControlPointsPerPatch);
    const bool patchValid = (patchID < patchInfo.numPatches);
    const uint mtl_BaseInstance = 0;
    const uint mtl_InstanceID = groupID.y - mtl_BaseInstance;
    const uint internalPatchID = mtl_InstanceID * patchInfo.numPatches + patchID;
    const uint patchIDInThreadGroup = (patchID % numPatchesInThreadGroup);
    const uint controlPointID = (tID.x % patchInfo.numControlPointsPerPatch);
    const uint mtl_BaseVertex = 0;
    const uint mtl_VertexID = ((mtl_InstanceID * (patchInfo.numControlPointsPerPatch * patchInfo.numPatches)) + tID.x) - mtl_BaseVertex;
    threadgroup Mtl_HullIn inputGroup[numPatchesInThreadGroup];
    threadgroup Mtl_HullIn &input = inputGroup[patchIDInThreadGroup];
    MTLTriangleTessellationFactorsHalf tessFactor;
    if (patchValid) {
        input.cp[controlPointID] = vertexFunction(vertexInput);
        output.INTERNALTESSPOS0 = input.cp[controlPointID].INTERNALTESSPOS0;
        output.TANGENT0 = input.cp[controlPointID].TANGENT0;
        output.NORMAL0 = input.cp[controlPointID].NORMAL0;
        output.TEXCOORD0 = input.cp[controlPointID].TEXCOORD0;
        output.TEXCOORD1 = input.cp[controlPointID].TEXCOORD1;
        output.TEXCOORD2 = input.cp[controlPointID].TEXCOORD2;
        output.TEXCOORD3 = input.cp[controlPointID].TEXCOORD3;
        output.COLOR0 = input.cp[controlPointID].COLOR0;
    }
    threadgroup_barrier(mem_flags::mem_threadgroup);
    if (!patchValid) {
        return;
    }
    float3 u_xlat0;
    float3 u_xlat1;
    float3 u_xlat2;
    float3 u_xlat3;
    float3 u_xlat4;
    float u_xlat12;
    float u_xlat13;
    // fork_phase2
    {
        u_xlat0.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[1].INTERNALTESSPOS0.yyy;
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[1].INTERNALTESSPOS0.xxx, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[1].INTERNALTESSPOS0.zzz, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[1].INTERNALTESSPOS0.www, u_xlat0.xyz);
        u_xlat1.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[2].INTERNALTESSPOS0.yyy;
        u_xlat1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[2].INTERNALTESSPOS0.xxx, u_xlat1.xyz);
        u_xlat1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[2].INTERNALTESSPOS0.zzz, u_xlat1.xyz);
        u_xlat1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[2].INTERNALTESSPOS0.www, u_xlat1.xyz);
        u_xlat2.xyz = u_xlat0.xyz + u_xlat1.xyz;
        u_xlat2.xyz = fma(u_xlat2.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat12 = dot(u_xlat2.xyz, u_xlat2.xyz);
        u_xlat12 = sqrt(u_xlat12);
        u_xlat12 = u_xlat12 * VGlobals._EdgeLength;
        u_xlat2.xyz = u_xlat0.xyz + (-u_xlat1.xyz);
        u_xlat13 = dot(u_xlat2.xyz, u_xlat2.xyz);
        u_xlat13 = sqrt(u_xlat13);
        u_xlat13 = u_xlat13 * VGlobals._ScreenParams.y;
        u_xlat12 = u_xlat13 / u_xlat12;
        tessFactor.edgeTessellationFactor[0] = max(u_xlat12, 1.0);
        u_xlat2.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[0].INTERNALTESSPOS0.yyy;
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[0].INTERNALTESSPOS0.xxx, u_xlat2.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[0].INTERNALTESSPOS0.zzz, u_xlat2.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[0].INTERNALTESSPOS0.www, u_xlat2.xyz);
        u_xlat3.xyz = u_xlat1.xyz + u_xlat2.xyz;
        u_xlat1.xyz = u_xlat1.xyz + (-u_xlat2.xyz);
        u_xlat12 = dot(u_xlat1.xyz, u_xlat1.xyz);
        u_xlat12 = sqrt(u_xlat12);
        u_xlat12 = u_xlat12 * VGlobals._ScreenParams.y;
        u_xlat1.xyz = fma(u_xlat3.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat1.x = dot(u_xlat1.xyz, u_xlat1.xyz);
        u_xlat1.x = sqrt(u_xlat1.x);
        u_xlat1.x = u_xlat1.x * VGlobals._EdgeLength;
        u_xlat12 = u_xlat12 / u_xlat1.x;
        tessFactor.edgeTessellationFactor[1] = max(u_xlat12, 1.0);
        u_xlat1.xyz = u_xlat0.xyz + u_xlat2.xyz;
        u_xlat0.xyz = (-u_xlat0.xyz) + u_xlat2.xyz;
        u_xlat0.x = dot(u_xlat0.xyz, u_xlat0.xyz);
        u_xlat0.x = sqrt(u_xlat0.x);
        u_xlat0.x = u_xlat0.x * VGlobals._ScreenParams.y;
        u_xlat4.xyz = fma(u_xlat1.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat4.x = dot(u_xlat4.xyz, u_xlat4.xyz);
        u_xlat4.x = sqrt(u_xlat4.x);
        u_xlat4.x = u_xlat4.x * VGlobals._EdgeLength;
        u_xlat0.x = u_xlat0.x / u_xlat4.x;
        tessFactor.edgeTessellationFactor[2] = max(u_xlat0.x, 1.0);
    }
    // join_phase3
    {
        u_xlat0.x = tessFactor.edgeTessellationFactor[0] + tessFactor.edgeTessellationFactor[1];
        u_xlat0.x = u_xlat0.x + tessFactor.edgeTessellationFactor[2];
        tessFactor.insideTessellationFactor = u_xlat0.x * 0.333333343;
    }
    controlPoints[mtl_VertexID] = output;
    tessFactors[internalPatchID] = tessFactor;
}
// SHADER_STAGE_HULL_end
// SHADER_STAGE_DOMAIN_begin
struct Mtl_VertexInPostTess
{
    patch_control_point<Mtl_ControlPointIn> cp;
};
struct Mtl_VertexOutPostTess
{
    float4 mtl_Position [[ position ]];
    float3 TEXCOORD1 [[ user(TEXCOORD1) ]];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    sampler sampler_Height [[ sampler (0) ]],
    texture2d<float, access::sample > _Height [[ texture(0) ]] ,
    float3 mtl_TessCoord [[ position_in_patch ]],
    uint patchID [[ patch_id ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    Mtl_VertexInPostTess input [[ stage_in ]])
{
#pragma clang diagnostic pop
    Mtl_VertexOutPostTess output;
    MTLTriangleTessellationFactorsHalf tessFactor;
    tessFactor = tessFactors[patchID];
    float4 u_xlat0;
    float4 u_xlat1;
    float4 u_xlat2;
    float4 u_xlat3;
    float4 u_xlat4;
    float u_xlat11;
    float u_xlat15;
    bool u_xlatb15;
    u_xlat0.xyz = mtl_TessCoord.yyy * input.cp[1].NORMAL0.xyz;
    u_xlat0.xyz = fma(input.cp[0].NORMAL0.xyz, mtl_TessCoord.xxx, u_xlat0.xyz);
    u_xlat0.xyz = fma(input.cp[2].NORMAL0.xyz, mtl_TessCoord.zzz, u_xlat0.xyz);
    u_xlat1.x = dot(u_xlat0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat1.y = dot(u_xlat0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat1.z = dot(u_xlat0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat15 = dot(u_xlat1.xyz, u_xlat1.xyz);
    u_xlat15 = rsqrt(u_xlat15);
    u_xlat1.xyz = float3(u_xlat15) * u_xlat1.xyz;
    u_xlat2.xy = mtl_TessCoord.yy * input.cp[1].TEXCOORD0.xy;
    u_xlat2.xy = fma(input.cp[0].TEXCOORD0.xy, mtl_TessCoord.xx, u_xlat2.xy);
    u_xlat2.xy = fma(input.cp[2].TEXCOORD0.xy, mtl_TessCoord.zz, u_xlat2.xy);
    u_xlat2.xy = u_xlat2.xy * float2(VGlobals._Tile);
    u_xlat2.xyz = _Height.sample(sampler_Height, u_xlat2.xy, level(1.0)).xyz;
    u_xlat0.xyz = u_xlat0.xyz * u_xlat2.xyz;
    u_xlat2 = mtl_TessCoord.yyyy * input.cp[1].INTERNALTESSPOS0;
    u_xlat2 = fma(input.cp[0].INTERNALTESSPOS0, mtl_TessCoord.xxxx, u_xlat2);
    u_xlat2 = fma(input.cp[2].INTERNALTESSPOS0, mtl_TessCoord.zzzz, u_xlat2);
    u_xlat0.xyz = fma(u_xlat0.xyz, float3(VGlobals._HeightDisplacement), u_xlat2.xyz);
    u_xlat3 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], u_xlat0.xxxx, u_xlat3);
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], u_xlat0.zzzz, u_xlat3);
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3], u_xlat2.wwww, u_xlat3);
    u_xlat2.xyz = fma((-u_xlat3.xyz), VGlobals._WorldSpaceLightPos0.www, VGlobals._WorldSpaceLightPos0.xyz);
    u_xlat15 = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat15 = rsqrt(u_xlat15);
    u_xlat2.xyz = float3(u_xlat15) * u_xlat2.xyz;
    u_xlat15 = dot(u_xlat1.xyz, u_xlat2.xyz);
    u_xlat15 = fma((-u_xlat15), u_xlat15, 1.0);
    u_xlat15 = sqrt(u_xlat15);
    u_xlat15 = u_xlat15 * VGlobals.unity_LightShadowBias.z;
    u_xlat1.xyz = fma((-u_xlat1.xyz), float3(u_xlat15), u_xlat3.xyz);
    u_xlatb15 = VGlobals.unity_LightShadowBias.z!=0.0;
    u_xlat1.xyz = (bool(u_xlatb15)) ? u_xlat1.xyz : u_xlat3.xyz;
    u_xlat4 = u_xlat1.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat4 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat1.xxxx, u_xlat4);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat1.zzzz, u_xlat4);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat3.wwww, u_xlat1);
    u_xlat15 = VGlobals.unity_LightShadowBias.x / u_xlat1.w;
    u_xlat15 = min(u_xlat15, 0.0);
    u_xlat15 = max(u_xlat15, -1.0);
    u_xlat15 = u_xlat15 + u_xlat1.z;
    u_xlat11 = min(u_xlat1.w, u_xlat15);
    output.mtl_Position.xyw = u_xlat1.xyw;
    u_xlat1.x = (-u_xlat15) + u_xlat11;
    output.mtl_Position.z = fma(VGlobals.unity_LightShadowBias.y, u_xlat1.x, u_xlat15);
    u_xlat1.xyz = u_xlat0.yyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz;
    u_xlat0.xyw = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, u_xlat0.xxx, u_xlat1.xyz);
    u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, u_xlat0.zzz, u_xlat0.xyw);
    output.TEXCOORD1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, u_xlat2.www, u_xlat0.xyz);
    return output;
}
// SHADER_STAGE_DOMAIN_end
Compilation succeeded with: 

program_source:299:53: warning: writable resources in non-void post-tessellation vertex function
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
                                                    ^
program_source:305:30: note: writable buffer defined here
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
                             ^
program_source:306:48: note: writable buffer defined here
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
                                               ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float4 TEXCOORD0 [[ attribute(3) ]] ;
    float4 TEXCOORD1 [[ attribute(4) ]] ;
    float4 TEXCOORD2 [[ attribute(5) ]] ;
    float4 TEXCOORD3 [[ attribute(6) ]] ;
    float4 COLOR0 [[ attribute(7) ]] ;
};
struct Mtl_VertexOut
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float4 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float4 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float4 TEXCOORD3 [[ user(TEXCOORD3) ]];
    float4 COLOR0 [[ user(COLOR0) ]];
};
static Mtl_VertexOut vertexFunction(
    Mtl_VertexIn input)
{
    Mtl_VertexOut output;
    output.INTERNALTESSPOS0 = input.POSITION0;
    output.TANGENT0 = input.TANGENT0;
    output.NORMAL0.xyz = input.NORMAL0.xyz;
    output.TEXCOORD0 = input.TEXCOORD0;
    output.TEXCOORD1 = input.TEXCOORD1;
    output.TEXCOORD2 = input.TEXCOORD2;
    output.TEXCOORD3 = input.TEXCOORD3;
    output.COLOR0 = input.COLOR0;
    return output;
}
// SHADER_STAGE_HULL_begin
struct Mtl_ControlPoint
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float4 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float4 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float4 TEXCOORD3 [[ user(TEXCOORD3) ]];
    float4 COLOR0 [[ user(COLOR0) ]];
};
struct Mtl_ControlPointIn
{
    float4 INTERNALTESSPOS0 [[ attribute(8) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float4 TEXCOORD0 [[ attribute(3) ]] ;
    float4 TEXCOORD1 [[ attribute(4) ]] ;
    float4 TEXCOORD2 [[ attribute(5) ]] ;
    float4 TEXCOORD3 [[ attribute(6) ]] ;
    float4 COLOR0 [[ attribute(7) ]] ;
};
struct Mtl_KernelPatchInfo
{
    uint numPatches;
    ushort numControlPointsPerPatch;
};
struct VGlobals_Type
{
    float4 _Time;
    float4 _SinTime;
    float4 _CosTime;
    float4 unity_DeltaTime;
    float3 _WorldSpaceCameraPos;
    float4 _ProjectionParams;
    float4 _ScreenParams;
    float4 _ZBufferParams;
    float4 unity_OrthoParams;
    float4 unity_CameraWorldClipPlanes[6];
    float4 hlslcc_mtx4x4unity_CameraProjection[4];
    float4 hlslcc_mtx4x4unity_CameraInvProjection[4];
    float4 hlslcc_mtx4x4unity_WorldToCamera[4];
    float4 hlslcc_mtx4x4unity_CameraToWorld[4];
    float4 _WorldSpaceLightPos0;
    float4 _LightPositionRange;
    float4 _LightProjectionParams;
    float4 unity_4LightPosX0;
    float4 unity_4LightPosY0;
    float4 unity_4LightPosZ0;
    float4 unity_4LightAtten0;
    float4 unity_LightColor[8];
    float4 unity_LightPosition[8];
    float4 unity_LightAtten[8];
    float4 unity_SpotDirection[8];
    float4 unity_SHAr;
    float4 unity_SHAg;
    float4 unity_SHAb;
    float4 unity_SHBr;
    float4 unity_SHBg;
    float4 unity_SHBb;
    float4 unity_SHC;
    float4 unity_OcclusionMaskSelector;
    float4 unity_ProbesOcclusion;
    float3 unity_LightColor0;
    float3 unity_LightColor1;
    float3 unity_LightColor2;
    float3 unity_LightColor3;
    float4 unity_ShadowSplitSpheres[4];
    float4 unity_ShadowSplitSqRadii;
    float4 unity_LightShadowBias;
    float4 _LightSplitsNear;
    float4 _LightSplitsFar;
    float4 hlslcc_mtx4x4unity_WorldToShadow[16];
    float4 _LightShadowData;
    float4 unity_ShadowFadeCenterAndType;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 unity_LODFade;
    float4 unity_WorldTransformParams;
    float4 unity_RenderingLayer;
    float4 hlslcc_mtx4x4glstate_matrix_transpose_modelview0[4];
    float4 glstate_lightmodel_ambient;
    float4 unity_AmbientSky;
    float4 unity_AmbientEquator;
    float4 unity_AmbientGround;
    float4 unity_IndirectSpecColor;
    float4 hlslcc_mtx4x4glstate_matrix_projection[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixInvV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    int unity_StereoEyeIndex;
    float4 unity_ShadowColor;
    float4 unity_FogColor;
    float4 unity_FogParams;
    float4 unity_LightmapST;
    float4 unity_DynamicLightmapST;
    float4 unity_SpecCube0_BoxMax;
    float4 unity_SpecCube0_BoxMin;
    float4 unity_SpecCube0_ProbePosition;
    float4 unity_SpecCube0_HDR;
    float4 unity_SpecCube1_BoxMax;
    float4 unity_SpecCube1_BoxMin;
    float4 unity_SpecCube1_ProbePosition;
    float4 unity_SpecCube1_HDR;
    float4 unity_ProbeVolumeParams;
    float4 hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[4];
    float3 unity_ProbeVolumeSizeInv;
    float3 unity_ProbeVolumeMin;
    float4 unity_Lightmap_HDR;
    float4 unity_DynamicLightmap_HDR;
    float4 _LightColor0;
    float4 _SpecColor;
    float _Tile;
    float _HeightDisplacement;
    float _NormalScale;
    float4 _ColorTint;
    float _MetallicStrength;
    float _SmoothnessStrength;
    float _EdgeLength;
    float4 _texcoord_ST;
    float4 unity_Ambient;
};
struct Mtl_HullIn
{
    Mtl_VertexOut cp[3];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
kernel void patchKernel(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn vertexInput [[ stage_in ]],
    uint2 tID [[ thread_position_in_grid ]],
    ushort2 groupID [[ threadgroup_position_in_grid ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    constant Mtl_KernelPatchInfo &patchInfo [[ buffer(3) ]])
{
#pragma clang diagnostic pop
    Mtl_ControlPoint output;
    const uint numPatchesInThreadGroup = 10;
    const uint patchID = (tID.x / patchInfo.numControlPointsPerPatch);
    const bool patchValid = (patchID < patchInfo.numPatches);
    const uint mtl_BaseInstance = 0;
    const uint mtl_InstanceID = groupID.y - mtl_BaseInstance;
    const uint internalPatchID = mtl_InstanceID * patchInfo.numPatches + patchID;
    const uint patchIDInThreadGroup = (patchID % numPatchesInThreadGroup);
    const uint controlPointID = (tID.x % patchInfo.numControlPointsPerPatch);
    const uint mtl_BaseVertex = 0;
    const uint mtl_VertexID = ((mtl_InstanceID * (patchInfo.numControlPointsPerPatch * patchInfo.numPatches)) + tID.x) - mtl_BaseVertex;
    threadgroup Mtl_HullIn inputGroup[numPatchesInThreadGroup];
    threadgroup Mtl_HullIn &input = inputGroup[patchIDInThreadGroup];
    MTLTriangleTessellationFactorsHalf tessFactor;
    if (patchValid) {
        input.cp[controlPointID] = vertexFunction(vertexInput);
        output.INTERNALTESSPOS0 = input.cp[controlPointID].INTERNALTESSPOS0;
        output.TANGENT0 = input.cp[controlPointID].TANGENT0;
        output.NORMAL0 = input.cp[controlPointID].NORMAL0;
        output.TEXCOORD0 = input.cp[controlPointID].TEXCOORD0;
        output.TEXCOORD1 = input.cp[controlPointID].TEXCOORD1;
        output.TEXCOORD2 = input.cp[controlPointID].TEXCOORD2;
        output.TEXCOORD3 = input.cp[controlPointID].TEXCOORD3;
        output.COLOR0 = input.cp[controlPointID].COLOR0;
    }
    threadgroup_barrier(mem_flags::mem_threadgroup);
    if (!patchValid) {
        return;
    }
    float3 u_xlat0;
    float3 u_xlat1;
    float3 u_xlat2;
    float3 u_xlat3;
    float3 u_xlat4;
    float u_xlat12;
    float u_xlat13;
    // fork_phase2
    {
        u_xlat0.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[1].INTERNALTESSPOS0.yyy;
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[1].INTERNALTESSPOS0.xxx, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[1].INTERNALTESSPOS0.zzz, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[1].INTERNALTESSPOS0.www, u_xlat0.xyz);
        u_xlat1.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[2].INTERNALTESSPOS0.yyy;
        u_xlat1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[2].INTERNALTESSPOS0.xxx, u_xlat1.xyz);
        u_xlat1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[2].INTERNALTESSPOS0.zzz, u_xlat1.xyz);
        u_xlat1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[2].INTERNALTESSPOS0.www, u_xlat1.xyz);
        u_xlat2.xyz = u_xlat0.xyz + u_xlat1.xyz;
        u_xlat2.xyz = fma(u_xlat2.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat12 = dot(u_xlat2.xyz, u_xlat2.xyz);
        u_xlat12 = sqrt(u_xlat12);
        u_xlat12 = u_xlat12 * VGlobals._EdgeLength;
        u_xlat2.xyz = u_xlat0.xyz + (-u_xlat1.xyz);
        u_xlat13 = dot(u_xlat2.xyz, u_xlat2.xyz);
        u_xlat13 = sqrt(u_xlat13);
        u_xlat13 = u_xlat13 * VGlobals._ScreenParams.y;
        u_xlat12 = u_xlat13 / u_xlat12;
        tessFactor.edgeTessellationFactor[0] = max(u_xlat12, 1.0);
        u_xlat2.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[0].INTERNALTESSPOS0.yyy;
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[0].INTERNALTESSPOS0.xxx, u_xlat2.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[0].INTERNALTESSPOS0.zzz, u_xlat2.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[0].INTERNALTESSPOS0.www, u_xlat2.xyz);
        u_xlat3.xyz = u_xlat1.xyz + u_xlat2.xyz;
        u_xlat1.xyz = u_xlat1.xyz + (-u_xlat2.xyz);
        u_xlat12 = dot(u_xlat1.xyz, u_xlat1.xyz);
        u_xlat12 = sqrt(u_xlat12);
        u_xlat12 = u_xlat12 * VGlobals._ScreenParams.y;
        u_xlat1.xyz = fma(u_xlat3.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat1.x = dot(u_xlat1.xyz, u_xlat1.xyz);
        u_xlat1.x = sqrt(u_xlat1.x);
        u_xlat1.x = u_xlat1.x * VGlobals._EdgeLength;
        u_xlat12 = u_xlat12 / u_xlat1.x;
        tessFactor.edgeTessellationFactor[1] = max(u_xlat12, 1.0);
        u_xlat1.xyz = u_xlat0.xyz + u_xlat2.xyz;
        u_xlat0.xyz = (-u_xlat0.xyz) + u_xlat2.xyz;
        u_xlat0.x = dot(u_xlat0.xyz, u_xlat0.xyz);
        u_xlat0.x = sqrt(u_xlat0.x);
        u_xlat0.x = u_xlat0.x * VGlobals._ScreenParams.y;
        u_xlat4.xyz = fma(u_xlat1.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat4.x = dot(u_xlat4.xyz, u_xlat4.xyz);
        u_xlat4.x = sqrt(u_xlat4.x);
        u_xlat4.x = u_xlat4.x * VGlobals._EdgeLength;
        u_xlat0.x = u_xlat0.x / u_xlat4.x;
        tessFactor.edgeTessellationFactor[2] = max(u_xlat0.x, 1.0);
    }
    // join_phase3
    {
        u_xlat0.x = tessFactor.edgeTessellationFactor[0] + tessFactor.edgeTessellationFactor[1];
        u_xlat0.x = u_xlat0.x + tessFactor.edgeTessellationFactor[2];
        tessFactor.insideTessellationFactor = u_xlat0.x * 0.333333343;
    }
    controlPoints[mtl_VertexID] = output;
    tessFactors[internalPatchID] = tessFactor;
}
// SHADER_STAGE_HULL_end
// SHADER_STAGE_DOMAIN_begin
struct Mtl_VertexInPostTess
{
    patch_control_point<Mtl_ControlPointIn> cp;
};
struct Mtl_VertexOutPostTess
{
    float4 mtl_Position [[ position ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float4 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float4 TEXCOORD3 [[ user(TEXCOORD3) ]];
    float4 TEXCOORD5 [[ user(TEXCOORD5) ]];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    sampler sampler_Height [[ sampler (0) ]],
    texture2d<float, access::sample > _Height [[ texture(0) ]] ,
    float3 mtl_TessCoord [[ position_in_patch ]],
    uint patchID [[ patch_id ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    Mtl_VertexInPostTess input [[ stage_in ]])
{
#pragma clang diagnostic pop
    Mtl_VertexOutPostTess output;
    MTLTriangleTessellationFactorsHalf tessFactor;
    tessFactor = tessFactors[patchID];
    float4 u_xlat0;
    float4 u_xlat1;
    float4 u_xlat2;
    float4 u_xlat3;
    float2 u_xlat9;
    float u_xlat12;
    float u_xlat13;
    u_xlat0 = mtl_TessCoord.yyyy * input.cp[1].INTERNALTESSPOS0;
    u_xlat0 = fma(input.cp[0].INTERNALTESSPOS0, mtl_TessCoord.xxxx, u_xlat0);
    u_xlat0 = fma(input.cp[2].INTERNALTESSPOS0, mtl_TessCoord.zzzz, u_xlat0);
    u_xlat1.xy = mtl_TessCoord.yy * input.cp[1].TEXCOORD0.xy;
    u_xlat1.xy = fma(input.cp[0].TEXCOORD0.xy, mtl_TessCoord.xx, u_xlat1.xy);
    u_xlat1.xy = fma(input.cp[2].TEXCOORD0.xy, mtl_TessCoord.zz, u_xlat1.xy);
    u_xlat9.xy = u_xlat1.xy * float2(VGlobals._Tile);
    output.TEXCOORD0.xy = fma(u_xlat1.xy, VGlobals._texcoord_ST.xy, VGlobals._texcoord_ST.zw);
    u_xlat1.xyz = _Height.sample(sampler_Height, u_xlat9.xy, level(1.0)).xyz;
    u_xlat2.xyz = mtl_TessCoord.yyy * input.cp[1].NORMAL0.xyz;
    u_xlat2.xyz = fma(input.cp[0].NORMAL0.xyz, mtl_TessCoord.xxx, u_xlat2.xyz);
    u_xlat2.xyz = fma(input.cp[2].NORMAL0.xyz, mtl_TessCoord.zzz, u_xlat2.xyz);
    u_xlat1.xyz = u_xlat1.xyz * u_xlat2.xyz;
    u_xlat0.xyz = fma(u_xlat1.xyz, float3(VGlobals._HeightDisplacement), u_xlat0.xyz);
    u_xlat1 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], u_xlat0.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], u_xlat0.zzzz, u_xlat1);
    u_xlat3 = u_xlat1 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, u_xlat0.www, u_xlat1.xyz);
    u_xlat1 = u_xlat3.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat3.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat3.zzzz, u_xlat1);
    output.mtl_Position = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat3.wwww, u_xlat1);
    u_xlat1.y = dot(u_xlat2.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat1.z = dot(u_xlat2.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat1.x = dot(u_xlat2.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat12 = dot(u_xlat1.xyz, u_xlat1.xyz);
    u_xlat12 = rsqrt(u_xlat12);
    u_xlat1.xyz = float3(u_xlat12) * u_xlat1.xyz;
    output.TEXCOORD1.z = u_xlat1.y;
    u_xlat2 = mtl_TessCoord.yyyy * input.cp[1].TANGENT0;
    u_xlat2 = fma(input.cp[0].TANGENT0, mtl_TessCoord.xxxx, u_xlat2);
    u_xlat2 = fma(input.cp[2].TANGENT0, mtl_TessCoord.zzzz, u_xlat2);
    u_xlat3.xyz = u_xlat2.yyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].yzx;
    u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].yzx, u_xlat2.xxx, u_xlat3.xyz);
    u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].yzx, u_xlat2.zzz, u_xlat3.xyz);
    u_xlat12 = u_xlat2.w * VGlobals.unity_WorldTransformParams.w;
    u_xlat13 = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat13 = rsqrt(u_xlat13);
    u_xlat2.xyz = float3(u_xlat13) * u_xlat2.xyz;
    u_xlat3.xyz = u_xlat1.xyz * u_xlat2.xyz;
    u_xlat3.xyz = fma(u_xlat1.zxy, u_xlat2.yzx, (-u_xlat3.xyz));
    u_xlat3.xyz = float3(u_xlat12) * u_xlat3.xyz;
    output.TEXCOORD1.y = u_xlat3.x;
    output.TEXCOORD1.w = u_xlat0.x;
    output.TEXCOORD1.x = u_xlat2.z;
    output.TEXCOORD2.w = u_xlat0.y;
    output.TEXCOORD3.w = u_xlat0.z;
    output.TEXCOORD2.x = u_xlat2.x;
    output.TEXCOORD3.x = u_xlat2.y;
    output.TEXCOORD2.z = u_xlat1.z;
    output.TEXCOORD3.z = u_xlat1.x;
    output.TEXCOORD2.y = u_xlat3.y;
    output.TEXCOORD3.y = u_xlat3.z;
    output.TEXCOORD5 = float4(0.0, 0.0, 0.0, 0.0);
    return output;
}
// SHADER_STAGE_DOMAIN_end
Compilation succeeded with: 

program_source:303:53: warning: writable resources in non-void post-tessellation vertex function
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
                                                    ^
program_source:309:30: note: writable buffer defined here
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
                             ^
program_source:310:48: note: writable buffer defined here
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
                                               ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float4 TEXCOORD0 [[ attribute(3) ]] ;
    float4 TEXCOORD1 [[ attribute(4) ]] ;
    float4 TEXCOORD2 [[ attribute(5) ]] ;
    float4 TEXCOORD3 [[ attribute(6) ]] ;
    float4 COLOR0 [[ attribute(7) ]] ;
};
struct Mtl_VertexOut
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float4 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float4 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float4 TEXCOORD3 [[ user(TEXCOORD3) ]];
    float4 COLOR0 [[ user(COLOR0) ]];
};
static Mtl_VertexOut vertexFunction(
    Mtl_VertexIn input)
{
    Mtl_VertexOut output;
    output.INTERNALTESSPOS0 = input.POSITION0;
    output.TANGENT0 = input.TANGENT0;
    output.NORMAL0.xyz = input.NORMAL0.xyz;
    output.TEXCOORD0 = input.TEXCOORD0;
    output.TEXCOORD1 = input.TEXCOORD1;
    output.TEXCOORD2 = input.TEXCOORD2;
    output.TEXCOORD3 = input.TEXCOORD3;
    output.COLOR0 = input.COLOR0;
    return output;
}
// SHADER_STAGE_HULL_begin
struct Mtl_ControlPoint
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float4 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float4 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float4 TEXCOORD3 [[ user(TEXCOORD3) ]];
    float4 COLOR0 [[ user(COLOR0) ]];
};
struct Mtl_ControlPointIn
{
    float4 INTERNALTESSPOS0 [[ attribute(8) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float4 TEXCOORD0 [[ attribute(3) ]] ;
    float4 TEXCOORD1 [[ attribute(4) ]] ;
    float4 TEXCOORD2 [[ attribute(5) ]] ;
    float4 TEXCOORD3 [[ attribute(6) ]] ;
    float4 COLOR0 [[ attribute(7) ]] ;
};
struct Mtl_KernelPatchInfo
{
    uint numPatches;
    ushort numControlPointsPerPatch;
};
struct VGlobals_Type
{
    float4 _Time;
    float4 _SinTime;
    float4 _CosTime;
    float4 unity_DeltaTime;
    float3 _WorldSpaceCameraPos;
    float4 _ProjectionParams;
    float4 _ScreenParams;
    float4 _ZBufferParams;
    float4 unity_OrthoParams;
    float4 unity_CameraWorldClipPlanes[6];
    float4 hlslcc_mtx4x4unity_CameraProjection[4];
    float4 hlslcc_mtx4x4unity_CameraInvProjection[4];
    float4 hlslcc_mtx4x4unity_WorldToCamera[4];
    float4 hlslcc_mtx4x4unity_CameraToWorld[4];
    float4 _WorldSpaceLightPos0;
    float4 _LightPositionRange;
    float4 _LightProjectionParams;
    float4 unity_4LightPosX0;
    float4 unity_4LightPosY0;
    float4 unity_4LightPosZ0;
    float4 unity_4LightAtten0;
    float4 unity_LightColor[8];
    float4 unity_LightPosition[8];
    float4 unity_LightAtten[8];
    float4 unity_SpotDirection[8];
    float4 unity_SHAr;
    float4 unity_SHAg;
    float4 unity_SHAb;
    float4 unity_SHBr;
    float4 unity_SHBg;
    float4 unity_SHBb;
    float4 unity_SHC;
    float4 unity_OcclusionMaskSelector;
    float4 unity_ProbesOcclusion;
    float3 unity_LightColor0;
    float3 unity_LightColor1;
    float3 unity_LightColor2;
    float3 unity_LightColor3;
    float4 unity_ShadowSplitSpheres[4];
    float4 unity_ShadowSplitSqRadii;
    float4 unity_LightShadowBias;
    float4 _LightSplitsNear;
    float4 _LightSplitsFar;
    float4 hlslcc_mtx4x4unity_WorldToShadow[16];
    float4 _LightShadowData;
    float4 unity_ShadowFadeCenterAndType;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 unity_LODFade;
    float4 unity_WorldTransformParams;
    float4 unity_RenderingLayer;
    float4 hlslcc_mtx4x4glstate_matrix_transpose_modelview0[4];
    float4 glstate_lightmodel_ambient;
    float4 unity_AmbientSky;
    float4 unity_AmbientEquator;
    float4 unity_AmbientGround;
    float4 unity_IndirectSpecColor;
    float4 hlslcc_mtx4x4glstate_matrix_projection[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixInvV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    int unity_StereoEyeIndex;
    float4 unity_ShadowColor;
    float4 unity_FogColor;
    float4 unity_FogParams;
    float4 unity_LightmapST;
    float4 unity_DynamicLightmapST;
    float4 unity_SpecCube0_BoxMax;
    float4 unity_SpecCube0_BoxMin;
    float4 unity_SpecCube0_ProbePosition;
    float4 unity_SpecCube0_HDR;
    float4 unity_SpecCube1_BoxMax;
    float4 unity_SpecCube1_BoxMin;
    float4 unity_SpecCube1_ProbePosition;
    float4 unity_SpecCube1_HDR;
    float4 unity_ProbeVolumeParams;
    float4 hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[4];
    float3 unity_ProbeVolumeSizeInv;
    float3 unity_ProbeVolumeMin;
    float4 unity_Lightmap_HDR;
    float4 unity_DynamicLightmap_HDR;
    float4 _LightColor0;
    float4 _SpecColor;
    float _Tile;
    float _HeightDisplacement;
    float _NormalScale;
    float4 _ColorTint;
    float _MetallicStrength;
    float _SmoothnessStrength;
    float _EdgeLength;
    bool4 unity_MetaVertexControl;
    bool4 unity_MetaFragmentControl;
    int unity_VisualizationMode;
    float unity_OneOverOutputBoost;
    float unity_MaxOutputValue;
    float unity_UseLinearSpace;
    float4 _texcoord_ST;
};
struct Mtl_HullIn
{
    Mtl_VertexOut cp[3];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
kernel void patchKernel(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn vertexInput [[ stage_in ]],
    uint2 tID [[ thread_position_in_grid ]],
    ushort2 groupID [[ threadgroup_position_in_grid ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    constant Mtl_KernelPatchInfo &patchInfo [[ buffer(3) ]])
{
#pragma clang diagnostic pop
    Mtl_ControlPoint output;
    const uint numPatchesInThreadGroup = 10;
    const uint patchID = (tID.x / patchInfo.numControlPointsPerPatch);
    const bool patchValid = (patchID < patchInfo.numPatches);
    const uint mtl_BaseInstance = 0;
    const uint mtl_InstanceID = groupID.y - mtl_BaseInstance;
    const uint internalPatchID = mtl_InstanceID * patchInfo.numPatches + patchID;
    const uint patchIDInThreadGroup = (patchID % numPatchesInThreadGroup);
    const uint controlPointID = (tID.x % patchInfo.numControlPointsPerPatch);
    const uint mtl_BaseVertex = 0;
    const uint mtl_VertexID = ((mtl_InstanceID * (patchInfo.numControlPointsPerPatch * patchInfo.numPatches)) + tID.x) - mtl_BaseVertex;
    threadgroup Mtl_HullIn inputGroup[numPatchesInThreadGroup];
    threadgroup Mtl_HullIn &input = inputGroup[patchIDInThreadGroup];
    MTLTriangleTessellationFactorsHalf tessFactor;
    if (patchValid) {
        input.cp[controlPointID] = vertexFunction(vertexInput);
        output.INTERNALTESSPOS0 = input.cp[controlPointID].INTERNALTESSPOS0;
        output.TANGENT0 = input.cp[controlPointID].TANGENT0;
        output.NORMAL0 = input.cp[controlPointID].NORMAL0;
        output.TEXCOORD0 = input.cp[controlPointID].TEXCOORD0;
        output.TEXCOORD1 = input.cp[controlPointID].TEXCOORD1;
        output.TEXCOORD2 = input.cp[controlPointID].TEXCOORD2;
        output.TEXCOORD3 = input.cp[controlPointID].TEXCOORD3;
        output.COLOR0 = input.cp[controlPointID].COLOR0;
    }
    threadgroup_barrier(mem_flags::mem_threadgroup);
    if (!patchValid) {
        return;
    }
    float3 u_xlat0;
    float3 u_xlat1;
    float3 u_xlat2;
    float3 u_xlat3;
    float3 u_xlat4;
    float u_xlat12;
    float u_xlat13;
    // fork_phase2
    {
        u_xlat0.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[1].INTERNALTESSPOS0.yyy;
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[1].INTERNALTESSPOS0.xxx, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[1].INTERNALTESSPOS0.zzz, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[1].INTERNALTESSPOS0.www, u_xlat0.xyz);
        u_xlat1.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[2].INTERNALTESSPOS0.yyy;
        u_xlat1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[2].INTERNALTESSPOS0.xxx, u_xlat1.xyz);
        u_xlat1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[2].INTERNALTESSPOS0.zzz, u_xlat1.xyz);
        u_xlat1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[2].INTERNALTESSPOS0.www, u_xlat1.xyz);
        u_xlat2.xyz = u_xlat0.xyz + u_xlat1.xyz;
        u_xlat2.xyz = fma(u_xlat2.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat12 = dot(u_xlat2.xyz, u_xlat2.xyz);
        u_xlat12 = sqrt(u_xlat12);
        u_xlat12 = u_xlat12 * VGlobals._EdgeLength;
        u_xlat2.xyz = u_xlat0.xyz + (-u_xlat1.xyz);
        u_xlat13 = dot(u_xlat2.xyz, u_xlat2.xyz);
        u_xlat13 = sqrt(u_xlat13);
        u_xlat13 = u_xlat13 * VGlobals._ScreenParams.y;
        u_xlat12 = u_xlat13 / u_xlat12;
        tessFactor.edgeTessellationFactor[0] = max(u_xlat12, 1.0);
        u_xlat2.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[0].INTERNALTESSPOS0.yyy;
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[0].INTERNALTESSPOS0.xxx, u_xlat2.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[0].INTERNALTESSPOS0.zzz, u_xlat2.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[0].INTERNALTESSPOS0.www, u_xlat2.xyz);
        u_xlat3.xyz = u_xlat1.xyz + u_xlat2.xyz;
        u_xlat1.xyz = u_xlat1.xyz + (-u_xlat2.xyz);
        u_xlat12 = dot(u_xlat1.xyz, u_xlat1.xyz);
        u_xlat12 = sqrt(u_xlat12);
        u_xlat12 = u_xlat12 * VGlobals._ScreenParams.y;
        u_xlat1.xyz = fma(u_xlat3.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat1.x = dot(u_xlat1.xyz, u_xlat1.xyz);
        u_xlat1.x = sqrt(u_xlat1.x);
        u_xlat1.x = u_xlat1.x * VGlobals._EdgeLength;
        u_xlat12 = u_xlat12 / u_xlat1.x;
        tessFactor.edgeTessellationFactor[1] = max(u_xlat12, 1.0);
        u_xlat1.xyz = u_xlat0.xyz + u_xlat2.xyz;
        u_xlat0.xyz = (-u_xlat0.xyz) + u_xlat2.xyz;
        u_xlat0.x = dot(u_xlat0.xyz, u_xlat0.xyz);
        u_xlat0.x = sqrt(u_xlat0.x);
        u_xlat0.x = u_xlat0.x * VGlobals._ScreenParams.y;
        u_xlat4.xyz = fma(u_xlat1.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat4.x = dot(u_xlat4.xyz, u_xlat4.xyz);
        u_xlat4.x = sqrt(u_xlat4.x);
        u_xlat4.x = u_xlat4.x * VGlobals._EdgeLength;
        u_xlat0.x = u_xlat0.x / u_xlat4.x;
        tessFactor.edgeTessellationFactor[2] = max(u_xlat0.x, 1.0);
    }
    // join_phase3
    {
        u_xlat0.x = tessFactor.edgeTessellationFactor[0] + tessFactor.edgeTessellationFactor[1];
        u_xlat0.x = u_xlat0.x + tessFactor.edgeTessellationFactor[2];
        tessFactor.insideTessellationFactor = u_xlat0.x * 0.333333343;
    }
    controlPoints[mtl_VertexID] = output;
    tessFactors[internalPatchID] = tessFactor;
}
// SHADER_STAGE_HULL_end
// SHADER_STAGE_DOMAIN_begin
struct Mtl_VertexInPostTess
{
    patch_control_point<Mtl_ControlPointIn> cp;
};
struct Mtl_VertexOutPostTess
{
    float4 mtl_Position [[ position ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float4 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float4 TEXCOORD3 [[ user(TEXCOORD3) ]];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    sampler sampler_Height [[ sampler (0) ]],
    texture2d<float, access::sample > _Height [[ texture(0) ]] ,
    float3 mtl_TessCoord [[ position_in_patch ]],
    uint patchID [[ patch_id ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    Mtl_VertexInPostTess input [[ stage_in ]])
{
#pragma clang diagnostic pop
    Mtl_VertexOutPostTess output;
    MTLTriangleTessellationFactorsHalf tessFactor;
    tessFactor = tessFactors[patchID];
    float4 u_xlat0;
    float4 u_xlat1;
    float4 u_xlat2;
    float3 u_xlat3;
    float3 u_xlat4;
    float2 u_xlat13;
    float u_xlat15;
    bool u_xlatb15;
    u_xlat0.xy = mtl_TessCoord.yy * input.cp[1].TEXCOORD2.xy;
    u_xlat0.xy = fma(input.cp[0].TEXCOORD2.xy, mtl_TessCoord.xx, u_xlat0.xy);
    u_xlat0.xy = fma(input.cp[2].TEXCOORD2.xy, mtl_TessCoord.zz, u_xlat0.xy);
    u_xlat0.xy = fma(u_xlat0.xy, VGlobals.unity_DynamicLightmapST.xy, VGlobals.unity_DynamicLightmapST.zw);
    u_xlat1.xy = mtl_TessCoord.yy * input.cp[1].TEXCOORD1.xy;
    u_xlat1.xy = fma(input.cp[0].TEXCOORD1.xy, mtl_TessCoord.xx, u_xlat1.xy);
    u_xlat1.xy = fma(input.cp[2].TEXCOORD1.xy, mtl_TessCoord.zz, u_xlat1.xy);
    u_xlat1.xy = fma(u_xlat1.xy, VGlobals.unity_LightmapST.xy, VGlobals.unity_LightmapST.zw);
    u_xlat2 = mtl_TessCoord.yyyy * input.cp[1].INTERNALTESSPOS0;
    u_xlat2 = fma(input.cp[0].INTERNALTESSPOS0, mtl_TessCoord.xxxx, u_xlat2);
    u_xlat2 = fma(input.cp[2].INTERNALTESSPOS0, mtl_TessCoord.zzzz, u_xlat2);
    u_xlat3.xy = mtl_TessCoord.yy * input.cp[1].TEXCOORD0.xy;
    u_xlat3.xy = fma(input.cp[0].TEXCOORD0.xy, mtl_TessCoord.xx, u_xlat3.xy);
    u_xlat3.xy = fma(input.cp[2].TEXCOORD0.xy, mtl_TessCoord.zz, u_xlat3.xy);
    u_xlat13.xy = u_xlat3.xy * float2(VGlobals._Tile);
    output.TEXCOORD0.xy = fma(u_xlat3.xy, VGlobals._texcoord_ST.xy, VGlobals._texcoord_ST.zw);
    u_xlat3.xyz = _Height.sample(sampler_Height, u_xlat13.xy, level(1.0)).xyz;
    u_xlat4.xyz = mtl_TessCoord.yyy * input.cp[1].NORMAL0.xyz;
    u_xlat4.xyz = fma(input.cp[0].NORMAL0.xyz, mtl_TessCoord.xxx, u_xlat4.xyz);
    u_xlat4.xyz = fma(input.cp[2].NORMAL0.xyz, mtl_TessCoord.zzz, u_xlat4.xyz);
    u_xlat3.xyz = u_xlat3.xyz * u_xlat4.xyz;
    u_xlat2.xyz = fma(u_xlat3.xyz, float3(VGlobals._HeightDisplacement), u_xlat2.xyz);
    u_xlatb15 = 0.0<u_xlat2.z;
    u_xlat1.z = u_xlatb15 ? 9.99999975e-05 : float(0.0);
    u_xlat1.xyz = (VGlobals.unity_MetaVertexControl.x) ? u_xlat1.xyz : u_xlat2.xyz;
    u_xlatb15 = 0.0<u_xlat1.z;
    u_xlat0.z = u_xlatb15 ? 9.99999975e-05 : float(0.0);
    u_xlat0.xyz = (VGlobals.unity_MetaVertexControl.y) ? u_xlat0.xyz : u_xlat1.xyz;
    u_xlat1 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat0.xxxx, u_xlat1);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat0.zzzz, u_xlat1);
    output.mtl_Position = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_MatrixVP[3];
    u_xlat0.xyz = u_xlat2.yyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz;
    u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, u_xlat2.xxx, u_xlat0.xyz);
    u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, u_xlat2.zzz, u_xlat0.xyz);
    u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, u_xlat2.www, u_xlat0.xyz);
    output.TEXCOORD1.w = u_xlat0.x;
    u_xlat1.y = dot(u_xlat4.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat1.z = dot(u_xlat4.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat1.x = dot(u_xlat4.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat0.x = dot(u_xlat1.xyz, u_xlat1.xyz);
    u_xlat0.x = rsqrt(u_xlat0.x);
    u_xlat1.xyz = u_xlat0.xxx * u_xlat1.xyz;
    output.TEXCOORD1.z = u_xlat1.y;
    u_xlat2 = mtl_TessCoord.yyyy * input.cp[1].TANGENT0;
    u_xlat2 = fma(input.cp[0].TANGENT0, mtl_TessCoord.xxxx, u_xlat2);
    u_xlat2 = fma(input.cp[2].TANGENT0, mtl_TessCoord.zzzz, u_xlat2);
    u_xlat3.xyz = u_xlat2.yyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].yzx;
    u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].yzx, u_xlat2.xxx, u_xlat3.xyz);
    u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].yzx, u_xlat2.zzz, u_xlat3.xyz);
    u_xlat0.x = u_xlat2.w * VGlobals.unity_WorldTransformParams.w;
    u_xlat15 = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat15 = rsqrt(u_xlat15);
    u_xlat2.xyz = float3(u_xlat15) * u_xlat2.xyz;
    u_xlat3.xyz = u_xlat1.xyz * u_xlat2.xyz;
    u_xlat3.xyz = fma(u_xlat1.zxy, u_xlat2.yzx, (-u_xlat3.xyz));
    u_xlat3.xyz = u_xlat0.xxx * u_xlat3.xyz;
    output.TEXCOORD1.y = u_xlat3.x;
    output.TEXCOORD1.x = u_xlat2.z;
    output.TEXCOORD2.w = u_xlat0.y;
    output.TEXCOORD3.w = u_xlat0.z;
    output.TEXCOORD2.x = u_xlat2.x;
    output.TEXCOORD3.x = u_xlat2.y;
    output.TEXCOORD2.z = u_xlat1.z;
    output.TEXCOORD3.z = u_xlat1.x;
    output.TEXCOORD2.y = u_xlat3.y;
    output.TEXCOORD3.y = u_xlat3.z;
    return output;
}
// SHADER_STAGE_DOMAIN_end
Refreshing native plugins compatible for Editor in 2.03 ms, found 2 plugins.
Preloading 0 native plugins for Editor in 0.00 ms.
Unloading 3375 Unused Serialized files (Serialized files now loaded: 0)
Unloading 20 unused Assets / (0.6 MB). Loaded Objects now: 3883.
Memory consumption went from 136.4 MB to 135.8 MB.
Total: 4.923758 ms (FindLiveObjects: 0.399526 ms CreateObjectMapping: 0.166835 ms MarkObjects: 3.907686 ms  DeleteObjects: 0.448465 ms)

AssetImportParameters requested are different than current active one (requested -> active):
  custom:video-decoder-ogg-theora: a1e56fd34408186e4bbccfd4996cb3dc -> 
  custom:container-muxer-webm: aa71ff27fc2769a1b78a27578f13a17b -> 
  custom:container-demuxer-webm: 4f35f7cbe854078d1ac9338744f61a02 -> 
  custom:video-encoder-webm-vp8: eb34c28f22e8b96e1ab97ce403110664 -> 
  custom:framework-osx-AVFoundation: b23960f63f64bdc6ff669e2cdcee2391 -> 
  custom:audio-encoder-webm-vorbis: bf7c407c2cedff20999df2af8eb42d56 -> 
  custom:container-demuxer-ogg: 62fdf1f143b41e24485cea50d1cbac27 -> 
  custom:video-decoder-webm-vp8: 9c59270c3fd7afecdb556c50c9e8de78 -> 
  custom:audio-decoder-ogg-vorbis: bf7c407c2cedff20999df2af8eb42d56 -> 
========================================================================
Received Prepare
Registering precompiled user dll's ...
Registered in 0.003270 seconds.
Begin MonoManager ReloadAssembly
Symbol file LoadedFromMemory doesn't match image /Users/kamilaamendolagine/Desktop/Staugen Raug v2 - Prefab - Map 1.01/Library/PackageCache/com.unity.visualscripting@1.7.8/Editor/VisualScripting.Core/Dependencies/YamlDotNet/Unity.VisualScripting.YamlDotNet.dll
Symbol file LoadedFromMemory doesn't match image /Users/kamilaamendolagine/Desktop/Staugen Raug v2 - Prefab - Map 1.01/Library/PackageCache/com.unity.visualscripting@1.7.8/Editor/VisualScripting.Core/Dependencies/DotNetZip/Unity.VisualScripting.IonicZip.dll
Native extension for OSXStandalone target not found
Native extension for WebGL target not found
Refreshing native plugins compatible for Editor in 0.82 ms, found 2 plugins.
Preloading 0 native plugins for Editor in 0.00 ms.
Mono: successfully reloaded assembly
- Completed reload, in  1.769 seconds
Domain Reload Profiling:
	ReloadAssembly (1770ms)
		BeginReloadAssembly (205ms)
			ExecutionOrderSort (0ms)
			DisableScriptedObjects (10ms)
			BackupInstance (0ms)
			ReleaseScriptingObjects (0ms)
			CreateAndSetChildDomain (89ms)
		EndReloadAssembly (1387ms)
			LoadAssemblies (93ms)
			RebuildTransferFunctionScriptingTraits (0ms)
			SetupTypeCache (487ms)
			ReleaseScriptCaches (2ms)
			RebuildScriptCaches (76ms)
			SetupLoadedEditorAssemblies (636ms)
				LogAssemblyErrors (0ms)
				InitializePlatformSupportModulesInManaged (17ms)
				SetLoadedEditorAssemblies (1ms)
				RefreshPlugins (1ms)
				BeforeProcessingInitializeOnLoad (96ms)
				ProcessInitializeOnLoadAttributes (470ms)
				ProcessInitializeOnLoadMethodAttributes (47ms)
				AfterProcessingInitializeOnLoad (4ms)
				EditorAssembliesLoaded (0ms)
			ExecutionOrderSort2 (0ms)
			AwakeInstancesAfterBackupRestoration (7ms)
Platform modules already initialized, skipping
Compilation succeeded with: 

program_source:299:53: warning: writable resources in non-void post-tessellation vertex function
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
                                                    ^
program_source:305:30: note: writable buffer defined here
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
                             ^
program_source:306:48: note: writable buffer defined here
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
                                               ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float4 TEXCOORD0 [[ attribute(3) ]] ;
    float4 TEXCOORD1 [[ attribute(4) ]] ;
    float4 TEXCOORD2 [[ attribute(5) ]] ;
    float4 TEXCOORD3 [[ attribute(6) ]] ;
    float4 COLOR0 [[ attribute(7) ]] ;
};
struct Mtl_VertexOut
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float4 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float4 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float4 TEXCOORD3 [[ user(TEXCOORD3) ]];
    float4 COLOR0 [[ user(COLOR0) ]];
};
static Mtl_VertexOut vertexFunction(
    Mtl_VertexIn input)
{
    Mtl_VertexOut output;
    output.INTERNALTESSPOS0 = input.POSITION0;
    output.TANGENT0 = input.TANGENT0;
    output.NORMAL0.xyz = input.NORMAL0.xyz;
    output.TEXCOORD0 = input.TEXCOORD0;
    output.TEXCOORD1 = input.TEXCOORD1;
    output.TEXCOORD2 = input.TEXCOORD2;
    output.TEXCOORD3 = input.TEXCOORD3;
    output.COLOR0 = input.COLOR0;
    return output;
}
// SHADER_STAGE_HULL_begin
struct Mtl_ControlPoint
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float4 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float4 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float4 TEXCOORD3 [[ user(TEXCOORD3) ]];
    float4 COLOR0 [[ user(COLOR0) ]];
};
struct Mtl_ControlPointIn
{
    float4 INTERNALTESSPOS0 [[ attribute(8) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float4 TEXCOORD0 [[ attribute(3) ]] ;
    float4 TEXCOORD1 [[ attribute(4) ]] ;
    float4 TEXCOORD2 [[ attribute(5) ]] ;
    float4 TEXCOORD3 [[ attribute(6) ]] ;
    float4 COLOR0 [[ attribute(7) ]] ;
};
struct Mtl_KernelPatchInfo
{
    uint numPatches;
    ushort numControlPointsPerPatch;
};
struct VGlobals_Type
{
    float4 _Time;
    float4 _SinTime;
    float4 _CosTime;
    float4 unity_DeltaTime;
    float3 _WorldSpaceCameraPos;
    float4 _ProjectionParams;
    float4 _ScreenParams;
    float4 _ZBufferParams;
    float4 unity_OrthoParams;
    float4 unity_CameraWorldClipPlanes[6];
    float4 hlslcc_mtx4x4unity_CameraProjection[4];
    float4 hlslcc_mtx4x4unity_CameraInvProjection[4];
    float4 hlslcc_mtx4x4unity_WorldToCamera[4];
    float4 hlslcc_mtx4x4unity_CameraToWorld[4];
    float4 _WorldSpaceLightPos0;
    float4 _LightPositionRange;
    float4 _LightProjectionParams;
    float4 unity_4LightPosX0;
    float4 unity_4LightPosY0;
    float4 unity_4LightPosZ0;
    float4 unity_4LightAtten0;
    float4 unity_LightColor[8];
    float4 unity_LightPosition[8];
    float4 unity_LightAtten[8];
    float4 unity_SpotDirection[8];
    float4 unity_SHAr;
    float4 unity_SHAg;
    float4 unity_SHAb;
    float4 unity_SHBr;
    float4 unity_SHBg;
    float4 unity_SHBb;
    float4 unity_SHC;
    float4 unity_OcclusionMaskSelector;
    float4 unity_ProbesOcclusion;
    float3 unity_LightColor0;
    float3 unity_LightColor1;
    float3 unity_LightColor2;
    float3 unity_LightColor3;
    float4 unity_ShadowSplitSpheres[4];
    float4 unity_ShadowSplitSqRadii;
    float4 unity_LightShadowBias;
    float4 _LightSplitsNear;
    float4 _LightSplitsFar;
    float4 hlslcc_mtx4x4unity_WorldToShadow[16];
    float4 _LightShadowData;
    float4 unity_ShadowFadeCenterAndType;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 unity_LODFade;
    float4 unity_WorldTransformParams;
    float4 unity_RenderingLayer;
    float4 hlslcc_mtx4x4glstate_matrix_transpose_modelview0[4];
    float4 glstate_lightmodel_ambient;
    float4 unity_AmbientSky;
    float4 unity_AmbientEquator;
    float4 unity_AmbientGround;
    float4 unity_IndirectSpecColor;
    float4 hlslcc_mtx4x4glstate_matrix_projection[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixInvV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    int unity_StereoEyeIndex;
    float4 unity_ShadowColor;
    float4 unity_FogColor;
    float4 unity_FogParams;
    float4 unity_LightmapST;
    float4 unity_DynamicLightmapST;
    float4 unity_SpecCube0_BoxMax;
    float4 unity_SpecCube0_BoxMin;
    float4 unity_SpecCube0_ProbePosition;
    float4 unity_SpecCube0_HDR;
    float4 unity_SpecCube1_BoxMax;
    float4 unity_SpecCube1_BoxMin;
    float4 unity_SpecCube1_ProbePosition;
    float4 unity_SpecCube1_HDR;
    float4 unity_ProbeVolumeParams;
    float4 hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[4];
    float3 unity_ProbeVolumeSizeInv;
    float3 unity_ProbeVolumeMin;
    float4 unity_Lightmap_HDR;
    float4 unity_DynamicLightmap_HDR;
    float4 _LightColor0;
    float4 _SpecColor;
    float _Tile;
    float _HeightDisplacement;
    float _NormalScale;
    float4 _ColorTint;
    float _MetallicStrength;
    float _SmoothnessStrength;
    float _EdgeLength;
    float4 _texcoord_ST;
};
struct Mtl_HullIn
{
    Mtl_VertexOut cp[3];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
kernel void patchKernel(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn vertexInput [[ stage_in ]],
    uint2 tID [[ thread_position_in_grid ]],
    ushort2 groupID [[ threadgroup_position_in_grid ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    constant Mtl_KernelPatchInfo &patchInfo [[ buffer(3) ]])
{
#pragma clang diagnostic pop
    Mtl_ControlPoint output;
    const uint numPatchesInThreadGroup = 10;
    const uint patchID = (tID.x / patchInfo.numControlPointsPerPatch);
    const bool patchValid = (patchID < patchInfo.numPatches);
    const uint mtl_BaseInstance = 0;
    const uint mtl_InstanceID = groupID.y - mtl_BaseInstance;
    const uint internalPatchID = mtl_InstanceID * patchInfo.numPatches + patchID;
    const uint patchIDInThreadGroup = (patchID % numPatchesInThreadGroup);
    const uint controlPointID = (tID.x % patchInfo.numControlPointsPerPatch);
    const uint mtl_BaseVertex = 0;
    const uint mtl_VertexID = ((mtl_InstanceID * (patchInfo.numControlPointsPerPatch * patchInfo.numPatches)) + tID.x) - mtl_BaseVertex;
    threadgroup Mtl_HullIn inputGroup[numPatchesInThreadGroup];
    threadgroup Mtl_HullIn &input = inputGroup[patchIDInThreadGroup];
    MTLTriangleTessellationFactorsHalf tessFactor;
    if (patchValid) {
        input.cp[controlPointID] = vertexFunction(vertexInput);
        output.INTERNALTESSPOS0 = input.cp[controlPointID].INTERNALTESSPOS0;
        output.TANGENT0 = input.cp[controlPointID].TANGENT0;
        output.NORMAL0 = input.cp[controlPointID].NORMAL0;
        output.TEXCOORD0 = input.cp[controlPointID].TEXCOORD0;
        output.TEXCOORD1 = input.cp[controlPointID].TEXCOORD1;
        output.TEXCOORD2 = input.cp[controlPointID].TEXCOORD2;
        output.TEXCOORD3 = input.cp[controlPointID].TEXCOORD3;
        output.COLOR0 = input.cp[controlPointID].COLOR0;
    }
    threadgroup_barrier(mem_flags::mem_threadgroup);
    if (!patchValid) {
        return;
    }
    float3 u_xlat0;
    float3 u_xlat1;
    float3 u_xlat2;
    float3 u_xlat3;
    float3 u_xlat4;
    float u_xlat12;
    float u_xlat13;
    // fork_phase2
    {
        u_xlat0.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[1].INTERNALTESSPOS0.yyy;
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[1].INTERNALTESSPOS0.xxx, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[1].INTERNALTESSPOS0.zzz, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[1].INTERNALTESSPOS0.www, u_xlat0.xyz);
        u_xlat1.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[2].INTERNALTESSPOS0.yyy;
        u_xlat1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[2].INTERNALTESSPOS0.xxx, u_xlat1.xyz);
        u_xlat1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[2].INTERNALTESSPOS0.zzz, u_xlat1.xyz);
        u_xlat1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[2].INTERNALTESSPOS0.www, u_xlat1.xyz);
        u_xlat2.xyz = u_xlat0.xyz + u_xlat1.xyz;
        u_xlat2.xyz = fma(u_xlat2.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat12 = dot(u_xlat2.xyz, u_xlat2.xyz);
        u_xlat12 = sqrt(u_xlat12);
        u_xlat12 = u_xlat12 * VGlobals._EdgeLength;
        u_xlat2.xyz = u_xlat0.xyz + (-u_xlat1.xyz);
        u_xlat13 = dot(u_xlat2.xyz, u_xlat2.xyz);
        u_xlat13 = sqrt(u_xlat13);
        u_xlat13 = u_xlat13 * VGlobals._ScreenParams.y;
        u_xlat12 = u_xlat13 / u_xlat12;
        tessFactor.edgeTessellationFactor[0] = max(u_xlat12, 1.0);
        u_xlat2.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[0].INTERNALTESSPOS0.yyy;
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[0].INTERNALTESSPOS0.xxx, u_xlat2.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[0].INTERNALTESSPOS0.zzz, u_xlat2.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[0].INTERNALTESSPOS0.www, u_xlat2.xyz);
        u_xlat3.xyz = u_xlat1.xyz + u_xlat2.xyz;
        u_xlat1.xyz = u_xlat1.xyz + (-u_xlat2.xyz);
        u_xlat12 = dot(u_xlat1.xyz, u_xlat1.xyz);
        u_xlat12 = sqrt(u_xlat12);
        u_xlat12 = u_xlat12 * VGlobals._ScreenParams.y;
        u_xlat1.xyz = fma(u_xlat3.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat1.x = dot(u_xlat1.xyz, u_xlat1.xyz);
        u_xlat1.x = sqrt(u_xlat1.x);
        u_xlat1.x = u_xlat1.x * VGlobals._EdgeLength;
        u_xlat12 = u_xlat12 / u_xlat1.x;
        tessFactor.edgeTessellationFactor[1] = max(u_xlat12, 1.0);
        u_xlat1.xyz = u_xlat0.xyz + u_xlat2.xyz;
        u_xlat0.xyz = (-u_xlat0.xyz) + u_xlat2.xyz;
        u_xlat0.x = dot(u_xlat0.xyz, u_xlat0.xyz);
        u_xlat0.x = sqrt(u_xlat0.x);
        u_xlat0.x = u_xlat0.x * VGlobals._ScreenParams.y;
        u_xlat4.xyz = fma(u_xlat1.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat4.x = dot(u_xlat4.xyz, u_xlat4.xyz);
        u_xlat4.x = sqrt(u_xlat4.x);
        u_xlat4.x = u_xlat4.x * VGlobals._EdgeLength;
        u_xlat0.x = u_xlat0.x / u_xlat4.x;
        tessFactor.edgeTessellationFactor[2] = max(u_xlat0.x, 1.0);
    }
    // join_phase3
    {
        u_xlat0.x = tessFactor.edgeTessellationFactor[0] + tessFactor.edgeTessellationFactor[1];
        u_xlat0.x = u_xlat0.x + tessFactor.edgeTessellationFactor[2];
        tessFactor.insideTessellationFactor = u_xlat0.x * 0.333333343;
    }
    controlPoints[mtl_VertexID] = output;
    tessFactors[internalPatchID] = tessFactor;
}
// SHADER_STAGE_HULL_end
// SHADER_STAGE_DOMAIN_begin
struct Mtl_VertexInPostTess
{
    patch_control_point<Mtl_ControlPointIn> cp;
};
struct Mtl_VertexOutPostTess
{
    float4 mtl_Position [[ position ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float4 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float4 TEXCOORD3 [[ user(TEXCOORD3) ]];
    float4 TEXCOORD6 [[ user(TEXCOORD6) ]];
    float4 TEXCOORD7 [[ user(TEXCOORD7) ]];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    sampler sampler_Height [[ sampler (0) ]],
    texture2d<float, access::sample > _Height [[ texture(0) ]] ,
    float3 mtl_TessCoord [[ position_in_patch ]],
    uint patchID [[ patch_id ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    Mtl_VertexInPostTess input [[ stage_in ]])
{
#pragma clang diagnostic pop
    Mtl_VertexOutPostTess output;
    MTLTriangleTessellationFactorsHalf tessFactor;
    tessFactor = tessFactors[patchID];
    float4 u_xlat0;
    float4 u_xlat1;
    float4 u_xlat2;
    float4 u_xlat3;
    float2 u_xlat9;
    float u_xlat12;
    float u_xlat13;
    u_xlat0 = mtl_TessCoord.yyyy * input.cp[1].INTERNALTESSPOS0;
    u_xlat0 = fma(input.cp[0].INTERNALTESSPOS0, mtl_TessCoord.xxxx, u_xlat0);
    u_xlat0 = fma(input.cp[2].INTERNALTESSPOS0, mtl_TessCoord.zzzz, u_xlat0);
    u_xlat1.xy = mtl_TessCoord.yy * input.cp[1].TEXCOORD0.xy;
    u_xlat1.xy = fma(input.cp[0].TEXCOORD0.xy, mtl_TessCoord.xx, u_xlat1.xy);
    u_xlat1.xy = fma(input.cp[2].TEXCOORD0.xy, mtl_TessCoord.zz, u_xlat1.xy);
    u_xlat9.xy = u_xlat1.xy * float2(VGlobals._Tile);
    output.TEXCOORD0.xy = fma(u_xlat1.xy, VGlobals._texcoord_ST.xy, VGlobals._texcoord_ST.zw);
    u_xlat1.xyz = _Height.sample(sampler_Height, u_xlat9.xy, level(1.0)).xyz;
    u_xlat2.xyz = mtl_TessCoord.yyy * input.cp[1].NORMAL0.xyz;
    u_xlat2.xyz = fma(input.cp[0].NORMAL0.xyz, mtl_TessCoord.xxx, u_xlat2.xyz);
    u_xlat2.xyz = fma(input.cp[2].NORMAL0.xyz, mtl_TessCoord.zzz, u_xlat2.xyz);
    u_xlat1.xyz = u_xlat1.xyz * u_xlat2.xyz;
    u_xlat0.xyz = fma(u_xlat1.xyz, float3(VGlobals._HeightDisplacement), u_xlat0.xyz);
    u_xlat1 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], u_xlat0.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], u_xlat0.zzzz, u_xlat1);
    u_xlat3 = u_xlat1 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, u_xlat0.www, u_xlat1.xyz);
    u_xlat1 = u_xlat3.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat3.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat3.zzzz, u_xlat1);
    output.mtl_Position = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat3.wwww, u_xlat1);
    u_xlat1.y = dot(u_xlat2.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat1.z = dot(u_xlat2.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat1.x = dot(u_xlat2.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat12 = dot(u_xlat1.xyz, u_xlat1.xyz);
    u_xlat12 = rsqrt(u_xlat12);
    u_xlat1.xyz = float3(u_xlat12) * u_xlat1.xyz;
    output.TEXCOORD1.z = u_xlat1.y;
    u_xlat2 = mtl_TessCoord.yyyy * input.cp[1].TANGENT0;
    u_xlat2 = fma(input.cp[0].TANGENT0, mtl_TessCoord.xxxx, u_xlat2);
    u_xlat2 = fma(input.cp[2].TANGENT0, mtl_TessCoord.zzzz, u_xlat2);
    u_xlat3.xyz = u_xlat2.yyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].yzx;
    u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].yzx, u_xlat2.xxx, u_xlat3.xyz);
    u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].yzx, u_xlat2.zzz, u_xlat3.xyz);
    u_xlat12 = u_xlat2.w * VGlobals.unity_WorldTransformParams.w;
    u_xlat13 = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat13 = rsqrt(u_xlat13);
    u_xlat2.xyz = float3(u_xlat13) * u_xlat2.xyz;
    u_xlat3.xyz = u_xlat1.xyz * u_xlat2.xyz;
    u_xlat3.xyz = fma(u_xlat1.zxy, u_xlat2.yzx, (-u_xlat3.xyz));
    u_xlat3.xyz = float3(u_xlat12) * u_xlat3.xyz;
    output.TEXCOORD1.y = u_xlat3.x;
    output.TEXCOORD1.w = u_xlat0.x;
    output.TEXCOORD1.x = u_xlat2.z;
    output.TEXCOORD2.w = u_xlat0.y;
    output.TEXCOORD3.w = u_xlat0.z;
    output.TEXCOORD2.x = u_xlat2.x;
    output.TEXCOORD3.x = u_xlat2.y;
    output.TEXCOORD2.z = u_xlat1.z;
    output.TEXCOORD3.z = u_xlat1.x;
    output.TEXCOORD2.y = u_xlat3.y;
    output.TEXCOORD3.y = u_xlat3.z;
    output.TEXCOORD6 = float4(0.0, 0.0, 0.0, 0.0);
    output.TEXCOORD7 = float4(0.0, 0.0, 0.0, 0.0);
    return output;
}
// SHADER_STAGE_DOMAIN_end
Compilation succeeded with: 

program_source:301:53: warning: writable resources in non-void post-tessellation vertex function
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
                                                    ^
program_source:307:30: note: writable buffer defined here
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
                             ^
program_source:308:48: note: writable buffer defined here
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
                                               ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float4 TEXCOORD0 [[ attribute(3) ]] ;
    float4 TEXCOORD1 [[ attribute(4) ]] ;
    float4 TEXCOORD2 [[ attribute(5) ]] ;
    float4 TEXCOORD3 [[ attribute(6) ]] ;
    float4 COLOR0 [[ attribute(7) ]] ;
};
struct Mtl_VertexOut
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float4 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float4 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float4 TEXCOORD3 [[ user(TEXCOORD3) ]];
    float4 COLOR0 [[ user(COLOR0) ]];
};
static Mtl_VertexOut vertexFunction(
    Mtl_VertexIn input)
{
    Mtl_VertexOut output;
    output.INTERNALTESSPOS0 = input.POSITION0;
    output.TANGENT0 = input.TANGENT0;
    output.NORMAL0.xyz = input.NORMAL0.xyz;
    output.TEXCOORD0 = input.TEXCOORD0;
    output.TEXCOORD1 = input.TEXCOORD1;
    output.TEXCOORD2 = input.TEXCOORD2;
    output.TEXCOORD3 = input.TEXCOORD3;
    output.COLOR0 = input.COLOR0;
    return output;
}
// SHADER_STAGE_HULL_begin
struct Mtl_ControlPoint
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float4 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float4 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float4 TEXCOORD3 [[ user(TEXCOORD3) ]];
    float4 COLOR0 [[ user(COLOR0) ]];
};
struct Mtl_ControlPointIn
{
    float4 INTERNALTESSPOS0 [[ attribute(8) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float4 TEXCOORD0 [[ attribute(3) ]] ;
    float4 TEXCOORD1 [[ attribute(4) ]] ;
    float4 TEXCOORD2 [[ attribute(5) ]] ;
    float4 TEXCOORD3 [[ attribute(6) ]] ;
    float4 COLOR0 [[ attribute(7) ]] ;
};
struct Mtl_KernelPatchInfo
{
    uint numPatches;
    ushort numControlPointsPerPatch;
};
struct VGlobals_Type
{
    float4 _Time;
    float4 _SinTime;
    float4 _CosTime;
    float4 unity_DeltaTime;
    float3 _WorldSpaceCameraPos;
    float4 _ProjectionParams;
    float4 _ScreenParams;
    float4 _ZBufferParams;
    float4 unity_OrthoParams;
    float4 unity_CameraWorldClipPlanes[6];
    float4 hlslcc_mtx4x4unity_CameraProjection[4];
    float4 hlslcc_mtx4x4unity_CameraInvProjection[4];
    float4 hlslcc_mtx4x4unity_WorldToCamera[4];
    float4 hlslcc_mtx4x4unity_CameraToWorld[4];
    float4 _WorldSpaceLightPos0;
    float4 _LightPositionRange;
    float4 _LightProjectionParams;
    float4 unity_4LightPosX0;
    float4 unity_4LightPosY0;
    float4 unity_4LightPosZ0;
    float4 unity_4LightAtten0;
    float4 unity_LightColor[8];
    float4 unity_LightPosition[8];
    float4 unity_LightAtten[8];
    float4 unity_SpotDirection[8];
    float4 unity_SHAr;
    float4 unity_SHAg;
    float4 unity_SHAb;
    float4 unity_SHBr;
    float4 unity_SHBg;
    float4 unity_SHBb;
    float4 unity_SHC;
    float4 unity_OcclusionMaskSelector;
    float4 unity_ProbesOcclusion;
    float3 unity_LightColor0;
    float3 unity_LightColor1;
    float3 unity_LightColor2;
    float3 unity_LightColor3;
    float4 unity_ShadowSplitSpheres[4];
    float4 unity_ShadowSplitSqRadii;
    float4 unity_LightShadowBias;
    float4 _LightSplitsNear;
    float4 _LightSplitsFar;
    float4 hlslcc_mtx4x4unity_WorldToShadow[16];
    float4 _LightShadowData;
    float4 unity_ShadowFadeCenterAndType;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 unity_LODFade;
    float4 unity_WorldTransformParams;
    float4 unity_RenderingLayer;
    float4 hlslcc_mtx4x4glstate_matrix_transpose_modelview0[4];
    float4 glstate_lightmodel_ambient;
    float4 unity_AmbientSky;
    float4 unity_AmbientEquator;
    float4 unity_AmbientGround;
    float4 unity_IndirectSpecColor;
    float4 hlslcc_mtx4x4glstate_matrix_projection[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixInvV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    int unity_StereoEyeIndex;
    float4 unity_ShadowColor;
    float4 unity_FogColor;
    float4 unity_FogParams;
    float4 unity_LightmapST;
    float4 unity_DynamicLightmapST;
    float4 unity_SpecCube0_BoxMax;
    float4 unity_SpecCube0_BoxMin;
    float4 unity_SpecCube0_ProbePosition;
    float4 unity_SpecCube0_HDR;
    float4 unity_SpecCube1_BoxMax;
    float4 unity_SpecCube1_BoxMin;
    float4 unity_SpecCube1_ProbePosition;
    float4 unity_SpecCube1_HDR;
    float4 unity_ProbeVolumeParams;
    float4 hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[4];
    float3 unity_ProbeVolumeSizeInv;
    float3 unity_ProbeVolumeMin;
    float4 unity_Lightmap_HDR;
    float4 unity_DynamicLightmap_HDR;
    float4 _LightColor0;
    float4 _SpecColor;
    float4 hlslcc_mtx4x4unity_WorldToLight[4];
    float _Tile;
    float _HeightDisplacement;
    float _NormalScale;
    float4 _ColorTint;
    float _MetallicStrength;
    float _SmoothnessStrength;
    float _EdgeLength;
    float4 _texcoord_ST;
};
struct Mtl_HullIn
{
    Mtl_VertexOut cp[3];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
kernel void patchKernel(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn vertexInput [[ stage_in ]],
    uint2 tID [[ thread_position_in_grid ]],
    ushort2 groupID [[ threadgroup_position_in_grid ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    constant Mtl_KernelPatchInfo &patchInfo [[ buffer(3) ]])
{
#pragma clang diagnostic pop
    Mtl_ControlPoint output;
    const uint numPatchesInThreadGroup = 10;
    const uint patchID = (tID.x / patchInfo.numControlPointsPerPatch);
    const bool patchValid = (patchID < patchInfo.numPatches);
    const uint mtl_BaseInstance = 0;
    const uint mtl_InstanceID = groupID.y - mtl_BaseInstance;
    const uint internalPatchID = mtl_InstanceID * patchInfo.numPatches + patchID;
    const uint patchIDInThreadGroup = (patchID % numPatchesInThreadGroup);
    const uint controlPointID = (tID.x % patchInfo.numControlPointsPerPatch);
    const uint mtl_BaseVertex = 0;
    const uint mtl_VertexID = ((mtl_InstanceID * (patchInfo.numControlPointsPerPatch * patchInfo.numPatches)) + tID.x) - mtl_BaseVertex;
    threadgroup Mtl_HullIn inputGroup[numPatchesInThreadGroup];
    threadgroup Mtl_HullIn &input = inputGroup[patchIDInThreadGroup];
    MTLTriangleTessellationFactorsHalf tessFactor;
    if (patchValid) {
        input.cp[controlPointID] = vertexFunction(vertexInput);
        output.INTERNALTESSPOS0 = input.cp[controlPointID].INTERNALTESSPOS0;
        output.TANGENT0 = input.cp[controlPointID].TANGENT0;
        output.NORMAL0 = input.cp[controlPointID].NORMAL0;
        output.TEXCOORD0 = input.cp[controlPointID].TEXCOORD0;
        output.TEXCOORD1 = input.cp[controlPointID].TEXCOORD1;
        output.TEXCOORD2 = input.cp[controlPointID].TEXCOORD2;
        output.TEXCOORD3 = input.cp[controlPointID].TEXCOORD3;
        output.COLOR0 = input.cp[controlPointID].COLOR0;
    }
    threadgroup_barrier(mem_flags::mem_threadgroup);
    if (!patchValid) {
        return;
    }
    float3 u_xlat0;
    float3 u_xlat1;
    float3 u_xlat2;
    float3 u_xlat3;
    float3 u_xlat4;
    float u_xlat12;
    float u_xlat13;
    // fork_phase2
    {
        u_xlat0.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[1].INTERNALTESSPOS0.yyy;
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[1].INTERNALTESSPOS0.xxx, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[1].INTERNALTESSPOS0.zzz, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[1].INTERNALTESSPOS0.www, u_xlat0.xyz);
        u_xlat1.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[2].INTERNALTESSPOS0.yyy;
        u_xlat1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[2].INTERNALTESSPOS0.xxx, u_xlat1.xyz);
        u_xlat1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[2].INTERNALTESSPOS0.zzz, u_xlat1.xyz);
        u_xlat1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[2].INTERNALTESSPOS0.www, u_xlat1.xyz);
        u_xlat2.xyz = u_xlat0.xyz + u_xlat1.xyz;
        u_xlat2.xyz = fma(u_xlat2.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat12 = dot(u_xlat2.xyz, u_xlat2.xyz);
        u_xlat12 = sqrt(u_xlat12);
        u_xlat12 = u_xlat12 * VGlobals._EdgeLength;
        u_xlat2.xyz = u_xlat0.xyz + (-u_xlat1.xyz);
        u_xlat13 = dot(u_xlat2.xyz, u_xlat2.xyz);
        u_xlat13 = sqrt(u_xlat13);
        u_xlat13 = u_xlat13 * VGlobals._ScreenParams.y;
        u_xlat12 = u_xlat13 / u_xlat12;
        tessFactor.edgeTessellationFactor[0] = max(u_xlat12, 1.0);
        u_xlat2.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[0].INTERNALTESSPOS0.yyy;
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[0].INTERNALTESSPOS0.xxx, u_xlat2.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[0].INTERNALTESSPOS0.zzz, u_xlat2.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[0].INTERNALTESSPOS0.www, u_xlat2.xyz);
        u_xlat3.xyz = u_xlat1.xyz + u_xlat2.xyz;
        u_xlat1.xyz = u_xlat1.xyz + (-u_xlat2.xyz);
        u_xlat12 = dot(u_xlat1.xyz, u_xlat1.xyz);
        u_xlat12 = sqrt(u_xlat12);
        u_xlat12 = u_xlat12 * VGlobals._ScreenParams.y;
        u_xlat1.xyz = fma(u_xlat3.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat1.x = dot(u_xlat1.xyz, u_xlat1.xyz);
        u_xlat1.x = sqrt(u_xlat1.x);
        u_xlat1.x = u_xlat1.x * VGlobals._EdgeLength;
        u_xlat12 = u_xlat12 / u_xlat1.x;
        tessFactor.edgeTessellationFactor[1] = max(u_xlat12, 1.0);
        u_xlat1.xyz = u_xlat0.xyz + u_xlat2.xyz;
        u_xlat0.xyz = (-u_xlat0.xyz) + u_xlat2.xyz;
        u_xlat0.x = dot(u_xlat0.xyz, u_xlat0.xyz);
        u_xlat0.x = sqrt(u_xlat0.x);
        u_xlat0.x = u_xlat0.x * VGlobals._ScreenParams.y;
        u_xlat4.xyz = fma(u_xlat1.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat4.x = dot(u_xlat4.xyz, u_xlat4.xyz);
        u_xlat4.x = sqrt(u_xlat4.x);
        u_xlat4.x = u_xlat4.x * VGlobals._EdgeLength;
        u_xlat0.x = u_xlat0.x / u_xlat4.x;
        tessFactor.edgeTessellationFactor[2] = max(u_xlat0.x, 1.0);
    }
    // join_phase3
    {
        u_xlat0.x = tessFactor.edgeTessellationFactor[0] + tessFactor.edgeTessellationFactor[1];
        u_xlat0.x = u_xlat0.x + tessFactor.edgeTessellationFactor[2];
        tessFactor.insideTessellationFactor = u_xlat0.x * 0.333333343;
    }
    controlPoints[mtl_VertexID] = output;
    tessFactors[internalPatchID] = tessFactor;
}
// SHADER_STAGE_HULL_end
// SHADER_STAGE_DOMAIN_begin
struct Mtl_VertexInPostTess
{
    patch_control_point<Mtl_ControlPointIn> cp;
};
struct Mtl_VertexOutPostTess
{
    float4 mtl_Position [[ position ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float3 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float3 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float3 TEXCOORD3 [[ user(TEXCOORD3) ]];
    float3 TEXCOORD4 [[ user(TEXCOORD4) ]];
    float3 TEXCOORD5 [[ user(TEXCOORD5) ]];
    float4 TEXCOORD6 [[ user(TEXCOORD6) ]];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    sampler sampler_Height [[ sampler (0) ]],
    texture2d<float, access::sample > _Height [[ texture(0) ]] ,
    float3 mtl_TessCoord [[ position_in_patch ]],
    uint patchID [[ patch_id ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    Mtl_VertexInPostTess input [[ stage_in ]])
{
#pragma clang diagnostic pop
    Mtl_VertexOutPostTess output;
    MTLTriangleTessellationFactorsHalf tessFactor;
    tessFactor = tessFactors[patchID];
    float4 u_xlat0;
    float3 u_xlat1;
    float4 u_xlat2;
    float4 u_xlat3;
    float4 u_xlat4;
    float2 u_xlat10;
    float u_xlat16;
    u_xlat0.xy = mtl_TessCoord.yy * input.cp[1].TEXCOORD0.xy;
    u_xlat0.xy = fma(input.cp[0].TEXCOORD0.xy, mtl_TessCoord.xx, u_xlat0.xy);
    u_xlat0.xy = fma(input.cp[2].TEXCOORD0.xy, mtl_TessCoord.zz, u_xlat0.xy);
    u_xlat10.xy = u_xlat0.xy * float2(VGlobals._Tile);
    output.TEXCOORD0.xy = fma(u_xlat0.xy, VGlobals._texcoord_ST.xy, VGlobals._texcoord_ST.zw);
    u_xlat0.xyz = _Height.sample(sampler_Height, u_xlat10.xy, level(1.0)).xyz;
    u_xlat1.xyz = mtl_TessCoord.yyy * input.cp[1].NORMAL0.xyz;
    u_xlat1.xyz = fma(input.cp[0].NORMAL0.xyz, mtl_TessCoord.xxx, u_xlat1.xyz);
    u_xlat1.xyz = fma(input.cp[2].NORMAL0.xyz, mtl_TessCoord.zzz, u_xlat1.xyz);
    u_xlat0.xyz = u_xlat0.xyz * u_xlat1.xyz;
    u_xlat2 = mtl_TessCoord.yyyy * input.cp[1].INTERNALTESSPOS0;
    u_xlat2 = fma(input.cp[0].INTERNALTESSPOS0, mtl_TessCoord.xxxx, u_xlat2);
    u_xlat2 = fma(input.cp[2].INTERNALTESSPOS0, mtl_TessCoord.zzzz, u_xlat2);
    u_xlat0.xyz = fma(u_xlat0.xyz, float3(VGlobals._HeightDisplacement), u_xlat2.xyz);
    u_xlat3 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], u_xlat0.xxxx, u_xlat3);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], u_xlat0.zzzz, u_xlat3);
    u_xlat3 = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat4 = u_xlat3.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat4 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat3.xxxx, u_xlat4);
    u_xlat4 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat3.zzzz, u_xlat4);
    output.mtl_Position = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat3.wwww, u_xlat4);
    u_xlat2.y = dot(u_xlat1.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat2.z = dot(u_xlat1.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat2.x = dot(u_xlat1.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat1.x = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat1.x = rsqrt(u_xlat1.x);
    u_xlat1.xyz = u_xlat1.xxx * u_xlat2.xyz;
    output.TEXCOORD1.z = u_xlat1.y;
    u_xlat3 = mtl_TessCoord.yyyy * input.cp[1].TANGENT0;
    u_xlat3 = fma(input.cp[0].TANGENT0, mtl_TessCoord.xxxx, u_xlat3);
    u_xlat3 = fma(input.cp[2].TANGENT0, mtl_TessCoord.zzzz, u_xlat3);
    u_xlat2.xyz = u_xlat3.yyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].yzx;
    u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].yzx, u_xlat3.xxx, u_xlat2.xyz);
    u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].yzx, u_xlat3.zzz, u_xlat2.xyz);
    u_xlat16 = u_xlat3.w * VGlobals.unity_WorldTransformParams.w;
    u_xlat3.x = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat3.x = rsqrt(u_xlat3.x);
    u_xlat2.xyz = u_xlat2.xyz * u_xlat3.xxx;
    u_xlat3.xyz = u_xlat1.xyz * u_xlat2.xyz;
    u_xlat3.xyz = fma(u_xlat1.zxy, u_xlat2.yzx, (-u_xlat3.xyz));
    u_xlat3.xyz = float3(u_xlat16) * u_xlat3.xyz;
    output.TEXCOORD1.y = u_xlat3.x;
    output.TEXCOORD1.x = u_xlat2.z;
    output.TEXCOORD2.x = u_xlat2.x;
    output.TEXCOORD3.x = u_xlat2.y;
    output.TEXCOORD2.z = u_xlat1.z;
    output.TEXCOORD3.z = u_xlat1.x;
    output.TEXCOORD2.y = u_xlat3.y;
    output.TEXCOORD3.y = u_xlat3.z;
    output.TEXCOORD4.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, u_xlat2.www, u_xlat0.xyz);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3], u_xlat2.wwww, u_xlat0);
    u_xlat1.xyz = u_xlat0.yyy * VGlobals.hlslcc_mtx4x4unity_WorldToLight[1].xyz;
    u_xlat1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_WorldToLight[0].xyz, u_xlat0.xxx, u_xlat1.xyz);
    u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_WorldToLight[2].xyz, u_xlat0.zzz, u_xlat1.xyz);
    output.TEXCOORD5.xyz = fma(VGlobals.hlslcc_mtx4x4unity_WorldToLight[3].xyz, u_xlat0.www, u_xlat0.xyz);
    output.TEXCOORD6 = float4(0.0, 0.0, 0.0, 0.0);
    return output;
}
// SHADER_STAGE_DOMAIN_end
Compilation succeeded with: 

program_source:293:53: warning: writable resources in non-void post-tessellation vertex function
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
                                                    ^
program_source:299:30: note: writable buffer defined here
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
                             ^
program_source:300:48: note: writable buffer defined here
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
                                               ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float4 TEXCOORD0 [[ attribute(3) ]] ;
    float4 TEXCOORD1 [[ attribute(4) ]] ;
    float4 TEXCOORD2 [[ attribute(5) ]] ;
    float4 TEXCOORD3 [[ attribute(6) ]] ;
    float4 COLOR0 [[ attribute(7) ]] ;
};
struct Mtl_VertexOut
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float4 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float4 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float4 TEXCOORD3 [[ user(TEXCOORD3) ]];
    float4 COLOR0 [[ user(COLOR0) ]];
};
static Mtl_VertexOut vertexFunction(
    Mtl_VertexIn input)
{
    Mtl_VertexOut output;
    output.INTERNALTESSPOS0 = input.POSITION0;
    output.TANGENT0 = input.TANGENT0;
    output.NORMAL0.xyz = input.NORMAL0.xyz;
    output.TEXCOORD0 = input.TEXCOORD0;
    output.TEXCOORD1 = input.TEXCOORD1;
    output.TEXCOORD2 = input.TEXCOORD2;
    output.TEXCOORD3 = input.TEXCOORD3;
    output.COLOR0 = input.COLOR0;
    return output;
}
// SHADER_STAGE_HULL_begin
struct Mtl_ControlPoint
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float4 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float4 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float4 TEXCOORD3 [[ user(TEXCOORD3) ]];
    float4 COLOR0 [[ user(COLOR0) ]];
};
struct Mtl_ControlPointIn
{
    float4 INTERNALTESSPOS0 [[ attribute(8) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float4 TEXCOORD0 [[ attribute(3) ]] ;
    float4 TEXCOORD1 [[ attribute(4) ]] ;
    float4 TEXCOORD2 [[ attribute(5) ]] ;
    float4 TEXCOORD3 [[ attribute(6) ]] ;
    float4 COLOR0 [[ attribute(7) ]] ;
};
struct Mtl_KernelPatchInfo
{
    uint numPatches;
    ushort numControlPointsPerPatch;
};
struct VGlobals_Type
{
    float4 _Time;
    float4 _SinTime;
    float4 _CosTime;
    float4 unity_DeltaTime;
    float3 _WorldSpaceCameraPos;
    float4 _ProjectionParams;
    float4 _ScreenParams;
    float4 _ZBufferParams;
    float4 unity_OrthoParams;
    float4 unity_CameraWorldClipPlanes[6];
    float4 hlslcc_mtx4x4unity_CameraProjection[4];
    float4 hlslcc_mtx4x4unity_CameraInvProjection[4];
    float4 hlslcc_mtx4x4unity_WorldToCamera[4];
    float4 hlslcc_mtx4x4unity_CameraToWorld[4];
    float4 _WorldSpaceLightPos0;
    float4 _LightPositionRange;
    float4 _LightProjectionParams;
    float4 unity_4LightPosX0;
    float4 unity_4LightPosY0;
    float4 unity_4LightPosZ0;
    float4 unity_4LightAtten0;
    float4 unity_LightColor[8];
    float4 unity_LightPosition[8];
    float4 unity_LightAtten[8];
    float4 unity_SpotDirection[8];
    float4 unity_SHAr;
    float4 unity_SHAg;
    float4 unity_SHAb;
    float4 unity_SHBr;
    float4 unity_SHBg;
    float4 unity_SHBb;
    float4 unity_SHC;
    float4 unity_OcclusionMaskSelector;
    float4 unity_ProbesOcclusion;
    float3 unity_LightColor0;
    float3 unity_LightColor1;
    float3 unity_LightColor2;
    float3 unity_LightColor3;
    float4 unity_ShadowSplitSpheres[4];
    float4 unity_ShadowSplitSqRadii;
    float4 unity_LightShadowBias;
    float4 _LightSplitsNear;
    float4 _LightSplitsFar;
    float4 hlslcc_mtx4x4unity_WorldToShadow[16];
    float4 _LightShadowData;
    float4 unity_ShadowFadeCenterAndType;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 unity_LODFade;
    float4 unity_WorldTransformParams;
    float4 unity_RenderingLayer;
    float4 hlslcc_mtx4x4glstate_matrix_transpose_modelview0[4];
    float4 glstate_lightmodel_ambient;
    float4 unity_AmbientSky;
    float4 unity_AmbientEquator;
    float4 unity_AmbientGround;
    float4 unity_IndirectSpecColor;
    float4 hlslcc_mtx4x4glstate_matrix_projection[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixInvV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    int unity_StereoEyeIndex;
    float4 unity_ShadowColor;
    float4 unity_FogColor;
    float4 unity_FogParams;
    float4 unity_LightmapST;
    float4 unity_DynamicLightmapST;
    float4 unity_SpecCube0_BoxMax;
    float4 unity_SpecCube0_BoxMin;
    float4 unity_SpecCube0_ProbePosition;
    float4 unity_SpecCube0_HDR;
    float4 unity_SpecCube1_BoxMax;
    float4 unity_SpecCube1_BoxMin;
    float4 unity_SpecCube1_ProbePosition;
    float4 unity_SpecCube1_HDR;
    float4 unity_ProbeVolumeParams;
    float4 hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[4];
    float3 unity_ProbeVolumeSizeInv;
    float3 unity_ProbeVolumeMin;
    float4 unity_Lightmap_HDR;
    float4 unity_DynamicLightmap_HDR;
    float4 _LightColor0;
    float4 _SpecColor;
    float _Tile;
    float _HeightDisplacement;
    float _NormalScale;
    float4 _ColorTint;
    float _MetallicStrength;
    float _SmoothnessStrength;
    float _EdgeLength;
};
struct Mtl_HullIn
{
    Mtl_VertexOut cp[3];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
kernel void patchKernel(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn vertexInput [[ stage_in ]],
    uint2 tID [[ thread_position_in_grid ]],
    ushort2 groupID [[ threadgroup_position_in_grid ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    constant Mtl_KernelPatchInfo &patchInfo [[ buffer(3) ]])
{
#pragma clang diagnostic pop
    Mtl_ControlPoint output;
    const uint numPatchesInThreadGroup = 10;
    const uint patchID = (tID.x / patchInfo.numControlPointsPerPatch);
    const bool patchValid = (patchID < patchInfo.numPatches);
    const uint mtl_BaseInstance = 0;
    const uint mtl_InstanceID = groupID.y - mtl_BaseInstance;
    const uint internalPatchID = mtl_InstanceID * patchInfo.numPatches + patchID;
    const uint patchIDInThreadGroup = (patchID % numPatchesInThreadGroup);
    const uint controlPointID = (tID.x % patchInfo.numControlPointsPerPatch);
    const uint mtl_BaseVertex = 0;
    const uint mtl_VertexID = ((mtl_InstanceID * (patchInfo.numControlPointsPerPatch * patchInfo.numPatches)) + tID.x) - mtl_BaseVertex;
    threadgroup Mtl_HullIn inputGroup[numPatchesInThreadGroup];
    threadgroup Mtl_HullIn &input = inputGroup[patchIDInThreadGroup];
    MTLTriangleTessellationFactorsHalf tessFactor;
    if (patchValid) {
        input.cp[controlPointID] = vertexFunction(vertexInput);
        output.INTERNALTESSPOS0 = input.cp[controlPointID].INTERNALTESSPOS0;
        output.TANGENT0 = input.cp[controlPointID].TANGENT0;
        output.NORMAL0 = input.cp[controlPointID].NORMAL0;
        output.TEXCOORD0 = input.cp[controlPointID].TEXCOORD0;
        output.TEXCOORD1 = input.cp[controlPointID].TEXCOORD1;
        output.TEXCOORD2 = input.cp[controlPointID].TEXCOORD2;
        output.TEXCOORD3 = input.cp[controlPointID].TEXCOORD3;
        output.COLOR0 = input.cp[controlPointID].COLOR0;
    }
    threadgroup_barrier(mem_flags::mem_threadgroup);
    if (!patchValid) {
        return;
    }
    float3 u_xlat0;
    float3 u_xlat1;
    float3 u_xlat2;
    float3 u_xlat3;
    float3 u_xlat4;
    float u_xlat12;
    float u_xlat13;
    // fork_phase2
    {
        u_xlat0.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[1].INTERNALTESSPOS0.yyy;
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[1].INTERNALTESSPOS0.xxx, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[1].INTERNALTESSPOS0.zzz, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[1].INTERNALTESSPOS0.www, u_xlat0.xyz);
        u_xlat1.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[2].INTERNALTESSPOS0.yyy;
        u_xlat1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[2].INTERNALTESSPOS0.xxx, u_xlat1.xyz);
        u_xlat1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[2].INTERNALTESSPOS0.zzz, u_xlat1.xyz);
        u_xlat1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[2].INTERNALTESSPOS0.www, u_xlat1.xyz);
        u_xlat2.xyz = u_xlat0.xyz + u_xlat1.xyz;
        u_xlat2.xyz = fma(u_xlat2.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat12 = dot(u_xlat2.xyz, u_xlat2.xyz);
        u_xlat12 = sqrt(u_xlat12);
        u_xlat12 = u_xlat12 * VGlobals._EdgeLength;
        u_xlat2.xyz = u_xlat0.xyz + (-u_xlat1.xyz);
        u_xlat13 = dot(u_xlat2.xyz, u_xlat2.xyz);
        u_xlat13 = sqrt(u_xlat13);
        u_xlat13 = u_xlat13 * VGlobals._ScreenParams.y;
        u_xlat12 = u_xlat13 / u_xlat12;
        tessFactor.edgeTessellationFactor[0] = max(u_xlat12, 1.0);
        u_xlat2.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[0].INTERNALTESSPOS0.yyy;
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[0].INTERNALTESSPOS0.xxx, u_xlat2.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[0].INTERNALTESSPOS0.zzz, u_xlat2.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[0].INTERNALTESSPOS0.www, u_xlat2.xyz);
        u_xlat3.xyz = u_xlat1.xyz + u_xlat2.xyz;
        u_xlat1.xyz = u_xlat1.xyz + (-u_xlat2.xyz);
        u_xlat12 = dot(u_xlat1.xyz, u_xlat1.xyz);
        u_xlat12 = sqrt(u_xlat12);
        u_xlat12 = u_xlat12 * VGlobals._ScreenParams.y;
        u_xlat1.xyz = fma(u_xlat3.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat1.x = dot(u_xlat1.xyz, u_xlat1.xyz);
        u_xlat1.x = sqrt(u_xlat1.x);
        u_xlat1.x = u_xlat1.x * VGlobals._EdgeLength;
        u_xlat12 = u_xlat12 / u_xlat1.x;
        tessFactor.edgeTessellationFactor[1] = max(u_xlat12, 1.0);
        u_xlat1.xyz = u_xlat0.xyz + u_xlat2.xyz;
        u_xlat0.xyz = (-u_xlat0.xyz) + u_xlat2.xyz;
        u_xlat0.x = dot(u_xlat0.xyz, u_xlat0.xyz);
        u_xlat0.x = sqrt(u_xlat0.x);
        u_xlat0.x = u_xlat0.x * VGlobals._ScreenParams.y;
        u_xlat4.xyz = fma(u_xlat1.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat4.x = dot(u_xlat4.xyz, u_xlat4.xyz);
        u_xlat4.x = sqrt(u_xlat4.x);
        u_xlat4.x = u_xlat4.x * VGlobals._EdgeLength;
        u_xlat0.x = u_xlat0.x / u_xlat4.x;
        tessFactor.edgeTessellationFactor[2] = max(u_xlat0.x, 1.0);
    }
    // join_phase3
    {
        u_xlat0.x = tessFactor.edgeTessellationFactor[0] + tessFactor.edgeTessellationFactor[1];
        u_xlat0.x = u_xlat0.x + tessFactor.edgeTessellationFactor[2];
        tessFactor.insideTessellationFactor = u_xlat0.x * 0.333333343;
    }
    controlPoints[mtl_VertexID] = output;
    tessFactors[internalPatchID] = tessFactor;
}
// SHADER_STAGE_HULL_end
// SHADER_STAGE_DOMAIN_begin
struct Mtl_VertexInPostTess
{
    patch_control_point<Mtl_ControlPointIn> cp;
};
struct Mtl_VertexOutPostTess
{
    float4 mtl_Position [[ position ]];
    float3 TEXCOORD1 [[ user(TEXCOORD1) ]];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    sampler sampler_Height [[ sampler (0) ]],
    texture2d<float, access::sample > _Height [[ texture(0) ]] ,
    float3 mtl_TessCoord [[ position_in_patch ]],
    uint patchID [[ patch_id ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    Mtl_VertexInPostTess input [[ stage_in ]])
{
#pragma clang diagnostic pop
    Mtl_VertexOutPostTess output;
    MTLTriangleTessellationFactorsHalf tessFactor;
    tessFactor = tessFactors[patchID];
    float4 u_xlat0;
    float4 u_xlat1;
    float4 u_xlat2;
    float4 u_xlat3;
    float4 u_xlat4;
    float u_xlat11;
    float u_xlat15;
    bool u_xlatb15;
    u_xlat0.xyz = mtl_TessCoord.yyy * input.cp[1].NORMAL0.xyz;
    u_xlat0.xyz = fma(input.cp[0].NORMAL0.xyz, mtl_TessCoord.xxx, u_xlat0.xyz);
    u_xlat0.xyz = fma(input.cp[2].NORMAL0.xyz, mtl_TessCoord.zzz, u_xlat0.xyz);
    u_xlat1.x = dot(u_xlat0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat1.y = dot(u_xlat0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat1.z = dot(u_xlat0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat15 = dot(u_xlat1.xyz, u_xlat1.xyz);
    u_xlat15 = rsqrt(u_xlat15);
    u_xlat1.xyz = float3(u_xlat15) * u_xlat1.xyz;
    u_xlat2.xy = mtl_TessCoord.yy * input.cp[1].TEXCOORD0.xy;
    u_xlat2.xy = fma(input.cp[0].TEXCOORD0.xy, mtl_TessCoord.xx, u_xlat2.xy);
    u_xlat2.xy = fma(input.cp[2].TEXCOORD0.xy, mtl_TessCoord.zz, u_xlat2.xy);
    u_xlat2.xy = u_xlat2.xy * float2(VGlobals._Tile);
    u_xlat2.xyz = _Height.sample(sampler_Height, u_xlat2.xy, level(1.0)).xyz;
    u_xlat0.xyz = u_xlat0.xyz * u_xlat2.xyz;
    u_xlat2 = mtl_TessCoord.yyyy * input.cp[1].INTERNALTESSPOS0;
    u_xlat2 = fma(input.cp[0].INTERNALTESSPOS0, mtl_TessCoord.xxxx, u_xlat2);
    u_xlat2 = fma(input.cp[2].INTERNALTESSPOS0, mtl_TessCoord.zzzz, u_xlat2);
    u_xlat0.xyz = fma(u_xlat0.xyz, float3(VGlobals._HeightDisplacement), u_xlat2.xyz);
    u_xlat3 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], u_xlat0.xxxx, u_xlat3);
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], u_xlat0.zzzz, u_xlat3);
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3], u_xlat2.wwww, u_xlat3);
    u_xlat2.xyz = fma((-u_xlat3.xyz), VGlobals._WorldSpaceLightPos0.www, VGlobals._WorldSpaceLightPos0.xyz);
    u_xlat15 = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat15 = rsqrt(u_xlat15);
    u_xlat2.xyz = float3(u_xlat15) * u_xlat2.xyz;
    u_xlat15 = dot(u_xlat1.xyz, u_xlat2.xyz);
    u_xlat15 = fma((-u_xlat15), u_xlat15, 1.0);
    u_xlat15 = sqrt(u_xlat15);
    u_xlat15 = u_xlat15 * VGlobals.unity_LightShadowBias.z;
    u_xlat1.xyz = fma((-u_xlat1.xyz), float3(u_xlat15), u_xlat3.xyz);
    u_xlatb15 = VGlobals.unity_LightShadowBias.z!=0.0;
    u_xlat1.xyz = (bool(u_xlatb15)) ? u_xlat1.xyz : u_xlat3.xyz;
    u_xlat4 = u_xlat1.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat4 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat1.xxxx, u_xlat4);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat1.zzzz, u_xlat4);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat3.wwww, u_xlat1);
    u_xlat15 = VGlobals.unity_LightShadowBias.x / u_xlat1.w;
    u_xlat15 = min(u_xlat15, 0.0);
    u_xlat15 = max(u_xlat15, -1.0);
    u_xlat15 = u_xlat15 + u_xlat1.z;
    u_xlat11 = min(u_xlat1.w, u_xlat15);
    output.mtl_Position.xyw = u_xlat1.xyw;
    u_xlat1.x = (-u_xlat15) + u_xlat11;
    output.mtl_Position.z = fma(VGlobals.unity_LightShadowBias.y, u_xlat1.x, u_xlat15);
    u_xlat1.xyz = u_xlat0.yyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz;
    u_xlat0.xyw = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, u_xlat0.xxx, u_xlat1.xyz);
    u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, u_xlat0.zzz, u_xlat0.xyw);
    output.TEXCOORD1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, u_xlat2.www, u_xlat0.xyz);
    return output;
}
// SHADER_STAGE_DOMAIN_end
Compilation succeeded with: 

program_source:299:53: warning: writable resources in non-void post-tessellation vertex function
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
                                                    ^
program_source:305:30: note: writable buffer defined here
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
                             ^
program_source:306:48: note: writable buffer defined here
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
                                               ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float4 TEXCOORD0 [[ attribute(3) ]] ;
    float4 TEXCOORD1 [[ attribute(4) ]] ;
    float4 TEXCOORD2 [[ attribute(5) ]] ;
    float4 TEXCOORD3 [[ attribute(6) ]] ;
    float4 COLOR0 [[ attribute(7) ]] ;
};
struct Mtl_VertexOut
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float4 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float4 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float4 TEXCOORD3 [[ user(TEXCOORD3) ]];
    float4 COLOR0 [[ user(COLOR0) ]];
};
static Mtl_VertexOut vertexFunction(
    Mtl_VertexIn input)
{
    Mtl_VertexOut output;
    output.INTERNALTESSPOS0 = input.POSITION0;
    output.TANGENT0 = input.TANGENT0;
    output.NORMAL0.xyz = input.NORMAL0.xyz;
    output.TEXCOORD0 = input.TEXCOORD0;
    output.TEXCOORD1 = input.TEXCOORD1;
    output.TEXCOORD2 = input.TEXCOORD2;
    output.TEXCOORD3 = input.TEXCOORD3;
    output.COLOR0 = input.COLOR0;
    return output;
}
// SHADER_STAGE_HULL_begin
struct Mtl_ControlPoint
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float4 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float4 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float4 TEXCOORD3 [[ user(TEXCOORD3) ]];
    float4 COLOR0 [[ user(COLOR0) ]];
};
struct Mtl_ControlPointIn
{
    float4 INTERNALTESSPOS0 [[ attribute(8) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float4 TEXCOORD0 [[ attribute(3) ]] ;
    float4 TEXCOORD1 [[ attribute(4) ]] ;
    float4 TEXCOORD2 [[ attribute(5) ]] ;
    float4 TEXCOORD3 [[ attribute(6) ]] ;
    float4 COLOR0 [[ attribute(7) ]] ;
};
struct Mtl_KernelPatchInfo
{
    uint numPatches;
    ushort numControlPointsPerPatch;
};
struct VGlobals_Type
{
    float4 _Time;
    float4 _SinTime;
    float4 _CosTime;
    float4 unity_DeltaTime;
    float3 _WorldSpaceCameraPos;
    float4 _ProjectionParams;
    float4 _ScreenParams;
    float4 _ZBufferParams;
    float4 unity_OrthoParams;
    float4 unity_CameraWorldClipPlanes[6];
    float4 hlslcc_mtx4x4unity_CameraProjection[4];
    float4 hlslcc_mtx4x4unity_CameraInvProjection[4];
    float4 hlslcc_mtx4x4unity_WorldToCamera[4];
    float4 hlslcc_mtx4x4unity_CameraToWorld[4];
    float4 _WorldSpaceLightPos0;
    float4 _LightPositionRange;
    float4 _LightProjectionParams;
    float4 unity_4LightPosX0;
    float4 unity_4LightPosY0;
    float4 unity_4LightPosZ0;
    float4 unity_4LightAtten0;
    float4 unity_LightColor[8];
    float4 unity_LightPosition[8];
    float4 unity_LightAtten[8];
    float4 unity_SpotDirection[8];
    float4 unity_SHAr;
    float4 unity_SHAg;
    float4 unity_SHAb;
    float4 unity_SHBr;
    float4 unity_SHBg;
    float4 unity_SHBb;
    float4 unity_SHC;
    float4 unity_OcclusionMaskSelector;
    float4 unity_ProbesOcclusion;
    float3 unity_LightColor0;
    float3 unity_LightColor1;
    float3 unity_LightColor2;
    float3 unity_LightColor3;
    float4 unity_ShadowSplitSpheres[4];
    float4 unity_ShadowSplitSqRadii;
    float4 unity_LightShadowBias;
    float4 _LightSplitsNear;
    float4 _LightSplitsFar;
    float4 hlslcc_mtx4x4unity_WorldToShadow[16];
    float4 _LightShadowData;
    float4 unity_ShadowFadeCenterAndType;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 unity_LODFade;
    float4 unity_WorldTransformParams;
    float4 unity_RenderingLayer;
    float4 hlslcc_mtx4x4glstate_matrix_transpose_modelview0[4];
    float4 glstate_lightmodel_ambient;
    float4 unity_AmbientSky;
    float4 unity_AmbientEquator;
    float4 unity_AmbientGround;
    float4 unity_IndirectSpecColor;
    float4 hlslcc_mtx4x4glstate_matrix_projection[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixInvV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    int unity_StereoEyeIndex;
    float4 unity_ShadowColor;
    float4 unity_FogColor;
    float4 unity_FogParams;
    float4 unity_LightmapST;
    float4 unity_DynamicLightmapST;
    float4 unity_SpecCube0_BoxMax;
    float4 unity_SpecCube0_BoxMin;
    float4 unity_SpecCube0_ProbePosition;
    float4 unity_SpecCube0_HDR;
    float4 unity_SpecCube1_BoxMax;
    float4 unity_SpecCube1_BoxMin;
    float4 unity_SpecCube1_ProbePosition;
    float4 unity_SpecCube1_HDR;
    float4 unity_ProbeVolumeParams;
    float4 hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[4];
    float3 unity_ProbeVolumeSizeInv;
    float3 unity_ProbeVolumeMin;
    float4 unity_Lightmap_HDR;
    float4 unity_DynamicLightmap_HDR;
    float4 _LightColor0;
    float4 _SpecColor;
    float _Tile;
    float _HeightDisplacement;
    float _NormalScale;
    float4 _ColorTint;
    float _MetallicStrength;
    float _SmoothnessStrength;
    float _EdgeLength;
    float4 _texcoord_ST;
    float4 unity_Ambient;
};
struct Mtl_HullIn
{
    Mtl_VertexOut cp[3];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
kernel void patchKernel(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn vertexInput [[ stage_in ]],
    uint2 tID [[ thread_position_in_grid ]],
    ushort2 groupID [[ threadgroup_position_in_grid ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    constant Mtl_KernelPatchInfo &patchInfo [[ buffer(3) ]])
{
#pragma clang diagnostic pop
    Mtl_ControlPoint output;
    const uint numPatchesInThreadGroup = 10;
    const uint patchID = (tID.x / patchInfo.numControlPointsPerPatch);
    const bool patchValid = (patchID < patchInfo.numPatches);
    const uint mtl_BaseInstance = 0;
    const uint mtl_InstanceID = groupID.y - mtl_BaseInstance;
    const uint internalPatchID = mtl_InstanceID * patchInfo.numPatches + patchID;
    const uint patchIDInThreadGroup = (patchID % numPatchesInThreadGroup);
    const uint controlPointID = (tID.x % patchInfo.numControlPointsPerPatch);
    const uint mtl_BaseVertex = 0;
    const uint mtl_VertexID = ((mtl_InstanceID * (patchInfo.numControlPointsPerPatch * patchInfo.numPatches)) + tID.x) - mtl_BaseVertex;
    threadgroup Mtl_HullIn inputGroup[numPatchesInThreadGroup];
    threadgroup Mtl_HullIn &input = inputGroup[patchIDInThreadGroup];
    MTLTriangleTessellationFactorsHalf tessFactor;
    if (patchValid) {
        input.cp[controlPointID] = vertexFunction(vertexInput);
        output.INTERNALTESSPOS0 = input.cp[controlPointID].INTERNALTESSPOS0;
        output.TANGENT0 = input.cp[controlPointID].TANGENT0;
        output.NORMAL0 = input.cp[controlPointID].NORMAL0;
        output.TEXCOORD0 = input.cp[controlPointID].TEXCOORD0;
        output.TEXCOORD1 = input.cp[controlPointID].TEXCOORD1;
        output.TEXCOORD2 = input.cp[controlPointID].TEXCOORD2;
        output.TEXCOORD3 = input.cp[controlPointID].TEXCOORD3;
        output.COLOR0 = input.cp[controlPointID].COLOR0;
    }
    threadgroup_barrier(mem_flags::mem_threadgroup);
    if (!patchValid) {
        return;
    }
    float3 u_xlat0;
    float3 u_xlat1;
    float3 u_xlat2;
    float3 u_xlat3;
    float3 u_xlat4;
    float u_xlat12;
    float u_xlat13;
    // fork_phase2
    {
        u_xlat0.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[1].INTERNALTESSPOS0.yyy;
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[1].INTERNALTESSPOS0.xxx, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[1].INTERNALTESSPOS0.zzz, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[1].INTERNALTESSPOS0.www, u_xlat0.xyz);
        u_xlat1.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[2].INTERNALTESSPOS0.yyy;
        u_xlat1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[2].INTERNALTESSPOS0.xxx, u_xlat1.xyz);
        u_xlat1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[2].INTERNALTESSPOS0.zzz, u_xlat1.xyz);
        u_xlat1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[2].INTERNALTESSPOS0.www, u_xlat1.xyz);
        u_xlat2.xyz = u_xlat0.xyz + u_xlat1.xyz;
        u_xlat2.xyz = fma(u_xlat2.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat12 = dot(u_xlat2.xyz, u_xlat2.xyz);
        u_xlat12 = sqrt(u_xlat12);
        u_xlat12 = u_xlat12 * VGlobals._EdgeLength;
        u_xlat2.xyz = u_xlat0.xyz + (-u_xlat1.xyz);
        u_xlat13 = dot(u_xlat2.xyz, u_xlat2.xyz);
        u_xlat13 = sqrt(u_xlat13);
        u_xlat13 = u_xlat13 * VGlobals._ScreenParams.y;
        u_xlat12 = u_xlat13 / u_xlat12;
        tessFactor.edgeTessellationFactor[0] = max(u_xlat12, 1.0);
        u_xlat2.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[0].INTERNALTESSPOS0.yyy;
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[0].INTERNALTESSPOS0.xxx, u_xlat2.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[0].INTERNALTESSPOS0.zzz, u_xlat2.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[0].INTERNALTESSPOS0.www, u_xlat2.xyz);
        u_xlat3.xyz = u_xlat1.xyz + u_xlat2.xyz;
        u_xlat1.xyz = u_xlat1.xyz + (-u_xlat2.xyz);
        u_xlat12 = dot(u_xlat1.xyz, u_xlat1.xyz);
        u_xlat12 = sqrt(u_xlat12);
        u_xlat12 = u_xlat12 * VGlobals._ScreenParams.y;
        u_xlat1.xyz = fma(u_xlat3.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat1.x = dot(u_xlat1.xyz, u_xlat1.xyz);
        u_xlat1.x = sqrt(u_xlat1.x);
        u_xlat1.x = u_xlat1.x * VGlobals._EdgeLength;
        u_xlat12 = u_xlat12 / u_xlat1.x;
        tessFactor.edgeTessellationFactor[1] = max(u_xlat12, 1.0);
        u_xlat1.xyz = u_xlat0.xyz + u_xlat2.xyz;
        u_xlat0.xyz = (-u_xlat0.xyz) + u_xlat2.xyz;
        u_xlat0.x = dot(u_xlat0.xyz, u_xlat0.xyz);
        u_xlat0.x = sqrt(u_xlat0.x);
        u_xlat0.x = u_xlat0.x * VGlobals._ScreenParams.y;
        u_xlat4.xyz = fma(u_xlat1.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat4.x = dot(u_xlat4.xyz, u_xlat4.xyz);
        u_xlat4.x = sqrt(u_xlat4.x);
        u_xlat4.x = u_xlat4.x * VGlobals._EdgeLength;
        u_xlat0.x = u_xlat0.x / u_xlat4.x;
        tessFactor.edgeTessellationFactor[2] = max(u_xlat0.x, 1.0);
    }
    // join_phase3
    {
        u_xlat0.x = tessFactor.edgeTessellationFactor[0] + tessFactor.edgeTessellationFactor[1];
        u_xlat0.x = u_xlat0.x + tessFactor.edgeTessellationFactor[2];
        tessFactor.insideTessellationFactor = u_xlat0.x * 0.333333343;
    }
    controlPoints[mtl_VertexID] = output;
    tessFactors[internalPatchID] = tessFactor;
}
// SHADER_STAGE_HULL_end
// SHADER_STAGE_DOMAIN_begin
struct Mtl_VertexInPostTess
{
    patch_control_point<Mtl_ControlPointIn> cp;
};
struct Mtl_VertexOutPostTess
{
    float4 mtl_Position [[ position ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float4 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float4 TEXCOORD3 [[ user(TEXCOORD3) ]];
    float4 TEXCOORD5 [[ user(TEXCOORD5) ]];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    sampler sampler_Height [[ sampler (0) ]],
    texture2d<float, access::sample > _Height [[ texture(0) ]] ,
    float3 mtl_TessCoord [[ position_in_patch ]],
    uint patchID [[ patch_id ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    Mtl_VertexInPostTess input [[ stage_in ]])
{
#pragma clang diagnostic pop
    Mtl_VertexOutPostTess output;
    MTLTriangleTessellationFactorsHalf tessFactor;
    tessFactor = tessFactors[patchID];
    float4 u_xlat0;
    float4 u_xlat1;
    float4 u_xlat2;
    float4 u_xlat3;
    float2 u_xlat9;
    float u_xlat12;
    float u_xlat13;
    u_xlat0 = mtl_TessCoord.yyyy * input.cp[1].INTERNALTESSPOS0;
    u_xlat0 = fma(input.cp[0].INTERNALTESSPOS0, mtl_TessCoord.xxxx, u_xlat0);
    u_xlat0 = fma(input.cp[2].INTERNALTESSPOS0, mtl_TessCoord.zzzz, u_xlat0);
    u_xlat1.xy = mtl_TessCoord.yy * input.cp[1].TEXCOORD0.xy;
    u_xlat1.xy = fma(input.cp[0].TEXCOORD0.xy, mtl_TessCoord.xx, u_xlat1.xy);
    u_xlat1.xy = fma(input.cp[2].TEXCOORD0.xy, mtl_TessCoord.zz, u_xlat1.xy);
    u_xlat9.xy = u_xlat1.xy * float2(VGlobals._Tile);
    output.TEXCOORD0.xy = fma(u_xlat1.xy, VGlobals._texcoord_ST.xy, VGlobals._texcoord_ST.zw);
    u_xlat1.xyz = _Height.sample(sampler_Height, u_xlat9.xy, level(1.0)).xyz;
    u_xlat2.xyz = mtl_TessCoord.yyy * input.cp[1].NORMAL0.xyz;
    u_xlat2.xyz = fma(input.cp[0].NORMAL0.xyz, mtl_TessCoord.xxx, u_xlat2.xyz);
    u_xlat2.xyz = fma(input.cp[2].NORMAL0.xyz, mtl_TessCoord.zzz, u_xlat2.xyz);
    u_xlat1.xyz = u_xlat1.xyz * u_xlat2.xyz;
    u_xlat0.xyz = fma(u_xlat1.xyz, float3(VGlobals._HeightDisplacement), u_xlat0.xyz);
    u_xlat1 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], u_xlat0.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], u_xlat0.zzzz, u_xlat1);
    u_xlat3 = u_xlat1 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, u_xlat0.www, u_xlat1.xyz);
    u_xlat1 = u_xlat3.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat3.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat3.zzzz, u_xlat1);
    output.mtl_Position = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat3.wwww, u_xlat1);
    u_xlat1.y = dot(u_xlat2.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat1.z = dot(u_xlat2.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat1.x = dot(u_xlat2.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat12 = dot(u_xlat1.xyz, u_xlat1.xyz);
    u_xlat12 = rsqrt(u_xlat12);
    u_xlat1.xyz = float3(u_xlat12) * u_xlat1.xyz;
    output.TEXCOORD1.z = u_xlat1.y;
    u_xlat2 = mtl_TessCoord.yyyy * input.cp[1].TANGENT0;
    u_xlat2 = fma(input.cp[0].TANGENT0, mtl_TessCoord.xxxx, u_xlat2);
    u_xlat2 = fma(input.cp[2].TANGENT0, mtl_TessCoord.zzzz, u_xlat2);
    u_xlat3.xyz = u_xlat2.yyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].yzx;
    u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].yzx, u_xlat2.xxx, u_xlat3.xyz);
    u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].yzx, u_xlat2.zzz, u_xlat3.xyz);
    u_xlat12 = u_xlat2.w * VGlobals.unity_WorldTransformParams.w;
    u_xlat13 = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat13 = rsqrt(u_xlat13);
    u_xlat2.xyz = float3(u_xlat13) * u_xlat2.xyz;
    u_xlat3.xyz = u_xlat1.xyz * u_xlat2.xyz;
    u_xlat3.xyz = fma(u_xlat1.zxy, u_xlat2.yzx, (-u_xlat3.xyz));
    u_xlat3.xyz = float3(u_xlat12) * u_xlat3.xyz;
    output.TEXCOORD1.y = u_xlat3.x;
    output.TEXCOORD1.w = u_xlat0.x;
    output.TEXCOORD1.x = u_xlat2.z;
    output.TEXCOORD2.w = u_xlat0.y;
    output.TEXCOORD3.w = u_xlat0.z;
    output.TEXCOORD2.x = u_xlat2.x;
    output.TEXCOORD3.x = u_xlat2.y;
    output.TEXCOORD2.z = u_xlat1.z;
    output.TEXCOORD3.z = u_xlat1.x;
    output.TEXCOORD2.y = u_xlat3.y;
    output.TEXCOORD3.y = u_xlat3.z;
    output.TEXCOORD5 = float4(0.0, 0.0, 0.0, 0.0);
    return output;
}
// SHADER_STAGE_DOMAIN_end
Compilation succeeded with: 

program_source:303:53: warning: writable resources in non-void post-tessellation vertex function
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
                                                    ^
program_source:309:30: note: writable buffer defined here
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
                             ^
program_source:310:48: note: writable buffer defined here
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
                                               ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float4 TEXCOORD0 [[ attribute(3) ]] ;
    float4 TEXCOORD1 [[ attribute(4) ]] ;
    float4 TEXCOORD2 [[ attribute(5) ]] ;
    float4 TEXCOORD3 [[ attribute(6) ]] ;
    float4 COLOR0 [[ attribute(7) ]] ;
};
struct Mtl_VertexOut
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float4 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float4 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float4 TEXCOORD3 [[ user(TEXCOORD3) ]];
    float4 COLOR0 [[ user(COLOR0) ]];
};
static Mtl_VertexOut vertexFunction(
    Mtl_VertexIn input)
{
    Mtl_VertexOut output;
    output.INTERNALTESSPOS0 = input.POSITION0;
    output.TANGENT0 = input.TANGENT0;
    output.NORMAL0.xyz = input.NORMAL0.xyz;
    output.TEXCOORD0 = input.TEXCOORD0;
    output.TEXCOORD1 = input.TEXCOORD1;
    output.TEXCOORD2 = input.TEXCOORD2;
    output.TEXCOORD3 = input.TEXCOORD3;
    output.COLOR0 = input.COLOR0;
    return output;
}
// SHADER_STAGE_HULL_begin
struct Mtl_ControlPoint
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float4 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float4 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float4 TEXCOORD3 [[ user(TEXCOORD3) ]];
    float4 COLOR0 [[ user(COLOR0) ]];
};
struct Mtl_ControlPointIn
{
    float4 INTERNALTESSPOS0 [[ attribute(8) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float4 TEXCOORD0 [[ attribute(3) ]] ;
    float4 TEXCOORD1 [[ attribute(4) ]] ;
    float4 TEXCOORD2 [[ attribute(5) ]] ;
    float4 TEXCOORD3 [[ attribute(6) ]] ;
    float4 COLOR0 [[ attribute(7) ]] ;
};
struct Mtl_KernelPatchInfo
{
    uint numPatches;
    ushort numControlPointsPerPatch;
};
struct VGlobals_Type
{
    float4 _Time;
    float4 _SinTime;
    float4 _CosTime;
    float4 unity_DeltaTime;
    float3 _WorldSpaceCameraPos;
    float4 _ProjectionParams;
    float4 _ScreenParams;
    float4 _ZBufferParams;
    float4 unity_OrthoParams;
    float4 unity_CameraWorldClipPlanes[6];
    float4 hlslcc_mtx4x4unity_CameraProjection[4];
    float4 hlslcc_mtx4x4unity_CameraInvProjection[4];
    float4 hlslcc_mtx4x4unity_WorldToCamera[4];
    float4 hlslcc_mtx4x4unity_CameraToWorld[4];
    float4 _WorldSpaceLightPos0;
    float4 _LightPositionRange;
    float4 _LightProjectionParams;
    float4 unity_4LightPosX0;
    float4 unity_4LightPosY0;
    float4 unity_4LightPosZ0;
    float4 unity_4LightAtten0;
    float4 unity_LightColor[8];
    float4 unity_LightPosition[8];
    float4 unity_LightAtten[8];
    float4 unity_SpotDirection[8];
    float4 unity_SHAr;
    float4 unity_SHAg;
    float4 unity_SHAb;
    float4 unity_SHBr;
    float4 unity_SHBg;
    float4 unity_SHBb;
    float4 unity_SHC;
    float4 unity_OcclusionMaskSelector;
    float4 unity_ProbesOcclusion;
    float3 unity_LightColor0;
    float3 unity_LightColor1;
    float3 unity_LightColor2;
    float3 unity_LightColor3;
    float4 unity_ShadowSplitSpheres[4];
    float4 unity_ShadowSplitSqRadii;
    float4 unity_LightShadowBias;
    float4 _LightSplitsNear;
    float4 _LightSplitsFar;
    float4 hlslcc_mtx4x4unity_WorldToShadow[16];
    float4 _LightShadowData;
    float4 unity_ShadowFadeCenterAndType;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 unity_LODFade;
    float4 unity_WorldTransformParams;
    float4 unity_RenderingLayer;
    float4 hlslcc_mtx4x4glstate_matrix_transpose_modelview0[4];
    float4 glstate_lightmodel_ambient;
    float4 unity_AmbientSky;
    float4 unity_AmbientEquator;
    float4 unity_AmbientGround;
    float4 unity_IndirectSpecColor;
    float4 hlslcc_mtx4x4glstate_matrix_projection[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixInvV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    int unity_StereoEyeIndex;
    float4 unity_ShadowColor;
    float4 unity_FogColor;
    float4 unity_FogParams;
    float4 unity_LightmapST;
    float4 unity_DynamicLightmapST;
    float4 unity_SpecCube0_BoxMax;
    float4 unity_SpecCube0_BoxMin;
    float4 unity_SpecCube0_ProbePosition;
    float4 unity_SpecCube0_HDR;
    float4 unity_SpecCube1_BoxMax;
    float4 unity_SpecCube1_BoxMin;
    float4 unity_SpecCube1_ProbePosition;
    float4 unity_SpecCube1_HDR;
    float4 unity_ProbeVolumeParams;
    float4 hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[4];
    float3 unity_ProbeVolumeSizeInv;
    float3 unity_ProbeVolumeMin;
    float4 unity_Lightmap_HDR;
    float4 unity_DynamicLightmap_HDR;
    float4 _LightColor0;
    float4 _SpecColor;
    float _Tile;
    float _HeightDisplacement;
    float _NormalScale;
    float4 _ColorTint;
    float _MetallicStrength;
    float _SmoothnessStrength;
    float _EdgeLength;
    bool4 unity_MetaVertexControl;
    bool4 unity_MetaFragmentControl;
    int unity_VisualizationMode;
    float unity_OneOverOutputBoost;
    float unity_MaxOutputValue;
    float unity_UseLinearSpace;
    float4 _texcoord_ST;
};
struct Mtl_HullIn
{
    Mtl_VertexOut cp[3];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
kernel void patchKernel(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn vertexInput [[ stage_in ]],
    uint2 tID [[ thread_position_in_grid ]],
    ushort2 groupID [[ threadgroup_position_in_grid ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    constant Mtl_KernelPatchInfo &patchInfo [[ buffer(3) ]])
{
#pragma clang diagnostic pop
    Mtl_ControlPoint output;
    const uint numPatchesInThreadGroup = 10;
    const uint patchID = (tID.x / patchInfo.numControlPointsPerPatch);
    const bool patchValid = (patchID < patchInfo.numPatches);
    const uint mtl_BaseInstance = 0;
    const uint mtl_InstanceID = groupID.y - mtl_BaseInstance;
    const uint internalPatchID = mtl_InstanceID * patchInfo.numPatches + patchID;
    const uint patchIDInThreadGroup = (patchID % numPatchesInThreadGroup);
    const uint controlPointID = (tID.x % patchInfo.numControlPointsPerPatch);
    const uint mtl_BaseVertex = 0;
    const uint mtl_VertexID = ((mtl_InstanceID * (patchInfo.numControlPointsPerPatch * patchInfo.numPatches)) + tID.x) - mtl_BaseVertex;
    threadgroup Mtl_HullIn inputGroup[numPatchesInThreadGroup];
    threadgroup Mtl_HullIn &input = inputGroup[patchIDInThreadGroup];
    MTLTriangleTessellationFactorsHalf tessFactor;
    if (patchValid) {
        input.cp[controlPointID] = vertexFunction(vertexInput);
        output.INTERNALTESSPOS0 = input.cp[controlPointID].INTERNALTESSPOS0;
        output.TANGENT0 = input.cp[controlPointID].TANGENT0;
        output.NORMAL0 = input.cp[controlPointID].NORMAL0;
        output.TEXCOORD0 = input.cp[controlPointID].TEXCOORD0;
        output.TEXCOORD1 = input.cp[controlPointID].TEXCOORD1;
        output.TEXCOORD2 = input.cp[controlPointID].TEXCOORD2;
        output.TEXCOORD3 = input.cp[controlPointID].TEXCOORD3;
        output.COLOR0 = input.cp[controlPointID].COLOR0;
    }
    threadgroup_barrier(mem_flags::mem_threadgroup);
    if (!patchValid) {
        return;
    }
    float3 u_xlat0;
    float3 u_xlat1;
    float3 u_xlat2;
    float3 u_xlat3;
    float3 u_xlat4;
    float u_xlat12;
    float u_xlat13;
    // fork_phase2
    {
        u_xlat0.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[1].INTERNALTESSPOS0.yyy;
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[1].INTERNALTESSPOS0.xxx, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[1].INTERNALTESSPOS0.zzz, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[1].INTERNALTESSPOS0.www, u_xlat0.xyz);
        u_xlat1.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[2].INTERNALTESSPOS0.yyy;
        u_xlat1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[2].INTERNALTESSPOS0.xxx, u_xlat1.xyz);
        u_xlat1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[2].INTERNALTESSPOS0.zzz, u_xlat1.xyz);
        u_xlat1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[2].INTERNALTESSPOS0.www, u_xlat1.xyz);
        u_xlat2.xyz = u_xlat0.xyz + u_xlat1.xyz;
        u_xlat2.xyz = fma(u_xlat2.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat12 = dot(u_xlat2.xyz, u_xlat2.xyz);
        u_xlat12 = sqrt(u_xlat12);
        u_xlat12 = u_xlat12 * VGlobals._EdgeLength;
        u_xlat2.xyz = u_xlat0.xyz + (-u_xlat1.xyz);
        u_xlat13 = dot(u_xlat2.xyz, u_xlat2.xyz);
        u_xlat13 = sqrt(u_xlat13);
        u_xlat13 = u_xlat13 * VGlobals._ScreenParams.y;
        u_xlat12 = u_xlat13 / u_xlat12;
        tessFactor.edgeTessellationFactor[0] = max(u_xlat12, 1.0);
        u_xlat2.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[0].INTERNALTESSPOS0.yyy;
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[0].INTERNALTESSPOS0.xxx, u_xlat2.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[0].INTERNALTESSPOS0.zzz, u_xlat2.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[0].INTERNALTESSPOS0.www, u_xlat2.xyz);
        u_xlat3.xyz = u_xlat1.xyz + u_xlat2.xyz;
        u_xlat1.xyz = u_xlat1.xyz + (-u_xlat2.xyz);
        u_xlat12 = dot(u_xlat1.xyz, u_xlat1.xyz);
        u_xlat12 = sqrt(u_xlat12);
        u_xlat12 = u_xlat12 * VGlobals._ScreenParams.y;
        u_xlat1.xyz = fma(u_xlat3.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat1.x = dot(u_xlat1.xyz, u_xlat1.xyz);
        u_xlat1.x = sqrt(u_xlat1.x);
        u_xlat1.x = u_xlat1.x * VGlobals._EdgeLength;
        u_xlat12 = u_xlat12 / u_xlat1.x;
        tessFactor.edgeTessellationFactor[1] = max(u_xlat12, 1.0);
        u_xlat1.xyz = u_xlat0.xyz + u_xlat2.xyz;
        u_xlat0.xyz = (-u_xlat0.xyz) + u_xlat2.xyz;
        u_xlat0.x = dot(u_xlat0.xyz, u_xlat0.xyz);
        u_xlat0.x = sqrt(u_xlat0.x);
        u_xlat0.x = u_xlat0.x * VGlobals._ScreenParams.y;
        u_xlat4.xyz = fma(u_xlat1.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat4.x = dot(u_xlat4.xyz, u_xlat4.xyz);
        u_xlat4.x = sqrt(u_xlat4.x);
        u_xlat4.x = u_xlat4.x * VGlobals._EdgeLength;
        u_xlat0.x = u_xlat0.x / u_xlat4.x;
        tessFactor.edgeTessellationFactor[2] = max(u_xlat0.x, 1.0);
    }
    // join_phase3
    {
        u_xlat0.x = tessFactor.edgeTessellationFactor[0] + tessFactor.edgeTessellationFactor[1];
        u_xlat0.x = u_xlat0.x + tessFactor.edgeTessellationFactor[2];
        tessFactor.insideTessellationFactor = u_xlat0.x * 0.333333343;
    }
    controlPoints[mtl_VertexID] = output;
    tessFactors[internalPatchID] = tessFactor;
}
// SHADER_STAGE_HULL_end
// SHADER_STAGE_DOMAIN_begin
struct Mtl_VertexInPostTess
{
    patch_control_point<Mtl_ControlPointIn> cp;
};
struct Mtl_VertexOutPostTess
{
    float4 mtl_Position [[ position ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float4 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float4 TEXCOORD3 [[ user(TEXCOORD3) ]];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    sampler sampler_Height [[ sampler (0) ]],
    texture2d<float, access::sample > _Height [[ texture(0) ]] ,
    float3 mtl_TessCoord [[ position_in_patch ]],
    uint patchID [[ patch_id ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    Mtl_VertexInPostTess input [[ stage_in ]])
{
#pragma clang diagnostic pop
    Mtl_VertexOutPostTess output;
    MTLTriangleTessellationFactorsHalf tessFactor;
    tessFactor = tessFactors[patchID];
    float4 u_xlat0;
    float4 u_xlat1;
    float4 u_xlat2;
    float3 u_xlat3;
    float3 u_xlat4;
    float2 u_xlat13;
    float u_xlat15;
    bool u_xlatb15;
    u_xlat0.xy = mtl_TessCoord.yy * input.cp[1].TEXCOORD2.xy;
    u_xlat0.xy = fma(input.cp[0].TEXCOORD2.xy, mtl_TessCoord.xx, u_xlat0.xy);
    u_xlat0.xy = fma(input.cp[2].TEXCOORD2.xy, mtl_TessCoord.zz, u_xlat0.xy);
    u_xlat0.xy = fma(u_xlat0.xy, VGlobals.unity_DynamicLightmapST.xy, VGlobals.unity_DynamicLightmapST.zw);
    u_xlat1.xy = mtl_TessCoord.yy * input.cp[1].TEXCOORD1.xy;
    u_xlat1.xy = fma(input.cp[0].TEXCOORD1.xy, mtl_TessCoord.xx, u_xlat1.xy);
    u_xlat1.xy = fma(input.cp[2].TEXCOORD1.xy, mtl_TessCoord.zz, u_xlat1.xy);
    u_xlat1.xy = fma(u_xlat1.xy, VGlobals.unity_LightmapST.xy, VGlobals.unity_LightmapST.zw);
    u_xlat2 = mtl_TessCoord.yyyy * input.cp[1].INTERNALTESSPOS0;
    u_xlat2 = fma(input.cp[0].INTERNALTESSPOS0, mtl_TessCoord.xxxx, u_xlat2);
    u_xlat2 = fma(input.cp[2].INTERNALTESSPOS0, mtl_TessCoord.zzzz, u_xlat2);
    u_xlat3.xy = mtl_TessCoord.yy * input.cp[1].TEXCOORD0.xy;
    u_xlat3.xy = fma(input.cp[0].TEXCOORD0.xy, mtl_TessCoord.xx, u_xlat3.xy);
    u_xlat3.xy = fma(input.cp[2].TEXCOORD0.xy, mtl_TessCoord.zz, u_xlat3.xy);
    u_xlat13.xy = u_xlat3.xy * float2(VGlobals._Tile);
    output.TEXCOORD0.xy = fma(u_xlat3.xy, VGlobals._texcoord_ST.xy, VGlobals._texcoord_ST.zw);
    u_xlat3.xyz = _Height.sample(sampler_Height, u_xlat13.xy, level(1.0)).xyz;
    u_xlat4.xyz = mtl_TessCoord.yyy * input.cp[1].NORMAL0.xyz;
    u_xlat4.xyz = fma(input.cp[0].NORMAL0.xyz, mtl_TessCoord.xxx, u_xlat4.xyz);
    u_xlat4.xyz = fma(input.cp[2].NORMAL0.xyz, mtl_TessCoord.zzz, u_xlat4.xyz);
    u_xlat3.xyz = u_xlat3.xyz * u_xlat4.xyz;
    u_xlat2.xyz = fma(u_xlat3.xyz, float3(VGlobals._HeightDisplacement), u_xlat2.xyz);
    u_xlatb15 = 0.0<u_xlat2.z;
    u_xlat1.z = u_xlatb15 ? 9.99999975e-05 : float(0.0);
    u_xlat1.xyz = (VGlobals.unity_MetaVertexControl.x) ? u_xlat1.xyz : u_xlat2.xyz;
    u_xlatb15 = 0.0<u_xlat1.z;
    u_xlat0.z = u_xlatb15 ? 9.99999975e-05 : float(0.0);
    u_xlat0.xyz = (VGlobals.unity_MetaVertexControl.y) ? u_xlat0.xyz : u_xlat1.xyz;
    u_xlat1 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat0.xxxx, u_xlat1);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat0.zzzz, u_xlat1);
    output.mtl_Position = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_MatrixVP[3];
    u_xlat0.xyz = u_xlat2.yyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz;
    u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, u_xlat2.xxx, u_xlat0.xyz);
    u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, u_xlat2.zzz, u_xlat0.xyz);
    u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, u_xlat2.www, u_xlat0.xyz);
    output.TEXCOORD1.w = u_xlat0.x;
    u_xlat1.y = dot(u_xlat4.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat1.z = dot(u_xlat4.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat1.x = dot(u_xlat4.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat0.x = dot(u_xlat1.xyz, u_xlat1.xyz);
    u_xlat0.x = rsqrt(u_xlat0.x);
    u_xlat1.xyz = u_xlat0.xxx * u_xlat1.xyz;
    output.TEXCOORD1.z = u_xlat1.y;
    u_xlat2 = mtl_TessCoord.yyyy * input.cp[1].TANGENT0;
    u_xlat2 = fma(input.cp[0].TANGENT0, mtl_TessCoord.xxxx, u_xlat2);
    u_xlat2 = fma(input.cp[2].TANGENT0, mtl_TessCoord.zzzz, u_xlat2);
    u_xlat3.xyz = u_xlat2.yyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].yzx;
    u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].yzx, u_xlat2.xxx, u_xlat3.xyz);
    u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].yzx, u_xlat2.zzz, u_xlat3.xyz);
    u_xlat0.x = u_xlat2.w * VGlobals.unity_WorldTransformParams.w;
    u_xlat15 = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat15 = rsqrt(u_xlat15);
    u_xlat2.xyz = float3(u_xlat15) * u_xlat2.xyz;
    u_xlat3.xyz = u_xlat1.xyz * u_xlat2.xyz;
    u_xlat3.xyz = fma(u_xlat1.zxy, u_xlat2.yzx, (-u_xlat3.xyz));
    u_xlat3.xyz = u_xlat0.xxx * u_xlat3.xyz;
    output.TEXCOORD1.y = u_xlat3.x;
    output.TEXCOORD1.x = u_xlat2.z;
    output.TEXCOORD2.w = u_xlat0.y;
    output.TEXCOORD3.w = u_xlat0.z;
    output.TEXCOORD2.x = u_xlat2.x;
    output.TEXCOORD3.x = u_xlat2.y;
    output.TEXCOORD2.z = u_xlat1.z;
    output.TEXCOORD3.z = u_xlat1.x;
    output.TEXCOORD2.y = u_xlat3.y;
    output.TEXCOORD3.y = u_xlat3.z;
    return output;
}
// SHADER_STAGE_DOMAIN_end
Refreshing native plugins compatible for Editor in 2.52 ms, found 2 plugins.
Preloading 0 native plugins for Editor in 0.00 ms.
Unloading 3375 Unused Serialized files (Serialized files now loaded: 0)
Unloading 20 unused Assets / (0.6 MB). Loaded Objects now: 3886.
Memory consumption went from 136.3 MB to 135.7 MB.
Total: 6.236638 ms (FindLiveObjects: 0.546361 ms CreateObjectMapping: 0.529699 ms MarkObjects: 4.504384 ms  DeleteObjects: 0.654469 ms)

AssetImportParameters requested are different than current active one (requested -> active):
  custom:video-decoder-ogg-theora: a1e56fd34408186e4bbccfd4996cb3dc -> 
  custom:container-muxer-webm: aa71ff27fc2769a1b78a27578f13a17b -> 
  custom:container-demuxer-webm: 4f35f7cbe854078d1ac9338744f61a02 -> 
  custom:video-encoder-webm-vp8: eb34c28f22e8b96e1ab97ce403110664 -> 
  custom:framework-osx-AVFoundation: b23960f63f64bdc6ff669e2cdcee2391 -> 
  custom:audio-encoder-webm-vorbis: bf7c407c2cedff20999df2af8eb42d56 -> 
  custom:container-demuxer-ogg: 62fdf1f143b41e24485cea50d1cbac27 -> 
  custom:video-decoder-webm-vp8: 9c59270c3fd7afecdb556c50c9e8de78 -> 
  custom:audio-decoder-ogg-vorbis: bf7c407c2cedff20999df2af8eb42d56 -> 
========================================================================
Received Prepare
Registering precompiled user dll's ...
Registered in 0.003557 seconds.
Begin MonoManager ReloadAssembly
Symbol file LoadedFromMemory doesn't match image /Users/kamilaamendolagine/Desktop/Staugen Raug v2 - Prefab - Map 1.01/Library/PackageCache/com.unity.visualscripting@1.7.8/Editor/VisualScripting.Core/Dependencies/YamlDotNet/Unity.VisualScripting.YamlDotNet.dll
Symbol file LoadedFromMemory doesn't match image /Users/kamilaamendolagine/Desktop/Staugen Raug v2 - Prefab - Map 1.01/Library/PackageCache/com.unity.visualscripting@1.7.8/Editor/VisualScripting.Core/Dependencies/DotNetZip/Unity.VisualScripting.IonicZip.dll
Native extension for OSXStandalone target not found
Native extension for WebGL target not found
Refreshing native plugins compatible for Editor in 0.88 ms, found 2 plugins.
Preloading 0 native plugins for Editor in 0.00 ms.
Mono: successfully reloaded assembly
- Completed reload, in  1.766 seconds
Domain Reload Profiling:
	ReloadAssembly (1767ms)
		BeginReloadAssembly (206ms)
			ExecutionOrderSort (0ms)
			DisableScriptedObjects (10ms)
			BackupInstance (0ms)
			ReleaseScriptingObjects (0ms)
			CreateAndSetChildDomain (91ms)
		EndReloadAssembly (1392ms)
			LoadAssemblies (91ms)
			RebuildTransferFunctionScriptingTraits (0ms)
			SetupTypeCache (492ms)
			ReleaseScriptCaches (1ms)
			RebuildScriptCaches (73ms)
			SetupLoadedEditorAssemblies (638ms)
				LogAssemblyErrors (0ms)
				InitializePlatformSupportModulesInManaged (19ms)
				SetLoadedEditorAssemblies (1ms)
				RefreshPlugins (1ms)
				BeforeProcessingInitializeOnLoad (97ms)
				ProcessInitializeOnLoadAttributes (469ms)
				ProcessInitializeOnLoadMethodAttributes (46ms)
				AfterProcessingInitializeOnLoad (3ms)
				EditorAssembliesLoaded (0ms)
			ExecutionOrderSort2 (0ms)
			AwakeInstancesAfterBackupRestoration (8ms)
Platform modules already initialized, skipping
Compilation succeeded with: 

program_source:299:53: warning: writable resources in non-void post-tessellation vertex function
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
                                                    ^
program_source:305:30: note: writable buffer defined here
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
                             ^
program_source:306:48: note: writable buffer defined here
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
                                               ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float4 TEXCOORD0 [[ attribute(3) ]] ;
    float4 TEXCOORD1 [[ attribute(4) ]] ;
    float4 TEXCOORD2 [[ attribute(5) ]] ;
    float4 TEXCOORD3 [[ attribute(6) ]] ;
    float4 COLOR0 [[ attribute(7) ]] ;
};
struct Mtl_VertexOut
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float4 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float4 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float4 TEXCOORD3 [[ user(TEXCOORD3) ]];
    float4 COLOR0 [[ user(COLOR0) ]];
};
static Mtl_VertexOut vertexFunction(
    Mtl_VertexIn input)
{
    Mtl_VertexOut output;
    output.INTERNALTESSPOS0 = input.POSITION0;
    output.TANGENT0 = input.TANGENT0;
    output.NORMAL0.xyz = input.NORMAL0.xyz;
    output.TEXCOORD0 = input.TEXCOORD0;
    output.TEXCOORD1 = input.TEXCOORD1;
    output.TEXCOORD2 = input.TEXCOORD2;
    output.TEXCOORD3 = input.TEXCOORD3;
    output.COLOR0 = input.COLOR0;
    return output;
}
// SHADER_STAGE_HULL_begin
struct Mtl_ControlPoint
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float4 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float4 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float4 TEXCOORD3 [[ user(TEXCOORD3) ]];
    float4 COLOR0 [[ user(COLOR0) ]];
};
struct Mtl_ControlPointIn
{
    float4 INTERNALTESSPOS0 [[ attribute(8) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float4 TEXCOORD0 [[ attribute(3) ]] ;
    float4 TEXCOORD1 [[ attribute(4) ]] ;
    float4 TEXCOORD2 [[ attribute(5) ]] ;
    float4 TEXCOORD3 [[ attribute(6) ]] ;
    float4 COLOR0 [[ attribute(7) ]] ;
};
struct Mtl_KernelPatchInfo
{
    uint numPatches;
    ushort numControlPointsPerPatch;
};
struct VGlobals_Type
{
    float4 _Time;
    float4 _SinTime;
    float4 _CosTime;
    float4 unity_DeltaTime;
    float3 _WorldSpaceCameraPos;
    float4 _ProjectionParams;
    float4 _ScreenParams;
    float4 _ZBufferParams;
    float4 unity_OrthoParams;
    float4 unity_CameraWorldClipPlanes[6];
    float4 hlslcc_mtx4x4unity_CameraProjection[4];
    float4 hlslcc_mtx4x4unity_CameraInvProjection[4];
    float4 hlslcc_mtx4x4unity_WorldToCamera[4];
    float4 hlslcc_mtx4x4unity_CameraToWorld[4];
    float4 _WorldSpaceLightPos0;
    float4 _LightPositionRange;
    float4 _LightProjectionParams;
    float4 unity_4LightPosX0;
    float4 unity_4LightPosY0;
    float4 unity_4LightPosZ0;
    float4 unity_4LightAtten0;
    float4 unity_LightColor[8];
    float4 unity_LightPosition[8];
    float4 unity_LightAtten[8];
    float4 unity_SpotDirection[8];
    float4 unity_SHAr;
    float4 unity_SHAg;
    float4 unity_SHAb;
    float4 unity_SHBr;
    float4 unity_SHBg;
    float4 unity_SHBb;
    float4 unity_SHC;
    float4 unity_OcclusionMaskSelector;
    float4 unity_ProbesOcclusion;
    float3 unity_LightColor0;
    float3 unity_LightColor1;
    float3 unity_LightColor2;
    float3 unity_LightColor3;
    float4 unity_ShadowSplitSpheres[4];
    float4 unity_ShadowSplitSqRadii;
    float4 unity_LightShadowBias;
    float4 _LightSplitsNear;
    float4 _LightSplitsFar;
    float4 hlslcc_mtx4x4unity_WorldToShadow[16];
    float4 _LightShadowData;
    float4 unity_ShadowFadeCenterAndType;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 unity_LODFade;
    float4 unity_WorldTransformParams;
    float4 unity_RenderingLayer;
    float4 hlslcc_mtx4x4glstate_matrix_transpose_modelview0[4];
    float4 glstate_lightmodel_ambient;
    float4 unity_AmbientSky;
    float4 unity_AmbientEquator;
    float4 unity_AmbientGround;
    float4 unity_IndirectSpecColor;
    float4 hlslcc_mtx4x4glstate_matrix_projection[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixInvV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    int unity_StereoEyeIndex;
    float4 unity_ShadowColor;
    float4 unity_FogColor;
    float4 unity_FogParams;
    float4 unity_LightmapST;
    float4 unity_DynamicLightmapST;
    float4 unity_SpecCube0_BoxMax;
    float4 unity_SpecCube0_BoxMin;
    float4 unity_SpecCube0_ProbePosition;
    float4 unity_SpecCube0_HDR;
    float4 unity_SpecCube1_BoxMax;
    float4 unity_SpecCube1_BoxMin;
    float4 unity_SpecCube1_ProbePosition;
    float4 unity_SpecCube1_HDR;
    float4 unity_ProbeVolumeParams;
    float4 hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[4];
    float3 unity_ProbeVolumeSizeInv;
    float3 unity_ProbeVolumeMin;
    float4 unity_Lightmap_HDR;
    float4 unity_DynamicLightmap_HDR;
    float4 _LightColor0;
    float4 _SpecColor;
    float _Tile;
    float _HeightDisplacement;
    float _NormalScale;
    float4 _ColorTint;
    float _MetallicStrength;
    float _SmoothnessStrength;
    float _EdgeLength;
    float4 _texcoord_ST;
};
struct Mtl_HullIn
{
    Mtl_VertexOut cp[3];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
kernel void patchKernel(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn vertexInput [[ stage_in ]],
    uint2 tID [[ thread_position_in_grid ]],
    ushort2 groupID [[ threadgroup_position_in_grid ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    constant Mtl_KernelPatchInfo &patchInfo [[ buffer(3) ]])
{
#pragma clang diagnostic pop
    Mtl_ControlPoint output;
    const uint numPatchesInThreadGroup = 10;
    const uint patchID = (tID.x / patchInfo.numControlPointsPerPatch);
    const bool patchValid = (patchID < patchInfo.numPatches);
    const uint mtl_BaseInstance = 0;
    const uint mtl_InstanceID = groupID.y - mtl_BaseInstance;
    const uint internalPatchID = mtl_InstanceID * patchInfo.numPatches + patchID;
    const uint patchIDInThreadGroup = (patchID % numPatchesInThreadGroup);
    const uint controlPointID = (tID.x % patchInfo.numControlPointsPerPatch);
    const uint mtl_BaseVertex = 0;
    const uint mtl_VertexID = ((mtl_InstanceID * (patchInfo.numControlPointsPerPatch * patchInfo.numPatches)) + tID.x) - mtl_BaseVertex;
    threadgroup Mtl_HullIn inputGroup[numPatchesInThreadGroup];
    threadgroup Mtl_HullIn &input = inputGroup[patchIDInThreadGroup];
    MTLTriangleTessellationFactorsHalf tessFactor;
    if (patchValid) {
        input.cp[controlPointID] = vertexFunction(vertexInput);
        output.INTERNALTESSPOS0 = input.cp[controlPointID].INTERNALTESSPOS0;
        output.TANGENT0 = input.cp[controlPointID].TANGENT0;
        output.NORMAL0 = input.cp[controlPointID].NORMAL0;
        output.TEXCOORD0 = input.cp[controlPointID].TEXCOORD0;
        output.TEXCOORD1 = input.cp[controlPointID].TEXCOORD1;
        output.TEXCOORD2 = input.cp[controlPointID].TEXCOORD2;
        output.TEXCOORD3 = input.cp[controlPointID].TEXCOORD3;
        output.COLOR0 = input.cp[controlPointID].COLOR0;
    }
    threadgroup_barrier(mem_flags::mem_threadgroup);
    if (!patchValid) {
        return;
    }
    float3 u_xlat0;
    float3 u_xlat1;
    float3 u_xlat2;
    float3 u_xlat3;
    float3 u_xlat4;
    float u_xlat12;
    float u_xlat13;
    // fork_phase2
    {
        u_xlat0.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[1].INTERNALTESSPOS0.yyy;
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[1].INTERNALTESSPOS0.xxx, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[1].INTERNALTESSPOS0.zzz, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[1].INTERNALTESSPOS0.www, u_xlat0.xyz);
        u_xlat1.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[2].INTERNALTESSPOS0.yyy;
        u_xlat1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[2].INTERNALTESSPOS0.xxx, u_xlat1.xyz);
        u_xlat1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[2].INTERNALTESSPOS0.zzz, u_xlat1.xyz);
        u_xlat1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[2].INTERNALTESSPOS0.www, u_xlat1.xyz);
        u_xlat2.xyz = u_xlat0.xyz + u_xlat1.xyz;
        u_xlat2.xyz = fma(u_xlat2.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat12 = dot(u_xlat2.xyz, u_xlat2.xyz);
        u_xlat12 = sqrt(u_xlat12);
        u_xlat12 = u_xlat12 * VGlobals._EdgeLength;
        u_xlat2.xyz = u_xlat0.xyz + (-u_xlat1.xyz);
        u_xlat13 = dot(u_xlat2.xyz, u_xlat2.xyz);
        u_xlat13 = sqrt(u_xlat13);
        u_xlat13 = u_xlat13 * VGlobals._ScreenParams.y;
        u_xlat12 = u_xlat13 / u_xlat12;
        tessFactor.edgeTessellationFactor[0] = max(u_xlat12, 1.0);
        u_xlat2.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[0].INTERNALTESSPOS0.yyy;
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[0].INTERNALTESSPOS0.xxx, u_xlat2.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[0].INTERNALTESSPOS0.zzz, u_xlat2.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[0].INTERNALTESSPOS0.www, u_xlat2.xyz);
        u_xlat3.xyz = u_xlat1.xyz + u_xlat2.xyz;
        u_xlat1.xyz = u_xlat1.xyz + (-u_xlat2.xyz);
        u_xlat12 = dot(u_xlat1.xyz, u_xlat1.xyz);
        u_xlat12 = sqrt(u_xlat12);
        u_xlat12 = u_xlat12 * VGlobals._ScreenParams.y;
        u_xlat1.xyz = fma(u_xlat3.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat1.x = dot(u_xlat1.xyz, u_xlat1.xyz);
        u_xlat1.x = sqrt(u_xlat1.x);
        u_xlat1.x = u_xlat1.x * VGlobals._EdgeLength;
        u_xlat12 = u_xlat12 / u_xlat1.x;
        tessFactor.edgeTessellationFactor[1] = max(u_xlat12, 1.0);
        u_xlat1.xyz = u_xlat0.xyz + u_xlat2.xyz;
        u_xlat0.xyz = (-u_xlat0.xyz) + u_xlat2.xyz;
        u_xlat0.x = dot(u_xlat0.xyz, u_xlat0.xyz);
        u_xlat0.x = sqrt(u_xlat0.x);
        u_xlat0.x = u_xlat0.x * VGlobals._ScreenParams.y;
        u_xlat4.xyz = fma(u_xlat1.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat4.x = dot(u_xlat4.xyz, u_xlat4.xyz);
        u_xlat4.x = sqrt(u_xlat4.x);
        u_xlat4.x = u_xlat4.x * VGlobals._EdgeLength;
        u_xlat0.x = u_xlat0.x / u_xlat4.x;
        tessFactor.edgeTessellationFactor[2] = max(u_xlat0.x, 1.0);
    }
    // join_phase3
    {
        u_xlat0.x = tessFactor.edgeTessellationFactor[0] + tessFactor.edgeTessellationFactor[1];
        u_xlat0.x = u_xlat0.x + tessFactor.edgeTessellationFactor[2];
        tessFactor.insideTessellationFactor = u_xlat0.x * 0.333333343;
    }
    controlPoints[mtl_VertexID] = output;
    tessFactors[internalPatchID] = tessFactor;
}
// SHADER_STAGE_HULL_end
// SHADER_STAGE_DOMAIN_begin
struct Mtl_VertexInPostTess
{
    patch_control_point<Mtl_ControlPointIn> cp;
};
struct Mtl_VertexOutPostTess
{
    float4 mtl_Position [[ position ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float4 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float4 TEXCOORD3 [[ user(TEXCOORD3) ]];
    float4 TEXCOORD6 [[ user(TEXCOORD6) ]];
    float4 TEXCOORD7 [[ user(TEXCOORD7) ]];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    sampler sampler_Height [[ sampler (0) ]],
    texture2d<float, access::sample > _Height [[ texture(0) ]] ,
    float3 mtl_TessCoord [[ position_in_patch ]],
    uint patchID [[ patch_id ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    Mtl_VertexInPostTess input [[ stage_in ]])
{
#pragma clang diagnostic pop
    Mtl_VertexOutPostTess output;
    MTLTriangleTessellationFactorsHalf tessFactor;
    tessFactor = tessFactors[patchID];
    float4 u_xlat0;
    float4 u_xlat1;
    float4 u_xlat2;
    float4 u_xlat3;
    float2 u_xlat9;
    float u_xlat12;
    float u_xlat13;
    u_xlat0 = mtl_TessCoord.yyyy * input.cp[1].INTERNALTESSPOS0;
    u_xlat0 = fma(input.cp[0].INTERNALTESSPOS0, mtl_TessCoord.xxxx, u_xlat0);
    u_xlat0 = fma(input.cp[2].INTERNALTESSPOS0, mtl_TessCoord.zzzz, u_xlat0);
    u_xlat1.xy = mtl_TessCoord.yy * input.cp[1].TEXCOORD0.xy;
    u_xlat1.xy = fma(input.cp[0].TEXCOORD0.xy, mtl_TessCoord.xx, u_xlat1.xy);
    u_xlat1.xy = fma(input.cp[2].TEXCOORD0.xy, mtl_TessCoord.zz, u_xlat1.xy);
    u_xlat9.xy = u_xlat1.xy * float2(VGlobals._Tile);
    output.TEXCOORD0.xy = fma(u_xlat1.xy, VGlobals._texcoord_ST.xy, VGlobals._texcoord_ST.zw);
    u_xlat1.xyz = _Height.sample(sampler_Height, u_xlat9.xy, level(1.0)).xyz;
    u_xlat2.xyz = mtl_TessCoord.yyy * input.cp[1].NORMAL0.xyz;
    u_xlat2.xyz = fma(input.cp[0].NORMAL0.xyz, mtl_TessCoord.xxx, u_xlat2.xyz);
    u_xlat2.xyz = fma(input.cp[2].NORMAL0.xyz, mtl_TessCoord.zzz, u_xlat2.xyz);
    u_xlat1.xyz = u_xlat1.xyz * u_xlat2.xyz;
    u_xlat0.xyz = fma(u_xlat1.xyz, float3(VGlobals._HeightDisplacement), u_xlat0.xyz);
    u_xlat1 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], u_xlat0.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], u_xlat0.zzzz, u_xlat1);
    u_xlat3 = u_xlat1 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, u_xlat0.www, u_xlat1.xyz);
    u_xlat1 = u_xlat3.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat3.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat3.zzzz, u_xlat1);
    output.mtl_Position = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat3.wwww, u_xlat1);
    u_xlat1.y = dot(u_xlat2.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat1.z = dot(u_xlat2.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat1.x = dot(u_xlat2.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat12 = dot(u_xlat1.xyz, u_xlat1.xyz);
    u_xlat12 = rsqrt(u_xlat12);
    u_xlat1.xyz = float3(u_xlat12) * u_xlat1.xyz;
    output.TEXCOORD1.z = u_xlat1.y;
    u_xlat2 = mtl_TessCoord.yyyy * input.cp[1].TANGENT0;
    u_xlat2 = fma(input.cp[0].TANGENT0, mtl_TessCoord.xxxx, u_xlat2);
    u_xlat2 = fma(input.cp[2].TANGENT0, mtl_TessCoord.zzzz, u_xlat2);
    u_xlat3.xyz = u_xlat2.yyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].yzx;
    u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].yzx, u_xlat2.xxx, u_xlat3.xyz);
    u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].yzx, u_xlat2.zzz, u_xlat3.xyz);
    u_xlat12 = u_xlat2.w * VGlobals.unity_WorldTransformParams.w;
    u_xlat13 = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat13 = rsqrt(u_xlat13);
    u_xlat2.xyz = float3(u_xlat13) * u_xlat2.xyz;
    u_xlat3.xyz = u_xlat1.xyz * u_xlat2.xyz;
    u_xlat3.xyz = fma(u_xlat1.zxy, u_xlat2.yzx, (-u_xlat3.xyz));
    u_xlat3.xyz = float3(u_xlat12) * u_xlat3.xyz;
    output.TEXCOORD1.y = u_xlat3.x;
    output.TEXCOORD1.w = u_xlat0.x;
    output.TEXCOORD1.x = u_xlat2.z;
    output.TEXCOORD2.w = u_xlat0.y;
    output.TEXCOORD3.w = u_xlat0.z;
    output.TEXCOORD2.x = u_xlat2.x;
    output.TEXCOORD3.x = u_xlat2.y;
    output.TEXCOORD2.z = u_xlat1.z;
    output.TEXCOORD3.z = u_xlat1.x;
    output.TEXCOORD2.y = u_xlat3.y;
    output.TEXCOORD3.y = u_xlat3.z;
    output.TEXCOORD6 = float4(0.0, 0.0, 0.0, 0.0);
    output.TEXCOORD7 = float4(0.0, 0.0, 0.0, 0.0);
    return output;
}
// SHADER_STAGE_DOMAIN_end
Compilation succeeded with: 

program_source:301:53: warning: writable resources in non-void post-tessellation vertex function
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
                                                    ^
program_source:307:30: note: writable buffer defined here
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
                             ^
program_source:308:48: note: writable buffer defined here
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
                                               ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float4 TEXCOORD0 [[ attribute(3) ]] ;
    float4 TEXCOORD1 [[ attribute(4) ]] ;
    float4 TEXCOORD2 [[ attribute(5) ]] ;
    float4 TEXCOORD3 [[ attribute(6) ]] ;
    float4 COLOR0 [[ attribute(7) ]] ;
};
struct Mtl_VertexOut
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float4 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float4 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float4 TEXCOORD3 [[ user(TEXCOORD3) ]];
    float4 COLOR0 [[ user(COLOR0) ]];
};
static Mtl_VertexOut vertexFunction(
    Mtl_VertexIn input)
{
    Mtl_VertexOut output;
    output.INTERNALTESSPOS0 = input.POSITION0;
    output.TANGENT0 = input.TANGENT0;
    output.NORMAL0.xyz = input.NORMAL0.xyz;
    output.TEXCOORD0 = input.TEXCOORD0;
    output.TEXCOORD1 = input.TEXCOORD1;
    output.TEXCOORD2 = input.TEXCOORD2;
    output.TEXCOORD3 = input.TEXCOORD3;
    output.COLOR0 = input.COLOR0;
    return output;
}
// SHADER_STAGE_HULL_begin
struct Mtl_ControlPoint
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float4 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float4 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float4 TEXCOORD3 [[ user(TEXCOORD3) ]];
    float4 COLOR0 [[ user(COLOR0) ]];
};
struct Mtl_ControlPointIn
{
    float4 INTERNALTESSPOS0 [[ attribute(8) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float4 TEXCOORD0 [[ attribute(3) ]] ;
    float4 TEXCOORD1 [[ attribute(4) ]] ;
    float4 TEXCOORD2 [[ attribute(5) ]] ;
    float4 TEXCOORD3 [[ attribute(6) ]] ;
    float4 COLOR0 [[ attribute(7) ]] ;
};
struct Mtl_KernelPatchInfo
{
    uint numPatches;
    ushort numControlPointsPerPatch;
};
struct VGlobals_Type
{
    float4 _Time;
    float4 _SinTime;
    float4 _CosTime;
    float4 unity_DeltaTime;
    float3 _WorldSpaceCameraPos;
    float4 _ProjectionParams;
    float4 _ScreenParams;
    float4 _ZBufferParams;
    float4 unity_OrthoParams;
    float4 unity_CameraWorldClipPlanes[6];
    float4 hlslcc_mtx4x4unity_CameraProjection[4];
    float4 hlslcc_mtx4x4unity_CameraInvProjection[4];
    float4 hlslcc_mtx4x4unity_WorldToCamera[4];
    float4 hlslcc_mtx4x4unity_CameraToWorld[4];
    float4 _WorldSpaceLightPos0;
    float4 _LightPositionRange;
    float4 _LightProjectionParams;
    float4 unity_4LightPosX0;
    float4 unity_4LightPosY0;
    float4 unity_4LightPosZ0;
    float4 unity_4LightAtten0;
    float4 unity_LightColor[8];
    float4 unity_LightPosition[8];
    float4 unity_LightAtten[8];
    float4 unity_SpotDirection[8];
    float4 unity_SHAr;
    float4 unity_SHAg;
    float4 unity_SHAb;
    float4 unity_SHBr;
    float4 unity_SHBg;
    float4 unity_SHBb;
    float4 unity_SHC;
    float4 unity_OcclusionMaskSelector;
    float4 unity_ProbesOcclusion;
    float3 unity_LightColor0;
    float3 unity_LightColor1;
    float3 unity_LightColor2;
    float3 unity_LightColor3;
    float4 unity_ShadowSplitSpheres[4];
    float4 unity_ShadowSplitSqRadii;
    float4 unity_LightShadowBias;
    float4 _LightSplitsNear;
    float4 _LightSplitsFar;
    float4 hlslcc_mtx4x4unity_WorldToShadow[16];
    float4 _LightShadowData;
    float4 unity_ShadowFadeCenterAndType;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 unity_LODFade;
    float4 unity_WorldTransformParams;
    float4 unity_RenderingLayer;
    float4 hlslcc_mtx4x4glstate_matrix_transpose_modelview0[4];
    float4 glstate_lightmodel_ambient;
    float4 unity_AmbientSky;
    float4 unity_AmbientEquator;
    float4 unity_AmbientGround;
    float4 unity_IndirectSpecColor;
    float4 hlslcc_mtx4x4glstate_matrix_projection[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixInvV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    int unity_StereoEyeIndex;
    float4 unity_ShadowColor;
    float4 unity_FogColor;
    float4 unity_FogParams;
    float4 unity_LightmapST;
    float4 unity_DynamicLightmapST;
    float4 unity_SpecCube0_BoxMax;
    float4 unity_SpecCube0_BoxMin;
    float4 unity_SpecCube0_ProbePosition;
    float4 unity_SpecCube0_HDR;
    float4 unity_SpecCube1_BoxMax;
    float4 unity_SpecCube1_BoxMin;
    float4 unity_SpecCube1_ProbePosition;
    float4 unity_SpecCube1_HDR;
    float4 unity_ProbeVolumeParams;
    float4 hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[4];
    float3 unity_ProbeVolumeSizeInv;
    float3 unity_ProbeVolumeMin;
    float4 unity_Lightmap_HDR;
    float4 unity_DynamicLightmap_HDR;
    float4 _LightColor0;
    float4 _SpecColor;
    float4 hlslcc_mtx4x4unity_WorldToLight[4];
    float _Tile;
    float _HeightDisplacement;
    float _NormalScale;
    float4 _ColorTint;
    float _MetallicStrength;
    float _SmoothnessStrength;
    float _EdgeLength;
    float4 _texcoord_ST;
};
struct Mtl_HullIn
{
    Mtl_VertexOut cp[3];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
kernel void patchKernel(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn vertexInput [[ stage_in ]],
    uint2 tID [[ thread_position_in_grid ]],
    ushort2 groupID [[ threadgroup_position_in_grid ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    constant Mtl_KernelPatchInfo &patchInfo [[ buffer(3) ]])
{
#pragma clang diagnostic pop
    Mtl_ControlPoint output;
    const uint numPatchesInThreadGroup = 10;
    const uint patchID = (tID.x / patchInfo.numControlPointsPerPatch);
    const bool patchValid = (patchID < patchInfo.numPatches);
    const uint mtl_BaseInstance = 0;
    const uint mtl_InstanceID = groupID.y - mtl_BaseInstance;
    const uint internalPatchID = mtl_InstanceID * patchInfo.numPatches + patchID;
    const uint patchIDInThreadGroup = (patchID % numPatchesInThreadGroup);
    const uint controlPointID = (tID.x % patchInfo.numControlPointsPerPatch);
    const uint mtl_BaseVertex = 0;
    const uint mtl_VertexID = ((mtl_InstanceID * (patchInfo.numControlPointsPerPatch * patchInfo.numPatches)) + tID.x) - mtl_BaseVertex;
    threadgroup Mtl_HullIn inputGroup[numPatchesInThreadGroup];
    threadgroup Mtl_HullIn &input = inputGroup[patchIDInThreadGroup];
    MTLTriangleTessellationFactorsHalf tessFactor;
    if (patchValid) {
        input.cp[controlPointID] = vertexFunction(vertexInput);
        output.INTERNALTESSPOS0 = input.cp[controlPointID].INTERNALTESSPOS0;
        output.TANGENT0 = input.cp[controlPointID].TANGENT0;
        output.NORMAL0 = input.cp[controlPointID].NORMAL0;
        output.TEXCOORD0 = input.cp[controlPointID].TEXCOORD0;
        output.TEXCOORD1 = input.cp[controlPointID].TEXCOORD1;
        output.TEXCOORD2 = input.cp[controlPointID].TEXCOORD2;
        output.TEXCOORD3 = input.cp[controlPointID].TEXCOORD3;
        output.COLOR0 = input.cp[controlPointID].COLOR0;
    }
    threadgroup_barrier(mem_flags::mem_threadgroup);
    if (!patchValid) {
        return;
    }
    float3 u_xlat0;
    float3 u_xlat1;
    float3 u_xlat2;
    float3 u_xlat3;
    float3 u_xlat4;
    float u_xlat12;
    float u_xlat13;
    // fork_phase2
    {
        u_xlat0.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[1].INTERNALTESSPOS0.yyy;
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[1].INTERNALTESSPOS0.xxx, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[1].INTERNALTESSPOS0.zzz, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[1].INTERNALTESSPOS0.www, u_xlat0.xyz);
        u_xlat1.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[2].INTERNALTESSPOS0.yyy;
        u_xlat1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[2].INTERNALTESSPOS0.xxx, u_xlat1.xyz);
        u_xlat1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[2].INTERNALTESSPOS0.zzz, u_xlat1.xyz);
        u_xlat1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[2].INTERNALTESSPOS0.www, u_xlat1.xyz);
        u_xlat2.xyz = u_xlat0.xyz + u_xlat1.xyz;
        u_xlat2.xyz = fma(u_xlat2.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat12 = dot(u_xlat2.xyz, u_xlat2.xyz);
        u_xlat12 = sqrt(u_xlat12);
        u_xlat12 = u_xlat12 * VGlobals._EdgeLength;
        u_xlat2.xyz = u_xlat0.xyz + (-u_xlat1.xyz);
        u_xlat13 = dot(u_xlat2.xyz, u_xlat2.xyz);
        u_xlat13 = sqrt(u_xlat13);
        u_xlat13 = u_xlat13 * VGlobals._ScreenParams.y;
        u_xlat12 = u_xlat13 / u_xlat12;
        tessFactor.edgeTessellationFactor[0] = max(u_xlat12, 1.0);
        u_xlat2.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[0].INTERNALTESSPOS0.yyy;
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[0].INTERNALTESSPOS0.xxx, u_xlat2.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[0].INTERNALTESSPOS0.zzz, u_xlat2.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[0].INTERNALTESSPOS0.www, u_xlat2.xyz);
        u_xlat3.xyz = u_xlat1.xyz + u_xlat2.xyz;
        u_xlat1.xyz = u_xlat1.xyz + (-u_xlat2.xyz);
        u_xlat12 = dot(u_xlat1.xyz, u_xlat1.xyz);
        u_xlat12 = sqrt(u_xlat12);
        u_xlat12 = u_xlat12 * VGlobals._ScreenParams.y;
        u_xlat1.xyz = fma(u_xlat3.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat1.x = dot(u_xlat1.xyz, u_xlat1.xyz);
        u_xlat1.x = sqrt(u_xlat1.x);
        u_xlat1.x = u_xlat1.x * VGlobals._EdgeLength;
        u_xlat12 = u_xlat12 / u_xlat1.x;
        tessFactor.edgeTessellationFactor[1] = max(u_xlat12, 1.0);
        u_xlat1.xyz = u_xlat0.xyz + u_xlat2.xyz;
        u_xlat0.xyz = (-u_xlat0.xyz) + u_xlat2.xyz;
        u_xlat0.x = dot(u_xlat0.xyz, u_xlat0.xyz);
        u_xlat0.x = sqrt(u_xlat0.x);
        u_xlat0.x = u_xlat0.x * VGlobals._ScreenParams.y;
        u_xlat4.xyz = fma(u_xlat1.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat4.x = dot(u_xlat4.xyz, u_xlat4.xyz);
        u_xlat4.x = sqrt(u_xlat4.x);
        u_xlat4.x = u_xlat4.x * VGlobals._EdgeLength;
        u_xlat0.x = u_xlat0.x / u_xlat4.x;
        tessFactor.edgeTessellationFactor[2] = max(u_xlat0.x, 1.0);
    }
    // join_phase3
    {
        u_xlat0.x = tessFactor.edgeTessellationFactor[0] + tessFactor.edgeTessellationFactor[1];
        u_xlat0.x = u_xlat0.x + tessFactor.edgeTessellationFactor[2];
        tessFactor.insideTessellationFactor = u_xlat0.x * 0.333333343;
    }
    controlPoints[mtl_VertexID] = output;
    tessFactors[internalPatchID] = tessFactor;
}
// SHADER_STAGE_HULL_end
// SHADER_STAGE_DOMAIN_begin
struct Mtl_VertexInPostTess
{
    patch_control_point<Mtl_ControlPointIn> cp;
};
struct Mtl_VertexOutPostTess
{
    float4 mtl_Position [[ position ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float3 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float3 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float3 TEXCOORD3 [[ user(TEXCOORD3) ]];
    float3 TEXCOORD4 [[ user(TEXCOORD4) ]];
    float3 TEXCOORD5 [[ user(TEXCOORD5) ]];
    float4 TEXCOORD6 [[ user(TEXCOORD6) ]];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    sampler sampler_Height [[ sampler (0) ]],
    texture2d<float, access::sample > _Height [[ texture(0) ]] ,
    float3 mtl_TessCoord [[ position_in_patch ]],
    uint patchID [[ patch_id ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    Mtl_VertexInPostTess input [[ stage_in ]])
{
#pragma clang diagnostic pop
    Mtl_VertexOutPostTess output;
    MTLTriangleTessellationFactorsHalf tessFactor;
    tessFactor = tessFactors[patchID];
    float4 u_xlat0;
    float3 u_xlat1;
    float4 u_xlat2;
    float4 u_xlat3;
    float4 u_xlat4;
    float2 u_xlat10;
    float u_xlat16;
    u_xlat0.xy = mtl_TessCoord.yy * input.cp[1].TEXCOORD0.xy;
    u_xlat0.xy = fma(input.cp[0].TEXCOORD0.xy, mtl_TessCoord.xx, u_xlat0.xy);
    u_xlat0.xy = fma(input.cp[2].TEXCOORD0.xy, mtl_TessCoord.zz, u_xlat0.xy);
    u_xlat10.xy = u_xlat0.xy * float2(VGlobals._Tile);
    output.TEXCOORD0.xy = fma(u_xlat0.xy, VGlobals._texcoord_ST.xy, VGlobals._texcoord_ST.zw);
    u_xlat0.xyz = _Height.sample(sampler_Height, u_xlat10.xy, level(1.0)).xyz;
    u_xlat1.xyz = mtl_TessCoord.yyy * input.cp[1].NORMAL0.xyz;
    u_xlat1.xyz = fma(input.cp[0].NORMAL0.xyz, mtl_TessCoord.xxx, u_xlat1.xyz);
    u_xlat1.xyz = fma(input.cp[2].NORMAL0.xyz, mtl_TessCoord.zzz, u_xlat1.xyz);
    u_xlat0.xyz = u_xlat0.xyz * u_xlat1.xyz;
    u_xlat2 = mtl_TessCoord.yyyy * input.cp[1].INTERNALTESSPOS0;
    u_xlat2 = fma(input.cp[0].INTERNALTESSPOS0, mtl_TessCoord.xxxx, u_xlat2);
    u_xlat2 = fma(input.cp[2].INTERNALTESSPOS0, mtl_TessCoord.zzzz, u_xlat2);
    u_xlat0.xyz = fma(u_xlat0.xyz, float3(VGlobals._HeightDisplacement), u_xlat2.xyz);
    u_xlat3 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], u_xlat0.xxxx, u_xlat3);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], u_xlat0.zzzz, u_xlat3);
    u_xlat3 = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat4 = u_xlat3.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat4 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat3.xxxx, u_xlat4);
    u_xlat4 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat3.zzzz, u_xlat4);
    output.mtl_Position = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat3.wwww, u_xlat4);
    u_xlat2.y = dot(u_xlat1.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat2.z = dot(u_xlat1.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat2.x = dot(u_xlat1.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat1.x = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat1.x = rsqrt(u_xlat1.x);
    u_xlat1.xyz = u_xlat1.xxx * u_xlat2.xyz;
    output.TEXCOORD1.z = u_xlat1.y;
    u_xlat3 = mtl_TessCoord.yyyy * input.cp[1].TANGENT0;
    u_xlat3 = fma(input.cp[0].TANGENT0, mtl_TessCoord.xxxx, u_xlat3);
    u_xlat3 = fma(input.cp[2].TANGENT0, mtl_TessCoord.zzzz, u_xlat3);
    u_xlat2.xyz = u_xlat3.yyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].yzx;
    u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].yzx, u_xlat3.xxx, u_xlat2.xyz);
    u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].yzx, u_xlat3.zzz, u_xlat2.xyz);
    u_xlat16 = u_xlat3.w * VGlobals.unity_WorldTransformParams.w;
    u_xlat3.x = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat3.x = rsqrt(u_xlat3.x);
    u_xlat2.xyz = u_xlat2.xyz * u_xlat3.xxx;
    u_xlat3.xyz = u_xlat1.xyz * u_xlat2.xyz;
    u_xlat3.xyz = fma(u_xlat1.zxy, u_xlat2.yzx, (-u_xlat3.xyz));
    u_xlat3.xyz = float3(u_xlat16) * u_xlat3.xyz;
    output.TEXCOORD1.y = u_xlat3.x;
    output.TEXCOORD1.x = u_xlat2.z;
    output.TEXCOORD2.x = u_xlat2.x;
    output.TEXCOORD3.x = u_xlat2.y;
    output.TEXCOORD2.z = u_xlat1.z;
    output.TEXCOORD3.z = u_xlat1.x;
    output.TEXCOORD2.y = u_xlat3.y;
    output.TEXCOORD3.y = u_xlat3.z;
    output.TEXCOORD4.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, u_xlat2.www, u_xlat0.xyz);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3], u_xlat2.wwww, u_xlat0);
    u_xlat1.xyz = u_xlat0.yyy * VGlobals.hlslcc_mtx4x4unity_WorldToLight[1].xyz;
    u_xlat1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_WorldToLight[0].xyz, u_xlat0.xxx, u_xlat1.xyz);
    u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_WorldToLight[2].xyz, u_xlat0.zzz, u_xlat1.xyz);
    output.TEXCOORD5.xyz = fma(VGlobals.hlslcc_mtx4x4unity_WorldToLight[3].xyz, u_xlat0.www, u_xlat0.xyz);
    output.TEXCOORD6 = float4(0.0, 0.0, 0.0, 0.0);
    return output;
}
// SHADER_STAGE_DOMAIN_end
Compilation succeeded with: 

program_source:293:53: warning: writable resources in non-void post-tessellation vertex function
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
                                                    ^
program_source:299:30: note: writable buffer defined here
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
                             ^
program_source:300:48: note: writable buffer defined here
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
                                               ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float4 TEXCOORD0 [[ attribute(3) ]] ;
    float4 TEXCOORD1 [[ attribute(4) ]] ;
    float4 TEXCOORD2 [[ attribute(5) ]] ;
    float4 TEXCOORD3 [[ attribute(6) ]] ;
    float4 COLOR0 [[ attribute(7) ]] ;
};
struct Mtl_VertexOut
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float4 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float4 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float4 TEXCOORD3 [[ user(TEXCOORD3) ]];
    float4 COLOR0 [[ user(COLOR0) ]];
};
static Mtl_VertexOut vertexFunction(
    Mtl_VertexIn input)
{
    Mtl_VertexOut output;
    output.INTERNALTESSPOS0 = input.POSITION0;
    output.TANGENT0 = input.TANGENT0;
    output.NORMAL0.xyz = input.NORMAL0.xyz;
    output.TEXCOORD0 = input.TEXCOORD0;
    output.TEXCOORD1 = input.TEXCOORD1;
    output.TEXCOORD2 = input.TEXCOORD2;
    output.TEXCOORD3 = input.TEXCOORD3;
    output.COLOR0 = input.COLOR0;
    return output;
}
// SHADER_STAGE_HULL_begin
struct Mtl_ControlPoint
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float4 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float4 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float4 TEXCOORD3 [[ user(TEXCOORD3) ]];
    float4 COLOR0 [[ user(COLOR0) ]];
};
struct Mtl_ControlPointIn
{
    float4 INTERNALTESSPOS0 [[ attribute(8) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float4 TEXCOORD0 [[ attribute(3) ]] ;
    float4 TEXCOORD1 [[ attribute(4) ]] ;
    float4 TEXCOORD2 [[ attribute(5) ]] ;
    float4 TEXCOORD3 [[ attribute(6) ]] ;
    float4 COLOR0 [[ attribute(7) ]] ;
};
struct Mtl_KernelPatchInfo
{
    uint numPatches;
    ushort numControlPointsPerPatch;
};
struct VGlobals_Type
{
    float4 _Time;
    float4 _SinTime;
    float4 _CosTime;
    float4 unity_DeltaTime;
    float3 _WorldSpaceCameraPos;
    float4 _ProjectionParams;
    float4 _ScreenParams;
    float4 _ZBufferParams;
    float4 unity_OrthoParams;
    float4 unity_CameraWorldClipPlanes[6];
    float4 hlslcc_mtx4x4unity_CameraProjection[4];
    float4 hlslcc_mtx4x4unity_CameraInvProjection[4];
    float4 hlslcc_mtx4x4unity_WorldToCamera[4];
    float4 hlslcc_mtx4x4unity_CameraToWorld[4];
    float4 _WorldSpaceLightPos0;
    float4 _LightPositionRange;
    float4 _LightProjectionParams;
    float4 unity_4LightPosX0;
    float4 unity_4LightPosY0;
    float4 unity_4LightPosZ0;
    float4 unity_4LightAtten0;
    float4 unity_LightColor[8];
    float4 unity_LightPosition[8];
    float4 unity_LightAtten[8];
    float4 unity_SpotDirection[8];
    float4 unity_SHAr;
    float4 unity_SHAg;
    float4 unity_SHAb;
    float4 unity_SHBr;
    float4 unity_SHBg;
    float4 unity_SHBb;
    float4 unity_SHC;
    float4 unity_OcclusionMaskSelector;
    float4 unity_ProbesOcclusion;
    float3 unity_LightColor0;
    float3 unity_LightColor1;
    float3 unity_LightColor2;
    float3 unity_LightColor3;
    float4 unity_ShadowSplitSpheres[4];
    float4 unity_ShadowSplitSqRadii;
    float4 unity_LightShadowBias;
    float4 _LightSplitsNear;
    float4 _LightSplitsFar;
    float4 hlslcc_mtx4x4unity_WorldToShadow[16];
    float4 _LightShadowData;
    float4 unity_ShadowFadeCenterAndType;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 unity_LODFade;
    float4 unity_WorldTransformParams;
    float4 unity_RenderingLayer;
    float4 hlslcc_mtx4x4glstate_matrix_transpose_modelview0[4];
    float4 glstate_lightmodel_ambient;
    float4 unity_AmbientSky;
    float4 unity_AmbientEquator;
    float4 unity_AmbientGround;
    float4 unity_IndirectSpecColor;
    float4 hlslcc_mtx4x4glstate_matrix_projection[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixInvV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    int unity_StereoEyeIndex;
    float4 unity_ShadowColor;
    float4 unity_FogColor;
    float4 unity_FogParams;
    float4 unity_LightmapST;
    float4 unity_DynamicLightmapST;
    float4 unity_SpecCube0_BoxMax;
    float4 unity_SpecCube0_BoxMin;
    float4 unity_SpecCube0_ProbePosition;
    float4 unity_SpecCube0_HDR;
    float4 unity_SpecCube1_BoxMax;
    float4 unity_SpecCube1_BoxMin;
    float4 unity_SpecCube1_ProbePosition;
    float4 unity_SpecCube1_HDR;
    float4 unity_ProbeVolumeParams;
    float4 hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[4];
    float3 unity_ProbeVolumeSizeInv;
    float3 unity_ProbeVolumeMin;
    float4 unity_Lightmap_HDR;
    float4 unity_DynamicLightmap_HDR;
    float4 _LightColor0;
    float4 _SpecColor;
    float _Tile;
    float _HeightDisplacement;
    float _NormalScale;
    float4 _ColorTint;
    float _MetallicStrength;
    float _SmoothnessStrength;
    float _EdgeLength;
};
struct Mtl_HullIn
{
    Mtl_VertexOut cp[3];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
kernel void patchKernel(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn vertexInput [[ stage_in ]],
    uint2 tID [[ thread_position_in_grid ]],
    ushort2 groupID [[ threadgroup_position_in_grid ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    constant Mtl_KernelPatchInfo &patchInfo [[ buffer(3) ]])
{
#pragma clang diagnostic pop
    Mtl_ControlPoint output;
    const uint numPatchesInThreadGroup = 10;
    const uint patchID = (tID.x / patchInfo.numControlPointsPerPatch);
    const bool patchValid = (patchID < patchInfo.numPatches);
    const uint mtl_BaseInstance = 0;
    const uint mtl_InstanceID = groupID.y - mtl_BaseInstance;
    const uint internalPatchID = mtl_InstanceID * patchInfo.numPatches + patchID;
    const uint patchIDInThreadGroup = (patchID % numPatchesInThreadGroup);
    const uint controlPointID = (tID.x % patchInfo.numControlPointsPerPatch);
    const uint mtl_BaseVertex = 0;
    const uint mtl_VertexID = ((mtl_InstanceID * (patchInfo.numControlPointsPerPatch * patchInfo.numPatches)) + tID.x) - mtl_BaseVertex;
    threadgroup Mtl_HullIn inputGroup[numPatchesInThreadGroup];
    threadgroup Mtl_HullIn &input = inputGroup[patchIDInThreadGroup];
    MTLTriangleTessellationFactorsHalf tessFactor;
    if (patchValid) {
        input.cp[controlPointID] = vertexFunction(vertexInput);
        output.INTERNALTESSPOS0 = input.cp[controlPointID].INTERNALTESSPOS0;
        output.TANGENT0 = input.cp[controlPointID].TANGENT0;
        output.NORMAL0 = input.cp[controlPointID].NORMAL0;
        output.TEXCOORD0 = input.cp[controlPointID].TEXCOORD0;
        output.TEXCOORD1 = input.cp[controlPointID].TEXCOORD1;
        output.TEXCOORD2 = input.cp[controlPointID].TEXCOORD2;
        output.TEXCOORD3 = input.cp[controlPointID].TEXCOORD3;
        output.COLOR0 = input.cp[controlPointID].COLOR0;
    }
    threadgroup_barrier(mem_flags::mem_threadgroup);
    if (!patchValid) {
        return;
    }
    float3 u_xlat0;
    float3 u_xlat1;
    float3 u_xlat2;
    float3 u_xlat3;
    float3 u_xlat4;
    float u_xlat12;
    float u_xlat13;
    // fork_phase2
    {
        u_xlat0.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[1].INTERNALTESSPOS0.yyy;
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[1].INTERNALTESSPOS0.xxx, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[1].INTERNALTESSPOS0.zzz, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[1].INTERNALTESSPOS0.www, u_xlat0.xyz);
        u_xlat1.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[2].INTERNALTESSPOS0.yyy;
        u_xlat1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[2].INTERNALTESSPOS0.xxx, u_xlat1.xyz);
        u_xlat1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[2].INTERNALTESSPOS0.zzz, u_xlat1.xyz);
        u_xlat1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[2].INTERNALTESSPOS0.www, u_xlat1.xyz);
        u_xlat2.xyz = u_xlat0.xyz + u_xlat1.xyz;
        u_xlat2.xyz = fma(u_xlat2.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat12 = dot(u_xlat2.xyz, u_xlat2.xyz);
        u_xlat12 = sqrt(u_xlat12);
        u_xlat12 = u_xlat12 * VGlobals._EdgeLength;
        u_xlat2.xyz = u_xlat0.xyz + (-u_xlat1.xyz);
        u_xlat13 = dot(u_xlat2.xyz, u_xlat2.xyz);
        u_xlat13 = sqrt(u_xlat13);
        u_xlat13 = u_xlat13 * VGlobals._ScreenParams.y;
        u_xlat12 = u_xlat13 / u_xlat12;
        tessFactor.edgeTessellationFactor[0] = max(u_xlat12, 1.0);
        u_xlat2.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[0].INTERNALTESSPOS0.yyy;
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[0].INTERNALTESSPOS0.xxx, u_xlat2.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[0].INTERNALTESSPOS0.zzz, u_xlat2.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[0].INTERNALTESSPOS0.www, u_xlat2.xyz);
        u_xlat3.xyz = u_xlat1.xyz + u_xlat2.xyz;
        u_xlat1.xyz = u_xlat1.xyz + (-u_xlat2.xyz);
        u_xlat12 = dot(u_xlat1.xyz, u_xlat1.xyz);
        u_xlat12 = sqrt(u_xlat12);
        u_xlat12 = u_xlat12 * VGlobals._ScreenParams.y;
        u_xlat1.xyz = fma(u_xlat3.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat1.x = dot(u_xlat1.xyz, u_xlat1.xyz);
        u_xlat1.x = sqrt(u_xlat1.x);
        u_xlat1.x = u_xlat1.x * VGlobals._EdgeLength;
        u_xlat12 = u_xlat12 / u_xlat1.x;
        tessFactor.edgeTessellationFactor[1] = max(u_xlat12, 1.0);
        u_xlat1.xyz = u_xlat0.xyz + u_xlat2.xyz;
        u_xlat0.xyz = (-u_xlat0.xyz) + u_xlat2.xyz;
        u_xlat0.x = dot(u_xlat0.xyz, u_xlat0.xyz);
        u_xlat0.x = sqrt(u_xlat0.x);
        u_xlat0.x = u_xlat0.x * VGlobals._ScreenParams.y;
        u_xlat4.xyz = fma(u_xlat1.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat4.x = dot(u_xlat4.xyz, u_xlat4.xyz);
        u_xlat4.x = sqrt(u_xlat4.x);
        u_xlat4.x = u_xlat4.x * VGlobals._EdgeLength;
        u_xlat0.x = u_xlat0.x / u_xlat4.x;
        tessFactor.edgeTessellationFactor[2] = max(u_xlat0.x, 1.0);
    }
    // join_phase3
    {
        u_xlat0.x = tessFactor.edgeTessellationFactor[0] + tessFactor.edgeTessellationFactor[1];
        u_xlat0.x = u_xlat0.x + tessFactor.edgeTessellationFactor[2];
        tessFactor.insideTessellationFactor = u_xlat0.x * 0.333333343;
    }
    controlPoints[mtl_VertexID] = output;
    tessFactors[internalPatchID] = tessFactor;
}
// SHADER_STAGE_HULL_end
// SHADER_STAGE_DOMAIN_begin
struct Mtl_VertexInPostTess
{
    patch_control_point<Mtl_ControlPointIn> cp;
};
struct Mtl_VertexOutPostTess
{
    float4 mtl_Position [[ position ]];
    float3 TEXCOORD1 [[ user(TEXCOORD1) ]];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    sampler sampler_Height [[ sampler (0) ]],
    texture2d<float, access::sample > _Height [[ texture(0) ]] ,
    float3 mtl_TessCoord [[ position_in_patch ]],
    uint patchID [[ patch_id ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    Mtl_VertexInPostTess input [[ stage_in ]])
{
#pragma clang diagnostic pop
    Mtl_VertexOutPostTess output;
    MTLTriangleTessellationFactorsHalf tessFactor;
    tessFactor = tessFactors[patchID];
    float4 u_xlat0;
    float4 u_xlat1;
    float4 u_xlat2;
    float4 u_xlat3;
    float4 u_xlat4;
    float u_xlat11;
    float u_xlat15;
    bool u_xlatb15;
    u_xlat0.xyz = mtl_TessCoord.yyy * input.cp[1].NORMAL0.xyz;
    u_xlat0.xyz = fma(input.cp[0].NORMAL0.xyz, mtl_TessCoord.xxx, u_xlat0.xyz);
    u_xlat0.xyz = fma(input.cp[2].NORMAL0.xyz, mtl_TessCoord.zzz, u_xlat0.xyz);
    u_xlat1.x = dot(u_xlat0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat1.y = dot(u_xlat0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat1.z = dot(u_xlat0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat15 = dot(u_xlat1.xyz, u_xlat1.xyz);
    u_xlat15 = rsqrt(u_xlat15);
    u_xlat1.xyz = float3(u_xlat15) * u_xlat1.xyz;
    u_xlat2.xy = mtl_TessCoord.yy * input.cp[1].TEXCOORD0.xy;
    u_xlat2.xy = fma(input.cp[0].TEXCOORD0.xy, mtl_TessCoord.xx, u_xlat2.xy);
    u_xlat2.xy = fma(input.cp[2].TEXCOORD0.xy, mtl_TessCoord.zz, u_xlat2.xy);
    u_xlat2.xy = u_xlat2.xy * float2(VGlobals._Tile);
    u_xlat2.xyz = _Height.sample(sampler_Height, u_xlat2.xy, level(1.0)).xyz;
    u_xlat0.xyz = u_xlat0.xyz * u_xlat2.xyz;
    u_xlat2 = mtl_TessCoord.yyyy * input.cp[1].INTERNALTESSPOS0;
    u_xlat2 = fma(input.cp[0].INTERNALTESSPOS0, mtl_TessCoord.xxxx, u_xlat2);
    u_xlat2 = fma(input.cp[2].INTERNALTESSPOS0, mtl_TessCoord.zzzz, u_xlat2);
    u_xlat0.xyz = fma(u_xlat0.xyz, float3(VGlobals._HeightDisplacement), u_xlat2.xyz);
    u_xlat3 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], u_xlat0.xxxx, u_xlat3);
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], u_xlat0.zzzz, u_xlat3);
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3], u_xlat2.wwww, u_xlat3);
    u_xlat2.xyz = fma((-u_xlat3.xyz), VGlobals._WorldSpaceLightPos0.www, VGlobals._WorldSpaceLightPos0.xyz);
    u_xlat15 = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat15 = rsqrt(u_xlat15);
    u_xlat2.xyz = float3(u_xlat15) * u_xlat2.xyz;
    u_xlat15 = dot(u_xlat1.xyz, u_xlat2.xyz);
    u_xlat15 = fma((-u_xlat15), u_xlat15, 1.0);
    u_xlat15 = sqrt(u_xlat15);
    u_xlat15 = u_xlat15 * VGlobals.unity_LightShadowBias.z;
    u_xlat1.xyz = fma((-u_xlat1.xyz), float3(u_xlat15), u_xlat3.xyz);
    u_xlatb15 = VGlobals.unity_LightShadowBias.z!=0.0;
    u_xlat1.xyz = (bool(u_xlatb15)) ? u_xlat1.xyz : u_xlat3.xyz;
    u_xlat4 = u_xlat1.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat4 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat1.xxxx, u_xlat4);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat1.zzzz, u_xlat4);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat3.wwww, u_xlat1);
    u_xlat15 = VGlobals.unity_LightShadowBias.x / u_xlat1.w;
    u_xlat15 = min(u_xlat15, 0.0);
    u_xlat15 = max(u_xlat15, -1.0);
    u_xlat15 = u_xlat15 + u_xlat1.z;
    u_xlat11 = min(u_xlat1.w, u_xlat15);
    output.mtl_Position.xyw = u_xlat1.xyw;
    u_xlat1.x = (-u_xlat15) + u_xlat11;
    output.mtl_Position.z = fma(VGlobals.unity_LightShadowBias.y, u_xlat1.x, u_xlat15);
    u_xlat1.xyz = u_xlat0.yyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz;
    u_xlat0.xyw = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, u_xlat0.xxx, u_xlat1.xyz);
    u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, u_xlat0.zzz, u_xlat0.xyw);
    output.TEXCOORD1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, u_xlat2.www, u_xlat0.xyz);
    return output;
}
// SHADER_STAGE_DOMAIN_end
Compilation succeeded with: 

program_source:299:53: warning: writable resources in non-void post-tessellation vertex function
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
                                                    ^
program_source:305:30: note: writable buffer defined here
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
                             ^
program_source:306:48: note: writable buffer defined here
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
                                               ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float4 TEXCOORD0 [[ attribute(3) ]] ;
    float4 TEXCOORD1 [[ attribute(4) ]] ;
    float4 TEXCOORD2 [[ attribute(5) ]] ;
    float4 TEXCOORD3 [[ attribute(6) ]] ;
    float4 COLOR0 [[ attribute(7) ]] ;
};
struct Mtl_VertexOut
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float4 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float4 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float4 TEXCOORD3 [[ user(TEXCOORD3) ]];
    float4 COLOR0 [[ user(COLOR0) ]];
};
static Mtl_VertexOut vertexFunction(
    Mtl_VertexIn input)
{
    Mtl_VertexOut output;
    output.INTERNALTESSPOS0 = input.POSITION0;
    output.TANGENT0 = input.TANGENT0;
    output.NORMAL0.xyz = input.NORMAL0.xyz;
    output.TEXCOORD0 = input.TEXCOORD0;
    output.TEXCOORD1 = input.TEXCOORD1;
    output.TEXCOORD2 = input.TEXCOORD2;
    output.TEXCOORD3 = input.TEXCOORD3;
    output.COLOR0 = input.COLOR0;
    return output;
}
// SHADER_STAGE_HULL_begin
struct Mtl_ControlPoint
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float4 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float4 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float4 TEXCOORD3 [[ user(TEXCOORD3) ]];
    float4 COLOR0 [[ user(COLOR0) ]];
};
struct Mtl_ControlPointIn
{
    float4 INTERNALTESSPOS0 [[ attribute(8) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float4 TEXCOORD0 [[ attribute(3) ]] ;
    float4 TEXCOORD1 [[ attribute(4) ]] ;
    float4 TEXCOORD2 [[ attribute(5) ]] ;
    float4 TEXCOORD3 [[ attribute(6) ]] ;
    float4 COLOR0 [[ attribute(7) ]] ;
};
struct Mtl_KernelPatchInfo
{
    uint numPatches;
    ushort numControlPointsPerPatch;
};
struct VGlobals_Type
{
    float4 _Time;
    float4 _SinTime;
    float4 _CosTime;
    float4 unity_DeltaTime;
    float3 _WorldSpaceCameraPos;
    float4 _ProjectionParams;
    float4 _ScreenParams;
    float4 _ZBufferParams;
    float4 unity_OrthoParams;
    float4 unity_CameraWorldClipPlanes[6];
    float4 hlslcc_mtx4x4unity_CameraProjection[4];
    float4 hlslcc_mtx4x4unity_CameraInvProjection[4];
    float4 hlslcc_mtx4x4unity_WorldToCamera[4];
    float4 hlslcc_mtx4x4unity_CameraToWorld[4];
    float4 _WorldSpaceLightPos0;
    float4 _LightPositionRange;
    float4 _LightProjectionParams;
    float4 unity_4LightPosX0;
    float4 unity_4LightPosY0;
    float4 unity_4LightPosZ0;
    float4 unity_4LightAtten0;
    float4 unity_LightColor[8];
    float4 unity_LightPosition[8];
    float4 unity_LightAtten[8];
    float4 unity_SpotDirection[8];
    float4 unity_SHAr;
    float4 unity_SHAg;
    float4 unity_SHAb;
    float4 unity_SHBr;
    float4 unity_SHBg;
    float4 unity_SHBb;
    float4 unity_SHC;
    float4 unity_OcclusionMaskSelector;
    float4 unity_ProbesOcclusion;
    float3 unity_LightColor0;
    float3 unity_LightColor1;
    float3 unity_LightColor2;
    float3 unity_LightColor3;
    float4 unity_ShadowSplitSpheres[4];
    float4 unity_ShadowSplitSqRadii;
    float4 unity_LightShadowBias;
    float4 _LightSplitsNear;
    float4 _LightSplitsFar;
    float4 hlslcc_mtx4x4unity_WorldToShadow[16];
    float4 _LightShadowData;
    float4 unity_ShadowFadeCenterAndType;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 unity_LODFade;
    float4 unity_WorldTransformParams;
    float4 unity_RenderingLayer;
    float4 hlslcc_mtx4x4glstate_matrix_transpose_modelview0[4];
    float4 glstate_lightmodel_ambient;
    float4 unity_AmbientSky;
    float4 unity_AmbientEquator;
    float4 unity_AmbientGround;
    float4 unity_IndirectSpecColor;
    float4 hlslcc_mtx4x4glstate_matrix_projection[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixInvV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    int unity_StereoEyeIndex;
    float4 unity_ShadowColor;
    float4 unity_FogColor;
    float4 unity_FogParams;
    float4 unity_LightmapST;
    float4 unity_DynamicLightmapST;
    float4 unity_SpecCube0_BoxMax;
    float4 unity_SpecCube0_BoxMin;
    float4 unity_SpecCube0_ProbePosition;
    float4 unity_SpecCube0_HDR;
    float4 unity_SpecCube1_BoxMax;
    float4 unity_SpecCube1_BoxMin;
    float4 unity_SpecCube1_ProbePosition;
    float4 unity_SpecCube1_HDR;
    float4 unity_ProbeVolumeParams;
    float4 hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[4];
    float3 unity_ProbeVolumeSizeInv;
    float3 unity_ProbeVolumeMin;
    float4 unity_Lightmap_HDR;
    float4 unity_DynamicLightmap_HDR;
    float4 _LightColor0;
    float4 _SpecColor;
    float _Tile;
    float _HeightDisplacement;
    float _NormalScale;
    float4 _ColorTint;
    float _MetallicStrength;
    float _SmoothnessStrength;
    float _EdgeLength;
    float4 _texcoord_ST;
    float4 unity_Ambient;
};
struct Mtl_HullIn
{
    Mtl_VertexOut cp[3];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
kernel void patchKernel(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn vertexInput [[ stage_in ]],
    uint2 tID [[ thread_position_in_grid ]],
    ushort2 groupID [[ threadgroup_position_in_grid ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    constant Mtl_KernelPatchInfo &patchInfo [[ buffer(3) ]])
{
#pragma clang diagnostic pop
    Mtl_ControlPoint output;
    const uint numPatchesInThreadGroup = 10;
    const uint patchID = (tID.x / patchInfo.numControlPointsPerPatch);
    const bool patchValid = (patchID < patchInfo.numPatches);
    const uint mtl_BaseInstance = 0;
    const uint mtl_InstanceID = groupID.y - mtl_BaseInstance;
    const uint internalPatchID = mtl_InstanceID * patchInfo.numPatches + patchID;
    const uint patchIDInThreadGroup = (patchID % numPatchesInThreadGroup);
    const uint controlPointID = (tID.x % patchInfo.numControlPointsPerPatch);
    const uint mtl_BaseVertex = 0;
    const uint mtl_VertexID = ((mtl_InstanceID * (patchInfo.numControlPointsPerPatch * patchInfo.numPatches)) + tID.x) - mtl_BaseVertex;
    threadgroup Mtl_HullIn inputGroup[numPatchesInThreadGroup];
    threadgroup Mtl_HullIn &input = inputGroup[patchIDInThreadGroup];
    MTLTriangleTessellationFactorsHalf tessFactor;
    if (patchValid) {
        input.cp[controlPointID] = vertexFunction(vertexInput);
        output.INTERNALTESSPOS0 = input.cp[controlPointID].INTERNALTESSPOS0;
        output.TANGENT0 = input.cp[controlPointID].TANGENT0;
        output.NORMAL0 = input.cp[controlPointID].NORMAL0;
        output.TEXCOORD0 = input.cp[controlPointID].TEXCOORD0;
        output.TEXCOORD1 = input.cp[controlPointID].TEXCOORD1;
        output.TEXCOORD2 = input.cp[controlPointID].TEXCOORD2;
        output.TEXCOORD3 = input.cp[controlPointID].TEXCOORD3;
        output.COLOR0 = input.cp[controlPointID].COLOR0;
    }
    threadgroup_barrier(mem_flags::mem_threadgroup);
    if (!patchValid) {
        return;
    }
    float3 u_xlat0;
    float3 u_xlat1;
    float3 u_xlat2;
    float3 u_xlat3;
    float3 u_xlat4;
    float u_xlat12;
    float u_xlat13;
    // fork_phase2
    {
        u_xlat0.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[1].INTERNALTESSPOS0.yyy;
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[1].INTERNALTESSPOS0.xxx, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[1].INTERNALTESSPOS0.zzz, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[1].INTERNALTESSPOS0.www, u_xlat0.xyz);
        u_xlat1.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[2].INTERNALTESSPOS0.yyy;
        u_xlat1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[2].INTERNALTESSPOS0.xxx, u_xlat1.xyz);
        u_xlat1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[2].INTERNALTESSPOS0.zzz, u_xlat1.xyz);
        u_xlat1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[2].INTERNALTESSPOS0.www, u_xlat1.xyz);
        u_xlat2.xyz = u_xlat0.xyz + u_xlat1.xyz;
        u_xlat2.xyz = fma(u_xlat2.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat12 = dot(u_xlat2.xyz, u_xlat2.xyz);
        u_xlat12 = sqrt(u_xlat12);
        u_xlat12 = u_xlat12 * VGlobals._EdgeLength;
        u_xlat2.xyz = u_xlat0.xyz + (-u_xlat1.xyz);
        u_xlat13 = dot(u_xlat2.xyz, u_xlat2.xyz);
        u_xlat13 = sqrt(u_xlat13);
        u_xlat13 = u_xlat13 * VGlobals._ScreenParams.y;
        u_xlat12 = u_xlat13 / u_xlat12;
        tessFactor.edgeTessellationFactor[0] = max(u_xlat12, 1.0);
        u_xlat2.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[0].INTERNALTESSPOS0.yyy;
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[0].INTERNALTESSPOS0.xxx, u_xlat2.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[0].INTERNALTESSPOS0.zzz, u_xlat2.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[0].INTERNALTESSPOS0.www, u_xlat2.xyz);
        u_xlat3.xyz = u_xlat1.xyz + u_xlat2.xyz;
        u_xlat1.xyz = u_xlat1.xyz + (-u_xlat2.xyz);
        u_xlat12 = dot(u_xlat1.xyz, u_xlat1.xyz);
        u_xlat12 = sqrt(u_xlat12);
        u_xlat12 = u_xlat12 * VGlobals._ScreenParams.y;
        u_xlat1.xyz = fma(u_xlat3.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat1.x = dot(u_xlat1.xyz, u_xlat1.xyz);
        u_xlat1.x = sqrt(u_xlat1.x);
        u_xlat1.x = u_xlat1.x * VGlobals._EdgeLength;
        u_xlat12 = u_xlat12 / u_xlat1.x;
        tessFactor.edgeTessellationFactor[1] = max(u_xlat12, 1.0);
        u_xlat1.xyz = u_xlat0.xyz + u_xlat2.xyz;
        u_xlat0.xyz = (-u_xlat0.xyz) + u_xlat2.xyz;
        u_xlat0.x = dot(u_xlat0.xyz, u_xlat0.xyz);
        u_xlat0.x = sqrt(u_xlat0.x);
        u_xlat0.x = u_xlat0.x * VGlobals._ScreenParams.y;
        u_xlat4.xyz = fma(u_xlat1.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat4.x = dot(u_xlat4.xyz, u_xlat4.xyz);
        u_xlat4.x = sqrt(u_xlat4.x);
        u_xlat4.x = u_xlat4.x * VGlobals._EdgeLength;
        u_xlat0.x = u_xlat0.x / u_xlat4.x;
        tessFactor.edgeTessellationFactor[2] = max(u_xlat0.x, 1.0);
    }
    // join_phase3
    {
        u_xlat0.x = tessFactor.edgeTessellationFactor[0] + tessFactor.edgeTessellationFactor[1];
        u_xlat0.x = u_xlat0.x + tessFactor.edgeTessellationFactor[2];
        tessFactor.insideTessellationFactor = u_xlat0.x * 0.333333343;
    }
    controlPoints[mtl_VertexID] = output;
    tessFactors[internalPatchID] = tessFactor;
}
// SHADER_STAGE_HULL_end
// SHADER_STAGE_DOMAIN_begin
struct Mtl_VertexInPostTess
{
    patch_control_point<Mtl_ControlPointIn> cp;
};
struct Mtl_VertexOutPostTess
{
    float4 mtl_Position [[ position ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float4 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float4 TEXCOORD3 [[ user(TEXCOORD3) ]];
    float4 TEXCOORD5 [[ user(TEXCOORD5) ]];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    sampler sampler_Height [[ sampler (0) ]],
    texture2d<float, access::sample > _Height [[ texture(0) ]] ,
    float3 mtl_TessCoord [[ position_in_patch ]],
    uint patchID [[ patch_id ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    Mtl_VertexInPostTess input [[ stage_in ]])
{
#pragma clang diagnostic pop
    Mtl_VertexOutPostTess output;
    MTLTriangleTessellationFactorsHalf tessFactor;
    tessFactor = tessFactors[patchID];
    float4 u_xlat0;
    float4 u_xlat1;
    float4 u_xlat2;
    float4 u_xlat3;
    float2 u_xlat9;
    float u_xlat12;
    float u_xlat13;
    u_xlat0 = mtl_TessCoord.yyyy * input.cp[1].INTERNALTESSPOS0;
    u_xlat0 = fma(input.cp[0].INTERNALTESSPOS0, mtl_TessCoord.xxxx, u_xlat0);
    u_xlat0 = fma(input.cp[2].INTERNALTESSPOS0, mtl_TessCoord.zzzz, u_xlat0);
    u_xlat1.xy = mtl_TessCoord.yy * input.cp[1].TEXCOORD0.xy;
    u_xlat1.xy = fma(input.cp[0].TEXCOORD0.xy, mtl_TessCoord.xx, u_xlat1.xy);
    u_xlat1.xy = fma(input.cp[2].TEXCOORD0.xy, mtl_TessCoord.zz, u_xlat1.xy);
    u_xlat9.xy = u_xlat1.xy * float2(VGlobals._Tile);
    output.TEXCOORD0.xy = fma(u_xlat1.xy, VGlobals._texcoord_ST.xy, VGlobals._texcoord_ST.zw);
    u_xlat1.xyz = _Height.sample(sampler_Height, u_xlat9.xy, level(1.0)).xyz;
    u_xlat2.xyz = mtl_TessCoord.yyy * input.cp[1].NORMAL0.xyz;
    u_xlat2.xyz = fma(input.cp[0].NORMAL0.xyz, mtl_TessCoord.xxx, u_xlat2.xyz);
    u_xlat2.xyz = fma(input.cp[2].NORMAL0.xyz, mtl_TessCoord.zzz, u_xlat2.xyz);
    u_xlat1.xyz = u_xlat1.xyz * u_xlat2.xyz;
    u_xlat0.xyz = fma(u_xlat1.xyz, float3(VGlobals._HeightDisplacement), u_xlat0.xyz);
    u_xlat1 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], u_xlat0.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], u_xlat0.zzzz, u_xlat1);
    u_xlat3 = u_xlat1 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, u_xlat0.www, u_xlat1.xyz);
    u_xlat1 = u_xlat3.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat3.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat3.zzzz, u_xlat1);
    output.mtl_Position = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat3.wwww, u_xlat1);
    u_xlat1.y = dot(u_xlat2.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat1.z = dot(u_xlat2.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat1.x = dot(u_xlat2.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat12 = dot(u_xlat1.xyz, u_xlat1.xyz);
    u_xlat12 = rsqrt(u_xlat12);
    u_xlat1.xyz = float3(u_xlat12) * u_xlat1.xyz;
    output.TEXCOORD1.z = u_xlat1.y;
    u_xlat2 = mtl_TessCoord.yyyy * input.cp[1].TANGENT0;
    u_xlat2 = fma(input.cp[0].TANGENT0, mtl_TessCoord.xxxx, u_xlat2);
    u_xlat2 = fma(input.cp[2].TANGENT0, mtl_TessCoord.zzzz, u_xlat2);
    u_xlat3.xyz = u_xlat2.yyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].yzx;
    u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].yzx, u_xlat2.xxx, u_xlat3.xyz);
    u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].yzx, u_xlat2.zzz, u_xlat3.xyz);
    u_xlat12 = u_xlat2.w * VGlobals.unity_WorldTransformParams.w;
    u_xlat13 = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat13 = rsqrt(u_xlat13);
    u_xlat2.xyz = float3(u_xlat13) * u_xlat2.xyz;
    u_xlat3.xyz = u_xlat1.xyz * u_xlat2.xyz;
    u_xlat3.xyz = fma(u_xlat1.zxy, u_xlat2.yzx, (-u_xlat3.xyz));
    u_xlat3.xyz = float3(u_xlat12) * u_xlat3.xyz;
    output.TEXCOORD1.y = u_xlat3.x;
    output.TEXCOORD1.w = u_xlat0.x;
    output.TEXCOORD1.x = u_xlat2.z;
    output.TEXCOORD2.w = u_xlat0.y;
    output.TEXCOORD3.w = u_xlat0.z;
    output.TEXCOORD2.x = u_xlat2.x;
    output.TEXCOORD3.x = u_xlat2.y;
    output.TEXCOORD2.z = u_xlat1.z;
    output.TEXCOORD3.z = u_xlat1.x;
    output.TEXCOORD2.y = u_xlat3.y;
    output.TEXCOORD3.y = u_xlat3.z;
    output.TEXCOORD5 = float4(0.0, 0.0, 0.0, 0.0);
    return output;
}
// SHADER_STAGE_DOMAIN_end
Compilation succeeded with: 

program_source:303:53: warning: writable resources in non-void post-tessellation vertex function
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
                                                    ^
program_source:309:30: note: writable buffer defined here
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
                             ^
program_source:310:48: note: writable buffer defined here
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
                                               ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float4 TEXCOORD0 [[ attribute(3) ]] ;
    float4 TEXCOORD1 [[ attribute(4) ]] ;
    float4 TEXCOORD2 [[ attribute(5) ]] ;
    float4 TEXCOORD3 [[ attribute(6) ]] ;
    float4 COLOR0 [[ attribute(7) ]] ;
};
struct Mtl_VertexOut
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float4 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float4 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float4 TEXCOORD3 [[ user(TEXCOORD3) ]];
    float4 COLOR0 [[ user(COLOR0) ]];
};
static Mtl_VertexOut vertexFunction(
    Mtl_VertexIn input)
{
    Mtl_VertexOut output;
    output.INTERNALTESSPOS0 = input.POSITION0;
    output.TANGENT0 = input.TANGENT0;
    output.NORMAL0.xyz = input.NORMAL0.xyz;
    output.TEXCOORD0 = input.TEXCOORD0;
    output.TEXCOORD1 = input.TEXCOORD1;
    output.TEXCOORD2 = input.TEXCOORD2;
    output.TEXCOORD3 = input.TEXCOORD3;
    output.COLOR0 = input.COLOR0;
    return output;
}
// SHADER_STAGE_HULL_begin
struct Mtl_ControlPoint
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float4 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float4 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float4 TEXCOORD3 [[ user(TEXCOORD3) ]];
    float4 COLOR0 [[ user(COLOR0) ]];
};
struct Mtl_ControlPointIn
{
    float4 INTERNALTESSPOS0 [[ attribute(8) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float4 TEXCOORD0 [[ attribute(3) ]] ;
    float4 TEXCOORD1 [[ attribute(4) ]] ;
    float4 TEXCOORD2 [[ attribute(5) ]] ;
    float4 TEXCOORD3 [[ attribute(6) ]] ;
    float4 COLOR0 [[ attribute(7) ]] ;
};
struct Mtl_KernelPatchInfo
{
    uint numPatches;
    ushort numControlPointsPerPatch;
};
struct VGlobals_Type
{
    float4 _Time;
    float4 _SinTime;
    float4 _CosTime;
    float4 unity_DeltaTime;
    float3 _WorldSpaceCameraPos;
    float4 _ProjectionParams;
    float4 _ScreenParams;
    float4 _ZBufferParams;
    float4 unity_OrthoParams;
    float4 unity_CameraWorldClipPlanes[6];
    float4 hlslcc_mtx4x4unity_CameraProjection[4];
    float4 hlslcc_mtx4x4unity_CameraInvProjection[4];
    float4 hlslcc_mtx4x4unity_WorldToCamera[4];
    float4 hlslcc_mtx4x4unity_CameraToWorld[4];
    float4 _WorldSpaceLightPos0;
    float4 _LightPositionRange;
    float4 _LightProjectionParams;
    float4 unity_4LightPosX0;
    float4 unity_4LightPosY0;
    float4 unity_4LightPosZ0;
    float4 unity_4LightAtten0;
    float4 unity_LightColor[8];
    float4 unity_LightPosition[8];
    float4 unity_LightAtten[8];
    float4 unity_SpotDirection[8];
    float4 unity_SHAr;
    float4 unity_SHAg;
    float4 unity_SHAb;
    float4 unity_SHBr;
    float4 unity_SHBg;
    float4 unity_SHBb;
    float4 unity_SHC;
    float4 unity_OcclusionMaskSelector;
    float4 unity_ProbesOcclusion;
    float3 unity_LightColor0;
    float3 unity_LightColor1;
    float3 unity_LightColor2;
    float3 unity_LightColor3;
    float4 unity_ShadowSplitSpheres[4];
    float4 unity_ShadowSplitSqRadii;
    float4 unity_LightShadowBias;
    float4 _LightSplitsNear;
    float4 _LightSplitsFar;
    float4 hlslcc_mtx4x4unity_WorldToShadow[16];
    float4 _LightShadowData;
    float4 unity_ShadowFadeCenterAndType;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 unity_LODFade;
    float4 unity_WorldTransformParams;
    float4 unity_RenderingLayer;
    float4 hlslcc_mtx4x4glstate_matrix_transpose_modelview0[4];
    float4 glstate_lightmodel_ambient;
    float4 unity_AmbientSky;
    float4 unity_AmbientEquator;
    float4 unity_AmbientGround;
    float4 unity_IndirectSpecColor;
    float4 hlslcc_mtx4x4glstate_matrix_projection[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixInvV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    int unity_StereoEyeIndex;
    float4 unity_ShadowColor;
    float4 unity_FogColor;
    float4 unity_FogParams;
    float4 unity_LightmapST;
    float4 unity_DynamicLightmapST;
    float4 unity_SpecCube0_BoxMax;
    float4 unity_SpecCube0_BoxMin;
    float4 unity_SpecCube0_ProbePosition;
    float4 unity_SpecCube0_HDR;
    float4 unity_SpecCube1_BoxMax;
    float4 unity_SpecCube1_BoxMin;
    float4 unity_SpecCube1_ProbePosition;
    float4 unity_SpecCube1_HDR;
    float4 unity_ProbeVolumeParams;
    float4 hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[4];
    float3 unity_ProbeVolumeSizeInv;
    float3 unity_ProbeVolumeMin;
    float4 unity_Lightmap_HDR;
    float4 unity_DynamicLightmap_HDR;
    float4 _LightColor0;
    float4 _SpecColor;
    float _Tile;
    float _HeightDisplacement;
    float _NormalScale;
    float4 _ColorTint;
    float _MetallicStrength;
    float _SmoothnessStrength;
    float _EdgeLength;
    bool4 unity_MetaVertexControl;
    bool4 unity_MetaFragmentControl;
    int unity_VisualizationMode;
    float unity_OneOverOutputBoost;
    float unity_MaxOutputValue;
    float unity_UseLinearSpace;
    float4 _texcoord_ST;
};
struct Mtl_HullIn
{
    Mtl_VertexOut cp[3];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
kernel void patchKernel(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn vertexInput [[ stage_in ]],
    uint2 tID [[ thread_position_in_grid ]],
    ushort2 groupID [[ threadgroup_position_in_grid ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    constant Mtl_KernelPatchInfo &patchInfo [[ buffer(3) ]])
{
#pragma clang diagnostic pop
    Mtl_ControlPoint output;
    const uint numPatchesInThreadGroup = 10;
    const uint patchID = (tID.x / patchInfo.numControlPointsPerPatch);
    const bool patchValid = (patchID < patchInfo.numPatches);
    const uint mtl_BaseInstance = 0;
    const uint mtl_InstanceID = groupID.y - mtl_BaseInstance;
    const uint internalPatchID = mtl_InstanceID * patchInfo.numPatches + patchID;
    const uint patchIDInThreadGroup = (patchID % numPatchesInThreadGroup);
    const uint controlPointID = (tID.x % patchInfo.numControlPointsPerPatch);
    const uint mtl_BaseVertex = 0;
    const uint mtl_VertexID = ((mtl_InstanceID * (patchInfo.numControlPointsPerPatch * patchInfo.numPatches)) + tID.x) - mtl_BaseVertex;
    threadgroup Mtl_HullIn inputGroup[numPatchesInThreadGroup];
    threadgroup Mtl_HullIn &input = inputGroup[patchIDInThreadGroup];
    MTLTriangleTessellationFactorsHalf tessFactor;
    if (patchValid) {
        input.cp[controlPointID] = vertexFunction(vertexInput);
        output.INTERNALTESSPOS0 = input.cp[controlPointID].INTERNALTESSPOS0;
        output.TANGENT0 = input.cp[controlPointID].TANGENT0;
        output.NORMAL0 = input.cp[controlPointID].NORMAL0;
        output.TEXCOORD0 = input.cp[controlPointID].TEXCOORD0;
        output.TEXCOORD1 = input.cp[controlPointID].TEXCOORD1;
        output.TEXCOORD2 = input.cp[controlPointID].TEXCOORD2;
        output.TEXCOORD3 = input.cp[controlPointID].TEXCOORD3;
        output.COLOR0 = input.cp[controlPointID].COLOR0;
    }
    threadgroup_barrier(mem_flags::mem_threadgroup);
    if (!patchValid) {
        return;
    }
    float3 u_xlat0;
    float3 u_xlat1;
    float3 u_xlat2;
    float3 u_xlat3;
    float3 u_xlat4;
    float u_xlat12;
    float u_xlat13;
    // fork_phase2
    {
        u_xlat0.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[1].INTERNALTESSPOS0.yyy;
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[1].INTERNALTESSPOS0.xxx, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[1].INTERNALTESSPOS0.zzz, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[1].INTERNALTESSPOS0.www, u_xlat0.xyz);
        u_xlat1.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[2].INTERNALTESSPOS0.yyy;
        u_xlat1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[2].INTERNALTESSPOS0.xxx, u_xlat1.xyz);
        u_xlat1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[2].INTERNALTESSPOS0.zzz, u_xlat1.xyz);
        u_xlat1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[2].INTERNALTESSPOS0.www, u_xlat1.xyz);
        u_xlat2.xyz = u_xlat0.xyz + u_xlat1.xyz;
        u_xlat2.xyz = fma(u_xlat2.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat12 = dot(u_xlat2.xyz, u_xlat2.xyz);
        u_xlat12 = sqrt(u_xlat12);
        u_xlat12 = u_xlat12 * VGlobals._EdgeLength;
        u_xlat2.xyz = u_xlat0.xyz + (-u_xlat1.xyz);
        u_xlat13 = dot(u_xlat2.xyz, u_xlat2.xyz);
        u_xlat13 = sqrt(u_xlat13);
        u_xlat13 = u_xlat13 * VGlobals._ScreenParams.y;
        u_xlat12 = u_xlat13 / u_xlat12;
        tessFactor.edgeTessellationFactor[0] = max(u_xlat12, 1.0);
        u_xlat2.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[0].INTERNALTESSPOS0.yyy;
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[0].INTERNALTESSPOS0.xxx, u_xlat2.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[0].INTERNALTESSPOS0.zzz, u_xlat2.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[0].INTERNALTESSPOS0.www, u_xlat2.xyz);
        u_xlat3.xyz = u_xlat1.xyz + u_xlat2.xyz;
        u_xlat1.xyz = u_xlat1.xyz + (-u_xlat2.xyz);
        u_xlat12 = dot(u_xlat1.xyz, u_xlat1.xyz);
        u_xlat12 = sqrt(u_xlat12);
        u_xlat12 = u_xlat12 * VGlobals._ScreenParams.y;
        u_xlat1.xyz = fma(u_xlat3.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat1.x = dot(u_xlat1.xyz, u_xlat1.xyz);
        u_xlat1.x = sqrt(u_xlat1.x);
        u_xlat1.x = u_xlat1.x * VGlobals._EdgeLength;
        u_xlat12 = u_xlat12 / u_xlat1.x;
        tessFactor.edgeTessellationFactor[1] = max(u_xlat12, 1.0);
        u_xlat1.xyz = u_xlat0.xyz + u_xlat2.xyz;
        u_xlat0.xyz = (-u_xlat0.xyz) + u_xlat2.xyz;
        u_xlat0.x = dot(u_xlat0.xyz, u_xlat0.xyz);
        u_xlat0.x = sqrt(u_xlat0.x);
        u_xlat0.x = u_xlat0.x * VGlobals._ScreenParams.y;
        u_xlat4.xyz = fma(u_xlat1.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat4.x = dot(u_xlat4.xyz, u_xlat4.xyz);
        u_xlat4.x = sqrt(u_xlat4.x);
        u_xlat4.x = u_xlat4.x * VGlobals._EdgeLength;
        u_xlat0.x = u_xlat0.x / u_xlat4.x;
        tessFactor.edgeTessellationFactor[2] = max(u_xlat0.x, 1.0);
    }
    // join_phase3
    {
        u_xlat0.x = tessFactor.edgeTessellationFactor[0] + tessFactor.edgeTessellationFactor[1];
        u_xlat0.x = u_xlat0.x + tessFactor.edgeTessellationFactor[2];
        tessFactor.insideTessellationFactor = u_xlat0.x * 0.333333343;
    }
    controlPoints[mtl_VertexID] = output;
    tessFactors[internalPatchID] = tessFactor;
}
// SHADER_STAGE_HULL_end
// SHADER_STAGE_DOMAIN_begin
struct Mtl_VertexInPostTess
{
    patch_control_point<Mtl_ControlPointIn> cp;
};
struct Mtl_VertexOutPostTess
{
    float4 mtl_Position [[ position ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float4 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float4 TEXCOORD3 [[ user(TEXCOORD3) ]];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    sampler sampler_Height [[ sampler (0) ]],
    texture2d<float, access::sample > _Height [[ texture(0) ]] ,
    float3 mtl_TessCoord [[ position_in_patch ]],
    uint patchID [[ patch_id ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    Mtl_VertexInPostTess input [[ stage_in ]])
{
#pragma clang diagnostic pop
    Mtl_VertexOutPostTess output;
    MTLTriangleTessellationFactorsHalf tessFactor;
    tessFactor = tessFactors[patchID];
    float4 u_xlat0;
    float4 u_xlat1;
    float4 u_xlat2;
    float3 u_xlat3;
    float3 u_xlat4;
    float2 u_xlat13;
    float u_xlat15;
    bool u_xlatb15;
    u_xlat0.xy = mtl_TessCoord.yy * input.cp[1].TEXCOORD2.xy;
    u_xlat0.xy = fma(input.cp[0].TEXCOORD2.xy, mtl_TessCoord.xx, u_xlat0.xy);
    u_xlat0.xy = fma(input.cp[2].TEXCOORD2.xy, mtl_TessCoord.zz, u_xlat0.xy);
    u_xlat0.xy = fma(u_xlat0.xy, VGlobals.unity_DynamicLightmapST.xy, VGlobals.unity_DynamicLightmapST.zw);
    u_xlat1.xy = mtl_TessCoord.yy * input.cp[1].TEXCOORD1.xy;
    u_xlat1.xy = fma(input.cp[0].TEXCOORD1.xy, mtl_TessCoord.xx, u_xlat1.xy);
    u_xlat1.xy = fma(input.cp[2].TEXCOORD1.xy, mtl_TessCoord.zz, u_xlat1.xy);
    u_xlat1.xy = fma(u_xlat1.xy, VGlobals.unity_LightmapST.xy, VGlobals.unity_LightmapST.zw);
    u_xlat2 = mtl_TessCoord.yyyy * input.cp[1].INTERNALTESSPOS0;
    u_xlat2 = fma(input.cp[0].INTERNALTESSPOS0, mtl_TessCoord.xxxx, u_xlat2);
    u_xlat2 = fma(input.cp[2].INTERNALTESSPOS0, mtl_TessCoord.zzzz, u_xlat2);
    u_xlat3.xy = mtl_TessCoord.yy * input.cp[1].TEXCOORD0.xy;
    u_xlat3.xy = fma(input.cp[0].TEXCOORD0.xy, mtl_TessCoord.xx, u_xlat3.xy);
    u_xlat3.xy = fma(input.cp[2].TEXCOORD0.xy, mtl_TessCoord.zz, u_xlat3.xy);
    u_xlat13.xy = u_xlat3.xy * float2(VGlobals._Tile);
    output.TEXCOORD0.xy = fma(u_xlat3.xy, VGlobals._texcoord_ST.xy, VGlobals._texcoord_ST.zw);
    u_xlat3.xyz = _Height.sample(sampler_Height, u_xlat13.xy, level(1.0)).xyz;
    u_xlat4.xyz = mtl_TessCoord.yyy * input.cp[1].NORMAL0.xyz;
    u_xlat4.xyz = fma(input.cp[0].NORMAL0.xyz, mtl_TessCoord.xxx, u_xlat4.xyz);
    u_xlat4.xyz = fma(input.cp[2].NORMAL0.xyz, mtl_TessCoord.zzz, u_xlat4.xyz);
    u_xlat3.xyz = u_xlat3.xyz * u_xlat4.xyz;
    u_xlat2.xyz = fma(u_xlat3.xyz, float3(VGlobals._HeightDisplacement), u_xlat2.xyz);
    u_xlatb15 = 0.0<u_xlat2.z;
    u_xlat1.z = u_xlatb15 ? 9.99999975e-05 : float(0.0);
    u_xlat1.xyz = (VGlobals.unity_MetaVertexControl.x) ? u_xlat1.xyz : u_xlat2.xyz;
    u_xlatb15 = 0.0<u_xlat1.z;
    u_xlat0.z = u_xlatb15 ? 9.99999975e-05 : float(0.0);
    u_xlat0.xyz = (VGlobals.unity_MetaVertexControl.y) ? u_xlat0.xyz : u_xlat1.xyz;
    u_xlat1 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat0.xxxx, u_xlat1);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat0.zzzz, u_xlat1);
    output.mtl_Position = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_MatrixVP[3];
    u_xlat0.xyz = u_xlat2.yyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz;
    u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, u_xlat2.xxx, u_xlat0.xyz);
    u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, u_xlat2.zzz, u_xlat0.xyz);
    u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, u_xlat2.www, u_xlat0.xyz);
    output.TEXCOORD1.w = u_xlat0.x;
    u_xlat1.y = dot(u_xlat4.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat1.z = dot(u_xlat4.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat1.x = dot(u_xlat4.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat0.x = dot(u_xlat1.xyz, u_xlat1.xyz);
    u_xlat0.x = rsqrt(u_xlat0.x);
    u_xlat1.xyz = u_xlat0.xxx * u_xlat1.xyz;
    output.TEXCOORD1.z = u_xlat1.y;
    u_xlat2 = mtl_TessCoord.yyyy * input.cp[1].TANGENT0;
    u_xlat2 = fma(input.cp[0].TANGENT0, mtl_TessCoord.xxxx, u_xlat2);
    u_xlat2 = fma(input.cp[2].TANGENT0, mtl_TessCoord.zzzz, u_xlat2);
    u_xlat3.xyz = u_xlat2.yyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].yzx;
    u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].yzx, u_xlat2.xxx, u_xlat3.xyz);
    u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].yzx, u_xlat2.zzz, u_xlat3.xyz);
    u_xlat0.x = u_xlat2.w * VGlobals.unity_WorldTransformParams.w;
    u_xlat15 = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat15 = rsqrt(u_xlat15);
    u_xlat2.xyz = float3(u_xlat15) * u_xlat2.xyz;
    u_xlat3.xyz = u_xlat1.xyz * u_xlat2.xyz;
    u_xlat3.xyz = fma(u_xlat1.zxy, u_xlat2.yzx, (-u_xlat3.xyz));
    u_xlat3.xyz = u_xlat0.xxx * u_xlat3.xyz;
    output.TEXCOORD1.y = u_xlat3.x;
    output.TEXCOORD1.x = u_xlat2.z;
    output.TEXCOORD2.w = u_xlat0.y;
    output.TEXCOORD3.w = u_xlat0.z;
    output.TEXCOORD2.x = u_xlat2.x;
    output.TEXCOORD3.x = u_xlat2.y;
    output.TEXCOORD2.z = u_xlat1.z;
    output.TEXCOORD3.z = u_xlat1.x;
    output.TEXCOORD2.y = u_xlat3.y;
    output.TEXCOORD3.y = u_xlat3.z;
    return output;
}
// SHADER_STAGE_DOMAIN_end
Refreshing native plugins compatible for Editor in 2.31 ms, found 2 plugins.
Preloading 0 native plugins for Editor in 0.00 ms.
Unloading 3375 Unused Serialized files (Serialized files now loaded: 0)
Unloading 20 unused Assets / (0.6 MB). Loaded Objects now: 3889.
Memory consumption went from 136.4 MB to 135.8 MB.
Total: 5.489912 ms (FindLiveObjects: 0.348048 ms CreateObjectMapping: 0.352471 ms MarkObjects: 4.312043 ms  DeleteObjects: 0.475867 ms)

AssetImportParameters requested are different than current active one (requested -> active):
  custom:video-decoder-ogg-theora: a1e56fd34408186e4bbccfd4996cb3dc -> 
  custom:container-muxer-webm: aa71ff27fc2769a1b78a27578f13a17b -> 
  custom:container-demuxer-webm: 4f35f7cbe854078d1ac9338744f61a02 -> 
  custom:video-encoder-webm-vp8: eb34c28f22e8b96e1ab97ce403110664 -> 
  custom:framework-osx-AVFoundation: b23960f63f64bdc6ff669e2cdcee2391 -> 
  custom:audio-encoder-webm-vorbis: bf7c407c2cedff20999df2af8eb42d56 -> 
  custom:container-demuxer-ogg: 62fdf1f143b41e24485cea50d1cbac27 -> 
  custom:video-decoder-webm-vp8: 9c59270c3fd7afecdb556c50c9e8de78 -> 
  custom:audio-decoder-ogg-vorbis: bf7c407c2cedff20999df2af8eb42d56 -> 
========================================================================
Received Prepare
Registering precompiled user dll's ...
Registered in 0.003569 seconds.
Begin MonoManager ReloadAssembly
Symbol file LoadedFromMemory doesn't match image /Users/kamilaamendolagine/Desktop/Staugen Raug v2 - Prefab - Map 1.01/Library/PackageCache/com.unity.visualscripting@1.7.8/Editor/VisualScripting.Core/Dependencies/YamlDotNet/Unity.VisualScripting.YamlDotNet.dll
Symbol file LoadedFromMemory doesn't match image /Users/kamilaamendolagine/Desktop/Staugen Raug v2 - Prefab - Map 1.01/Library/PackageCache/com.unity.visualscripting@1.7.8/Editor/VisualScripting.Core/Dependencies/DotNetZip/Unity.VisualScripting.IonicZip.dll
Native extension for OSXStandalone target not found
Native extension for WebGL target not found
Refreshing native plugins compatible for Editor in 1.07 ms, found 2 plugins.
Preloading 0 native plugins for Editor in 0.00 ms.
Mono: successfully reloaded assembly
- Completed reload, in  1.864 seconds
Domain Reload Profiling:
	ReloadAssembly (1866ms)
		BeginReloadAssembly (201ms)
			ExecutionOrderSort (0ms)
			DisableScriptedObjects (10ms)
			BackupInstance (0ms)
			ReleaseScriptingObjects (0ms)
			CreateAndSetChildDomain (87ms)
		EndReloadAssembly (1495ms)
			LoadAssemblies (90ms)
			RebuildTransferFunctionScriptingTraits (0ms)
			SetupTypeCache (501ms)
			ReleaseScriptCaches (1ms)
			RebuildScriptCaches (84ms)
			SetupLoadedEditorAssemblies (701ms)
				LogAssemblyErrors (0ms)
				InitializePlatformSupportModulesInManaged (21ms)
				SetLoadedEditorAssemblies (1ms)
				RefreshPlugins (1ms)
				BeforeProcessingInitializeOnLoad (110ms)
				ProcessInitializeOnLoadAttributes (513ms)
				ProcessInitializeOnLoadMethodAttributes (51ms)
				AfterProcessingInitializeOnLoad (3ms)
				EditorAssembliesLoaded (0ms)
			ExecutionOrderSort2 (0ms)
			AwakeInstancesAfterBackupRestoration (9ms)
Platform modules already initialized, skipping
Compilation succeeded with: 

program_source:299:53: warning: writable resources in non-void post-tessellation vertex function
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
                                                    ^
program_source:305:30: note: writable buffer defined here
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
                             ^
program_source:306:48: note: writable buffer defined here
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
                                               ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float4 TEXCOORD0 [[ attribute(3) ]] ;
    float4 TEXCOORD1 [[ attribute(4) ]] ;
    float4 TEXCOORD2 [[ attribute(5) ]] ;
    float4 TEXCOORD3 [[ attribute(6) ]] ;
    float4 COLOR0 [[ attribute(7) ]] ;
};
struct Mtl_VertexOut
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float4 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float4 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float4 TEXCOORD3 [[ user(TEXCOORD3) ]];
    float4 COLOR0 [[ user(COLOR0) ]];
};
static Mtl_VertexOut vertexFunction(
    Mtl_VertexIn input)
{
    Mtl_VertexOut output;
    output.INTERNALTESSPOS0 = input.POSITION0;
    output.TANGENT0 = input.TANGENT0;
    output.NORMAL0.xyz = input.NORMAL0.xyz;
    output.TEXCOORD0 = input.TEXCOORD0;
    output.TEXCOORD1 = input.TEXCOORD1;
    output.TEXCOORD2 = input.TEXCOORD2;
    output.TEXCOORD3 = input.TEXCOORD3;
    output.COLOR0 = input.COLOR0;
    return output;
}
// SHADER_STAGE_HULL_begin
struct Mtl_ControlPoint
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float4 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float4 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float4 TEXCOORD3 [[ user(TEXCOORD3) ]];
    float4 COLOR0 [[ user(COLOR0) ]];
};
struct Mtl_ControlPointIn
{
    float4 INTERNALTESSPOS0 [[ attribute(8) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float4 TEXCOORD0 [[ attribute(3) ]] ;
    float4 TEXCOORD1 [[ attribute(4) ]] ;
    float4 TEXCOORD2 [[ attribute(5) ]] ;
    float4 TEXCOORD3 [[ attribute(6) ]] ;
    float4 COLOR0 [[ attribute(7) ]] ;
};
struct Mtl_KernelPatchInfo
{
    uint numPatches;
    ushort numControlPointsPerPatch;
};
struct VGlobals_Type
{
    float4 _Time;
    float4 _SinTime;
    float4 _CosTime;
    float4 unity_DeltaTime;
    float3 _WorldSpaceCameraPos;
    float4 _ProjectionParams;
    float4 _ScreenParams;
    float4 _ZBufferParams;
    float4 unity_OrthoParams;
    float4 unity_CameraWorldClipPlanes[6];
    float4 hlslcc_mtx4x4unity_CameraProjection[4];
    float4 hlslcc_mtx4x4unity_CameraInvProjection[4];
    float4 hlslcc_mtx4x4unity_WorldToCamera[4];
    float4 hlslcc_mtx4x4unity_CameraToWorld[4];
    float4 _WorldSpaceLightPos0;
    float4 _LightPositionRange;
    float4 _LightProjectionParams;
    float4 unity_4LightPosX0;
    float4 unity_4LightPosY0;
    float4 unity_4LightPosZ0;
    float4 unity_4LightAtten0;
    float4 unity_LightColor[8];
    float4 unity_LightPosition[8];
    float4 unity_LightAtten[8];
    float4 unity_SpotDirection[8];
    float4 unity_SHAr;
    float4 unity_SHAg;
    float4 unity_SHAb;
    float4 unity_SHBr;
    float4 unity_SHBg;
    float4 unity_SHBb;
    float4 unity_SHC;
    float4 unity_OcclusionMaskSelector;
    float4 unity_ProbesOcclusion;
    float3 unity_LightColor0;
    float3 unity_LightColor1;
    float3 unity_LightColor2;
    float3 unity_LightColor3;
    float4 unity_ShadowSplitSpheres[4];
    float4 unity_ShadowSplitSqRadii;
    float4 unity_LightShadowBias;
    float4 _LightSplitsNear;
    float4 _LightSplitsFar;
    float4 hlslcc_mtx4x4unity_WorldToShadow[16];
    float4 _LightShadowData;
    float4 unity_ShadowFadeCenterAndType;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 unity_LODFade;
    float4 unity_WorldTransformParams;
    float4 unity_RenderingLayer;
    float4 hlslcc_mtx4x4glstate_matrix_transpose_modelview0[4];
    float4 glstate_lightmodel_ambient;
    float4 unity_AmbientSky;
    float4 unity_AmbientEquator;
    float4 unity_AmbientGround;
    float4 unity_IndirectSpecColor;
    float4 hlslcc_mtx4x4glstate_matrix_projection[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixInvV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    int unity_StereoEyeIndex;
    float4 unity_ShadowColor;
    float4 unity_FogColor;
    float4 unity_FogParams;
    float4 unity_LightmapST;
    float4 unity_DynamicLightmapST;
    float4 unity_SpecCube0_BoxMax;
    float4 unity_SpecCube0_BoxMin;
    float4 unity_SpecCube0_ProbePosition;
    float4 unity_SpecCube0_HDR;
    float4 unity_SpecCube1_BoxMax;
    float4 unity_SpecCube1_BoxMin;
    float4 unity_SpecCube1_ProbePosition;
    float4 unity_SpecCube1_HDR;
    float4 unity_ProbeVolumeParams;
    float4 hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[4];
    float3 unity_ProbeVolumeSizeInv;
    float3 unity_ProbeVolumeMin;
    float4 unity_Lightmap_HDR;
    float4 unity_DynamicLightmap_HDR;
    float4 _LightColor0;
    float4 _SpecColor;
    float _Tile;
    float _HeightDisplacement;
    float _NormalScale;
    float4 _ColorTint;
    float _MetallicStrength;
    float _SmoothnessStrength;
    float _EdgeLength;
    float4 _texcoord_ST;
};
struct Mtl_HullIn
{
    Mtl_VertexOut cp[3];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
kernel void patchKernel(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn vertexInput [[ stage_in ]],
    uint2 tID [[ thread_position_in_grid ]],
    ushort2 groupID [[ threadgroup_position_in_grid ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    constant Mtl_KernelPatchInfo &patchInfo [[ buffer(3) ]])
{
#pragma clang diagnostic pop
    Mtl_ControlPoint output;
    const uint numPatchesInThreadGroup = 10;
    const uint patchID = (tID.x / patchInfo.numControlPointsPerPatch);
    const bool patchValid = (patchID < patchInfo.numPatches);
    const uint mtl_BaseInstance = 0;
    const uint mtl_InstanceID = groupID.y - mtl_BaseInstance;
    const uint internalPatchID = mtl_InstanceID * patchInfo.numPatches + patchID;
    const uint patchIDInThreadGroup = (patchID % numPatchesInThreadGroup);
    const uint controlPointID = (tID.x % patchInfo.numControlPointsPerPatch);
    const uint mtl_BaseVertex = 0;
    const uint mtl_VertexID = ((mtl_InstanceID * (patchInfo.numControlPointsPerPatch * patchInfo.numPatches)) + tID.x) - mtl_BaseVertex;
    threadgroup Mtl_HullIn inputGroup[numPatchesInThreadGroup];
    threadgroup Mtl_HullIn &input = inputGroup[patchIDInThreadGroup];
    MTLTriangleTessellationFactorsHalf tessFactor;
    if (patchValid) {
        input.cp[controlPointID] = vertexFunction(vertexInput);
        output.INTERNALTESSPOS0 = input.cp[controlPointID].INTERNALTESSPOS0;
        output.TANGENT0 = input.cp[controlPointID].TANGENT0;
        output.NORMAL0 = input.cp[controlPointID].NORMAL0;
        output.TEXCOORD0 = input.cp[controlPointID].TEXCOORD0;
        output.TEXCOORD1 = input.cp[controlPointID].TEXCOORD1;
        output.TEXCOORD2 = input.cp[controlPointID].TEXCOORD2;
        output.TEXCOORD3 = input.cp[controlPointID].TEXCOORD3;
        output.COLOR0 = input.cp[controlPointID].COLOR0;
    }
    threadgroup_barrier(mem_flags::mem_threadgroup);
    if (!patchValid) {
        return;
    }
    float3 u_xlat0;
    float3 u_xlat1;
    float3 u_xlat2;
    float3 u_xlat3;
    float3 u_xlat4;
    float u_xlat12;
    float u_xlat13;
    // fork_phase2
    {
        u_xlat0.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[1].INTERNALTESSPOS0.yyy;
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[1].INTERNALTESSPOS0.xxx, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[1].INTERNALTESSPOS0.zzz, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[1].INTERNALTESSPOS0.www, u_xlat0.xyz);
        u_xlat1.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[2].INTERNALTESSPOS0.yyy;
        u_xlat1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[2].INTERNALTESSPOS0.xxx, u_xlat1.xyz);
        u_xlat1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[2].INTERNALTESSPOS0.zzz, u_xlat1.xyz);
        u_xlat1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[2].INTERNALTESSPOS0.www, u_xlat1.xyz);
        u_xlat2.xyz = u_xlat0.xyz + u_xlat1.xyz;
        u_xlat2.xyz = fma(u_xlat2.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat12 = dot(u_xlat2.xyz, u_xlat2.xyz);
        u_xlat12 = sqrt(u_xlat12);
        u_xlat12 = u_xlat12 * VGlobals._EdgeLength;
        u_xlat2.xyz = u_xlat0.xyz + (-u_xlat1.xyz);
        u_xlat13 = dot(u_xlat2.xyz, u_xlat2.xyz);
        u_xlat13 = sqrt(u_xlat13);
        u_xlat13 = u_xlat13 * VGlobals._ScreenParams.y;
        u_xlat12 = u_xlat13 / u_xlat12;
        tessFactor.edgeTessellationFactor[0] = max(u_xlat12, 1.0);
        u_xlat2.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[0].INTERNALTESSPOS0.yyy;
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[0].INTERNALTESSPOS0.xxx, u_xlat2.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[0].INTERNALTESSPOS0.zzz, u_xlat2.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[0].INTERNALTESSPOS0.www, u_xlat2.xyz);
        u_xlat3.xyz = u_xlat1.xyz + u_xlat2.xyz;
        u_xlat1.xyz = u_xlat1.xyz + (-u_xlat2.xyz);
        u_xlat12 = dot(u_xlat1.xyz, u_xlat1.xyz);
        u_xlat12 = sqrt(u_xlat12);
        u_xlat12 = u_xlat12 * VGlobals._ScreenParams.y;
        u_xlat1.xyz = fma(u_xlat3.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat1.x = dot(u_xlat1.xyz, u_xlat1.xyz);
        u_xlat1.x = sqrt(u_xlat1.x);
        u_xlat1.x = u_xlat1.x * VGlobals._EdgeLength;
        u_xlat12 = u_xlat12 / u_xlat1.x;
        tessFactor.edgeTessellationFactor[1] = max(u_xlat12, 1.0);
        u_xlat1.xyz = u_xlat0.xyz + u_xlat2.xyz;
        u_xlat0.xyz = (-u_xlat0.xyz) + u_xlat2.xyz;
        u_xlat0.x = dot(u_xlat0.xyz, u_xlat0.xyz);
        u_xlat0.x = sqrt(u_xlat0.x);
        u_xlat0.x = u_xlat0.x * VGlobals._ScreenParams.y;
        u_xlat4.xyz = fma(u_xlat1.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat4.x = dot(u_xlat4.xyz, u_xlat4.xyz);
        u_xlat4.x = sqrt(u_xlat4.x);
        u_xlat4.x = u_xlat4.x * VGlobals._EdgeLength;
        u_xlat0.x = u_xlat0.x / u_xlat4.x;
        tessFactor.edgeTessellationFactor[2] = max(u_xlat0.x, 1.0);
    }
    // join_phase3
    {
        u_xlat0.x = tessFactor.edgeTessellationFactor[0] + tessFactor.edgeTessellationFactor[1];
        u_xlat0.x = u_xlat0.x + tessFactor.edgeTessellationFactor[2];
        tessFactor.insideTessellationFactor = u_xlat0.x * 0.333333343;
    }
    controlPoints[mtl_VertexID] = output;
    tessFactors[internalPatchID] = tessFactor;
}
// SHADER_STAGE_HULL_end
// SHADER_STAGE_DOMAIN_begin
struct Mtl_VertexInPostTess
{
    patch_control_point<Mtl_ControlPointIn> cp;
};
struct Mtl_VertexOutPostTess
{
    float4 mtl_Position [[ position ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float4 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float4 TEXCOORD3 [[ user(TEXCOORD3) ]];
    float4 TEXCOORD6 [[ user(TEXCOORD6) ]];
    float4 TEXCOORD7 [[ user(TEXCOORD7) ]];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    sampler sampler_Height [[ sampler (0) ]],
    texture2d<float, access::sample > _Height [[ texture(0) ]] ,
    float3 mtl_TessCoord [[ position_in_patch ]],
    uint patchID [[ patch_id ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    Mtl_VertexInPostTess input [[ stage_in ]])
{
#pragma clang diagnostic pop
    Mtl_VertexOutPostTess output;
    MTLTriangleTessellationFactorsHalf tessFactor;
    tessFactor = tessFactors[patchID];
    float4 u_xlat0;
    float4 u_xlat1;
    float4 u_xlat2;
    float4 u_xlat3;
    float2 u_xlat9;
    float u_xlat12;
    float u_xlat13;
    u_xlat0 = mtl_TessCoord.yyyy * input.cp[1].INTERNALTESSPOS0;
    u_xlat0 = fma(input.cp[0].INTERNALTESSPOS0, mtl_TessCoord.xxxx, u_xlat0);
    u_xlat0 = fma(input.cp[2].INTERNALTESSPOS0, mtl_TessCoord.zzzz, u_xlat0);
    u_xlat1.xy = mtl_TessCoord.yy * input.cp[1].TEXCOORD0.xy;
    u_xlat1.xy = fma(input.cp[0].TEXCOORD0.xy, mtl_TessCoord.xx, u_xlat1.xy);
    u_xlat1.xy = fma(input.cp[2].TEXCOORD0.xy, mtl_TessCoord.zz, u_xlat1.xy);
    u_xlat9.xy = u_xlat1.xy * float2(VGlobals._Tile);
    output.TEXCOORD0.xy = fma(u_xlat1.xy, VGlobals._texcoord_ST.xy, VGlobals._texcoord_ST.zw);
    u_xlat1.xyz = _Height.sample(sampler_Height, u_xlat9.xy, level(1.0)).xyz;
    u_xlat2.xyz = mtl_TessCoord.yyy * input.cp[1].NORMAL0.xyz;
    u_xlat2.xyz = fma(input.cp[0].NORMAL0.xyz, mtl_TessCoord.xxx, u_xlat2.xyz);
    u_xlat2.xyz = fma(input.cp[2].NORMAL0.xyz, mtl_TessCoord.zzz, u_xlat2.xyz);
    u_xlat1.xyz = u_xlat1.xyz * u_xlat2.xyz;
    u_xlat0.xyz = fma(u_xlat1.xyz, float3(VGlobals._HeightDisplacement), u_xlat0.xyz);
    u_xlat1 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], u_xlat0.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], u_xlat0.zzzz, u_xlat1);
    u_xlat3 = u_xlat1 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, u_xlat0.www, u_xlat1.xyz);
    u_xlat1 = u_xlat3.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat3.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat3.zzzz, u_xlat1);
    output.mtl_Position = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat3.wwww, u_xlat1);
    u_xlat1.y = dot(u_xlat2.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat1.z = dot(u_xlat2.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat1.x = dot(u_xlat2.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat12 = dot(u_xlat1.xyz, u_xlat1.xyz);
    u_xlat12 = rsqrt(u_xlat12);
    u_xlat1.xyz = float3(u_xlat12) * u_xlat1.xyz;
    output.TEXCOORD1.z = u_xlat1.y;
    u_xlat2 = mtl_TessCoord.yyyy * input.cp[1].TANGENT0;
    u_xlat2 = fma(input.cp[0].TANGENT0, mtl_TessCoord.xxxx, u_xlat2);
    u_xlat2 = fma(input.cp[2].TANGENT0, mtl_TessCoord.zzzz, u_xlat2);
    u_xlat3.xyz = u_xlat2.yyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].yzx;
    u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].yzx, u_xlat2.xxx, u_xlat3.xyz);
    u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].yzx, u_xlat2.zzz, u_xlat3.xyz);
    u_xlat12 = u_xlat2.w * VGlobals.unity_WorldTransformParams.w;
    u_xlat13 = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat13 = rsqrt(u_xlat13);
    u_xlat2.xyz = float3(u_xlat13) * u_xlat2.xyz;
    u_xlat3.xyz = u_xlat1.xyz * u_xlat2.xyz;
    u_xlat3.xyz = fma(u_xlat1.zxy, u_xlat2.yzx, (-u_xlat3.xyz));
    u_xlat3.xyz = float3(u_xlat12) * u_xlat3.xyz;
    output.TEXCOORD1.y = u_xlat3.x;
    output.TEXCOORD1.w = u_xlat0.x;
    output.TEXCOORD1.x = u_xlat2.z;
    output.TEXCOORD2.w = u_xlat0.y;
    output.TEXCOORD3.w = u_xlat0.z;
    output.TEXCOORD2.x = u_xlat2.x;
    output.TEXCOORD3.x = u_xlat2.y;
    output.TEXCOORD2.z = u_xlat1.z;
    output.TEXCOORD3.z = u_xlat1.x;
    output.TEXCOORD2.y = u_xlat3.y;
    output.TEXCOORD3.y = u_xlat3.z;
    output.TEXCOORD6 = float4(0.0, 0.0, 0.0, 0.0);
    output.TEXCOORD7 = float4(0.0, 0.0, 0.0, 0.0);
    return output;
}
// SHADER_STAGE_DOMAIN_end
Compilation succeeded with: 

program_source:301:53: warning: writable resources in non-void post-tessellation vertex function
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
                                                    ^
program_source:307:30: note: writable buffer defined here
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
                             ^
program_source:308:48: note: writable buffer defined here
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
                                               ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float4 TEXCOORD0 [[ attribute(3) ]] ;
    float4 TEXCOORD1 [[ attribute(4) ]] ;
    float4 TEXCOORD2 [[ attribute(5) ]] ;
    float4 TEXCOORD3 [[ attribute(6) ]] ;
    float4 COLOR0 [[ attribute(7) ]] ;
};
struct Mtl_VertexOut
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float4 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float4 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float4 TEXCOORD3 [[ user(TEXCOORD3) ]];
    float4 COLOR0 [[ user(COLOR0) ]];
};
static Mtl_VertexOut vertexFunction(
    Mtl_VertexIn input)
{
    Mtl_VertexOut output;
    output.INTERNALTESSPOS0 = input.POSITION0;
    output.TANGENT0 = input.TANGENT0;
    output.NORMAL0.xyz = input.NORMAL0.xyz;
    output.TEXCOORD0 = input.TEXCOORD0;
    output.TEXCOORD1 = input.TEXCOORD1;
    output.TEXCOORD2 = input.TEXCOORD2;
    output.TEXCOORD3 = input.TEXCOORD3;
    output.COLOR0 = input.COLOR0;
    return output;
}
// SHADER_STAGE_HULL_begin
struct Mtl_ControlPoint
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float4 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float4 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float4 TEXCOORD3 [[ user(TEXCOORD3) ]];
    float4 COLOR0 [[ user(COLOR0) ]];
};
struct Mtl_ControlPointIn
{
    float4 INTERNALTESSPOS0 [[ attribute(8) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float4 TEXCOORD0 [[ attribute(3) ]] ;
    float4 TEXCOORD1 [[ attribute(4) ]] ;
    float4 TEXCOORD2 [[ attribute(5) ]] ;
    float4 TEXCOORD3 [[ attribute(6) ]] ;
    float4 COLOR0 [[ attribute(7) ]] ;
};
struct Mtl_KernelPatchInfo
{
    uint numPatches;
    ushort numControlPointsPerPatch;
};
struct VGlobals_Type
{
    float4 _Time;
    float4 _SinTime;
    float4 _CosTime;
    float4 unity_DeltaTime;
    float3 _WorldSpaceCameraPos;
    float4 _ProjectionParams;
    float4 _ScreenParams;
    float4 _ZBufferParams;
    float4 unity_OrthoParams;
    float4 unity_CameraWorldClipPlanes[6];
    float4 hlslcc_mtx4x4unity_CameraProjection[4];
    float4 hlslcc_mtx4x4unity_CameraInvProjection[4];
    float4 hlslcc_mtx4x4unity_WorldToCamera[4];
    float4 hlslcc_mtx4x4unity_CameraToWorld[4];
    float4 _WorldSpaceLightPos0;
    float4 _LightPositionRange;
    float4 _LightProjectionParams;
    float4 unity_4LightPosX0;
    float4 unity_4LightPosY0;
    float4 unity_4LightPosZ0;
    float4 unity_4LightAtten0;
    float4 unity_LightColor[8];
    float4 unity_LightPosition[8];
    float4 unity_LightAtten[8];
    float4 unity_SpotDirection[8];
    float4 unity_SHAr;
    float4 unity_SHAg;
    float4 unity_SHAb;
    float4 unity_SHBr;
    float4 unity_SHBg;
    float4 unity_SHBb;
    float4 unity_SHC;
    float4 unity_OcclusionMaskSelector;
    float4 unity_ProbesOcclusion;
    float3 unity_LightColor0;
    float3 unity_LightColor1;
    float3 unity_LightColor2;
    float3 unity_LightColor3;
    float4 unity_ShadowSplitSpheres[4];
    float4 unity_ShadowSplitSqRadii;
    float4 unity_LightShadowBias;
    float4 _LightSplitsNear;
    float4 _LightSplitsFar;
    float4 hlslcc_mtx4x4unity_WorldToShadow[16];
    float4 _LightShadowData;
    float4 unity_ShadowFadeCenterAndType;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 unity_LODFade;
    float4 unity_WorldTransformParams;
    float4 unity_RenderingLayer;
    float4 hlslcc_mtx4x4glstate_matrix_transpose_modelview0[4];
    float4 glstate_lightmodel_ambient;
    float4 unity_AmbientSky;
    float4 unity_AmbientEquator;
    float4 unity_AmbientGround;
    float4 unity_IndirectSpecColor;
    float4 hlslcc_mtx4x4glstate_matrix_projection[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixInvV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    int unity_StereoEyeIndex;
    float4 unity_ShadowColor;
    float4 unity_FogColor;
    float4 unity_FogParams;
    float4 unity_LightmapST;
    float4 unity_DynamicLightmapST;
    float4 unity_SpecCube0_BoxMax;
    float4 unity_SpecCube0_BoxMin;
    float4 unity_SpecCube0_ProbePosition;
    float4 unity_SpecCube0_HDR;
    float4 unity_SpecCube1_BoxMax;
    float4 unity_SpecCube1_BoxMin;
    float4 unity_SpecCube1_ProbePosition;
    float4 unity_SpecCube1_HDR;
    float4 unity_ProbeVolumeParams;
    float4 hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[4];
    float3 unity_ProbeVolumeSizeInv;
    float3 unity_ProbeVolumeMin;
    float4 unity_Lightmap_HDR;
    float4 unity_DynamicLightmap_HDR;
    float4 _LightColor0;
    float4 _SpecColor;
    float4 hlslcc_mtx4x4unity_WorldToLight[4];
    float _Tile;
    float _HeightDisplacement;
    float _NormalScale;
    float4 _ColorTint;
    float _MetallicStrength;
    float _SmoothnessStrength;
    float _EdgeLength;
    float4 _texcoord_ST;
};
struct Mtl_HullIn
{
    Mtl_VertexOut cp[3];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
kernel void patchKernel(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn vertexInput [[ stage_in ]],
    uint2 tID [[ thread_position_in_grid ]],
    ushort2 groupID [[ threadgroup_position_in_grid ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    constant Mtl_KernelPatchInfo &patchInfo [[ buffer(3) ]])
{
#pragma clang diagnostic pop
    Mtl_ControlPoint output;
    const uint numPatchesInThreadGroup = 10;
    const uint patchID = (tID.x / patchInfo.numControlPointsPerPatch);
    const bool patchValid = (patchID < patchInfo.numPatches);
    const uint mtl_BaseInstance = 0;
    const uint mtl_InstanceID = groupID.y - mtl_BaseInstance;
    const uint internalPatchID = mtl_InstanceID * patchInfo.numPatches + patchID;
    const uint patchIDInThreadGroup = (patchID % numPatchesInThreadGroup);
    const uint controlPointID = (tID.x % patchInfo.numControlPointsPerPatch);
    const uint mtl_BaseVertex = 0;
    const uint mtl_VertexID = ((mtl_InstanceID * (patchInfo.numControlPointsPerPatch * patchInfo.numPatches)) + tID.x) - mtl_BaseVertex;
    threadgroup Mtl_HullIn inputGroup[numPatchesInThreadGroup];
    threadgroup Mtl_HullIn &input = inputGroup[patchIDInThreadGroup];
    MTLTriangleTessellationFactorsHalf tessFactor;
    if (patchValid) {
        input.cp[controlPointID] = vertexFunction(vertexInput);
        output.INTERNALTESSPOS0 = input.cp[controlPointID].INTERNALTESSPOS0;
        output.TANGENT0 = input.cp[controlPointID].TANGENT0;
        output.NORMAL0 = input.cp[controlPointID].NORMAL0;
        output.TEXCOORD0 = input.cp[controlPointID].TEXCOORD0;
        output.TEXCOORD1 = input.cp[controlPointID].TEXCOORD1;
        output.TEXCOORD2 = input.cp[controlPointID].TEXCOORD2;
        output.TEXCOORD3 = input.cp[controlPointID].TEXCOORD3;
        output.COLOR0 = input.cp[controlPointID].COLOR0;
    }
    threadgroup_barrier(mem_flags::mem_threadgroup);
    if (!patchValid) {
        return;
    }
    float3 u_xlat0;
    float3 u_xlat1;
    float3 u_xlat2;
    float3 u_xlat3;
    float3 u_xlat4;
    float u_xlat12;
    float u_xlat13;
    // fork_phase2
    {
        u_xlat0.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[1].INTERNALTESSPOS0.yyy;
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[1].INTERNALTESSPOS0.xxx, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[1].INTERNALTESSPOS0.zzz, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[1].INTERNALTESSPOS0.www, u_xlat0.xyz);
        u_xlat1.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[2].INTERNALTESSPOS0.yyy;
        u_xlat1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[2].INTERNALTESSPOS0.xxx, u_xlat1.xyz);
        u_xlat1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[2].INTERNALTESSPOS0.zzz, u_xlat1.xyz);
        u_xlat1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[2].INTERNALTESSPOS0.www, u_xlat1.xyz);
        u_xlat2.xyz = u_xlat0.xyz + u_xlat1.xyz;
        u_xlat2.xyz = fma(u_xlat2.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat12 = dot(u_xlat2.xyz, u_xlat2.xyz);
        u_xlat12 = sqrt(u_xlat12);
        u_xlat12 = u_xlat12 * VGlobals._EdgeLength;
        u_xlat2.xyz = u_xlat0.xyz + (-u_xlat1.xyz);
        u_xlat13 = dot(u_xlat2.xyz, u_xlat2.xyz);
        u_xlat13 = sqrt(u_xlat13);
        u_xlat13 = u_xlat13 * VGlobals._ScreenParams.y;
        u_xlat12 = u_xlat13 / u_xlat12;
        tessFactor.edgeTessellationFactor[0] = max(u_xlat12, 1.0);
        u_xlat2.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[0].INTERNALTESSPOS0.yyy;
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[0].INTERNALTESSPOS0.xxx, u_xlat2.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[0].INTERNALTESSPOS0.zzz, u_xlat2.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[0].INTERNALTESSPOS0.www, u_xlat2.xyz);
        u_xlat3.xyz = u_xlat1.xyz + u_xlat2.xyz;
        u_xlat1.xyz = u_xlat1.xyz + (-u_xlat2.xyz);
        u_xlat12 = dot(u_xlat1.xyz, u_xlat1.xyz);
        u_xlat12 = sqrt(u_xlat12);
        u_xlat12 = u_xlat12 * VGlobals._ScreenParams.y;
        u_xlat1.xyz = fma(u_xlat3.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat1.x = dot(u_xlat1.xyz, u_xlat1.xyz);
        u_xlat1.x = sqrt(u_xlat1.x);
        u_xlat1.x = u_xlat1.x * VGlobals._EdgeLength;
        u_xlat12 = u_xlat12 / u_xlat1.x;
        tessFactor.edgeTessellationFactor[1] = max(u_xlat12, 1.0);
        u_xlat1.xyz = u_xlat0.xyz + u_xlat2.xyz;
        u_xlat0.xyz = (-u_xlat0.xyz) + u_xlat2.xyz;
        u_xlat0.x = dot(u_xlat0.xyz, u_xlat0.xyz);
        u_xlat0.x = sqrt(u_xlat0.x);
        u_xlat0.x = u_xlat0.x * VGlobals._ScreenParams.y;
        u_xlat4.xyz = fma(u_xlat1.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat4.x = dot(u_xlat4.xyz, u_xlat4.xyz);
        u_xlat4.x = sqrt(u_xlat4.x);
        u_xlat4.x = u_xlat4.x * VGlobals._EdgeLength;
        u_xlat0.x = u_xlat0.x / u_xlat4.x;
        tessFactor.edgeTessellationFactor[2] = max(u_xlat0.x, 1.0);
    }
    // join_phase3
    {
        u_xlat0.x = tessFactor.edgeTessellationFactor[0] + tessFactor.edgeTessellationFactor[1];
        u_xlat0.x = u_xlat0.x + tessFactor.edgeTessellationFactor[2];
        tessFactor.insideTessellationFactor = u_xlat0.x * 0.333333343;
    }
    controlPoints[mtl_VertexID] = output;
    tessFactors[internalPatchID] = tessFactor;
}
// SHADER_STAGE_HULL_end
// SHADER_STAGE_DOMAIN_begin
struct Mtl_VertexInPostTess
{
    patch_control_point<Mtl_ControlPointIn> cp;
};
struct Mtl_VertexOutPostTess
{
    float4 mtl_Position [[ position ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float3 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float3 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float3 TEXCOORD3 [[ user(TEXCOORD3) ]];
    float3 TEXCOORD4 [[ user(TEXCOORD4) ]];
    float3 TEXCOORD5 [[ user(TEXCOORD5) ]];
    float4 TEXCOORD6 [[ user(TEXCOORD6) ]];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    sampler sampler_Height [[ sampler (0) ]],
    texture2d<float, access::sample > _Height [[ texture(0) ]] ,
    float3 mtl_TessCoord [[ position_in_patch ]],
    uint patchID [[ patch_id ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    Mtl_VertexInPostTess input [[ stage_in ]])
{
#pragma clang diagnostic pop
    Mtl_VertexOutPostTess output;
    MTLTriangleTessellationFactorsHalf tessFactor;
    tessFactor = tessFactors[patchID];
    float4 u_xlat0;
    float3 u_xlat1;
    float4 u_xlat2;
    float4 u_xlat3;
    float4 u_xlat4;
    float2 u_xlat10;
    float u_xlat16;
    u_xlat0.xy = mtl_TessCoord.yy * input.cp[1].TEXCOORD0.xy;
    u_xlat0.xy = fma(input.cp[0].TEXCOORD0.xy, mtl_TessCoord.xx, u_xlat0.xy);
    u_xlat0.xy = fma(input.cp[2].TEXCOORD0.xy, mtl_TessCoord.zz, u_xlat0.xy);
    u_xlat10.xy = u_xlat0.xy * float2(VGlobals._Tile);
    output.TEXCOORD0.xy = fma(u_xlat0.xy, VGlobals._texcoord_ST.xy, VGlobals._texcoord_ST.zw);
    u_xlat0.xyz = _Height.sample(sampler_Height, u_xlat10.xy, level(1.0)).xyz;
    u_xlat1.xyz = mtl_TessCoord.yyy * input.cp[1].NORMAL0.xyz;
    u_xlat1.xyz = fma(input.cp[0].NORMAL0.xyz, mtl_TessCoord.xxx, u_xlat1.xyz);
    u_xlat1.xyz = fma(input.cp[2].NORMAL0.xyz, mtl_TessCoord.zzz, u_xlat1.xyz);
    u_xlat0.xyz = u_xlat0.xyz * u_xlat1.xyz;
    u_xlat2 = mtl_TessCoord.yyyy * input.cp[1].INTERNALTESSPOS0;
    u_xlat2 = fma(input.cp[0].INTERNALTESSPOS0, mtl_TessCoord.xxxx, u_xlat2);
    u_xlat2 = fma(input.cp[2].INTERNALTESSPOS0, mtl_TessCoord.zzzz, u_xlat2);
    u_xlat0.xyz = fma(u_xlat0.xyz, float3(VGlobals._HeightDisplacement), u_xlat2.xyz);
    u_xlat3 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], u_xlat0.xxxx, u_xlat3);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], u_xlat0.zzzz, u_xlat3);
    u_xlat3 = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat4 = u_xlat3.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat4 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat3.xxxx, u_xlat4);
    u_xlat4 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat3.zzzz, u_xlat4);
    output.mtl_Position = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat3.wwww, u_xlat4);
    u_xlat2.y = dot(u_xlat1.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat2.z = dot(u_xlat1.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat2.x = dot(u_xlat1.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat1.x = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat1.x = rsqrt(u_xlat1.x);
    u_xlat1.xyz = u_xlat1.xxx * u_xlat2.xyz;
    output.TEXCOORD1.z = u_xlat1.y;
    u_xlat3 = mtl_TessCoord.yyyy * input.cp[1].TANGENT0;
    u_xlat3 = fma(input.cp[0].TANGENT0, mtl_TessCoord.xxxx, u_xlat3);
    u_xlat3 = fma(input.cp[2].TANGENT0, mtl_TessCoord.zzzz, u_xlat3);
    u_xlat2.xyz = u_xlat3.yyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].yzx;
    u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].yzx, u_xlat3.xxx, u_xlat2.xyz);
    u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].yzx, u_xlat3.zzz, u_xlat2.xyz);
    u_xlat16 = u_xlat3.w * VGlobals.unity_WorldTransformParams.w;
    u_xlat3.x = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat3.x = rsqrt(u_xlat3.x);
    u_xlat2.xyz = u_xlat2.xyz * u_xlat3.xxx;
    u_xlat3.xyz = u_xlat1.xyz * u_xlat2.xyz;
    u_xlat3.xyz = fma(u_xlat1.zxy, u_xlat2.yzx, (-u_xlat3.xyz));
    u_xlat3.xyz = float3(u_xlat16) * u_xlat3.xyz;
    output.TEXCOORD1.y = u_xlat3.x;
    output.TEXCOORD1.x = u_xlat2.z;
    output.TEXCOORD2.x = u_xlat2.x;
    output.TEXCOORD3.x = u_xlat2.y;
    output.TEXCOORD2.z = u_xlat1.z;
    output.TEXCOORD3.z = u_xlat1.x;
    output.TEXCOORD2.y = u_xlat3.y;
    output.TEXCOORD3.y = u_xlat3.z;
    output.TEXCOORD4.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, u_xlat2.www, u_xlat0.xyz);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3], u_xlat2.wwww, u_xlat0);
    u_xlat1.xyz = u_xlat0.yyy * VGlobals.hlslcc_mtx4x4unity_WorldToLight[1].xyz;
    u_xlat1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_WorldToLight[0].xyz, u_xlat0.xxx, u_xlat1.xyz);
    u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_WorldToLight[2].xyz, u_xlat0.zzz, u_xlat1.xyz);
    output.TEXCOORD5.xyz = fma(VGlobals.hlslcc_mtx4x4unity_WorldToLight[3].xyz, u_xlat0.www, u_xlat0.xyz);
    output.TEXCOORD6 = float4(0.0, 0.0, 0.0, 0.0);
    return output;
}
// SHADER_STAGE_DOMAIN_end
Compilation succeeded with: 

program_source:293:53: warning: writable resources in non-void post-tessellation vertex function
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
                                                    ^
program_source:299:30: note: writable buffer defined here
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
                             ^
program_source:300:48: note: writable buffer defined here
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
                                               ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float4 TEXCOORD0 [[ attribute(3) ]] ;
    float4 TEXCOORD1 [[ attribute(4) ]] ;
    float4 TEXCOORD2 [[ attribute(5) ]] ;
    float4 TEXCOORD3 [[ attribute(6) ]] ;
    float4 COLOR0 [[ attribute(7) ]] ;
};
struct Mtl_VertexOut
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float4 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float4 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float4 TEXCOORD3 [[ user(TEXCOORD3) ]];
    float4 COLOR0 [[ user(COLOR0) ]];
};
static Mtl_VertexOut vertexFunction(
    Mtl_VertexIn input)
{
    Mtl_VertexOut output;
    output.INTERNALTESSPOS0 = input.POSITION0;
    output.TANGENT0 = input.TANGENT0;
    output.NORMAL0.xyz = input.NORMAL0.xyz;
    output.TEXCOORD0 = input.TEXCOORD0;
    output.TEXCOORD1 = input.TEXCOORD1;
    output.TEXCOORD2 = input.TEXCOORD2;
    output.TEXCOORD3 = input.TEXCOORD3;
    output.COLOR0 = input.COLOR0;
    return output;
}
// SHADER_STAGE_HULL_begin
struct Mtl_ControlPoint
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float4 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float4 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float4 TEXCOORD3 [[ user(TEXCOORD3) ]];
    float4 COLOR0 [[ user(COLOR0) ]];
};
struct Mtl_ControlPointIn
{
    float4 INTERNALTESSPOS0 [[ attribute(8) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float4 TEXCOORD0 [[ attribute(3) ]] ;
    float4 TEXCOORD1 [[ attribute(4) ]] ;
    float4 TEXCOORD2 [[ attribute(5) ]] ;
    float4 TEXCOORD3 [[ attribute(6) ]] ;
    float4 COLOR0 [[ attribute(7) ]] ;
};
struct Mtl_KernelPatchInfo
{
    uint numPatches;
    ushort numControlPointsPerPatch;
};
struct VGlobals_Type
{
    float4 _Time;
    float4 _SinTime;
    float4 _CosTime;
    float4 unity_DeltaTime;
    float3 _WorldSpaceCameraPos;
    float4 _ProjectionParams;
    float4 _ScreenParams;
    float4 _ZBufferParams;
    float4 unity_OrthoParams;
    float4 unity_CameraWorldClipPlanes[6];
    float4 hlslcc_mtx4x4unity_CameraProjection[4];
    float4 hlslcc_mtx4x4unity_CameraInvProjection[4];
    float4 hlslcc_mtx4x4unity_WorldToCamera[4];
    float4 hlslcc_mtx4x4unity_CameraToWorld[4];
    float4 _WorldSpaceLightPos0;
    float4 _LightPositionRange;
    float4 _LightProjectionParams;
    float4 unity_4LightPosX0;
    float4 unity_4LightPosY0;
    float4 unity_4LightPosZ0;
    float4 unity_4LightAtten0;
    float4 unity_LightColor[8];
    float4 unity_LightPosition[8];
    float4 unity_LightAtten[8];
    float4 unity_SpotDirection[8];
    float4 unity_SHAr;
    float4 unity_SHAg;
    float4 unity_SHAb;
    float4 unity_SHBr;
    float4 unity_SHBg;
    float4 unity_SHBb;
    float4 unity_SHC;
    float4 unity_OcclusionMaskSelector;
    float4 unity_ProbesOcclusion;
    float3 unity_LightColor0;
    float3 unity_LightColor1;
    float3 unity_LightColor2;
    float3 unity_LightColor3;
    float4 unity_ShadowSplitSpheres[4];
    float4 unity_ShadowSplitSqRadii;
    float4 unity_LightShadowBias;
    float4 _LightSplitsNear;
    float4 _LightSplitsFar;
    float4 hlslcc_mtx4x4unity_WorldToShadow[16];
    float4 _LightShadowData;
    float4 unity_ShadowFadeCenterAndType;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 unity_LODFade;
    float4 unity_WorldTransformParams;
    float4 unity_RenderingLayer;
    float4 hlslcc_mtx4x4glstate_matrix_transpose_modelview0[4];
    float4 glstate_lightmodel_ambient;
    float4 unity_AmbientSky;
    float4 unity_AmbientEquator;
    float4 unity_AmbientGround;
    float4 unity_IndirectSpecColor;
    float4 hlslcc_mtx4x4glstate_matrix_projection[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixInvV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    int unity_StereoEyeIndex;
    float4 unity_ShadowColor;
    float4 unity_FogColor;
    float4 unity_FogParams;
    float4 unity_LightmapST;
    float4 unity_DynamicLightmapST;
    float4 unity_SpecCube0_BoxMax;
    float4 unity_SpecCube0_BoxMin;
    float4 unity_SpecCube0_ProbePosition;
    float4 unity_SpecCube0_HDR;
    float4 unity_SpecCube1_BoxMax;
    float4 unity_SpecCube1_BoxMin;
    float4 unity_SpecCube1_ProbePosition;
    float4 unity_SpecCube1_HDR;
    float4 unity_ProbeVolumeParams;
    float4 hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[4];
    float3 unity_ProbeVolumeSizeInv;
    float3 unity_ProbeVolumeMin;
    float4 unity_Lightmap_HDR;
    float4 unity_DynamicLightmap_HDR;
    float4 _LightColor0;
    float4 _SpecColor;
    float _Tile;
    float _HeightDisplacement;
    float _NormalScale;
    float4 _ColorTint;
    float _MetallicStrength;
    float _SmoothnessStrength;
    float _EdgeLength;
};
struct Mtl_HullIn
{
    Mtl_VertexOut cp[3];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
kernel void patchKernel(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn vertexInput [[ stage_in ]],
    uint2 tID [[ thread_position_in_grid ]],
    ushort2 groupID [[ threadgroup_position_in_grid ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    constant Mtl_KernelPatchInfo &patchInfo [[ buffer(3) ]])
{
#pragma clang diagnostic pop
    Mtl_ControlPoint output;
    const uint numPatchesInThreadGroup = 10;
    const uint patchID = (tID.x / patchInfo.numControlPointsPerPatch);
    const bool patchValid = (patchID < patchInfo.numPatches);
    const uint mtl_BaseInstance = 0;
    const uint mtl_InstanceID = groupID.y - mtl_BaseInstance;
    const uint internalPatchID = mtl_InstanceID * patchInfo.numPatches + patchID;
    const uint patchIDInThreadGroup = (patchID % numPatchesInThreadGroup);
    const uint controlPointID = (tID.x % patchInfo.numControlPointsPerPatch);
    const uint mtl_BaseVertex = 0;
    const uint mtl_VertexID = ((mtl_InstanceID * (patchInfo.numControlPointsPerPatch * patchInfo.numPatches)) + tID.x) - mtl_BaseVertex;
    threadgroup Mtl_HullIn inputGroup[numPatchesInThreadGroup];
    threadgroup Mtl_HullIn &input = inputGroup[patchIDInThreadGroup];
    MTLTriangleTessellationFactorsHalf tessFactor;
    if (patchValid) {
        input.cp[controlPointID] = vertexFunction(vertexInput);
        output.INTERNALTESSPOS0 = input.cp[controlPointID].INTERNALTESSPOS0;
        output.TANGENT0 = input.cp[controlPointID].TANGENT0;
        output.NORMAL0 = input.cp[controlPointID].NORMAL0;
        output.TEXCOORD0 = input.cp[controlPointID].TEXCOORD0;
        output.TEXCOORD1 = input.cp[controlPointID].TEXCOORD1;
        output.TEXCOORD2 = input.cp[controlPointID].TEXCOORD2;
        output.TEXCOORD3 = input.cp[controlPointID].TEXCOORD3;
        output.COLOR0 = input.cp[controlPointID].COLOR0;
    }
    threadgroup_barrier(mem_flags::mem_threadgroup);
    if (!patchValid) {
        return;
    }
    float3 u_xlat0;
    float3 u_xlat1;
    float3 u_xlat2;
    float3 u_xlat3;
    float3 u_xlat4;
    float u_xlat12;
    float u_xlat13;
    // fork_phase2
    {
        u_xlat0.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[1].INTERNALTESSPOS0.yyy;
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[1].INTERNALTESSPOS0.xxx, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[1].INTERNALTESSPOS0.zzz, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[1].INTERNALTESSPOS0.www, u_xlat0.xyz);
        u_xlat1.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[2].INTERNALTESSPOS0.yyy;
        u_xlat1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[2].INTERNALTESSPOS0.xxx, u_xlat1.xyz);
        u_xlat1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[2].INTERNALTESSPOS0.zzz, u_xlat1.xyz);
        u_xlat1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[2].INTERNALTESSPOS0.www, u_xlat1.xyz);
        u_xlat2.xyz = u_xlat0.xyz + u_xlat1.xyz;
        u_xlat2.xyz = fma(u_xlat2.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat12 = dot(u_xlat2.xyz, u_xlat2.xyz);
        u_xlat12 = sqrt(u_xlat12);
        u_xlat12 = u_xlat12 * VGlobals._EdgeLength;
        u_xlat2.xyz = u_xlat0.xyz + (-u_xlat1.xyz);
        u_xlat13 = dot(u_xlat2.xyz, u_xlat2.xyz);
        u_xlat13 = sqrt(u_xlat13);
        u_xlat13 = u_xlat13 * VGlobals._ScreenParams.y;
        u_xlat12 = u_xlat13 / u_xlat12;
        tessFactor.edgeTessellationFactor[0] = max(u_xlat12, 1.0);
        u_xlat2.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[0].INTERNALTESSPOS0.yyy;
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[0].INTERNALTESSPOS0.xxx, u_xlat2.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[0].INTERNALTESSPOS0.zzz, u_xlat2.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[0].INTERNALTESSPOS0.www, u_xlat2.xyz);
        u_xlat3.xyz = u_xlat1.xyz + u_xlat2.xyz;
        u_xlat1.xyz = u_xlat1.xyz + (-u_xlat2.xyz);
        u_xlat12 = dot(u_xlat1.xyz, u_xlat1.xyz);
        u_xlat12 = sqrt(u_xlat12);
        u_xlat12 = u_xlat12 * VGlobals._ScreenParams.y;
        u_xlat1.xyz = fma(u_xlat3.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat1.x = dot(u_xlat1.xyz, u_xlat1.xyz);
        u_xlat1.x = sqrt(u_xlat1.x);
        u_xlat1.x = u_xlat1.x * VGlobals._EdgeLength;
        u_xlat12 = u_xlat12 / u_xlat1.x;
        tessFactor.edgeTessellationFactor[1] = max(u_xlat12, 1.0);
        u_xlat1.xyz = u_xlat0.xyz + u_xlat2.xyz;
        u_xlat0.xyz = (-u_xlat0.xyz) + u_xlat2.xyz;
        u_xlat0.x = dot(u_xlat0.xyz, u_xlat0.xyz);
        u_xlat0.x = sqrt(u_xlat0.x);
        u_xlat0.x = u_xlat0.x * VGlobals._ScreenParams.y;
        u_xlat4.xyz = fma(u_xlat1.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat4.x = dot(u_xlat4.xyz, u_xlat4.xyz);
        u_xlat4.x = sqrt(u_xlat4.x);
        u_xlat4.x = u_xlat4.x * VGlobals._EdgeLength;
        u_xlat0.x = u_xlat0.x / u_xlat4.x;
        tessFactor.edgeTessellationFactor[2] = max(u_xlat0.x, 1.0);
    }
    // join_phase3
    {
        u_xlat0.x = tessFactor.edgeTessellationFactor[0] + tessFactor.edgeTessellationFactor[1];
        u_xlat0.x = u_xlat0.x + tessFactor.edgeTessellationFactor[2];
        tessFactor.insideTessellationFactor = u_xlat0.x * 0.333333343;
    }
    controlPoints[mtl_VertexID] = output;
    tessFactors[internalPatchID] = tessFactor;
}
// SHADER_STAGE_HULL_end
// SHADER_STAGE_DOMAIN_begin
struct Mtl_VertexInPostTess
{
    patch_control_point<Mtl_ControlPointIn> cp;
};
struct Mtl_VertexOutPostTess
{
    float4 mtl_Position [[ position ]];
    float3 TEXCOORD1 [[ user(TEXCOORD1) ]];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    sampler sampler_Height [[ sampler (0) ]],
    texture2d<float, access::sample > _Height [[ texture(0) ]] ,
    float3 mtl_TessCoord [[ position_in_patch ]],
    uint patchID [[ patch_id ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    Mtl_VertexInPostTess input [[ stage_in ]])
{
#pragma clang diagnostic pop
    Mtl_VertexOutPostTess output;
    MTLTriangleTessellationFactorsHalf tessFactor;
    tessFactor = tessFactors[patchID];
    float4 u_xlat0;
    float4 u_xlat1;
    float4 u_xlat2;
    float4 u_xlat3;
    float4 u_xlat4;
    float u_xlat11;
    float u_xlat15;
    bool u_xlatb15;
    u_xlat0.xyz = mtl_TessCoord.yyy * input.cp[1].NORMAL0.xyz;
    u_xlat0.xyz = fma(input.cp[0].NORMAL0.xyz, mtl_TessCoord.xxx, u_xlat0.xyz);
    u_xlat0.xyz = fma(input.cp[2].NORMAL0.xyz, mtl_TessCoord.zzz, u_xlat0.xyz);
    u_xlat1.x = dot(u_xlat0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat1.y = dot(u_xlat0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat1.z = dot(u_xlat0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat15 = dot(u_xlat1.xyz, u_xlat1.xyz);
    u_xlat15 = rsqrt(u_xlat15);
    u_xlat1.xyz = float3(u_xlat15) * u_xlat1.xyz;
    u_xlat2.xy = mtl_TessCoord.yy * input.cp[1].TEXCOORD0.xy;
    u_xlat2.xy = fma(input.cp[0].TEXCOORD0.xy, mtl_TessCoord.xx, u_xlat2.xy);
    u_xlat2.xy = fma(input.cp[2].TEXCOORD0.xy, mtl_TessCoord.zz, u_xlat2.xy);
    u_xlat2.xy = u_xlat2.xy * float2(VGlobals._Tile);
    u_xlat2.xyz = _Height.sample(sampler_Height, u_xlat2.xy, level(1.0)).xyz;
    u_xlat0.xyz = u_xlat0.xyz * u_xlat2.xyz;
    u_xlat2 = mtl_TessCoord.yyyy * input.cp[1].INTERNALTESSPOS0;
    u_xlat2 = fma(input.cp[0].INTERNALTESSPOS0, mtl_TessCoord.xxxx, u_xlat2);
    u_xlat2 = fma(input.cp[2].INTERNALTESSPOS0, mtl_TessCoord.zzzz, u_xlat2);
    u_xlat0.xyz = fma(u_xlat0.xyz, float3(VGlobals._HeightDisplacement), u_xlat2.xyz);
    u_xlat3 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], u_xlat0.xxxx, u_xlat3);
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], u_xlat0.zzzz, u_xlat3);
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3], u_xlat2.wwww, u_xlat3);
    u_xlat2.xyz = fma((-u_xlat3.xyz), VGlobals._WorldSpaceLightPos0.www, VGlobals._WorldSpaceLightPos0.xyz);
    u_xlat15 = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat15 = rsqrt(u_xlat15);
    u_xlat2.xyz = float3(u_xlat15) * u_xlat2.xyz;
    u_xlat15 = dot(u_xlat1.xyz, u_xlat2.xyz);
    u_xlat15 = fma((-u_xlat15), u_xlat15, 1.0);
    u_xlat15 = sqrt(u_xlat15);
    u_xlat15 = u_xlat15 * VGlobals.unity_LightShadowBias.z;
    u_xlat1.xyz = fma((-u_xlat1.xyz), float3(u_xlat15), u_xlat3.xyz);
    u_xlatb15 = VGlobals.unity_LightShadowBias.z!=0.0;
    u_xlat1.xyz = (bool(u_xlatb15)) ? u_xlat1.xyz : u_xlat3.xyz;
    u_xlat4 = u_xlat1.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat4 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat1.xxxx, u_xlat4);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat1.zzzz, u_xlat4);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat3.wwww, u_xlat1);
    u_xlat15 = VGlobals.unity_LightShadowBias.x / u_xlat1.w;
    u_xlat15 = min(u_xlat15, 0.0);
    u_xlat15 = max(u_xlat15, -1.0);
    u_xlat15 = u_xlat15 + u_xlat1.z;
    u_xlat11 = min(u_xlat1.w, u_xlat15);
    output.mtl_Position.xyw = u_xlat1.xyw;
    u_xlat1.x = (-u_xlat15) + u_xlat11;
    output.mtl_Position.z = fma(VGlobals.unity_LightShadowBias.y, u_xlat1.x, u_xlat15);
    u_xlat1.xyz = u_xlat0.yyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz;
    u_xlat0.xyw = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, u_xlat0.xxx, u_xlat1.xyz);
    u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, u_xlat0.zzz, u_xlat0.xyw);
    output.TEXCOORD1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, u_xlat2.www, u_xlat0.xyz);
    return output;
}
// SHADER_STAGE_DOMAIN_end
Compilation succeeded with: 

program_source:299:53: warning: writable resources in non-void post-tessellation vertex function
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
                                                    ^
program_source:305:30: note: writable buffer defined here
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
                             ^
program_source:306:48: note: writable buffer defined here
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
                                               ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float4 TEXCOORD0 [[ attribute(3) ]] ;
    float4 TEXCOORD1 [[ attribute(4) ]] ;
    float4 TEXCOORD2 [[ attribute(5) ]] ;
    float4 TEXCOORD3 [[ attribute(6) ]] ;
    float4 COLOR0 [[ attribute(7) ]] ;
};
struct Mtl_VertexOut
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float4 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float4 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float4 TEXCOORD3 [[ user(TEXCOORD3) ]];
    float4 COLOR0 [[ user(COLOR0) ]];
};
static Mtl_VertexOut vertexFunction(
    Mtl_VertexIn input)
{
    Mtl_VertexOut output;
    output.INTERNALTESSPOS0 = input.POSITION0;
    output.TANGENT0 = input.TANGENT0;
    output.NORMAL0.xyz = input.NORMAL0.xyz;
    output.TEXCOORD0 = input.TEXCOORD0;
    output.TEXCOORD1 = input.TEXCOORD1;
    output.TEXCOORD2 = input.TEXCOORD2;
    output.TEXCOORD3 = input.TEXCOORD3;
    output.COLOR0 = input.COLOR0;
    return output;
}
// SHADER_STAGE_HULL_begin
struct Mtl_ControlPoint
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float4 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float4 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float4 TEXCOORD3 [[ user(TEXCOORD3) ]];
    float4 COLOR0 [[ user(COLOR0) ]];
};
struct Mtl_ControlPointIn
{
    float4 INTERNALTESSPOS0 [[ attribute(8) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float4 TEXCOORD0 [[ attribute(3) ]] ;
    float4 TEXCOORD1 [[ attribute(4) ]] ;
    float4 TEXCOORD2 [[ attribute(5) ]] ;
    float4 TEXCOORD3 [[ attribute(6) ]] ;
    float4 COLOR0 [[ attribute(7) ]] ;
};
struct Mtl_KernelPatchInfo
{
    uint numPatches;
    ushort numControlPointsPerPatch;
};
struct VGlobals_Type
{
    float4 _Time;
    float4 _SinTime;
    float4 _CosTime;
    float4 unity_DeltaTime;
    float3 _WorldSpaceCameraPos;
    float4 _ProjectionParams;
    float4 _ScreenParams;
    float4 _ZBufferParams;
    float4 unity_OrthoParams;
    float4 unity_CameraWorldClipPlanes[6];
    float4 hlslcc_mtx4x4unity_CameraProjection[4];
    float4 hlslcc_mtx4x4unity_CameraInvProjection[4];
    float4 hlslcc_mtx4x4unity_WorldToCamera[4];
    float4 hlslcc_mtx4x4unity_CameraToWorld[4];
    float4 _WorldSpaceLightPos0;
    float4 _LightPositionRange;
    float4 _LightProjectionParams;
    float4 unity_4LightPosX0;
    float4 unity_4LightPosY0;
    float4 unity_4LightPosZ0;
    float4 unity_4LightAtten0;
    float4 unity_LightColor[8];
    float4 unity_LightPosition[8];
    float4 unity_LightAtten[8];
    float4 unity_SpotDirection[8];
    float4 unity_SHAr;
    float4 unity_SHAg;
    float4 unity_SHAb;
    float4 unity_SHBr;
    float4 unity_SHBg;
    float4 unity_SHBb;
    float4 unity_SHC;
    float4 unity_OcclusionMaskSelector;
    float4 unity_ProbesOcclusion;
    float3 unity_LightColor0;
    float3 unity_LightColor1;
    float3 unity_LightColor2;
    float3 unity_LightColor3;
    float4 unity_ShadowSplitSpheres[4];
    float4 unity_ShadowSplitSqRadii;
    float4 unity_LightShadowBias;
    float4 _LightSplitsNear;
    float4 _LightSplitsFar;
    float4 hlslcc_mtx4x4unity_WorldToShadow[16];
    float4 _LightShadowData;
    float4 unity_ShadowFadeCenterAndType;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 unity_LODFade;
    float4 unity_WorldTransformParams;
    float4 unity_RenderingLayer;
    float4 hlslcc_mtx4x4glstate_matrix_transpose_modelview0[4];
    float4 glstate_lightmodel_ambient;
    float4 unity_AmbientSky;
    float4 unity_AmbientEquator;
    float4 unity_AmbientGround;
    float4 unity_IndirectSpecColor;
    float4 hlslcc_mtx4x4glstate_matrix_projection[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixInvV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    int unity_StereoEyeIndex;
    float4 unity_ShadowColor;
    float4 unity_FogColor;
    float4 unity_FogParams;
    float4 unity_LightmapST;
    float4 unity_DynamicLightmapST;
    float4 unity_SpecCube0_BoxMax;
    float4 unity_SpecCube0_BoxMin;
    float4 unity_SpecCube0_ProbePosition;
    float4 unity_SpecCube0_HDR;
    float4 unity_SpecCube1_BoxMax;
    float4 unity_SpecCube1_BoxMin;
    float4 unity_SpecCube1_ProbePosition;
    float4 unity_SpecCube1_HDR;
    float4 unity_ProbeVolumeParams;
    float4 hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[4];
    float3 unity_ProbeVolumeSizeInv;
    float3 unity_ProbeVolumeMin;
    float4 unity_Lightmap_HDR;
    float4 unity_DynamicLightmap_HDR;
    float4 _LightColor0;
    float4 _SpecColor;
    float _Tile;
    float _HeightDisplacement;
    float _NormalScale;
    float4 _ColorTint;
    float _MetallicStrength;
    float _SmoothnessStrength;
    float _EdgeLength;
    float4 _texcoord_ST;
    float4 unity_Ambient;
};
struct Mtl_HullIn
{
    Mtl_VertexOut cp[3];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
kernel void patchKernel(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn vertexInput [[ stage_in ]],
    uint2 tID [[ thread_position_in_grid ]],
    ushort2 groupID [[ threadgroup_position_in_grid ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    constant Mtl_KernelPatchInfo &patchInfo [[ buffer(3) ]])
{
#pragma clang diagnostic pop
    Mtl_ControlPoint output;
    const uint numPatchesInThreadGroup = 10;
    const uint patchID = (tID.x / patchInfo.numControlPointsPerPatch);
    const bool patchValid = (patchID < patchInfo.numPatches);
    const uint mtl_BaseInstance = 0;
    const uint mtl_InstanceID = groupID.y - mtl_BaseInstance;
    const uint internalPatchID = mtl_InstanceID * patchInfo.numPatches + patchID;
    const uint patchIDInThreadGroup = (patchID % numPatchesInThreadGroup);
    const uint controlPointID = (tID.x % patchInfo.numControlPointsPerPatch);
    const uint mtl_BaseVertex = 0;
    const uint mtl_VertexID = ((mtl_InstanceID * (patchInfo.numControlPointsPerPatch * patchInfo.numPatches)) + tID.x) - mtl_BaseVertex;
    threadgroup Mtl_HullIn inputGroup[numPatchesInThreadGroup];
    threadgroup Mtl_HullIn &input = inputGroup[patchIDInThreadGroup];
    MTLTriangleTessellationFactorsHalf tessFactor;
    if (patchValid) {
        input.cp[controlPointID] = vertexFunction(vertexInput);
        output.INTERNALTESSPOS0 = input.cp[controlPointID].INTERNALTESSPOS0;
        output.TANGENT0 = input.cp[controlPointID].TANGENT0;
        output.NORMAL0 = input.cp[controlPointID].NORMAL0;
        output.TEXCOORD0 = input.cp[controlPointID].TEXCOORD0;
        output.TEXCOORD1 = input.cp[controlPointID].TEXCOORD1;
        output.TEXCOORD2 = input.cp[controlPointID].TEXCOORD2;
        output.TEXCOORD3 = input.cp[controlPointID].TEXCOORD3;
        output.COLOR0 = input.cp[controlPointID].COLOR0;
    }
    threadgroup_barrier(mem_flags::mem_threadgroup);
    if (!patchValid) {
        return;
    }
    float3 u_xlat0;
    float3 u_xlat1;
    float3 u_xlat2;
    float3 u_xlat3;
    float3 u_xlat4;
    float u_xlat12;
    float u_xlat13;
    // fork_phase2
    {
        u_xlat0.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[1].INTERNALTESSPOS0.yyy;
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[1].INTERNALTESSPOS0.xxx, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[1].INTERNALTESSPOS0.zzz, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[1].INTERNALTESSPOS0.www, u_xlat0.xyz);
        u_xlat1.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[2].INTERNALTESSPOS0.yyy;
        u_xlat1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[2].INTERNALTESSPOS0.xxx, u_xlat1.xyz);
        u_xlat1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[2].INTERNALTESSPOS0.zzz, u_xlat1.xyz);
        u_xlat1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[2].INTERNALTESSPOS0.www, u_xlat1.xyz);
        u_xlat2.xyz = u_xlat0.xyz + u_xlat1.xyz;
        u_xlat2.xyz = fma(u_xlat2.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat12 = dot(u_xlat2.xyz, u_xlat2.xyz);
        u_xlat12 = sqrt(u_xlat12);
        u_xlat12 = u_xlat12 * VGlobals._EdgeLength;
        u_xlat2.xyz = u_xlat0.xyz + (-u_xlat1.xyz);
        u_xlat13 = dot(u_xlat2.xyz, u_xlat2.xyz);
        u_xlat13 = sqrt(u_xlat13);
        u_xlat13 = u_xlat13 * VGlobals._ScreenParams.y;
        u_xlat12 = u_xlat13 / u_xlat12;
        tessFactor.edgeTessellationFactor[0] = max(u_xlat12, 1.0);
        u_xlat2.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[0].INTERNALTESSPOS0.yyy;
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[0].INTERNALTESSPOS0.xxx, u_xlat2.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[0].INTERNALTESSPOS0.zzz, u_xlat2.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[0].INTERNALTESSPOS0.www, u_xlat2.xyz);
        u_xlat3.xyz = u_xlat1.xyz + u_xlat2.xyz;
        u_xlat1.xyz = u_xlat1.xyz + (-u_xlat2.xyz);
        u_xlat12 = dot(u_xlat1.xyz, u_xlat1.xyz);
        u_xlat12 = sqrt(u_xlat12);
        u_xlat12 = u_xlat12 * VGlobals._ScreenParams.y;
        u_xlat1.xyz = fma(u_xlat3.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat1.x = dot(u_xlat1.xyz, u_xlat1.xyz);
        u_xlat1.x = sqrt(u_xlat1.x);
        u_xlat1.x = u_xlat1.x * VGlobals._EdgeLength;
        u_xlat12 = u_xlat12 / u_xlat1.x;
        tessFactor.edgeTessellationFactor[1] = max(u_xlat12, 1.0);
        u_xlat1.xyz = u_xlat0.xyz + u_xlat2.xyz;
        u_xlat0.xyz = (-u_xlat0.xyz) + u_xlat2.xyz;
        u_xlat0.x = dot(u_xlat0.xyz, u_xlat0.xyz);
        u_xlat0.x = sqrt(u_xlat0.x);
        u_xlat0.x = u_xlat0.x * VGlobals._ScreenParams.y;
        u_xlat4.xyz = fma(u_xlat1.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat4.x = dot(u_xlat4.xyz, u_xlat4.xyz);
        u_xlat4.x = sqrt(u_xlat4.x);
        u_xlat4.x = u_xlat4.x * VGlobals._EdgeLength;
        u_xlat0.x = u_xlat0.x / u_xlat4.x;
        tessFactor.edgeTessellationFactor[2] = max(u_xlat0.x, 1.0);
    }
    // join_phase3
    {
        u_xlat0.x = tessFactor.edgeTessellationFactor[0] + tessFactor.edgeTessellationFactor[1];
        u_xlat0.x = u_xlat0.x + tessFactor.edgeTessellationFactor[2];
        tessFactor.insideTessellationFactor = u_xlat0.x * 0.333333343;
    }
    controlPoints[mtl_VertexID] = output;
    tessFactors[internalPatchID] = tessFactor;
}
// SHADER_STAGE_HULL_end
// SHADER_STAGE_DOMAIN_begin
struct Mtl_VertexInPostTess
{
    patch_control_point<Mtl_ControlPointIn> cp;
};
struct Mtl_VertexOutPostTess
{
    float4 mtl_Position [[ position ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float4 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float4 TEXCOORD3 [[ user(TEXCOORD3) ]];
    float4 TEXCOORD5 [[ user(TEXCOORD5) ]];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    sampler sampler_Height [[ sampler (0) ]],
    texture2d<float, access::sample > _Height [[ texture(0) ]] ,
    float3 mtl_TessCoord [[ position_in_patch ]],
    uint patchID [[ patch_id ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    Mtl_VertexInPostTess input [[ stage_in ]])
{
#pragma clang diagnostic pop
    Mtl_VertexOutPostTess output;
    MTLTriangleTessellationFactorsHalf tessFactor;
    tessFactor = tessFactors[patchID];
    float4 u_xlat0;
    float4 u_xlat1;
    float4 u_xlat2;
    float4 u_xlat3;
    float2 u_xlat9;
    float u_xlat12;
    float u_xlat13;
    u_xlat0 = mtl_TessCoord.yyyy * input.cp[1].INTERNALTESSPOS0;
    u_xlat0 = fma(input.cp[0].INTERNALTESSPOS0, mtl_TessCoord.xxxx, u_xlat0);
    u_xlat0 = fma(input.cp[2].INTERNALTESSPOS0, mtl_TessCoord.zzzz, u_xlat0);
    u_xlat1.xy = mtl_TessCoord.yy * input.cp[1].TEXCOORD0.xy;
    u_xlat1.xy = fma(input.cp[0].TEXCOORD0.xy, mtl_TessCoord.xx, u_xlat1.xy);
    u_xlat1.xy = fma(input.cp[2].TEXCOORD0.xy, mtl_TessCoord.zz, u_xlat1.xy);
    u_xlat9.xy = u_xlat1.xy * float2(VGlobals._Tile);
    output.TEXCOORD0.xy = fma(u_xlat1.xy, VGlobals._texcoord_ST.xy, VGlobals._texcoord_ST.zw);
    u_xlat1.xyz = _Height.sample(sampler_Height, u_xlat9.xy, level(1.0)).xyz;
    u_xlat2.xyz = mtl_TessCoord.yyy * input.cp[1].NORMAL0.xyz;
    u_xlat2.xyz = fma(input.cp[0].NORMAL0.xyz, mtl_TessCoord.xxx, u_xlat2.xyz);
    u_xlat2.xyz = fma(input.cp[2].NORMAL0.xyz, mtl_TessCoord.zzz, u_xlat2.xyz);
    u_xlat1.xyz = u_xlat1.xyz * u_xlat2.xyz;
    u_xlat0.xyz = fma(u_xlat1.xyz, float3(VGlobals._HeightDisplacement), u_xlat0.xyz);
    u_xlat1 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], u_xlat0.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], u_xlat0.zzzz, u_xlat1);
    u_xlat3 = u_xlat1 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, u_xlat0.www, u_xlat1.xyz);
    u_xlat1 = u_xlat3.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat3.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat3.zzzz, u_xlat1);
    output.mtl_Position = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat3.wwww, u_xlat1);
    u_xlat1.y = dot(u_xlat2.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat1.z = dot(u_xlat2.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat1.x = dot(u_xlat2.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat12 = dot(u_xlat1.xyz, u_xlat1.xyz);
    u_xlat12 = rsqrt(u_xlat12);
    u_xlat1.xyz = float3(u_xlat12) * u_xlat1.xyz;
    output.TEXCOORD1.z = u_xlat1.y;
    u_xlat2 = mtl_TessCoord.yyyy * input.cp[1].TANGENT0;
    u_xlat2 = fma(input.cp[0].TANGENT0, mtl_TessCoord.xxxx, u_xlat2);
    u_xlat2 = fma(input.cp[2].TANGENT0, mtl_TessCoord.zzzz, u_xlat2);
    u_xlat3.xyz = u_xlat2.yyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].yzx;
    u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].yzx, u_xlat2.xxx, u_xlat3.xyz);
    u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].yzx, u_xlat2.zzz, u_xlat3.xyz);
    u_xlat12 = u_xlat2.w * VGlobals.unity_WorldTransformParams.w;
    u_xlat13 = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat13 = rsqrt(u_xlat13);
    u_xlat2.xyz = float3(u_xlat13) * u_xlat2.xyz;
    u_xlat3.xyz = u_xlat1.xyz * u_xlat2.xyz;
    u_xlat3.xyz = fma(u_xlat1.zxy, u_xlat2.yzx, (-u_xlat3.xyz));
    u_xlat3.xyz = float3(u_xlat12) * u_xlat3.xyz;
    output.TEXCOORD1.y = u_xlat3.x;
    output.TEXCOORD1.w = u_xlat0.x;
    output.TEXCOORD1.x = u_xlat2.z;
    output.TEXCOORD2.w = u_xlat0.y;
    output.TEXCOORD3.w = u_xlat0.z;
    output.TEXCOORD2.x = u_xlat2.x;
    output.TEXCOORD3.x = u_xlat2.y;
    output.TEXCOORD2.z = u_xlat1.z;
    output.TEXCOORD3.z = u_xlat1.x;
    output.TEXCOORD2.y = u_xlat3.y;
    output.TEXCOORD3.y = u_xlat3.z;
    output.TEXCOORD5 = float4(0.0, 0.0, 0.0, 0.0);
    return output;
}
// SHADER_STAGE_DOMAIN_end
Compilation succeeded with: 

program_source:303:53: warning: writable resources in non-void post-tessellation vertex function
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
                                                    ^
program_source:309:30: note: writable buffer defined here
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
                             ^
program_source:310:48: note: writable buffer defined here
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
                                               ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float4 TEXCOORD0 [[ attribute(3) ]] ;
    float4 TEXCOORD1 [[ attribute(4) ]] ;
    float4 TEXCOORD2 [[ attribute(5) ]] ;
    float4 TEXCOORD3 [[ attribute(6) ]] ;
    float4 COLOR0 [[ attribute(7) ]] ;
};
struct Mtl_VertexOut
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float4 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float4 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float4 TEXCOORD3 [[ user(TEXCOORD3) ]];
    float4 COLOR0 [[ user(COLOR0) ]];
};
static Mtl_VertexOut vertexFunction(
    Mtl_VertexIn input)
{
    Mtl_VertexOut output;
    output.INTERNALTESSPOS0 = input.POSITION0;
    output.TANGENT0 = input.TANGENT0;
    output.NORMAL0.xyz = input.NORMAL0.xyz;
    output.TEXCOORD0 = input.TEXCOORD0;
    output.TEXCOORD1 = input.TEXCOORD1;
    output.TEXCOORD2 = input.TEXCOORD2;
    output.TEXCOORD3 = input.TEXCOORD3;
    output.COLOR0 = input.COLOR0;
    return output;
}
// SHADER_STAGE_HULL_begin
struct Mtl_ControlPoint
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float4 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float4 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float4 TEXCOORD3 [[ user(TEXCOORD3) ]];
    float4 COLOR0 [[ user(COLOR0) ]];
};
struct Mtl_ControlPointIn
{
    float4 INTERNALTESSPOS0 [[ attribute(8) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float4 TEXCOORD0 [[ attribute(3) ]] ;
    float4 TEXCOORD1 [[ attribute(4) ]] ;
    float4 TEXCOORD2 [[ attribute(5) ]] ;
    float4 TEXCOORD3 [[ attribute(6) ]] ;
    float4 COLOR0 [[ attribute(7) ]] ;
};
struct Mtl_KernelPatchInfo
{
    uint numPatches;
    ushort numControlPointsPerPatch;
};
struct VGlobals_Type
{
    float4 _Time;
    float4 _SinTime;
    float4 _CosTime;
    float4 unity_DeltaTime;
    float3 _WorldSpaceCameraPos;
    float4 _ProjectionParams;
    float4 _ScreenParams;
    float4 _ZBufferParams;
    float4 unity_OrthoParams;
    float4 unity_CameraWorldClipPlanes[6];
    float4 hlslcc_mtx4x4unity_CameraProjection[4];
    float4 hlslcc_mtx4x4unity_CameraInvProjection[4];
    float4 hlslcc_mtx4x4unity_WorldToCamera[4];
    float4 hlslcc_mtx4x4unity_CameraToWorld[4];
    float4 _WorldSpaceLightPos0;
    float4 _LightPositionRange;
    float4 _LightProjectionParams;
    float4 unity_4LightPosX0;
    float4 unity_4LightPosY0;
    float4 unity_4LightPosZ0;
    float4 unity_4LightAtten0;
    float4 unity_LightColor[8];
    float4 unity_LightPosition[8];
    float4 unity_LightAtten[8];
    float4 unity_SpotDirection[8];
    float4 unity_SHAr;
    float4 unity_SHAg;
    float4 unity_SHAb;
    float4 unity_SHBr;
    float4 unity_SHBg;
    float4 unity_SHBb;
    float4 unity_SHC;
    float4 unity_OcclusionMaskSelector;
    float4 unity_ProbesOcclusion;
    float3 unity_LightColor0;
    float3 unity_LightColor1;
    float3 unity_LightColor2;
    float3 unity_LightColor3;
    float4 unity_ShadowSplitSpheres[4];
    float4 unity_ShadowSplitSqRadii;
    float4 unity_LightShadowBias;
    float4 _LightSplitsNear;
    float4 _LightSplitsFar;
    float4 hlslcc_mtx4x4unity_WorldToShadow[16];
    float4 _LightShadowData;
    float4 unity_ShadowFadeCenterAndType;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 unity_LODFade;
    float4 unity_WorldTransformParams;
    float4 unity_RenderingLayer;
    float4 hlslcc_mtx4x4glstate_matrix_transpose_modelview0[4];
    float4 glstate_lightmodel_ambient;
    float4 unity_AmbientSky;
    float4 unity_AmbientEquator;
    float4 unity_AmbientGround;
    float4 unity_IndirectSpecColor;
    float4 hlslcc_mtx4x4glstate_matrix_projection[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixInvV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    int unity_StereoEyeIndex;
    float4 unity_ShadowColor;
    float4 unity_FogColor;
    float4 unity_FogParams;
    float4 unity_LightmapST;
    float4 unity_DynamicLightmapST;
    float4 unity_SpecCube0_BoxMax;
    float4 unity_SpecCube0_BoxMin;
    float4 unity_SpecCube0_ProbePosition;
    float4 unity_SpecCube0_HDR;
    float4 unity_SpecCube1_BoxMax;
    float4 unity_SpecCube1_BoxMin;
    float4 unity_SpecCube1_ProbePosition;
    float4 unity_SpecCube1_HDR;
    float4 unity_ProbeVolumeParams;
    float4 hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[4];
    float3 unity_ProbeVolumeSizeInv;
    float3 unity_ProbeVolumeMin;
    float4 unity_Lightmap_HDR;
    float4 unity_DynamicLightmap_HDR;
    float4 _LightColor0;
    float4 _SpecColor;
    float _Tile;
    float _HeightDisplacement;
    float _NormalScale;
    float4 _ColorTint;
    float _MetallicStrength;
    float _SmoothnessStrength;
    float _EdgeLength;
    bool4 unity_MetaVertexControl;
    bool4 unity_MetaFragmentControl;
    int unity_VisualizationMode;
    float unity_OneOverOutputBoost;
    float unity_MaxOutputValue;
    float unity_UseLinearSpace;
    float4 _texcoord_ST;
};
struct Mtl_HullIn
{
    Mtl_VertexOut cp[3];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
kernel void patchKernel(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn vertexInput [[ stage_in ]],
    uint2 tID [[ thread_position_in_grid ]],
    ushort2 groupID [[ threadgroup_position_in_grid ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    constant Mtl_KernelPatchInfo &patchInfo [[ buffer(3) ]])
{
#pragma clang diagnostic pop
    Mtl_ControlPoint output;
    const uint numPatchesInThreadGroup = 10;
    const uint patchID = (tID.x / patchInfo.numControlPointsPerPatch);
    const bool patchValid = (patchID < patchInfo.numPatches);
    const uint mtl_BaseInstance = 0;
    const uint mtl_InstanceID = groupID.y - mtl_BaseInstance;
    const uint internalPatchID = mtl_InstanceID * patchInfo.numPatches + patchID;
    const uint patchIDInThreadGroup = (patchID % numPatchesInThreadGroup);
    const uint controlPointID = (tID.x % patchInfo.numControlPointsPerPatch);
    const uint mtl_BaseVertex = 0;
    const uint mtl_VertexID = ((mtl_InstanceID * (patchInfo.numControlPointsPerPatch * patchInfo.numPatches)) + tID.x) - mtl_BaseVertex;
    threadgroup Mtl_HullIn inputGroup[numPatchesInThreadGroup];
    threadgroup Mtl_HullIn &input = inputGroup[patchIDInThreadGroup];
    MTLTriangleTessellationFactorsHalf tessFactor;
    if (patchValid) {
        input.cp[controlPointID] = vertexFunction(vertexInput);
        output.INTERNALTESSPOS0 = input.cp[controlPointID].INTERNALTESSPOS0;
        output.TANGENT0 = input.cp[controlPointID].TANGENT0;
        output.NORMAL0 = input.cp[controlPointID].NORMAL0;
        output.TEXCOORD0 = input.cp[controlPointID].TEXCOORD0;
        output.TEXCOORD1 = input.cp[controlPointID].TEXCOORD1;
        output.TEXCOORD2 = input.cp[controlPointID].TEXCOORD2;
        output.TEXCOORD3 = input.cp[controlPointID].TEXCOORD3;
        output.COLOR0 = input.cp[controlPointID].COLOR0;
    }
    threadgroup_barrier(mem_flags::mem_threadgroup);
    if (!patchValid) {
        return;
    }
    float3 u_xlat0;
    float3 u_xlat1;
    float3 u_xlat2;
    float3 u_xlat3;
    float3 u_xlat4;
    float u_xlat12;
    float u_xlat13;
    // fork_phase2
    {
        u_xlat0.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[1].INTERNALTESSPOS0.yyy;
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[1].INTERNALTESSPOS0.xxx, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[1].INTERNALTESSPOS0.zzz, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[1].INTERNALTESSPOS0.www, u_xlat0.xyz);
        u_xlat1.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[2].INTERNALTESSPOS0.yyy;
        u_xlat1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[2].INTERNALTESSPOS0.xxx, u_xlat1.xyz);
        u_xlat1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[2].INTERNALTESSPOS0.zzz, u_xlat1.xyz);
        u_xlat1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[2].INTERNALTESSPOS0.www, u_xlat1.xyz);
        u_xlat2.xyz = u_xlat0.xyz + u_xlat1.xyz;
        u_xlat2.xyz = fma(u_xlat2.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat12 = dot(u_xlat2.xyz, u_xlat2.xyz);
        u_xlat12 = sqrt(u_xlat12);
        u_xlat12 = u_xlat12 * VGlobals._EdgeLength;
        u_xlat2.xyz = u_xlat0.xyz + (-u_xlat1.xyz);
        u_xlat13 = dot(u_xlat2.xyz, u_xlat2.xyz);
        u_xlat13 = sqrt(u_xlat13);
        u_xlat13 = u_xlat13 * VGlobals._ScreenParams.y;
        u_xlat12 = u_xlat13 / u_xlat12;
        tessFactor.edgeTessellationFactor[0] = max(u_xlat12, 1.0);
        u_xlat2.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[0].INTERNALTESSPOS0.yyy;
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[0].INTERNALTESSPOS0.xxx, u_xlat2.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[0].INTERNALTESSPOS0.zzz, u_xlat2.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[0].INTERNALTESSPOS0.www, u_xlat2.xyz);
        u_xlat3.xyz = u_xlat1.xyz + u_xlat2.xyz;
        u_xlat1.xyz = u_xlat1.xyz + (-u_xlat2.xyz);
        u_xlat12 = dot(u_xlat1.xyz, u_xlat1.xyz);
        u_xlat12 = sqrt(u_xlat12);
        u_xlat12 = u_xlat12 * VGlobals._ScreenParams.y;
        u_xlat1.xyz = fma(u_xlat3.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat1.x = dot(u_xlat1.xyz, u_xlat1.xyz);
        u_xlat1.x = sqrt(u_xlat1.x);
        u_xlat1.x = u_xlat1.x * VGlobals._EdgeLength;
        u_xlat12 = u_xlat12 / u_xlat1.x;
        tessFactor.edgeTessellationFactor[1] = max(u_xlat12, 1.0);
        u_xlat1.xyz = u_xlat0.xyz + u_xlat2.xyz;
        u_xlat0.xyz = (-u_xlat0.xyz) + u_xlat2.xyz;
        u_xlat0.x = dot(u_xlat0.xyz, u_xlat0.xyz);
        u_xlat0.x = sqrt(u_xlat0.x);
        u_xlat0.x = u_xlat0.x * VGlobals._ScreenParams.y;
        u_xlat4.xyz = fma(u_xlat1.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat4.x = dot(u_xlat4.xyz, u_xlat4.xyz);
        u_xlat4.x = sqrt(u_xlat4.x);
        u_xlat4.x = u_xlat4.x * VGlobals._EdgeLength;
        u_xlat0.x = u_xlat0.x / u_xlat4.x;
        tessFactor.edgeTessellationFactor[2] = max(u_xlat0.x, 1.0);
    }
    // join_phase3
    {
        u_xlat0.x = tessFactor.edgeTessellationFactor[0] + tessFactor.edgeTessellationFactor[1];
        u_xlat0.x = u_xlat0.x + tessFactor.edgeTessellationFactor[2];
        tessFactor.insideTessellationFactor = u_xlat0.x * 0.333333343;
    }
    controlPoints[mtl_VertexID] = output;
    tessFactors[internalPatchID] = tessFactor;
}
// SHADER_STAGE_HULL_end
// SHADER_STAGE_DOMAIN_begin
struct Mtl_VertexInPostTess
{
    patch_control_point<Mtl_ControlPointIn> cp;
};
struct Mtl_VertexOutPostTess
{
    float4 mtl_Position [[ position ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float4 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float4 TEXCOORD3 [[ user(TEXCOORD3) ]];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    sampler sampler_Height [[ sampler (0) ]],
    texture2d<float, access::sample > _Height [[ texture(0) ]] ,
    float3 mtl_TessCoord [[ position_in_patch ]],
    uint patchID [[ patch_id ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    Mtl_VertexInPostTess input [[ stage_in ]])
{
#pragma clang diagnostic pop
    Mtl_VertexOutPostTess output;
    MTLTriangleTessellationFactorsHalf tessFactor;
    tessFactor = tessFactors[patchID];
    float4 u_xlat0;
    float4 u_xlat1;
    float4 u_xlat2;
    float3 u_xlat3;
    float3 u_xlat4;
    float2 u_xlat13;
    float u_xlat15;
    bool u_xlatb15;
    u_xlat0.xy = mtl_TessCoord.yy * input.cp[1].TEXCOORD2.xy;
    u_xlat0.xy = fma(input.cp[0].TEXCOORD2.xy, mtl_TessCoord.xx, u_xlat0.xy);
    u_xlat0.xy = fma(input.cp[2].TEXCOORD2.xy, mtl_TessCoord.zz, u_xlat0.xy);
    u_xlat0.xy = fma(u_xlat0.xy, VGlobals.unity_DynamicLightmapST.xy, VGlobals.unity_DynamicLightmapST.zw);
    u_xlat1.xy = mtl_TessCoord.yy * input.cp[1].TEXCOORD1.xy;
    u_xlat1.xy = fma(input.cp[0].TEXCOORD1.xy, mtl_TessCoord.xx, u_xlat1.xy);
    u_xlat1.xy = fma(input.cp[2].TEXCOORD1.xy, mtl_TessCoord.zz, u_xlat1.xy);
    u_xlat1.xy = fma(u_xlat1.xy, VGlobals.unity_LightmapST.xy, VGlobals.unity_LightmapST.zw);
    u_xlat2 = mtl_TessCoord.yyyy * input.cp[1].INTERNALTESSPOS0;
    u_xlat2 = fma(input.cp[0].INTERNALTESSPOS0, mtl_TessCoord.xxxx, u_xlat2);
    u_xlat2 = fma(input.cp[2].INTERNALTESSPOS0, mtl_TessCoord.zzzz, u_xlat2);
    u_xlat3.xy = mtl_TessCoord.yy * input.cp[1].TEXCOORD0.xy;
    u_xlat3.xy = fma(input.cp[0].TEXCOORD0.xy, mtl_TessCoord.xx, u_xlat3.xy);
    u_xlat3.xy = fma(input.cp[2].TEXCOORD0.xy, mtl_TessCoord.zz, u_xlat3.xy);
    u_xlat13.xy = u_xlat3.xy * float2(VGlobals._Tile);
    output.TEXCOORD0.xy = fma(u_xlat3.xy, VGlobals._texcoord_ST.xy, VGlobals._texcoord_ST.zw);
    u_xlat3.xyz = _Height.sample(sampler_Height, u_xlat13.xy, level(1.0)).xyz;
    u_xlat4.xyz = mtl_TessCoord.yyy * input.cp[1].NORMAL0.xyz;
    u_xlat4.xyz = fma(input.cp[0].NORMAL0.xyz, mtl_TessCoord.xxx, u_xlat4.xyz);
    u_xlat4.xyz = fma(input.cp[2].NORMAL0.xyz, mtl_TessCoord.zzz, u_xlat4.xyz);
    u_xlat3.xyz = u_xlat3.xyz * u_xlat4.xyz;
    u_xlat2.xyz = fma(u_xlat3.xyz, float3(VGlobals._HeightDisplacement), u_xlat2.xyz);
    u_xlatb15 = 0.0<u_xlat2.z;
    u_xlat1.z = u_xlatb15 ? 9.99999975e-05 : float(0.0);
    u_xlat1.xyz = (VGlobals.unity_MetaVertexControl.x) ? u_xlat1.xyz : u_xlat2.xyz;
    u_xlatb15 = 0.0<u_xlat1.z;
    u_xlat0.z = u_xlatb15 ? 9.99999975e-05 : float(0.0);
    u_xlat0.xyz = (VGlobals.unity_MetaVertexControl.y) ? u_xlat0.xyz : u_xlat1.xyz;
    u_xlat1 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat0.xxxx, u_xlat1);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat0.zzzz, u_xlat1);
    output.mtl_Position = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_MatrixVP[3];
    u_xlat0.xyz = u_xlat2.yyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz;
    u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, u_xlat2.xxx, u_xlat0.xyz);
    u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, u_xlat2.zzz, u_xlat0.xyz);
    u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, u_xlat2.www, u_xlat0.xyz);
    output.TEXCOORD1.w = u_xlat0.x;
    u_xlat1.y = dot(u_xlat4.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat1.z = dot(u_xlat4.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat1.x = dot(u_xlat4.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat0.x = dot(u_xlat1.xyz, u_xlat1.xyz);
    u_xlat0.x = rsqrt(u_xlat0.x);
    u_xlat1.xyz = u_xlat0.xxx * u_xlat1.xyz;
    output.TEXCOORD1.z = u_xlat1.y;
    u_xlat2 = mtl_TessCoord.yyyy * input.cp[1].TANGENT0;
    u_xlat2 = fma(input.cp[0].TANGENT0, mtl_TessCoord.xxxx, u_xlat2);
    u_xlat2 = fma(input.cp[2].TANGENT0, mtl_TessCoord.zzzz, u_xlat2);
    u_xlat3.xyz = u_xlat2.yyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].yzx;
    u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].yzx, u_xlat2.xxx, u_xlat3.xyz);
    u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].yzx, u_xlat2.zzz, u_xlat3.xyz);
    u_xlat0.x = u_xlat2.w * VGlobals.unity_WorldTransformParams.w;
    u_xlat15 = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat15 = rsqrt(u_xlat15);
    u_xlat2.xyz = float3(u_xlat15) * u_xlat2.xyz;
    u_xlat3.xyz = u_xlat1.xyz * u_xlat2.xyz;
    u_xlat3.xyz = fma(u_xlat1.zxy, u_xlat2.yzx, (-u_xlat3.xyz));
    u_xlat3.xyz = u_xlat0.xxx * u_xlat3.xyz;
    output.TEXCOORD1.y = u_xlat3.x;
    output.TEXCOORD1.x = u_xlat2.z;
    output.TEXCOORD2.w = u_xlat0.y;
    output.TEXCOORD3.w = u_xlat0.z;
    output.TEXCOORD2.x = u_xlat2.x;
    output.TEXCOORD3.x = u_xlat2.y;
    output.TEXCOORD2.z = u_xlat1.z;
    output.TEXCOORD3.z = u_xlat1.x;
    output.TEXCOORD2.y = u_xlat3.y;
    output.TEXCOORD3.y = u_xlat3.z;
    return output;
}
// SHADER_STAGE_DOMAIN_end
Refreshing native plugins compatible for Editor in 2.24 ms, found 2 plugins.
Preloading 0 native plugins for Editor in 0.00 ms.
Unloading 3375 Unused Serialized files (Serialized files now loaded: 0)
Unloading 20 unused Assets / (0.6 MB). Loaded Objects now: 3892.
Memory consumption went from 136.4 MB to 135.8 MB.
Total: 5.425991 ms (FindLiveObjects: 0.362920 ms CreateObjectMapping: 0.166282 ms MarkObjects: 4.449436 ms  DeleteObjects: 0.445820 ms)

AssetImportParameters requested are different than current active one (requested -> active):
  custom:video-decoder-ogg-theora: a1e56fd34408186e4bbccfd4996cb3dc -> 
  custom:container-muxer-webm: aa71ff27fc2769a1b78a27578f13a17b -> 
  custom:container-demuxer-webm: 4f35f7cbe854078d1ac9338744f61a02 -> 
  custom:video-encoder-webm-vp8: eb34c28f22e8b96e1ab97ce403110664 -> 
  custom:framework-osx-AVFoundation: b23960f63f64bdc6ff669e2cdcee2391 -> 
  custom:audio-encoder-webm-vorbis: bf7c407c2cedff20999df2af8eb42d56 -> 
  custom:container-demuxer-ogg: 62fdf1f143b41e24485cea50d1cbac27 -> 
  custom:video-decoder-webm-vp8: 9c59270c3fd7afecdb556c50c9e8de78 -> 
  custom:audio-decoder-ogg-vorbis: bf7c407c2cedff20999df2af8eb42d56 -> 
========================================================================
Received Prepare
Registering precompiled user dll's ...
Registered in 0.003455 seconds.
Begin MonoManager ReloadAssembly
Symbol file LoadedFromMemory doesn't match image /Users/kamilaamendolagine/Desktop/Staugen Raug v2 - Prefab - Map 1.01/Library/PackageCache/com.unity.visualscripting@1.7.8/Editor/VisualScripting.Core/Dependencies/YamlDotNet/Unity.VisualScripting.YamlDotNet.dll
Symbol file LoadedFromMemory doesn't match image /Users/kamilaamendolagine/Desktop/Staugen Raug v2 - Prefab - Map 1.01/Library/PackageCache/com.unity.visualscripting@1.7.8/Editor/VisualScripting.Core/Dependencies/DotNetZip/Unity.VisualScripting.IonicZip.dll
Native extension for OSXStandalone target not found
Native extension for WebGL target not found
Refreshing native plugins compatible for Editor in 0.90 ms, found 2 plugins.
Preloading 0 native plugins for Editor in 0.00 ms.
Mono: successfully reloaded assembly
- Completed reload, in  1.869 seconds
Domain Reload Profiling:
	ReloadAssembly (1870ms)
		BeginReloadAssembly (205ms)
			ExecutionOrderSort (0ms)
			DisableScriptedObjects (10ms)
			BackupInstance (0ms)
			ReleaseScriptingObjects (0ms)
			CreateAndSetChildDomain (89ms)
		EndReloadAssembly (1495ms)
			LoadAssemblies (91ms)
			RebuildTransferFunctionScriptingTraits (0ms)
			SetupTypeCache (499ms)
			ReleaseScriptCaches (2ms)
			RebuildScriptCaches (84ms)
			SetupLoadedEditorAssemblies (706ms)
				LogAssemblyErrors (0ms)
				InitializePlatformSupportModulesInManaged (19ms)
				SetLoadedEditorAssemblies (1ms)
				RefreshPlugins (1ms)
				BeforeProcessingInitializeOnLoad (106ms)
				ProcessInitializeOnLoadAttributes (523ms)
				ProcessInitializeOnLoadMethodAttributes (52ms)
				AfterProcessingInitializeOnLoad (4ms)
				EditorAssembliesLoaded (0ms)
			ExecutionOrderSort2 (0ms)
			AwakeInstancesAfterBackupRestoration (9ms)
Platform modules already initialized, skipping
Compilation succeeded with: 

program_source:299:53: warning: writable resources in non-void post-tessellation vertex function
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
                                                    ^
program_source:305:30: note: writable buffer defined here
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
                             ^
program_source:306:48: note: writable buffer defined here
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
                                               ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float4 TEXCOORD0 [[ attribute(3) ]] ;
    float4 TEXCOORD1 [[ attribute(4) ]] ;
    float4 TEXCOORD2 [[ attribute(5) ]] ;
    float4 TEXCOORD3 [[ attribute(6) ]] ;
    float4 COLOR0 [[ attribute(7) ]] ;
};
struct Mtl_VertexOut
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float4 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float4 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float4 TEXCOORD3 [[ user(TEXCOORD3) ]];
    float4 COLOR0 [[ user(COLOR0) ]];
};
static Mtl_VertexOut vertexFunction(
    Mtl_VertexIn input)
{
    Mtl_VertexOut output;
    output.INTERNALTESSPOS0 = input.POSITION0;
    output.TANGENT0 = input.TANGENT0;
    output.NORMAL0.xyz = input.NORMAL0.xyz;
    output.TEXCOORD0 = input.TEXCOORD0;
    output.TEXCOORD1 = input.TEXCOORD1;
    output.TEXCOORD2 = input.TEXCOORD2;
    output.TEXCOORD3 = input.TEXCOORD3;
    output.COLOR0 = input.COLOR0;
    return output;
}
// SHADER_STAGE_HULL_begin
struct Mtl_ControlPoint
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float4 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float4 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float4 TEXCOORD3 [[ user(TEXCOORD3) ]];
    float4 COLOR0 [[ user(COLOR0) ]];
};
struct Mtl_ControlPointIn
{
    float4 INTERNALTESSPOS0 [[ attribute(8) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float4 TEXCOORD0 [[ attribute(3) ]] ;
    float4 TEXCOORD1 [[ attribute(4) ]] ;
    float4 TEXCOORD2 [[ attribute(5) ]] ;
    float4 TEXCOORD3 [[ attribute(6) ]] ;
    float4 COLOR0 [[ attribute(7) ]] ;
};
struct Mtl_KernelPatchInfo
{
    uint numPatches;
    ushort numControlPointsPerPatch;
};
struct VGlobals_Type
{
    float4 _Time;
    float4 _SinTime;
    float4 _CosTime;
    float4 unity_DeltaTime;
    float3 _WorldSpaceCameraPos;
    float4 _ProjectionParams;
    float4 _ScreenParams;
    float4 _ZBufferParams;
    float4 unity_OrthoParams;
    float4 unity_CameraWorldClipPlanes[6];
    float4 hlslcc_mtx4x4unity_CameraProjection[4];
    float4 hlslcc_mtx4x4unity_CameraInvProjection[4];
    float4 hlslcc_mtx4x4unity_WorldToCamera[4];
    float4 hlslcc_mtx4x4unity_CameraToWorld[4];
    float4 _WorldSpaceLightPos0;
    float4 _LightPositionRange;
    float4 _LightProjectionParams;
    float4 unity_4LightPosX0;
    float4 unity_4LightPosY0;
    float4 unity_4LightPosZ0;
    float4 unity_4LightAtten0;
    float4 unity_LightColor[8];
    float4 unity_LightPosition[8];
    float4 unity_LightAtten[8];
    float4 unity_SpotDirection[8];
    float4 unity_SHAr;
    float4 unity_SHAg;
    float4 unity_SHAb;
    float4 unity_SHBr;
    float4 unity_SHBg;
    float4 unity_SHBb;
    float4 unity_SHC;
    float4 unity_OcclusionMaskSelector;
    float4 unity_ProbesOcclusion;
    float3 unity_LightColor0;
    float3 unity_LightColor1;
    float3 unity_LightColor2;
    float3 unity_LightColor3;
    float4 unity_ShadowSplitSpheres[4];
    float4 unity_ShadowSplitSqRadii;
    float4 unity_LightShadowBias;
    float4 _LightSplitsNear;
    float4 _LightSplitsFar;
    float4 hlslcc_mtx4x4unity_WorldToShadow[16];
    float4 _LightShadowData;
    float4 unity_ShadowFadeCenterAndType;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 unity_LODFade;
    float4 unity_WorldTransformParams;
    float4 unity_RenderingLayer;
    float4 hlslcc_mtx4x4glstate_matrix_transpose_modelview0[4];
    float4 glstate_lightmodel_ambient;
    float4 unity_AmbientSky;
    float4 unity_AmbientEquator;
    float4 unity_AmbientGround;
    float4 unity_IndirectSpecColor;
    float4 hlslcc_mtx4x4glstate_matrix_projection[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixInvV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    int unity_StereoEyeIndex;
    float4 unity_ShadowColor;
    float4 unity_FogColor;
    float4 unity_FogParams;
    float4 unity_LightmapST;
    float4 unity_DynamicLightmapST;
    float4 unity_SpecCube0_BoxMax;
    float4 unity_SpecCube0_BoxMin;
    float4 unity_SpecCube0_ProbePosition;
    float4 unity_SpecCube0_HDR;
    float4 unity_SpecCube1_BoxMax;
    float4 unity_SpecCube1_BoxMin;
    float4 unity_SpecCube1_ProbePosition;
    float4 unity_SpecCube1_HDR;
    float4 unity_ProbeVolumeParams;
    float4 hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[4];
    float3 unity_ProbeVolumeSizeInv;
    float3 unity_ProbeVolumeMin;
    float4 unity_Lightmap_HDR;
    float4 unity_DynamicLightmap_HDR;
    float4 _LightColor0;
    float4 _SpecColor;
    float _Tile;
    float _HeightDisplacement;
    float _NormalScale;
    float4 _ColorTint;
    float _MetallicStrength;
    float _SmoothnessStrength;
    float _EdgeLength;
    float4 _texcoord_ST;
};
struct Mtl_HullIn
{
    Mtl_VertexOut cp[3];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
kernel void patchKernel(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn vertexInput [[ stage_in ]],
    uint2 tID [[ thread_position_in_grid ]],
    ushort2 groupID [[ threadgroup_position_in_grid ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    constant Mtl_KernelPatchInfo &patchInfo [[ buffer(3) ]])
{
#pragma clang diagnostic pop
    Mtl_ControlPoint output;
    const uint numPatchesInThreadGroup = 10;
    const uint patchID = (tID.x / patchInfo.numControlPointsPerPatch);
    const bool patchValid = (patchID < patchInfo.numPatches);
    const uint mtl_BaseInstance = 0;
    const uint mtl_InstanceID = groupID.y - mtl_BaseInstance;
    const uint internalPatchID = mtl_InstanceID * patchInfo.numPatches + patchID;
    const uint patchIDInThreadGroup = (patchID % numPatchesInThreadGroup);
    const uint controlPointID = (tID.x % patchInfo.numControlPointsPerPatch);
    const uint mtl_BaseVertex = 0;
    const uint mtl_VertexID = ((mtl_InstanceID * (patchInfo.numControlPointsPerPatch * patchInfo.numPatches)) + tID.x) - mtl_BaseVertex;
    threadgroup Mtl_HullIn inputGroup[numPatchesInThreadGroup];
    threadgroup Mtl_HullIn &input = inputGroup[patchIDInThreadGroup];
    MTLTriangleTessellationFactorsHalf tessFactor;
    if (patchValid) {
        input.cp[controlPointID] = vertexFunction(vertexInput);
        output.INTERNALTESSPOS0 = input.cp[controlPointID].INTERNALTESSPOS0;
        output.TANGENT0 = input.cp[controlPointID].TANGENT0;
        output.NORMAL0 = input.cp[controlPointID].NORMAL0;
        output.TEXCOORD0 = input.cp[controlPointID].TEXCOORD0;
        output.TEXCOORD1 = input.cp[controlPointID].TEXCOORD1;
        output.TEXCOORD2 = input.cp[controlPointID].TEXCOORD2;
        output.TEXCOORD3 = input.cp[controlPointID].TEXCOORD3;
        output.COLOR0 = input.cp[controlPointID].COLOR0;
    }
    threadgroup_barrier(mem_flags::mem_threadgroup);
    if (!patchValid) {
        return;
    }
    float3 u_xlat0;
    float3 u_xlat1;
    float3 u_xlat2;
    float3 u_xlat3;
    float3 u_xlat4;
    float u_xlat12;
    float u_xlat13;
    // fork_phase2
    {
        u_xlat0.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[1].INTERNALTESSPOS0.yyy;
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[1].INTERNALTESSPOS0.xxx, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[1].INTERNALTESSPOS0.zzz, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[1].INTERNALTESSPOS0.www, u_xlat0.xyz);
        u_xlat1.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[2].INTERNALTESSPOS0.yyy;
        u_xlat1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[2].INTERNALTESSPOS0.xxx, u_xlat1.xyz);
        u_xlat1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[2].INTERNALTESSPOS0.zzz, u_xlat1.xyz);
        u_xlat1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[2].INTERNALTESSPOS0.www, u_xlat1.xyz);
        u_xlat2.xyz = u_xlat0.xyz + u_xlat1.xyz;
        u_xlat2.xyz = fma(u_xlat2.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat12 = dot(u_xlat2.xyz, u_xlat2.xyz);
        u_xlat12 = sqrt(u_xlat12);
        u_xlat12 = u_xlat12 * VGlobals._EdgeLength;
        u_xlat2.xyz = u_xlat0.xyz + (-u_xlat1.xyz);
        u_xlat13 = dot(u_xlat2.xyz, u_xlat2.xyz);
        u_xlat13 = sqrt(u_xlat13);
        u_xlat13 = u_xlat13 * VGlobals._ScreenParams.y;
        u_xlat12 = u_xlat13 / u_xlat12;
        tessFactor.edgeTessellationFactor[0] = max(u_xlat12, 1.0);
        u_xlat2.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[0].INTERNALTESSPOS0.yyy;
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[0].INTERNALTESSPOS0.xxx, u_xlat2.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[0].INTERNALTESSPOS0.zzz, u_xlat2.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[0].INTERNALTESSPOS0.www, u_xlat2.xyz);
        u_xlat3.xyz = u_xlat1.xyz + u_xlat2.xyz;
        u_xlat1.xyz = u_xlat1.xyz + (-u_xlat2.xyz);
        u_xlat12 = dot(u_xlat1.xyz, u_xlat1.xyz);
        u_xlat12 = sqrt(u_xlat12);
        u_xlat12 = u_xlat12 * VGlobals._ScreenParams.y;
        u_xlat1.xyz = fma(u_xlat3.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat1.x = dot(u_xlat1.xyz, u_xlat1.xyz);
        u_xlat1.x = sqrt(u_xlat1.x);
        u_xlat1.x = u_xlat1.x * VGlobals._EdgeLength;
        u_xlat12 = u_xlat12 / u_xlat1.x;
        tessFactor.edgeTessellationFactor[1] = max(u_xlat12, 1.0);
        u_xlat1.xyz = u_xlat0.xyz + u_xlat2.xyz;
        u_xlat0.xyz = (-u_xlat0.xyz) + u_xlat2.xyz;
        u_xlat0.x = dot(u_xlat0.xyz, u_xlat0.xyz);
        u_xlat0.x = sqrt(u_xlat0.x);
        u_xlat0.x = u_xlat0.x * VGlobals._ScreenParams.y;
        u_xlat4.xyz = fma(u_xlat1.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat4.x = dot(u_xlat4.xyz, u_xlat4.xyz);
        u_xlat4.x = sqrt(u_xlat4.x);
        u_xlat4.x = u_xlat4.x * VGlobals._EdgeLength;
        u_xlat0.x = u_xlat0.x / u_xlat4.x;
        tessFactor.edgeTessellationFactor[2] = max(u_xlat0.x, 1.0);
    }
    // join_phase3
    {
        u_xlat0.x = tessFactor.edgeTessellationFactor[0] + tessFactor.edgeTessellationFactor[1];
        u_xlat0.x = u_xlat0.x + tessFactor.edgeTessellationFactor[2];
        tessFactor.insideTessellationFactor = u_xlat0.x * 0.333333343;
    }
    controlPoints[mtl_VertexID] = output;
    tessFactors[internalPatchID] = tessFactor;
}
// SHADER_STAGE_HULL_end
// SHADER_STAGE_DOMAIN_begin
struct Mtl_VertexInPostTess
{
    patch_control_point<Mtl_ControlPointIn> cp;
};
struct Mtl_VertexOutPostTess
{
    float4 mtl_Position [[ position ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float4 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float4 TEXCOORD3 [[ user(TEXCOORD3) ]];
    float4 TEXCOORD6 [[ user(TEXCOORD6) ]];
    float4 TEXCOORD7 [[ user(TEXCOORD7) ]];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    sampler sampler_Height [[ sampler (0) ]],
    texture2d<float, access::sample > _Height [[ texture(0) ]] ,
    float3 mtl_TessCoord [[ position_in_patch ]],
    uint patchID [[ patch_id ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    Mtl_VertexInPostTess input [[ stage_in ]])
{
#pragma clang diagnostic pop
    Mtl_VertexOutPostTess output;
    MTLTriangleTessellationFactorsHalf tessFactor;
    tessFactor = tessFactors[patchID];
    float4 u_xlat0;
    float4 u_xlat1;
    float4 u_xlat2;
    float4 u_xlat3;
    float2 u_xlat9;
    float u_xlat12;
    float u_xlat13;
    u_xlat0 = mtl_TessCoord.yyyy * input.cp[1].INTERNALTESSPOS0;
    u_xlat0 = fma(input.cp[0].INTERNALTESSPOS0, mtl_TessCoord.xxxx, u_xlat0);
    u_xlat0 = fma(input.cp[2].INTERNALTESSPOS0, mtl_TessCoord.zzzz, u_xlat0);
    u_xlat1.xy = mtl_TessCoord.yy * input.cp[1].TEXCOORD0.xy;
    u_xlat1.xy = fma(input.cp[0].TEXCOORD0.xy, mtl_TessCoord.xx, u_xlat1.xy);
    u_xlat1.xy = fma(input.cp[2].TEXCOORD0.xy, mtl_TessCoord.zz, u_xlat1.xy);
    u_xlat9.xy = u_xlat1.xy * float2(VGlobals._Tile);
    output.TEXCOORD0.xy = fma(u_xlat1.xy, VGlobals._texcoord_ST.xy, VGlobals._texcoord_ST.zw);
    u_xlat1.xyz = _Height.sample(sampler_Height, u_xlat9.xy, level(1.0)).xyz;
    u_xlat2.xyz = mtl_TessCoord.yyy * input.cp[1].NORMAL0.xyz;
    u_xlat2.xyz = fma(input.cp[0].NORMAL0.xyz, mtl_TessCoord.xxx, u_xlat2.xyz);
    u_xlat2.xyz = fma(input.cp[2].NORMAL0.xyz, mtl_TessCoord.zzz, u_xlat2.xyz);
    u_xlat1.xyz = u_xlat1.xyz * u_xlat2.xyz;
    u_xlat0.xyz = fma(u_xlat1.xyz, float3(VGlobals._HeightDisplacement), u_xlat0.xyz);
    u_xlat1 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], u_xlat0.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], u_xlat0.zzzz, u_xlat1);
    u_xlat3 = u_xlat1 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, u_xlat0.www, u_xlat1.xyz);
    u_xlat1 = u_xlat3.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat3.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat3.zzzz, u_xlat1);
    output.mtl_Position = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat3.wwww, u_xlat1);
    u_xlat1.y = dot(u_xlat2.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat1.z = dot(u_xlat2.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat1.x = dot(u_xlat2.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat12 = dot(u_xlat1.xyz, u_xlat1.xyz);
    u_xlat12 = rsqrt(u_xlat12);
    u_xlat1.xyz = float3(u_xlat12) * u_xlat1.xyz;
    output.TEXCOORD1.z = u_xlat1.y;
    u_xlat2 = mtl_TessCoord.yyyy * input.cp[1].TANGENT0;
    u_xlat2 = fma(input.cp[0].TANGENT0, mtl_TessCoord.xxxx, u_xlat2);
    u_xlat2 = fma(input.cp[2].TANGENT0, mtl_TessCoord.zzzz, u_xlat2);
    u_xlat3.xyz = u_xlat2.yyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].yzx;
    u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].yzx, u_xlat2.xxx, u_xlat3.xyz);
    u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].yzx, u_xlat2.zzz, u_xlat3.xyz);
    u_xlat12 = u_xlat2.w * VGlobals.unity_WorldTransformParams.w;
    u_xlat13 = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat13 = rsqrt(u_xlat13);
    u_xlat2.xyz = float3(u_xlat13) * u_xlat2.xyz;
    u_xlat3.xyz = u_xlat1.xyz * u_xlat2.xyz;
    u_xlat3.xyz = fma(u_xlat1.zxy, u_xlat2.yzx, (-u_xlat3.xyz));
    u_xlat3.xyz = float3(u_xlat12) * u_xlat3.xyz;
    output.TEXCOORD1.y = u_xlat3.x;
    output.TEXCOORD1.w = u_xlat0.x;
    output.TEXCOORD1.x = u_xlat2.z;
    output.TEXCOORD2.w = u_xlat0.y;
    output.TEXCOORD3.w = u_xlat0.z;
    output.TEXCOORD2.x = u_xlat2.x;
    output.TEXCOORD3.x = u_xlat2.y;
    output.TEXCOORD2.z = u_xlat1.z;
    output.TEXCOORD3.z = u_xlat1.x;
    output.TEXCOORD2.y = u_xlat3.y;
    output.TEXCOORD3.y = u_xlat3.z;
    output.TEXCOORD6 = float4(0.0, 0.0, 0.0, 0.0);
    output.TEXCOORD7 = float4(0.0, 0.0, 0.0, 0.0);
    return output;
}
// SHADER_STAGE_DOMAIN_end
Compilation succeeded with: 

program_source:301:53: warning: writable resources in non-void post-tessellation vertex function
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
                                                    ^
program_source:307:30: note: writable buffer defined here
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
                             ^
program_source:308:48: note: writable buffer defined here
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
                                               ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float4 TEXCOORD0 [[ attribute(3) ]] ;
    float4 TEXCOORD1 [[ attribute(4) ]] ;
    float4 TEXCOORD2 [[ attribute(5) ]] ;
    float4 TEXCOORD3 [[ attribute(6) ]] ;
    float4 COLOR0 [[ attribute(7) ]] ;
};
struct Mtl_VertexOut
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float4 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float4 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float4 TEXCOORD3 [[ user(TEXCOORD3) ]];
    float4 COLOR0 [[ user(COLOR0) ]];
};
static Mtl_VertexOut vertexFunction(
    Mtl_VertexIn input)
{
    Mtl_VertexOut output;
    output.INTERNALTESSPOS0 = input.POSITION0;
    output.TANGENT0 = input.TANGENT0;
    output.NORMAL0.xyz = input.NORMAL0.xyz;
    output.TEXCOORD0 = input.TEXCOORD0;
    output.TEXCOORD1 = input.TEXCOORD1;
    output.TEXCOORD2 = input.TEXCOORD2;
    output.TEXCOORD3 = input.TEXCOORD3;
    output.COLOR0 = input.COLOR0;
    return output;
}
// SHADER_STAGE_HULL_begin
struct Mtl_ControlPoint
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float4 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float4 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float4 TEXCOORD3 [[ user(TEXCOORD3) ]];
    float4 COLOR0 [[ user(COLOR0) ]];
};
struct Mtl_ControlPointIn
{
    float4 INTERNALTESSPOS0 [[ attribute(8) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float4 TEXCOORD0 [[ attribute(3) ]] ;
    float4 TEXCOORD1 [[ attribute(4) ]] ;
    float4 TEXCOORD2 [[ attribute(5) ]] ;
    float4 TEXCOORD3 [[ attribute(6) ]] ;
    float4 COLOR0 [[ attribute(7) ]] ;
};
struct Mtl_KernelPatchInfo
{
    uint numPatches;
    ushort numControlPointsPerPatch;
};
struct VGlobals_Type
{
    float4 _Time;
    float4 _SinTime;
    float4 _CosTime;
    float4 unity_DeltaTime;
    float3 _WorldSpaceCameraPos;
    float4 _ProjectionParams;
    float4 _ScreenParams;
    float4 _ZBufferParams;
    float4 unity_OrthoParams;
    float4 unity_CameraWorldClipPlanes[6];
    float4 hlslcc_mtx4x4unity_CameraProjection[4];
    float4 hlslcc_mtx4x4unity_CameraInvProjection[4];
    float4 hlslcc_mtx4x4unity_WorldToCamera[4];
    float4 hlslcc_mtx4x4unity_CameraToWorld[4];
    float4 _WorldSpaceLightPos0;
    float4 _LightPositionRange;
    float4 _LightProjectionParams;
    float4 unity_4LightPosX0;
    float4 unity_4LightPosY0;
    float4 unity_4LightPosZ0;
    float4 unity_4LightAtten0;
    float4 unity_LightColor[8];
    float4 unity_LightPosition[8];
    float4 unity_LightAtten[8];
    float4 unity_SpotDirection[8];
    float4 unity_SHAr;
    float4 unity_SHAg;
    float4 unity_SHAb;
    float4 unity_SHBr;
    float4 unity_SHBg;
    float4 unity_SHBb;
    float4 unity_SHC;
    float4 unity_OcclusionMaskSelector;
    float4 unity_ProbesOcclusion;
    float3 unity_LightColor0;
    float3 unity_LightColor1;
    float3 unity_LightColor2;
    float3 unity_LightColor3;
    float4 unity_ShadowSplitSpheres[4];
    float4 unity_ShadowSplitSqRadii;
    float4 unity_LightShadowBias;
    float4 _LightSplitsNear;
    float4 _LightSplitsFar;
    float4 hlslcc_mtx4x4unity_WorldToShadow[16];
    float4 _LightShadowData;
    float4 unity_ShadowFadeCenterAndType;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 unity_LODFade;
    float4 unity_WorldTransformParams;
    float4 unity_RenderingLayer;
    float4 hlslcc_mtx4x4glstate_matrix_transpose_modelview0[4];
    float4 glstate_lightmodel_ambient;
    float4 unity_AmbientSky;
    float4 unity_AmbientEquator;
    float4 unity_AmbientGround;
    float4 unity_IndirectSpecColor;
    float4 hlslcc_mtx4x4glstate_matrix_projection[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixInvV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    int unity_StereoEyeIndex;
    float4 unity_ShadowColor;
    float4 unity_FogColor;
    float4 unity_FogParams;
    float4 unity_LightmapST;
    float4 unity_DynamicLightmapST;
    float4 unity_SpecCube0_BoxMax;
    float4 unity_SpecCube0_BoxMin;
    float4 unity_SpecCube0_ProbePosition;
    float4 unity_SpecCube0_HDR;
    float4 unity_SpecCube1_BoxMax;
    float4 unity_SpecCube1_BoxMin;
    float4 unity_SpecCube1_ProbePosition;
    float4 unity_SpecCube1_HDR;
    float4 unity_ProbeVolumeParams;
    float4 hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[4];
    float3 unity_ProbeVolumeSizeInv;
    float3 unity_ProbeVolumeMin;
    float4 unity_Lightmap_HDR;
    float4 unity_DynamicLightmap_HDR;
    float4 _LightColor0;
    float4 _SpecColor;
    float4 hlslcc_mtx4x4unity_WorldToLight[4];
    float _Tile;
    float _HeightDisplacement;
    float _NormalScale;
    float4 _ColorTint;
    float _MetallicStrength;
    float _SmoothnessStrength;
    float _EdgeLength;
    float4 _texcoord_ST;
};
struct Mtl_HullIn
{
    Mtl_VertexOut cp[3];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
kernel void patchKernel(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn vertexInput [[ stage_in ]],
    uint2 tID [[ thread_position_in_grid ]],
    ushort2 groupID [[ threadgroup_position_in_grid ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    constant Mtl_KernelPatchInfo &patchInfo [[ buffer(3) ]])
{
#pragma clang diagnostic pop
    Mtl_ControlPoint output;
    const uint numPatchesInThreadGroup = 10;
    const uint patchID = (tID.x / patchInfo.numControlPointsPerPatch);
    const bool patchValid = (patchID < patchInfo.numPatches);
    const uint mtl_BaseInstance = 0;
    const uint mtl_InstanceID = groupID.y - mtl_BaseInstance;
    const uint internalPatchID = mtl_InstanceID * patchInfo.numPatches + patchID;
    const uint patchIDInThreadGroup = (patchID % numPatchesInThreadGroup);
    const uint controlPointID = (tID.x % patchInfo.numControlPointsPerPatch);
    const uint mtl_BaseVertex = 0;
    const uint mtl_VertexID = ((mtl_InstanceID * (patchInfo.numControlPointsPerPatch * patchInfo.numPatches)) + tID.x) - mtl_BaseVertex;
    threadgroup Mtl_HullIn inputGroup[numPatchesInThreadGroup];
    threadgroup Mtl_HullIn &input = inputGroup[patchIDInThreadGroup];
    MTLTriangleTessellationFactorsHalf tessFactor;
    if (patchValid) {
        input.cp[controlPointID] = vertexFunction(vertexInput);
        output.INTERNALTESSPOS0 = input.cp[controlPointID].INTERNALTESSPOS0;
        output.TANGENT0 = input.cp[controlPointID].TANGENT0;
        output.NORMAL0 = input.cp[controlPointID].NORMAL0;
        output.TEXCOORD0 = input.cp[controlPointID].TEXCOORD0;
        output.TEXCOORD1 = input.cp[controlPointID].TEXCOORD1;
        output.TEXCOORD2 = input.cp[controlPointID].TEXCOORD2;
        output.TEXCOORD3 = input.cp[controlPointID].TEXCOORD3;
        output.COLOR0 = input.cp[controlPointID].COLOR0;
    }
    threadgroup_barrier(mem_flags::mem_threadgroup);
    if (!patchValid) {
        return;
    }
    float3 u_xlat0;
    float3 u_xlat1;
    float3 u_xlat2;
    float3 u_xlat3;
    float3 u_xlat4;
    float u_xlat12;
    float u_xlat13;
    // fork_phase2
    {
        u_xlat0.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[1].INTERNALTESSPOS0.yyy;
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[1].INTERNALTESSPOS0.xxx, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[1].INTERNALTESSPOS0.zzz, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[1].INTERNALTESSPOS0.www, u_xlat0.xyz);
        u_xlat1.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[2].INTERNALTESSPOS0.yyy;
        u_xlat1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[2].INTERNALTESSPOS0.xxx, u_xlat1.xyz);
        u_xlat1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[2].INTERNALTESSPOS0.zzz, u_xlat1.xyz);
        u_xlat1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[2].INTERNALTESSPOS0.www, u_xlat1.xyz);
        u_xlat2.xyz = u_xlat0.xyz + u_xlat1.xyz;
        u_xlat2.xyz = fma(u_xlat2.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat12 = dot(u_xlat2.xyz, u_xlat2.xyz);
        u_xlat12 = sqrt(u_xlat12);
        u_xlat12 = u_xlat12 * VGlobals._EdgeLength;
        u_xlat2.xyz = u_xlat0.xyz + (-u_xlat1.xyz);
        u_xlat13 = dot(u_xlat2.xyz, u_xlat2.xyz);
        u_xlat13 = sqrt(u_xlat13);
        u_xlat13 = u_xlat13 * VGlobals._ScreenParams.y;
        u_xlat12 = u_xlat13 / u_xlat12;
        tessFactor.edgeTessellationFactor[0] = max(u_xlat12, 1.0);
        u_xlat2.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[0].INTERNALTESSPOS0.yyy;
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[0].INTERNALTESSPOS0.xxx, u_xlat2.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[0].INTERNALTESSPOS0.zzz, u_xlat2.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[0].INTERNALTESSPOS0.www, u_xlat2.xyz);
        u_xlat3.xyz = u_xlat1.xyz + u_xlat2.xyz;
        u_xlat1.xyz = u_xlat1.xyz + (-u_xlat2.xyz);
        u_xlat12 = dot(u_xlat1.xyz, u_xlat1.xyz);
        u_xlat12 = sqrt(u_xlat12);
        u_xlat12 = u_xlat12 * VGlobals._ScreenParams.y;
        u_xlat1.xyz = fma(u_xlat3.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat1.x = dot(u_xlat1.xyz, u_xlat1.xyz);
        u_xlat1.x = sqrt(u_xlat1.x);
        u_xlat1.x = u_xlat1.x * VGlobals._EdgeLength;
        u_xlat12 = u_xlat12 / u_xlat1.x;
        tessFactor.edgeTessellationFactor[1] = max(u_xlat12, 1.0);
        u_xlat1.xyz = u_xlat0.xyz + u_xlat2.xyz;
        u_xlat0.xyz = (-u_xlat0.xyz) + u_xlat2.xyz;
        u_xlat0.x = dot(u_xlat0.xyz, u_xlat0.xyz);
        u_xlat0.x = sqrt(u_xlat0.x);
        u_xlat0.x = u_xlat0.x * VGlobals._ScreenParams.y;
        u_xlat4.xyz = fma(u_xlat1.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat4.x = dot(u_xlat4.xyz, u_xlat4.xyz);
        u_xlat4.x = sqrt(u_xlat4.x);
        u_xlat4.x = u_xlat4.x * VGlobals._EdgeLength;
        u_xlat0.x = u_xlat0.x / u_xlat4.x;
        tessFactor.edgeTessellationFactor[2] = max(u_xlat0.x, 1.0);
    }
    // join_phase3
    {
        u_xlat0.x = tessFactor.edgeTessellationFactor[0] + tessFactor.edgeTessellationFactor[1];
        u_xlat0.x = u_xlat0.x + tessFactor.edgeTessellationFactor[2];
        tessFactor.insideTessellationFactor = u_xlat0.x * 0.333333343;
    }
    controlPoints[mtl_VertexID] = output;
    tessFactors[internalPatchID] = tessFactor;
}
// SHADER_STAGE_HULL_end
// SHADER_STAGE_DOMAIN_begin
struct Mtl_VertexInPostTess
{
    patch_control_point<Mtl_ControlPointIn> cp;
};
struct Mtl_VertexOutPostTess
{
    float4 mtl_Position [[ position ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float3 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float3 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float3 TEXCOORD3 [[ user(TEXCOORD3) ]];
    float3 TEXCOORD4 [[ user(TEXCOORD4) ]];
    float3 TEXCOORD5 [[ user(TEXCOORD5) ]];
    float4 TEXCOORD6 [[ user(TEXCOORD6) ]];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    sampler sampler_Height [[ sampler (0) ]],
    texture2d<float, access::sample > _Height [[ texture(0) ]] ,
    float3 mtl_TessCoord [[ position_in_patch ]],
    uint patchID [[ patch_id ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    Mtl_VertexInPostTess input [[ stage_in ]])
{
#pragma clang diagnostic pop
    Mtl_VertexOutPostTess output;
    MTLTriangleTessellationFactorsHalf tessFactor;
    tessFactor = tessFactors[patchID];
    float4 u_xlat0;
    float3 u_xlat1;
    float4 u_xlat2;
    float4 u_xlat3;
    float4 u_xlat4;
    float2 u_xlat10;
    float u_xlat16;
    u_xlat0.xy = mtl_TessCoord.yy * input.cp[1].TEXCOORD0.xy;
    u_xlat0.xy = fma(input.cp[0].TEXCOORD0.xy, mtl_TessCoord.xx, u_xlat0.xy);
    u_xlat0.xy = fma(input.cp[2].TEXCOORD0.xy, mtl_TessCoord.zz, u_xlat0.xy);
    u_xlat10.xy = u_xlat0.xy * float2(VGlobals._Tile);
    output.TEXCOORD0.xy = fma(u_xlat0.xy, VGlobals._texcoord_ST.xy, VGlobals._texcoord_ST.zw);
    u_xlat0.xyz = _Height.sample(sampler_Height, u_xlat10.xy, level(1.0)).xyz;
    u_xlat1.xyz = mtl_TessCoord.yyy * input.cp[1].NORMAL0.xyz;
    u_xlat1.xyz = fma(input.cp[0].NORMAL0.xyz, mtl_TessCoord.xxx, u_xlat1.xyz);
    u_xlat1.xyz = fma(input.cp[2].NORMAL0.xyz, mtl_TessCoord.zzz, u_xlat1.xyz);
    u_xlat0.xyz = u_xlat0.xyz * u_xlat1.xyz;
    u_xlat2 = mtl_TessCoord.yyyy * input.cp[1].INTERNALTESSPOS0;
    u_xlat2 = fma(input.cp[0].INTERNALTESSPOS0, mtl_TessCoord.xxxx, u_xlat2);
    u_xlat2 = fma(input.cp[2].INTERNALTESSPOS0, mtl_TessCoord.zzzz, u_xlat2);
    u_xlat0.xyz = fma(u_xlat0.xyz, float3(VGlobals._HeightDisplacement), u_xlat2.xyz);
    u_xlat3 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], u_xlat0.xxxx, u_xlat3);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], u_xlat0.zzzz, u_xlat3);
    u_xlat3 = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat4 = u_xlat3.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat4 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat3.xxxx, u_xlat4);
    u_xlat4 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat3.zzzz, u_xlat4);
    output.mtl_Position = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat3.wwww, u_xlat4);
    u_xlat2.y = dot(u_xlat1.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat2.z = dot(u_xlat1.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat2.x = dot(u_xlat1.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat1.x = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat1.x = rsqrt(u_xlat1.x);
    u_xlat1.xyz = u_xlat1.xxx * u_xlat2.xyz;
    output.TEXCOORD1.z = u_xlat1.y;
    u_xlat3 = mtl_TessCoord.yyyy * input.cp[1].TANGENT0;
    u_xlat3 = fma(input.cp[0].TANGENT0, mtl_TessCoord.xxxx, u_xlat3);
    u_xlat3 = fma(input.cp[2].TANGENT0, mtl_TessCoord.zzzz, u_xlat3);
    u_xlat2.xyz = u_xlat3.yyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].yzx;
    u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].yzx, u_xlat3.xxx, u_xlat2.xyz);
    u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].yzx, u_xlat3.zzz, u_xlat2.xyz);
    u_xlat16 = u_xlat3.w * VGlobals.unity_WorldTransformParams.w;
    u_xlat3.x = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat3.x = rsqrt(u_xlat3.x);
    u_xlat2.xyz = u_xlat2.xyz * u_xlat3.xxx;
    u_xlat3.xyz = u_xlat1.xyz * u_xlat2.xyz;
    u_xlat3.xyz = fma(u_xlat1.zxy, u_xlat2.yzx, (-u_xlat3.xyz));
    u_xlat3.xyz = float3(u_xlat16) * u_xlat3.xyz;
    output.TEXCOORD1.y = u_xlat3.x;
    output.TEXCOORD1.x = u_xlat2.z;
    output.TEXCOORD2.x = u_xlat2.x;
    output.TEXCOORD3.x = u_xlat2.y;
    output.TEXCOORD2.z = u_xlat1.z;
    output.TEXCOORD3.z = u_xlat1.x;
    output.TEXCOORD2.y = u_xlat3.y;
    output.TEXCOORD3.y = u_xlat3.z;
    output.TEXCOORD4.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, u_xlat2.www, u_xlat0.xyz);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3], u_xlat2.wwww, u_xlat0);
    u_xlat1.xyz = u_xlat0.yyy * VGlobals.hlslcc_mtx4x4unity_WorldToLight[1].xyz;
    u_xlat1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_WorldToLight[0].xyz, u_xlat0.xxx, u_xlat1.xyz);
    u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_WorldToLight[2].xyz, u_xlat0.zzz, u_xlat1.xyz);
    output.TEXCOORD5.xyz = fma(VGlobals.hlslcc_mtx4x4unity_WorldToLight[3].xyz, u_xlat0.www, u_xlat0.xyz);
    output.TEXCOORD6 = float4(0.0, 0.0, 0.0, 0.0);
    return output;
}
// SHADER_STAGE_DOMAIN_end
Compilation succeeded with: 

program_source:293:53: warning: writable resources in non-void post-tessellation vertex function
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
                                                    ^
program_source:299:30: note: writable buffer defined here
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
                             ^
program_source:300:48: note: writable buffer defined here
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
                                               ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float4 TEXCOORD0 [[ attribute(3) ]] ;
    float4 TEXCOORD1 [[ attribute(4) ]] ;
    float4 TEXCOORD2 [[ attribute(5) ]] ;
    float4 TEXCOORD3 [[ attribute(6) ]] ;
    float4 COLOR0 [[ attribute(7) ]] ;
};
struct Mtl_VertexOut
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float4 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float4 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float4 TEXCOORD3 [[ user(TEXCOORD3) ]];
    float4 COLOR0 [[ user(COLOR0) ]];
};
static Mtl_VertexOut vertexFunction(
    Mtl_VertexIn input)
{
    Mtl_VertexOut output;
    output.INTERNALTESSPOS0 = input.POSITION0;
    output.TANGENT0 = input.TANGENT0;
    output.NORMAL0.xyz = input.NORMAL0.xyz;
    output.TEXCOORD0 = input.TEXCOORD0;
    output.TEXCOORD1 = input.TEXCOORD1;
    output.TEXCOORD2 = input.TEXCOORD2;
    output.TEXCOORD3 = input.TEXCOORD3;
    output.COLOR0 = input.COLOR0;
    return output;
}
// SHADER_STAGE_HULL_begin
struct Mtl_ControlPoint
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float4 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float4 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float4 TEXCOORD3 [[ user(TEXCOORD3) ]];
    float4 COLOR0 [[ user(COLOR0) ]];
};
struct Mtl_ControlPointIn
{
    float4 INTERNALTESSPOS0 [[ attribute(8) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float4 TEXCOORD0 [[ attribute(3) ]] ;
    float4 TEXCOORD1 [[ attribute(4) ]] ;
    float4 TEXCOORD2 [[ attribute(5) ]] ;
    float4 TEXCOORD3 [[ attribute(6) ]] ;
    float4 COLOR0 [[ attribute(7) ]] ;
};
struct Mtl_KernelPatchInfo
{
    uint numPatches;
    ushort numControlPointsPerPatch;
};
struct VGlobals_Type
{
    float4 _Time;
    float4 _SinTime;
    float4 _CosTime;
    float4 unity_DeltaTime;
    float3 _WorldSpaceCameraPos;
    float4 _ProjectionParams;
    float4 _ScreenParams;
    float4 _ZBufferParams;
    float4 unity_OrthoParams;
    float4 unity_CameraWorldClipPlanes[6];
    float4 hlslcc_mtx4x4unity_CameraProjection[4];
    float4 hlslcc_mtx4x4unity_CameraInvProjection[4];
    float4 hlslcc_mtx4x4unity_WorldToCamera[4];
    float4 hlslcc_mtx4x4unity_CameraToWorld[4];
    float4 _WorldSpaceLightPos0;
    float4 _LightPositionRange;
    float4 _LightProjectionParams;
    float4 unity_4LightPosX0;
    float4 unity_4LightPosY0;
    float4 unity_4LightPosZ0;
    float4 unity_4LightAtten0;
    float4 unity_LightColor[8];
    float4 unity_LightPosition[8];
    float4 unity_LightAtten[8];
    float4 unity_SpotDirection[8];
    float4 unity_SHAr;
    float4 unity_SHAg;
    float4 unity_SHAb;
    float4 unity_SHBr;
    float4 unity_SHBg;
    float4 unity_SHBb;
    float4 unity_SHC;
    float4 unity_OcclusionMaskSelector;
    float4 unity_ProbesOcclusion;
    float3 unity_LightColor0;
    float3 unity_LightColor1;
    float3 unity_LightColor2;
    float3 unity_LightColor3;
    float4 unity_ShadowSplitSpheres[4];
    float4 unity_ShadowSplitSqRadii;
    float4 unity_LightShadowBias;
    float4 _LightSplitsNear;
    float4 _LightSplitsFar;
    float4 hlslcc_mtx4x4unity_WorldToShadow[16];
    float4 _LightShadowData;
    float4 unity_ShadowFadeCenterAndType;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 unity_LODFade;
    float4 unity_WorldTransformParams;
    float4 unity_RenderingLayer;
    float4 hlslcc_mtx4x4glstate_matrix_transpose_modelview0[4];
    float4 glstate_lightmodel_ambient;
    float4 unity_AmbientSky;
    float4 unity_AmbientEquator;
    float4 unity_AmbientGround;
    float4 unity_IndirectSpecColor;
    float4 hlslcc_mtx4x4glstate_matrix_projection[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixInvV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    int unity_StereoEyeIndex;
    float4 unity_ShadowColor;
    float4 unity_FogColor;
    float4 unity_FogParams;
    float4 unity_LightmapST;
    float4 unity_DynamicLightmapST;
    float4 unity_SpecCube0_BoxMax;
    float4 unity_SpecCube0_BoxMin;
    float4 unity_SpecCube0_ProbePosition;
    float4 unity_SpecCube0_HDR;
    float4 unity_SpecCube1_BoxMax;
    float4 unity_SpecCube1_BoxMin;
    float4 unity_SpecCube1_ProbePosition;
    float4 unity_SpecCube1_HDR;
    float4 unity_ProbeVolumeParams;
    float4 hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[4];
    float3 unity_ProbeVolumeSizeInv;
    float3 unity_ProbeVolumeMin;
    float4 unity_Lightmap_HDR;
    float4 unity_DynamicLightmap_HDR;
    float4 _LightColor0;
    float4 _SpecColor;
    float _Tile;
    float _HeightDisplacement;
    float _NormalScale;
    float4 _ColorTint;
    float _MetallicStrength;
    float _SmoothnessStrength;
    float _EdgeLength;
};
struct Mtl_HullIn
{
    Mtl_VertexOut cp[3];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
kernel void patchKernel(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn vertexInput [[ stage_in ]],
    uint2 tID [[ thread_position_in_grid ]],
    ushort2 groupID [[ threadgroup_position_in_grid ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    constant Mtl_KernelPatchInfo &patchInfo [[ buffer(3) ]])
{
#pragma clang diagnostic pop
    Mtl_ControlPoint output;
    const uint numPatchesInThreadGroup = 10;
    const uint patchID = (tID.x / patchInfo.numControlPointsPerPatch);
    const bool patchValid = (patchID < patchInfo.numPatches);
    const uint mtl_BaseInstance = 0;
    const uint mtl_InstanceID = groupID.y - mtl_BaseInstance;
    const uint internalPatchID = mtl_InstanceID * patchInfo.numPatches + patchID;
    const uint patchIDInThreadGroup = (patchID % numPatchesInThreadGroup);
    const uint controlPointID = (tID.x % patchInfo.numControlPointsPerPatch);
    const uint mtl_BaseVertex = 0;
    const uint mtl_VertexID = ((mtl_InstanceID * (patchInfo.numControlPointsPerPatch * patchInfo.numPatches)) + tID.x) - mtl_BaseVertex;
    threadgroup Mtl_HullIn inputGroup[numPatchesInThreadGroup];
    threadgroup Mtl_HullIn &input = inputGroup[patchIDInThreadGroup];
    MTLTriangleTessellationFactorsHalf tessFactor;
    if (patchValid) {
        input.cp[controlPointID] = vertexFunction(vertexInput);
        output.INTERNALTESSPOS0 = input.cp[controlPointID].INTERNALTESSPOS0;
        output.TANGENT0 = input.cp[controlPointID].TANGENT0;
        output.NORMAL0 = input.cp[controlPointID].NORMAL0;
        output.TEXCOORD0 = input.cp[controlPointID].TEXCOORD0;
        output.TEXCOORD1 = input.cp[controlPointID].TEXCOORD1;
        output.TEXCOORD2 = input.cp[controlPointID].TEXCOORD2;
        output.TEXCOORD3 = input.cp[controlPointID].TEXCOORD3;
        output.COLOR0 = input.cp[controlPointID].COLOR0;
    }
    threadgroup_barrier(mem_flags::mem_threadgroup);
    if (!patchValid) {
        return;
    }
    float3 u_xlat0;
    float3 u_xlat1;
    float3 u_xlat2;
    float3 u_xlat3;
    float3 u_xlat4;
    float u_xlat12;
    float u_xlat13;
    // fork_phase2
    {
        u_xlat0.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[1].INTERNALTESSPOS0.yyy;
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[1].INTERNALTESSPOS0.xxx, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[1].INTERNALTESSPOS0.zzz, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[1].INTERNALTESSPOS0.www, u_xlat0.xyz);
        u_xlat1.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[2].INTERNALTESSPOS0.yyy;
        u_xlat1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[2].INTERNALTESSPOS0.xxx, u_xlat1.xyz);
        u_xlat1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[2].INTERNALTESSPOS0.zzz, u_xlat1.xyz);
        u_xlat1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[2].INTERNALTESSPOS0.www, u_xlat1.xyz);
        u_xlat2.xyz = u_xlat0.xyz + u_xlat1.xyz;
        u_xlat2.xyz = fma(u_xlat2.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat12 = dot(u_xlat2.xyz, u_xlat2.xyz);
        u_xlat12 = sqrt(u_xlat12);
        u_xlat12 = u_xlat12 * VGlobals._EdgeLength;
        u_xlat2.xyz = u_xlat0.xyz + (-u_xlat1.xyz);
        u_xlat13 = dot(u_xlat2.xyz, u_xlat2.xyz);
        u_xlat13 = sqrt(u_xlat13);
        u_xlat13 = u_xlat13 * VGlobals._ScreenParams.y;
        u_xlat12 = u_xlat13 / u_xlat12;
        tessFactor.edgeTessellationFactor[0] = max(u_xlat12, 1.0);
        u_xlat2.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[0].INTERNALTESSPOS0.yyy;
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[0].INTERNALTESSPOS0.xxx, u_xlat2.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[0].INTERNALTESSPOS0.zzz, u_xlat2.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[0].INTERNALTESSPOS0.www, u_xlat2.xyz);
        u_xlat3.xyz = u_xlat1.xyz + u_xlat2.xyz;
        u_xlat1.xyz = u_xlat1.xyz + (-u_xlat2.xyz);
        u_xlat12 = dot(u_xlat1.xyz, u_xlat1.xyz);
        u_xlat12 = sqrt(u_xlat12);
        u_xlat12 = u_xlat12 * VGlobals._ScreenParams.y;
        u_xlat1.xyz = fma(u_xlat3.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat1.x = dot(u_xlat1.xyz, u_xlat1.xyz);
        u_xlat1.x = sqrt(u_xlat1.x);
        u_xlat1.x = u_xlat1.x * VGlobals._EdgeLength;
        u_xlat12 = u_xlat12 / u_xlat1.x;
        tessFactor.edgeTessellationFactor[1] = max(u_xlat12, 1.0);
        u_xlat1.xyz = u_xlat0.xyz + u_xlat2.xyz;
        u_xlat0.xyz = (-u_xlat0.xyz) + u_xlat2.xyz;
        u_xlat0.x = dot(u_xlat0.xyz, u_xlat0.xyz);
        u_xlat0.x = sqrt(u_xlat0.x);
        u_xlat0.x = u_xlat0.x * VGlobals._ScreenParams.y;
        u_xlat4.xyz = fma(u_xlat1.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat4.x = dot(u_xlat4.xyz, u_xlat4.xyz);
        u_xlat4.x = sqrt(u_xlat4.x);
        u_xlat4.x = u_xlat4.x * VGlobals._EdgeLength;
        u_xlat0.x = u_xlat0.x / u_xlat4.x;
        tessFactor.edgeTessellationFactor[2] = max(u_xlat0.x, 1.0);
    }
    // join_phase3
    {
        u_xlat0.x = tessFactor.edgeTessellationFactor[0] + tessFactor.edgeTessellationFactor[1];
        u_xlat0.x = u_xlat0.x + tessFactor.edgeTessellationFactor[2];
        tessFactor.insideTessellationFactor = u_xlat0.x * 0.333333343;
    }
    controlPoints[mtl_VertexID] = output;
    tessFactors[internalPatchID] = tessFactor;
}
// SHADER_STAGE_HULL_end
// SHADER_STAGE_DOMAIN_begin
struct Mtl_VertexInPostTess
{
    patch_control_point<Mtl_ControlPointIn> cp;
};
struct Mtl_VertexOutPostTess
{
    float4 mtl_Position [[ position ]];
    float3 TEXCOORD1 [[ user(TEXCOORD1) ]];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    sampler sampler_Height [[ sampler (0) ]],
    texture2d<float, access::sample > _Height [[ texture(0) ]] ,
    float3 mtl_TessCoord [[ position_in_patch ]],
    uint patchID [[ patch_id ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    Mtl_VertexInPostTess input [[ stage_in ]])
{
#pragma clang diagnostic pop
    Mtl_VertexOutPostTess output;
    MTLTriangleTessellationFactorsHalf tessFactor;
    tessFactor = tessFactors[patchID];
    float4 u_xlat0;
    float4 u_xlat1;
    float4 u_xlat2;
    float4 u_xlat3;
    float4 u_xlat4;
    float u_xlat11;
    float u_xlat15;
    bool u_xlatb15;
    u_xlat0.xyz = mtl_TessCoord.yyy * input.cp[1].NORMAL0.xyz;
    u_xlat0.xyz = fma(input.cp[0].NORMAL0.xyz, mtl_TessCoord.xxx, u_xlat0.xyz);
    u_xlat0.xyz = fma(input.cp[2].NORMAL0.xyz, mtl_TessCoord.zzz, u_xlat0.xyz);
    u_xlat1.x = dot(u_xlat0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat1.y = dot(u_xlat0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat1.z = dot(u_xlat0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat15 = dot(u_xlat1.xyz, u_xlat1.xyz);
    u_xlat15 = rsqrt(u_xlat15);
    u_xlat1.xyz = float3(u_xlat15) * u_xlat1.xyz;
    u_xlat2.xy = mtl_TessCoord.yy * input.cp[1].TEXCOORD0.xy;
    u_xlat2.xy = fma(input.cp[0].TEXCOORD0.xy, mtl_TessCoord.xx, u_xlat2.xy);
    u_xlat2.xy = fma(input.cp[2].TEXCOORD0.xy, mtl_TessCoord.zz, u_xlat2.xy);
    u_xlat2.xy = u_xlat2.xy * float2(VGlobals._Tile);
    u_xlat2.xyz = _Height.sample(sampler_Height, u_xlat2.xy, level(1.0)).xyz;
    u_xlat0.xyz = u_xlat0.xyz * u_xlat2.xyz;
    u_xlat2 = mtl_TessCoord.yyyy * input.cp[1].INTERNALTESSPOS0;
    u_xlat2 = fma(input.cp[0].INTERNALTESSPOS0, mtl_TessCoord.xxxx, u_xlat2);
    u_xlat2 = fma(input.cp[2].INTERNALTESSPOS0, mtl_TessCoord.zzzz, u_xlat2);
    u_xlat0.xyz = fma(u_xlat0.xyz, float3(VGlobals._HeightDisplacement), u_xlat2.xyz);
    u_xlat3 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], u_xlat0.xxxx, u_xlat3);
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], u_xlat0.zzzz, u_xlat3);
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3], u_xlat2.wwww, u_xlat3);
    u_xlat2.xyz = fma((-u_xlat3.xyz), VGlobals._WorldSpaceLightPos0.www, VGlobals._WorldSpaceLightPos0.xyz);
    u_xlat15 = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat15 = rsqrt(u_xlat15);
    u_xlat2.xyz = float3(u_xlat15) * u_xlat2.xyz;
    u_xlat15 = dot(u_xlat1.xyz, u_xlat2.xyz);
    u_xlat15 = fma((-u_xlat15), u_xlat15, 1.0);
    u_xlat15 = sqrt(u_xlat15);
    u_xlat15 = u_xlat15 * VGlobals.unity_LightShadowBias.z;
    u_xlat1.xyz = fma((-u_xlat1.xyz), float3(u_xlat15), u_xlat3.xyz);
    u_xlatb15 = VGlobals.unity_LightShadowBias.z!=0.0;
    u_xlat1.xyz = (bool(u_xlatb15)) ? u_xlat1.xyz : u_xlat3.xyz;
    u_xlat4 = u_xlat1.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat4 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat1.xxxx, u_xlat4);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat1.zzzz, u_xlat4);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat3.wwww, u_xlat1);
    u_xlat15 = VGlobals.unity_LightShadowBias.x / u_xlat1.w;
    u_xlat15 = min(u_xlat15, 0.0);
    u_xlat15 = max(u_xlat15, -1.0);
    u_xlat15 = u_xlat15 + u_xlat1.z;
    u_xlat11 = min(u_xlat1.w, u_xlat15);
    output.mtl_Position.xyw = u_xlat1.xyw;
    u_xlat1.x = (-u_xlat15) + u_xlat11;
    output.mtl_Position.z = fma(VGlobals.unity_LightShadowBias.y, u_xlat1.x, u_xlat15);
    u_xlat1.xyz = u_xlat0.yyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz;
    u_xlat0.xyw = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, u_xlat0.xxx, u_xlat1.xyz);
    u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, u_xlat0.zzz, u_xlat0.xyw);
    output.TEXCOORD1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, u_xlat2.www, u_xlat0.xyz);
    return output;
}
// SHADER_STAGE_DOMAIN_end
Compilation succeeded with: 

program_source:299:53: warning: writable resources in non-void post-tessellation vertex function
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
                                                    ^
program_source:305:30: note: writable buffer defined here
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
                             ^
program_source:306:48: note: writable buffer defined here
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
                                               ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float4 TEXCOORD0 [[ attribute(3) ]] ;
    float4 TEXCOORD1 [[ attribute(4) ]] ;
    float4 TEXCOORD2 [[ attribute(5) ]] ;
    float4 TEXCOORD3 [[ attribute(6) ]] ;
    float4 COLOR0 [[ attribute(7) ]] ;
};
struct Mtl_VertexOut
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float4 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float4 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float4 TEXCOORD3 [[ user(TEXCOORD3) ]];
    float4 COLOR0 [[ user(COLOR0) ]];
};
static Mtl_VertexOut vertexFunction(
    Mtl_VertexIn input)
{
    Mtl_VertexOut output;
    output.INTERNALTESSPOS0 = input.POSITION0;
    output.TANGENT0 = input.TANGENT0;
    output.NORMAL0.xyz = input.NORMAL0.xyz;
    output.TEXCOORD0 = input.TEXCOORD0;
    output.TEXCOORD1 = input.TEXCOORD1;
    output.TEXCOORD2 = input.TEXCOORD2;
    output.TEXCOORD3 = input.TEXCOORD3;
    output.COLOR0 = input.COLOR0;
    return output;
}
// SHADER_STAGE_HULL_begin
struct Mtl_ControlPoint
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float4 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float4 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float4 TEXCOORD3 [[ user(TEXCOORD3) ]];
    float4 COLOR0 [[ user(COLOR0) ]];
};
struct Mtl_ControlPointIn
{
    float4 INTERNALTESSPOS0 [[ attribute(8) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float4 TEXCOORD0 [[ attribute(3) ]] ;
    float4 TEXCOORD1 [[ attribute(4) ]] ;
    float4 TEXCOORD2 [[ attribute(5) ]] ;
    float4 TEXCOORD3 [[ attribute(6) ]] ;
    float4 COLOR0 [[ attribute(7) ]] ;
};
struct Mtl_KernelPatchInfo
{
    uint numPatches;
    ushort numControlPointsPerPatch;
};
struct VGlobals_Type
{
    float4 _Time;
    float4 _SinTime;
    float4 _CosTime;
    float4 unity_DeltaTime;
    float3 _WorldSpaceCameraPos;
    float4 _ProjectionParams;
    float4 _ScreenParams;
    float4 _ZBufferParams;
    float4 unity_OrthoParams;
    float4 unity_CameraWorldClipPlanes[6];
    float4 hlslcc_mtx4x4unity_CameraProjection[4];
    float4 hlslcc_mtx4x4unity_CameraInvProjection[4];
    float4 hlslcc_mtx4x4unity_WorldToCamera[4];
    float4 hlslcc_mtx4x4unity_CameraToWorld[4];
    float4 _WorldSpaceLightPos0;
    float4 _LightPositionRange;
    float4 _LightProjectionParams;
    float4 unity_4LightPosX0;
    float4 unity_4LightPosY0;
    float4 unity_4LightPosZ0;
    float4 unity_4LightAtten0;
    float4 unity_LightColor[8];
    float4 unity_LightPosition[8];
    float4 unity_LightAtten[8];
    float4 unity_SpotDirection[8];
    float4 unity_SHAr;
    float4 unity_SHAg;
    float4 unity_SHAb;
    float4 unity_SHBr;
    float4 unity_SHBg;
    float4 unity_SHBb;
    float4 unity_SHC;
    float4 unity_OcclusionMaskSelector;
    float4 unity_ProbesOcclusion;
    float3 unity_LightColor0;
    float3 unity_LightColor1;
    float3 unity_LightColor2;
    float3 unity_LightColor3;
    float4 unity_ShadowSplitSpheres[4];
    float4 unity_ShadowSplitSqRadii;
    float4 unity_LightShadowBias;
    float4 _LightSplitsNear;
    float4 _LightSplitsFar;
    float4 hlslcc_mtx4x4unity_WorldToShadow[16];
    float4 _LightShadowData;
    float4 unity_ShadowFadeCenterAndType;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 unity_LODFade;
    float4 unity_WorldTransformParams;
    float4 unity_RenderingLayer;
    float4 hlslcc_mtx4x4glstate_matrix_transpose_modelview0[4];
    float4 glstate_lightmodel_ambient;
    float4 unity_AmbientSky;
    float4 unity_AmbientEquator;
    float4 unity_AmbientGround;
    float4 unity_IndirectSpecColor;
    float4 hlslcc_mtx4x4glstate_matrix_projection[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixInvV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    int unity_StereoEyeIndex;
    float4 unity_ShadowColor;
    float4 unity_FogColor;
    float4 unity_FogParams;
    float4 unity_LightmapST;
    float4 unity_DynamicLightmapST;
    float4 unity_SpecCube0_BoxMax;
    float4 unity_SpecCube0_BoxMin;
    float4 unity_SpecCube0_ProbePosition;
    float4 unity_SpecCube0_HDR;
    float4 unity_SpecCube1_BoxMax;
    float4 unity_SpecCube1_BoxMin;
    float4 unity_SpecCube1_ProbePosition;
    float4 unity_SpecCube1_HDR;
    float4 unity_ProbeVolumeParams;
    float4 hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[4];
    float3 unity_ProbeVolumeSizeInv;
    float3 unity_ProbeVolumeMin;
    float4 unity_Lightmap_HDR;
    float4 unity_DynamicLightmap_HDR;
    float4 _LightColor0;
    float4 _SpecColor;
    float _Tile;
    float _HeightDisplacement;
    float _NormalScale;
    float4 _ColorTint;
    float _MetallicStrength;
    float _SmoothnessStrength;
    float _EdgeLength;
    float4 _texcoord_ST;
    float4 unity_Ambient;
};
struct Mtl_HullIn
{
    Mtl_VertexOut cp[3];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
kernel void patchKernel(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn vertexInput [[ stage_in ]],
    uint2 tID [[ thread_position_in_grid ]],
    ushort2 groupID [[ threadgroup_position_in_grid ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    constant Mtl_KernelPatchInfo &patchInfo [[ buffer(3) ]])
{
#pragma clang diagnostic pop
    Mtl_ControlPoint output;
    const uint numPatchesInThreadGroup = 10;
    const uint patchID = (tID.x / patchInfo.numControlPointsPerPatch);
    const bool patchValid = (patchID < patchInfo.numPatches);
    const uint mtl_BaseInstance = 0;
    const uint mtl_InstanceID = groupID.y - mtl_BaseInstance;
    const uint internalPatchID = mtl_InstanceID * patchInfo.numPatches + patchID;
    const uint patchIDInThreadGroup = (patchID % numPatchesInThreadGroup);
    const uint controlPointID = (tID.x % patchInfo.numControlPointsPerPatch);
    const uint mtl_BaseVertex = 0;
    const uint mtl_VertexID = ((mtl_InstanceID * (patchInfo.numControlPointsPerPatch * patchInfo.numPatches)) + tID.x) - mtl_BaseVertex;
    threadgroup Mtl_HullIn inputGroup[numPatchesInThreadGroup];
    threadgroup Mtl_HullIn &input = inputGroup[patchIDInThreadGroup];
    MTLTriangleTessellationFactorsHalf tessFactor;
    if (patchValid) {
        input.cp[controlPointID] = vertexFunction(vertexInput);
        output.INTERNALTESSPOS0 = input.cp[controlPointID].INTERNALTESSPOS0;
        output.TANGENT0 = input.cp[controlPointID].TANGENT0;
        output.NORMAL0 = input.cp[controlPointID].NORMAL0;
        output.TEXCOORD0 = input.cp[controlPointID].TEXCOORD0;
        output.TEXCOORD1 = input.cp[controlPointID].TEXCOORD1;
        output.TEXCOORD2 = input.cp[controlPointID].TEXCOORD2;
        output.TEXCOORD3 = input.cp[controlPointID].TEXCOORD3;
        output.COLOR0 = input.cp[controlPointID].COLOR0;
    }
    threadgroup_barrier(mem_flags::mem_threadgroup);
    if (!patchValid) {
        return;
    }
    float3 u_xlat0;
    float3 u_xlat1;
    float3 u_xlat2;
    float3 u_xlat3;
    float3 u_xlat4;
    float u_xlat12;
    float u_xlat13;
    // fork_phase2
    {
        u_xlat0.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[1].INTERNALTESSPOS0.yyy;
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[1].INTERNALTESSPOS0.xxx, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[1].INTERNALTESSPOS0.zzz, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[1].INTERNALTESSPOS0.www, u_xlat0.xyz);
        u_xlat1.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[2].INTERNALTESSPOS0.yyy;
        u_xlat1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[2].INTERNALTESSPOS0.xxx, u_xlat1.xyz);
        u_xlat1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[2].INTERNALTESSPOS0.zzz, u_xlat1.xyz);
        u_xlat1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[2].INTERNALTESSPOS0.www, u_xlat1.xyz);
        u_xlat2.xyz = u_xlat0.xyz + u_xlat1.xyz;
        u_xlat2.xyz = fma(u_xlat2.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat12 = dot(u_xlat2.xyz, u_xlat2.xyz);
        u_xlat12 = sqrt(u_xlat12);
        u_xlat12 = u_xlat12 * VGlobals._EdgeLength;
        u_xlat2.xyz = u_xlat0.xyz + (-u_xlat1.xyz);
        u_xlat13 = dot(u_xlat2.xyz, u_xlat2.xyz);
        u_xlat13 = sqrt(u_xlat13);
        u_xlat13 = u_xlat13 * VGlobals._ScreenParams.y;
        u_xlat12 = u_xlat13 / u_xlat12;
        tessFactor.edgeTessellationFactor[0] = max(u_xlat12, 1.0);
        u_xlat2.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[0].INTERNALTESSPOS0.yyy;
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[0].INTERNALTESSPOS0.xxx, u_xlat2.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[0].INTERNALTESSPOS0.zzz, u_xlat2.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[0].INTERNALTESSPOS0.www, u_xlat2.xyz);
        u_xlat3.xyz = u_xlat1.xyz + u_xlat2.xyz;
        u_xlat1.xyz = u_xlat1.xyz + (-u_xlat2.xyz);
        u_xlat12 = dot(u_xlat1.xyz, u_xlat1.xyz);
        u_xlat12 = sqrt(u_xlat12);
        u_xlat12 = u_xlat12 * VGlobals._ScreenParams.y;
        u_xlat1.xyz = fma(u_xlat3.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat1.x = dot(u_xlat1.xyz, u_xlat1.xyz);
        u_xlat1.x = sqrt(u_xlat1.x);
        u_xlat1.x = u_xlat1.x * VGlobals._EdgeLength;
        u_xlat12 = u_xlat12 / u_xlat1.x;
        tessFactor.edgeTessellationFactor[1] = max(u_xlat12, 1.0);
        u_xlat1.xyz = u_xlat0.xyz + u_xlat2.xyz;
        u_xlat0.xyz = (-u_xlat0.xyz) + u_xlat2.xyz;
        u_xlat0.x = dot(u_xlat0.xyz, u_xlat0.xyz);
        u_xlat0.x = sqrt(u_xlat0.x);
        u_xlat0.x = u_xlat0.x * VGlobals._ScreenParams.y;
        u_xlat4.xyz = fma(u_xlat1.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat4.x = dot(u_xlat4.xyz, u_xlat4.xyz);
        u_xlat4.x = sqrt(u_xlat4.x);
        u_xlat4.x = u_xlat4.x * VGlobals._EdgeLength;
        u_xlat0.x = u_xlat0.x / u_xlat4.x;
        tessFactor.edgeTessellationFactor[2] = max(u_xlat0.x, 1.0);
    }
    // join_phase3
    {
        u_xlat0.x = tessFactor.edgeTessellationFactor[0] + tessFactor.edgeTessellationFactor[1];
        u_xlat0.x = u_xlat0.x + tessFactor.edgeTessellationFactor[2];
        tessFactor.insideTessellationFactor = u_xlat0.x * 0.333333343;
    }
    controlPoints[mtl_VertexID] = output;
    tessFactors[internalPatchID] = tessFactor;
}
// SHADER_STAGE_HULL_end
// SHADER_STAGE_DOMAIN_begin
struct Mtl_VertexInPostTess
{
    patch_control_point<Mtl_ControlPointIn> cp;
};
struct Mtl_VertexOutPostTess
{
    float4 mtl_Position [[ position ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float4 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float4 TEXCOORD3 [[ user(TEXCOORD3) ]];
    float4 TEXCOORD5 [[ user(TEXCOORD5) ]];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    sampler sampler_Height [[ sampler (0) ]],
    texture2d<float, access::sample > _Height [[ texture(0) ]] ,
    float3 mtl_TessCoord [[ position_in_patch ]],
    uint patchID [[ patch_id ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    Mtl_VertexInPostTess input [[ stage_in ]])
{
#pragma clang diagnostic pop
    Mtl_VertexOutPostTess output;
    MTLTriangleTessellationFactorsHalf tessFactor;
    tessFactor = tessFactors[patchID];
    float4 u_xlat0;
    float4 u_xlat1;
    float4 u_xlat2;
    float4 u_xlat3;
    float2 u_xlat9;
    float u_xlat12;
    float u_xlat13;
    u_xlat0 = mtl_TessCoord.yyyy * input.cp[1].INTERNALTESSPOS0;
    u_xlat0 = fma(input.cp[0].INTERNALTESSPOS0, mtl_TessCoord.xxxx, u_xlat0);
    u_xlat0 = fma(input.cp[2].INTERNALTESSPOS0, mtl_TessCoord.zzzz, u_xlat0);
    u_xlat1.xy = mtl_TessCoord.yy * input.cp[1].TEXCOORD0.xy;
    u_xlat1.xy = fma(input.cp[0].TEXCOORD0.xy, mtl_TessCoord.xx, u_xlat1.xy);
    u_xlat1.xy = fma(input.cp[2].TEXCOORD0.xy, mtl_TessCoord.zz, u_xlat1.xy);
    u_xlat9.xy = u_xlat1.xy * float2(VGlobals._Tile);
    output.TEXCOORD0.xy = fma(u_xlat1.xy, VGlobals._texcoord_ST.xy, VGlobals._texcoord_ST.zw);
    u_xlat1.xyz = _Height.sample(sampler_Height, u_xlat9.xy, level(1.0)).xyz;
    u_xlat2.xyz = mtl_TessCoord.yyy * input.cp[1].NORMAL0.xyz;
    u_xlat2.xyz = fma(input.cp[0].NORMAL0.xyz, mtl_TessCoord.xxx, u_xlat2.xyz);
    u_xlat2.xyz = fma(input.cp[2].NORMAL0.xyz, mtl_TessCoord.zzz, u_xlat2.xyz);
    u_xlat1.xyz = u_xlat1.xyz * u_xlat2.xyz;
    u_xlat0.xyz = fma(u_xlat1.xyz, float3(VGlobals._HeightDisplacement), u_xlat0.xyz);
    u_xlat1 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], u_xlat0.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], u_xlat0.zzzz, u_xlat1);
    u_xlat3 = u_xlat1 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, u_xlat0.www, u_xlat1.xyz);
    u_xlat1 = u_xlat3.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat3.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat3.zzzz, u_xlat1);
    output.mtl_Position = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat3.wwww, u_xlat1);
    u_xlat1.y = dot(u_xlat2.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat1.z = dot(u_xlat2.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat1.x = dot(u_xlat2.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat12 = dot(u_xlat1.xyz, u_xlat1.xyz);
    u_xlat12 = rsqrt(u_xlat12);
    u_xlat1.xyz = float3(u_xlat12) * u_xlat1.xyz;
    output.TEXCOORD1.z = u_xlat1.y;
    u_xlat2 = mtl_TessCoord.yyyy * input.cp[1].TANGENT0;
    u_xlat2 = fma(input.cp[0].TANGENT0, mtl_TessCoord.xxxx, u_xlat2);
    u_xlat2 = fma(input.cp[2].TANGENT0, mtl_TessCoord.zzzz, u_xlat2);
    u_xlat3.xyz = u_xlat2.yyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].yzx;
    u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].yzx, u_xlat2.xxx, u_xlat3.xyz);
    u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].yzx, u_xlat2.zzz, u_xlat3.xyz);
    u_xlat12 = u_xlat2.w * VGlobals.unity_WorldTransformParams.w;
    u_xlat13 = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat13 = rsqrt(u_xlat13);
    u_xlat2.xyz = float3(u_xlat13) * u_xlat2.xyz;
    u_xlat3.xyz = u_xlat1.xyz * u_xlat2.xyz;
    u_xlat3.xyz = fma(u_xlat1.zxy, u_xlat2.yzx, (-u_xlat3.xyz));
    u_xlat3.xyz = float3(u_xlat12) * u_xlat3.xyz;
    output.TEXCOORD1.y = u_xlat3.x;
    output.TEXCOORD1.w = u_xlat0.x;
    output.TEXCOORD1.x = u_xlat2.z;
    output.TEXCOORD2.w = u_xlat0.y;
    output.TEXCOORD3.w = u_xlat0.z;
    output.TEXCOORD2.x = u_xlat2.x;
    output.TEXCOORD3.x = u_xlat2.y;
    output.TEXCOORD2.z = u_xlat1.z;
    output.TEXCOORD3.z = u_xlat1.x;
    output.TEXCOORD2.y = u_xlat3.y;
    output.TEXCOORD3.y = u_xlat3.z;
    output.TEXCOORD5 = float4(0.0, 0.0, 0.0, 0.0);
    return output;
}
// SHADER_STAGE_DOMAIN_end
Compilation succeeded with: 

program_source:303:53: warning: writable resources in non-void post-tessellation vertex function
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
                                                    ^
program_source:309:30: note: writable buffer defined here
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
                             ^
program_source:310:48: note: writable buffer defined here
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
                                               ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float4 TEXCOORD0 [[ attribute(3) ]] ;
    float4 TEXCOORD1 [[ attribute(4) ]] ;
    float4 TEXCOORD2 [[ attribute(5) ]] ;
    float4 TEXCOORD3 [[ attribute(6) ]] ;
    float4 COLOR0 [[ attribute(7) ]] ;
};
struct Mtl_VertexOut
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float4 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float4 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float4 TEXCOORD3 [[ user(TEXCOORD3) ]];
    float4 COLOR0 [[ user(COLOR0) ]];
};
static Mtl_VertexOut vertexFunction(
    Mtl_VertexIn input)
{
    Mtl_VertexOut output;
    output.INTERNALTESSPOS0 = input.POSITION0;
    output.TANGENT0 = input.TANGENT0;
    output.NORMAL0.xyz = input.NORMAL0.xyz;
    output.TEXCOORD0 = input.TEXCOORD0;
    output.TEXCOORD1 = input.TEXCOORD1;
    output.TEXCOORD2 = input.TEXCOORD2;
    output.TEXCOORD3 = input.TEXCOORD3;
    output.COLOR0 = input.COLOR0;
    return output;
}
// SHADER_STAGE_HULL_begin
struct Mtl_ControlPoint
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float4 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float4 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float4 TEXCOORD3 [[ user(TEXCOORD3) ]];
    float4 COLOR0 [[ user(COLOR0) ]];
};
struct Mtl_ControlPointIn
{
    float4 INTERNALTESSPOS0 [[ attribute(8) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float4 TEXCOORD0 [[ attribute(3) ]] ;
    float4 TEXCOORD1 [[ attribute(4) ]] ;
    float4 TEXCOORD2 [[ attribute(5) ]] ;
    float4 TEXCOORD3 [[ attribute(6) ]] ;
    float4 COLOR0 [[ attribute(7) ]] ;
};
struct Mtl_KernelPatchInfo
{
    uint numPatches;
    ushort numControlPointsPerPatch;
};
struct VGlobals_Type
{
    float4 _Time;
    float4 _SinTime;
    float4 _CosTime;
    float4 unity_DeltaTime;
    float3 _WorldSpaceCameraPos;
    float4 _ProjectionParams;
    float4 _ScreenParams;
    float4 _ZBufferParams;
    float4 unity_OrthoParams;
    float4 unity_CameraWorldClipPlanes[6];
    float4 hlslcc_mtx4x4unity_CameraProjection[4];
    float4 hlslcc_mtx4x4unity_CameraInvProjection[4];
    float4 hlslcc_mtx4x4unity_WorldToCamera[4];
    float4 hlslcc_mtx4x4unity_CameraToWorld[4];
    float4 _WorldSpaceLightPos0;
    float4 _LightPositionRange;
    float4 _LightProjectionParams;
    float4 unity_4LightPosX0;
    float4 unity_4LightPosY0;
    float4 unity_4LightPosZ0;
    float4 unity_4LightAtten0;
    float4 unity_LightColor[8];
    float4 unity_LightPosition[8];
    float4 unity_LightAtten[8];
    float4 unity_SpotDirection[8];
    float4 unity_SHAr;
    float4 unity_SHAg;
    float4 unity_SHAb;
    float4 unity_SHBr;
    float4 unity_SHBg;
    float4 unity_SHBb;
    float4 unity_SHC;
    float4 unity_OcclusionMaskSelector;
    float4 unity_ProbesOcclusion;
    float3 unity_LightColor0;
    float3 unity_LightColor1;
    float3 unity_LightColor2;
    float3 unity_LightColor3;
    float4 unity_ShadowSplitSpheres[4];
    float4 unity_ShadowSplitSqRadii;
    float4 unity_LightShadowBias;
    float4 _LightSplitsNear;
    float4 _LightSplitsFar;
    float4 hlslcc_mtx4x4unity_WorldToShadow[16];
    float4 _LightShadowData;
    float4 unity_ShadowFadeCenterAndType;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 unity_LODFade;
    float4 unity_WorldTransformParams;
    float4 unity_RenderingLayer;
    float4 hlslcc_mtx4x4glstate_matrix_transpose_modelview0[4];
    float4 glstate_lightmodel_ambient;
    float4 unity_AmbientSky;
    float4 unity_AmbientEquator;
    float4 unity_AmbientGround;
    float4 unity_IndirectSpecColor;
    float4 hlslcc_mtx4x4glstate_matrix_projection[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixInvV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    int unity_StereoEyeIndex;
    float4 unity_ShadowColor;
    float4 unity_FogColor;
    float4 unity_FogParams;
    float4 unity_LightmapST;
    float4 unity_DynamicLightmapST;
    float4 unity_SpecCube0_BoxMax;
    float4 unity_SpecCube0_BoxMin;
    float4 unity_SpecCube0_ProbePosition;
    float4 unity_SpecCube0_HDR;
    float4 unity_SpecCube1_BoxMax;
    float4 unity_SpecCube1_BoxMin;
    float4 unity_SpecCube1_ProbePosition;
    float4 unity_SpecCube1_HDR;
    float4 unity_ProbeVolumeParams;
    float4 hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[4];
    float3 unity_ProbeVolumeSizeInv;
    float3 unity_ProbeVolumeMin;
    float4 unity_Lightmap_HDR;
    float4 unity_DynamicLightmap_HDR;
    float4 _LightColor0;
    float4 _SpecColor;
    float _Tile;
    float _HeightDisplacement;
    float _NormalScale;
    float4 _ColorTint;
    float _MetallicStrength;
    float _SmoothnessStrength;
    float _EdgeLength;
    bool4 unity_MetaVertexControl;
    bool4 unity_MetaFragmentControl;
    int unity_VisualizationMode;
    float unity_OneOverOutputBoost;
    float unity_MaxOutputValue;
    float unity_UseLinearSpace;
    float4 _texcoord_ST;
};
struct Mtl_HullIn
{
    Mtl_VertexOut cp[3];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
kernel void patchKernel(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn vertexInput [[ stage_in ]],
    uint2 tID [[ thread_position_in_grid ]],
    ushort2 groupID [[ threadgroup_position_in_grid ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    constant Mtl_KernelPatchInfo &patchInfo [[ buffer(3) ]])
{
#pragma clang diagnostic pop
    Mtl_ControlPoint output;
    const uint numPatchesInThreadGroup = 10;
    const uint patchID = (tID.x / patchInfo.numControlPointsPerPatch);
    const bool patchValid = (patchID < patchInfo.numPatches);
    const uint mtl_BaseInstance = 0;
    const uint mtl_InstanceID = groupID.y - mtl_BaseInstance;
    const uint internalPatchID = mtl_InstanceID * patchInfo.numPatches + patchID;
    const uint patchIDInThreadGroup = (patchID % numPatchesInThreadGroup);
    const uint controlPointID = (tID.x % patchInfo.numControlPointsPerPatch);
    const uint mtl_BaseVertex = 0;
    const uint mtl_VertexID = ((mtl_InstanceID * (patchInfo.numControlPointsPerPatch * patchInfo.numPatches)) + tID.x) - mtl_BaseVertex;
    threadgroup Mtl_HullIn inputGroup[numPatchesInThreadGroup];
    threadgroup Mtl_HullIn &input = inputGroup[patchIDInThreadGroup];
    MTLTriangleTessellationFactorsHalf tessFactor;
    if (patchValid) {
        input.cp[controlPointID] = vertexFunction(vertexInput);
        output.INTERNALTESSPOS0 = input.cp[controlPointID].INTERNALTESSPOS0;
        output.TANGENT0 = input.cp[controlPointID].TANGENT0;
        output.NORMAL0 = input.cp[controlPointID].NORMAL0;
        output.TEXCOORD0 = input.cp[controlPointID].TEXCOORD0;
        output.TEXCOORD1 = input.cp[controlPointID].TEXCOORD1;
        output.TEXCOORD2 = input.cp[controlPointID].TEXCOORD2;
        output.TEXCOORD3 = input.cp[controlPointID].TEXCOORD3;
        output.COLOR0 = input.cp[controlPointID].COLOR0;
    }
    threadgroup_barrier(mem_flags::mem_threadgroup);
    if (!patchValid) {
        return;
    }
    float3 u_xlat0;
    float3 u_xlat1;
    float3 u_xlat2;
    float3 u_xlat3;
    float3 u_xlat4;
    float u_xlat12;
    float u_xlat13;
    // fork_phase2
    {
        u_xlat0.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[1].INTERNALTESSPOS0.yyy;
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[1].INTERNALTESSPOS0.xxx, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[1].INTERNALTESSPOS0.zzz, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[1].INTERNALTESSPOS0.www, u_xlat0.xyz);
        u_xlat1.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[2].INTERNALTESSPOS0.yyy;
        u_xlat1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[2].INTERNALTESSPOS0.xxx, u_xlat1.xyz);
        u_xlat1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[2].INTERNALTESSPOS0.zzz, u_xlat1.xyz);
        u_xlat1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[2].INTERNALTESSPOS0.www, u_xlat1.xyz);
        u_xlat2.xyz = u_xlat0.xyz + u_xlat1.xyz;
        u_xlat2.xyz = fma(u_xlat2.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat12 = dot(u_xlat2.xyz, u_xlat2.xyz);
        u_xlat12 = sqrt(u_xlat12);
        u_xlat12 = u_xlat12 * VGlobals._EdgeLength;
        u_xlat2.xyz = u_xlat0.xyz + (-u_xlat1.xyz);
        u_xlat13 = dot(u_xlat2.xyz, u_xlat2.xyz);
        u_xlat13 = sqrt(u_xlat13);
        u_xlat13 = u_xlat13 * VGlobals._ScreenParams.y;
        u_xlat12 = u_xlat13 / u_xlat12;
        tessFactor.edgeTessellationFactor[0] = max(u_xlat12, 1.0);
        u_xlat2.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[0].INTERNALTESSPOS0.yyy;
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[0].INTERNALTESSPOS0.xxx, u_xlat2.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[0].INTERNALTESSPOS0.zzz, u_xlat2.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[0].INTERNALTESSPOS0.www, u_xlat2.xyz);
        u_xlat3.xyz = u_xlat1.xyz + u_xlat2.xyz;
        u_xlat1.xyz = u_xlat1.xyz + (-u_xlat2.xyz);
        u_xlat12 = dot(u_xlat1.xyz, u_xlat1.xyz);
        u_xlat12 = sqrt(u_xlat12);
        u_xlat12 = u_xlat12 * VGlobals._ScreenParams.y;
        u_xlat1.xyz = fma(u_xlat3.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat1.x = dot(u_xlat1.xyz, u_xlat1.xyz);
        u_xlat1.x = sqrt(u_xlat1.x);
        u_xlat1.x = u_xlat1.x * VGlobals._EdgeLength;
        u_xlat12 = u_xlat12 / u_xlat1.x;
        tessFactor.edgeTessellationFactor[1] = max(u_xlat12, 1.0);
        u_xlat1.xyz = u_xlat0.xyz + u_xlat2.xyz;
        u_xlat0.xyz = (-u_xlat0.xyz) + u_xlat2.xyz;
        u_xlat0.x = dot(u_xlat0.xyz, u_xlat0.xyz);
        u_xlat0.x = sqrt(u_xlat0.x);
        u_xlat0.x = u_xlat0.x * VGlobals._ScreenParams.y;
        u_xlat4.xyz = fma(u_xlat1.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat4.x = dot(u_xlat4.xyz, u_xlat4.xyz);
        u_xlat4.x = sqrt(u_xlat4.x);
        u_xlat4.x = u_xlat4.x * VGlobals._EdgeLength;
        u_xlat0.x = u_xlat0.x / u_xlat4.x;
        tessFactor.edgeTessellationFactor[2] = max(u_xlat0.x, 1.0);
    }
    // join_phase3
    {
        u_xlat0.x = tessFactor.edgeTessellationFactor[0] + tessFactor.edgeTessellationFactor[1];
        u_xlat0.x = u_xlat0.x + tessFactor.edgeTessellationFactor[2];
        tessFactor.insideTessellationFactor = u_xlat0.x * 0.333333343;
    }
    controlPoints[mtl_VertexID] = output;
    tessFactors[internalPatchID] = tessFactor;
}
// SHADER_STAGE_HULL_end
// SHADER_STAGE_DOMAIN_begin
struct Mtl_VertexInPostTess
{
    patch_control_point<Mtl_ControlPointIn> cp;
};
struct Mtl_VertexOutPostTess
{
    float4 mtl_Position [[ position ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float4 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float4 TEXCOORD3 [[ user(TEXCOORD3) ]];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    sampler sampler_Height [[ sampler (0) ]],
    texture2d<float, access::sample > _Height [[ texture(0) ]] ,
    float3 mtl_TessCoord [[ position_in_patch ]],
    uint patchID [[ patch_id ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    Mtl_VertexInPostTess input [[ stage_in ]])
{
#pragma clang diagnostic pop
    Mtl_VertexOutPostTess output;
    MTLTriangleTessellationFactorsHalf tessFactor;
    tessFactor = tessFactors[patchID];
    float4 u_xlat0;
    float4 u_xlat1;
    float4 u_xlat2;
    float3 u_xlat3;
    float3 u_xlat4;
    float2 u_xlat13;
    float u_xlat15;
    bool u_xlatb15;
    u_xlat0.xy = mtl_TessCoord.yy * input.cp[1].TEXCOORD2.xy;
    u_xlat0.xy = fma(input.cp[0].TEXCOORD2.xy, mtl_TessCoord.xx, u_xlat0.xy);
    u_xlat0.xy = fma(input.cp[2].TEXCOORD2.xy, mtl_TessCoord.zz, u_xlat0.xy);
    u_xlat0.xy = fma(u_xlat0.xy, VGlobals.unity_DynamicLightmapST.xy, VGlobals.unity_DynamicLightmapST.zw);
    u_xlat1.xy = mtl_TessCoord.yy * input.cp[1].TEXCOORD1.xy;
    u_xlat1.xy = fma(input.cp[0].TEXCOORD1.xy, mtl_TessCoord.xx, u_xlat1.xy);
    u_xlat1.xy = fma(input.cp[2].TEXCOORD1.xy, mtl_TessCoord.zz, u_xlat1.xy);
    u_xlat1.xy = fma(u_xlat1.xy, VGlobals.unity_LightmapST.xy, VGlobals.unity_LightmapST.zw);
    u_xlat2 = mtl_TessCoord.yyyy * input.cp[1].INTERNALTESSPOS0;
    u_xlat2 = fma(input.cp[0].INTERNALTESSPOS0, mtl_TessCoord.xxxx, u_xlat2);
    u_xlat2 = fma(input.cp[2].INTERNALTESSPOS0, mtl_TessCoord.zzzz, u_xlat2);
    u_xlat3.xy = mtl_TessCoord.yy * input.cp[1].TEXCOORD0.xy;
    u_xlat3.xy = fma(input.cp[0].TEXCOORD0.xy, mtl_TessCoord.xx, u_xlat3.xy);
    u_xlat3.xy = fma(input.cp[2].TEXCOORD0.xy, mtl_TessCoord.zz, u_xlat3.xy);
    u_xlat13.xy = u_xlat3.xy * float2(VGlobals._Tile);
    output.TEXCOORD0.xy = fma(u_xlat3.xy, VGlobals._texcoord_ST.xy, VGlobals._texcoord_ST.zw);
    u_xlat3.xyz = _Height.sample(sampler_Height, u_xlat13.xy, level(1.0)).xyz;
    u_xlat4.xyz = mtl_TessCoord.yyy * input.cp[1].NORMAL0.xyz;
    u_xlat4.xyz = fma(input.cp[0].NORMAL0.xyz, mtl_TessCoord.xxx, u_xlat4.xyz);
    u_xlat4.xyz = fma(input.cp[2].NORMAL0.xyz, mtl_TessCoord.zzz, u_xlat4.xyz);
    u_xlat3.xyz = u_xlat3.xyz * u_xlat4.xyz;
    u_xlat2.xyz = fma(u_xlat3.xyz, float3(VGlobals._HeightDisplacement), u_xlat2.xyz);
    u_xlatb15 = 0.0<u_xlat2.z;
    u_xlat1.z = u_xlatb15 ? 9.99999975e-05 : float(0.0);
    u_xlat1.xyz = (VGlobals.unity_MetaVertexControl.x) ? u_xlat1.xyz : u_xlat2.xyz;
    u_xlatb15 = 0.0<u_xlat1.z;
    u_xlat0.z = u_xlatb15 ? 9.99999975e-05 : float(0.0);
    u_xlat0.xyz = (VGlobals.unity_MetaVertexControl.y) ? u_xlat0.xyz : u_xlat1.xyz;
    u_xlat1 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat0.xxxx, u_xlat1);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat0.zzzz, u_xlat1);
    output.mtl_Position = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_MatrixVP[3];
    u_xlat0.xyz = u_xlat2.yyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz;
    u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, u_xlat2.xxx, u_xlat0.xyz);
    u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, u_xlat2.zzz, u_xlat0.xyz);
    u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, u_xlat2.www, u_xlat0.xyz);
    output.TEXCOORD1.w = u_xlat0.x;
    u_xlat1.y = dot(u_xlat4.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat1.z = dot(u_xlat4.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat1.x = dot(u_xlat4.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat0.x = dot(u_xlat1.xyz, u_xlat1.xyz);
    u_xlat0.x = rsqrt(u_xlat0.x);
    u_xlat1.xyz = u_xlat0.xxx * u_xlat1.xyz;
    output.TEXCOORD1.z = u_xlat1.y;
    u_xlat2 = mtl_TessCoord.yyyy * input.cp[1].TANGENT0;
    u_xlat2 = fma(input.cp[0].TANGENT0, mtl_TessCoord.xxxx, u_xlat2);
    u_xlat2 = fma(input.cp[2].TANGENT0, mtl_TessCoord.zzzz, u_xlat2);
    u_xlat3.xyz = u_xlat2.yyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].yzx;
    u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].yzx, u_xlat2.xxx, u_xlat3.xyz);
    u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].yzx, u_xlat2.zzz, u_xlat3.xyz);
    u_xlat0.x = u_xlat2.w * VGlobals.unity_WorldTransformParams.w;
    u_xlat15 = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat15 = rsqrt(u_xlat15);
    u_xlat2.xyz = float3(u_xlat15) * u_xlat2.xyz;
    u_xlat3.xyz = u_xlat1.xyz * u_xlat2.xyz;
    u_xlat3.xyz = fma(u_xlat1.zxy, u_xlat2.yzx, (-u_xlat3.xyz));
    u_xlat3.xyz = u_xlat0.xxx * u_xlat3.xyz;
    output.TEXCOORD1.y = u_xlat3.x;
    output.TEXCOORD1.x = u_xlat2.z;
    output.TEXCOORD2.w = u_xlat0.y;
    output.TEXCOORD3.w = u_xlat0.z;
    output.TEXCOORD2.x = u_xlat2.x;
    output.TEXCOORD3.x = u_xlat2.y;
    output.TEXCOORD2.z = u_xlat1.z;
    output.TEXCOORD3.z = u_xlat1.x;
    output.TEXCOORD2.y = u_xlat3.y;
    output.TEXCOORD3.y = u_xlat3.z;
    return output;
}
// SHADER_STAGE_DOMAIN_end
Refreshing native plugins compatible for Editor in 2.15 ms, found 2 plugins.
Preloading 0 native plugins for Editor in 0.00 ms.
Unloading 3375 Unused Serialized files (Serialized files now loaded: 0)
Unloading 20 unused Assets / (0.6 MB). Loaded Objects now: 3895.
Memory consumption went from 136.3 MB to 135.7 MB.
Total: 5.965957 ms (FindLiveObjects: 0.493276 ms CreateObjectMapping: 0.405913 ms MarkObjects: 4.548180 ms  DeleteObjects: 0.517373 ms)

AssetImportParameters requested are different than current active one (requested -> active):
  custom:video-decoder-ogg-theora: a1e56fd34408186e4bbccfd4996cb3dc -> 
  custom:container-muxer-webm: aa71ff27fc2769a1b78a27578f13a17b -> 
  custom:container-demuxer-webm: 4f35f7cbe854078d1ac9338744f61a02 -> 
  custom:video-encoder-webm-vp8: eb34c28f22e8b96e1ab97ce403110664 -> 
  custom:framework-osx-AVFoundation: b23960f63f64bdc6ff669e2cdcee2391 -> 
  custom:audio-encoder-webm-vorbis: bf7c407c2cedff20999df2af8eb42d56 -> 
  custom:container-demuxer-ogg: 62fdf1f143b41e24485cea50d1cbac27 -> 
  custom:video-decoder-webm-vp8: 9c59270c3fd7afecdb556c50c9e8de78 -> 
  custom:audio-decoder-ogg-vorbis: bf7c407c2cedff20999df2af8eb42d56 -> 
========================================================================
Received Prepare
Registering precompiled user dll's ...
Registered in 0.003452 seconds.
Begin MonoManager ReloadAssembly
Symbol file LoadedFromMemory doesn't match image /Users/kamilaamendolagine/Desktop/Staugen Raug v2 - Prefab - Map 1.01/Library/PackageCache/com.unity.visualscripting@1.7.8/Editor/VisualScripting.Core/Dependencies/YamlDotNet/Unity.VisualScripting.YamlDotNet.dll
Symbol file LoadedFromMemory doesn't match image /Users/kamilaamendolagine/Desktop/Staugen Raug v2 - Prefab - Map 1.01/Library/PackageCache/com.unity.visualscripting@1.7.8/Editor/VisualScripting.Core/Dependencies/DotNetZip/Unity.VisualScripting.IonicZip.dll
Native extension for OSXStandalone target not found
Native extension for WebGL target not found
Refreshing native plugins compatible for Editor in 0.88 ms, found 2 plugins.
Preloading 0 native plugins for Editor in 0.00 ms.
Mono: successfully reloaded assembly
- Completed reload, in  1.889 seconds
Domain Reload Profiling:
	ReloadAssembly (1890ms)
		BeginReloadAssembly (208ms)
			ExecutionOrderSort (0ms)
			DisableScriptedObjects (10ms)
			BackupInstance (0ms)
			ReleaseScriptingObjects (0ms)
			CreateAndSetChildDomain (92ms)
		EndReloadAssembly (1510ms)
			LoadAssemblies (91ms)
			RebuildTransferFunctionScriptingTraits (0ms)
			SetupTypeCache (508ms)
			ReleaseScriptCaches (2ms)
			RebuildScriptCaches (83ms)
			SetupLoadedEditorAssemblies (711ms)
				LogAssemblyErrors (0ms)
				InitializePlatformSupportModulesInManaged (21ms)
				SetLoadedEditorAssemblies (1ms)
				RefreshPlugins (1ms)
				BeforeProcessingInitializeOnLoad (109ms)
				ProcessInitializeOnLoadAttributes (522ms)
				ProcessInitializeOnLoadMethodAttributes (53ms)
				AfterProcessingInitializeOnLoad (3ms)
				EditorAssembliesLoaded (0ms)
			ExecutionOrderSort2 (0ms)
			AwakeInstancesAfterBackupRestoration (9ms)
Platform modules already initialized, skipping
Compilation succeeded with: 

program_source:299:53: warning: writable resources in non-void post-tessellation vertex function
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
                                                    ^
program_source:305:30: note: writable buffer defined here
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
                             ^
program_source:306:48: note: writable buffer defined here
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
                                               ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float4 TEXCOORD0 [[ attribute(3) ]] ;
    float4 TEXCOORD1 [[ attribute(4) ]] ;
    float4 TEXCOORD2 [[ attribute(5) ]] ;
    float4 TEXCOORD3 [[ attribute(6) ]] ;
    float4 COLOR0 [[ attribute(7) ]] ;
};
struct Mtl_VertexOut
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float4 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float4 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float4 TEXCOORD3 [[ user(TEXCOORD3) ]];
    float4 COLOR0 [[ user(COLOR0) ]];
};
static Mtl_VertexOut vertexFunction(
    Mtl_VertexIn input)
{
    Mtl_VertexOut output;
    output.INTERNALTESSPOS0 = input.POSITION0;
    output.TANGENT0 = input.TANGENT0;
    output.NORMAL0.xyz = input.NORMAL0.xyz;
    output.TEXCOORD0 = input.TEXCOORD0;
    output.TEXCOORD1 = input.TEXCOORD1;
    output.TEXCOORD2 = input.TEXCOORD2;
    output.TEXCOORD3 = input.TEXCOORD3;
    output.COLOR0 = input.COLOR0;
    return output;
}
// SHADER_STAGE_HULL_begin
struct Mtl_ControlPoint
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float4 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float4 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float4 TEXCOORD3 [[ user(TEXCOORD3) ]];
    float4 COLOR0 [[ user(COLOR0) ]];
};
struct Mtl_ControlPointIn
{
    float4 INTERNALTESSPOS0 [[ attribute(8) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float4 TEXCOORD0 [[ attribute(3) ]] ;
    float4 TEXCOORD1 [[ attribute(4) ]] ;
    float4 TEXCOORD2 [[ attribute(5) ]] ;
    float4 TEXCOORD3 [[ attribute(6) ]] ;
    float4 COLOR0 [[ attribute(7) ]] ;
};
struct Mtl_KernelPatchInfo
{
    uint numPatches;
    ushort numControlPointsPerPatch;
};
struct VGlobals_Type
{
    float4 _Time;
    float4 _SinTime;
    float4 _CosTime;
    float4 unity_DeltaTime;
    float3 _WorldSpaceCameraPos;
    float4 _ProjectionParams;
    float4 _ScreenParams;
    float4 _ZBufferParams;
    float4 unity_OrthoParams;
    float4 unity_CameraWorldClipPlanes[6];
    float4 hlslcc_mtx4x4unity_CameraProjection[4];
    float4 hlslcc_mtx4x4unity_CameraInvProjection[4];
    float4 hlslcc_mtx4x4unity_WorldToCamera[4];
    float4 hlslcc_mtx4x4unity_CameraToWorld[4];
    float4 _WorldSpaceLightPos0;
    float4 _LightPositionRange;
    float4 _LightProjectionParams;
    float4 unity_4LightPosX0;
    float4 unity_4LightPosY0;
    float4 unity_4LightPosZ0;
    float4 unity_4LightAtten0;
    float4 unity_LightColor[8];
    float4 unity_LightPosition[8];
    float4 unity_LightAtten[8];
    float4 unity_SpotDirection[8];
    float4 unity_SHAr;
    float4 unity_SHAg;
    float4 unity_SHAb;
    float4 unity_SHBr;
    float4 unity_SHBg;
    float4 unity_SHBb;
    float4 unity_SHC;
    float4 unity_OcclusionMaskSelector;
    float4 unity_ProbesOcclusion;
    float3 unity_LightColor0;
    float3 unity_LightColor1;
    float3 unity_LightColor2;
    float3 unity_LightColor3;
    float4 unity_ShadowSplitSpheres[4];
    float4 unity_ShadowSplitSqRadii;
    float4 unity_LightShadowBias;
    float4 _LightSplitsNear;
    float4 _LightSplitsFar;
    float4 hlslcc_mtx4x4unity_WorldToShadow[16];
    float4 _LightShadowData;
    float4 unity_ShadowFadeCenterAndType;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 unity_LODFade;
    float4 unity_WorldTransformParams;
    float4 unity_RenderingLayer;
    float4 hlslcc_mtx4x4glstate_matrix_transpose_modelview0[4];
    float4 glstate_lightmodel_ambient;
    float4 unity_AmbientSky;
    float4 unity_AmbientEquator;
    float4 unity_AmbientGround;
    float4 unity_IndirectSpecColor;
    float4 hlslcc_mtx4x4glstate_matrix_projection[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixInvV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    int unity_StereoEyeIndex;
    float4 unity_ShadowColor;
    float4 unity_FogColor;
    float4 unity_FogParams;
    float4 unity_LightmapST;
    float4 unity_DynamicLightmapST;
    float4 unity_SpecCube0_BoxMax;
    float4 unity_SpecCube0_BoxMin;
    float4 unity_SpecCube0_ProbePosition;
    float4 unity_SpecCube0_HDR;
    float4 unity_SpecCube1_BoxMax;
    float4 unity_SpecCube1_BoxMin;
    float4 unity_SpecCube1_ProbePosition;
    float4 unity_SpecCube1_HDR;
    float4 unity_ProbeVolumeParams;
    float4 hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[4];
    float3 unity_ProbeVolumeSizeInv;
    float3 unity_ProbeVolumeMin;
    float4 unity_Lightmap_HDR;
    float4 unity_DynamicLightmap_HDR;
    float4 _LightColor0;
    float4 _SpecColor;
    float _Tile;
    float _HeightDisplacement;
    float _NormalScale;
    float4 _ColorTint;
    float _MetallicStrength;
    float _SmoothnessStrength;
    float _EdgeLength;
    float4 _texcoord_ST;
};
struct Mtl_HullIn
{
    Mtl_VertexOut cp[3];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
kernel void patchKernel(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn vertexInput [[ stage_in ]],
    uint2 tID [[ thread_position_in_grid ]],
    ushort2 groupID [[ threadgroup_position_in_grid ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    constant Mtl_KernelPatchInfo &patchInfo [[ buffer(3) ]])
{
#pragma clang diagnostic pop
    Mtl_ControlPoint output;
    const uint numPatchesInThreadGroup = 10;
    const uint patchID = (tID.x / patchInfo.numControlPointsPerPatch);
    const bool patchValid = (patchID < patchInfo.numPatches);
    const uint mtl_BaseInstance = 0;
    const uint mtl_InstanceID = groupID.y - mtl_BaseInstance;
    const uint internalPatchID = mtl_InstanceID * patchInfo.numPatches + patchID;
    const uint patchIDInThreadGroup = (patchID % numPatchesInThreadGroup);
    const uint controlPointID = (tID.x % patchInfo.numControlPointsPerPatch);
    const uint mtl_BaseVertex = 0;
    const uint mtl_VertexID = ((mtl_InstanceID * (patchInfo.numControlPointsPerPatch * patchInfo.numPatches)) + tID.x) - mtl_BaseVertex;
    threadgroup Mtl_HullIn inputGroup[numPatchesInThreadGroup];
    threadgroup Mtl_HullIn &input = inputGroup[patchIDInThreadGroup];
    MTLTriangleTessellationFactorsHalf tessFactor;
    if (patchValid) {
        input.cp[controlPointID] = vertexFunction(vertexInput);
        output.INTERNALTESSPOS0 = input.cp[controlPointID].INTERNALTESSPOS0;
        output.TANGENT0 = input.cp[controlPointID].TANGENT0;
        output.NORMAL0 = input.cp[controlPointID].NORMAL0;
        output.TEXCOORD0 = input.cp[controlPointID].TEXCOORD0;
        output.TEXCOORD1 = input.cp[controlPointID].TEXCOORD1;
        output.TEXCOORD2 = input.cp[controlPointID].TEXCOORD2;
        output.TEXCOORD3 = input.cp[controlPointID].TEXCOORD3;
        output.COLOR0 = input.cp[controlPointID].COLOR0;
    }
    threadgroup_barrier(mem_flags::mem_threadgroup);
    if (!patchValid) {
        return;
    }
    float3 u_xlat0;
    float3 u_xlat1;
    float3 u_xlat2;
    float3 u_xlat3;
    float3 u_xlat4;
    float u_xlat12;
    float u_xlat13;
    // fork_phase2
    {
        u_xlat0.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[1].INTERNALTESSPOS0.yyy;
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[1].INTERNALTESSPOS0.xxx, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[1].INTERNALTESSPOS0.zzz, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[1].INTERNALTESSPOS0.www, u_xlat0.xyz);
        u_xlat1.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[2].INTERNALTESSPOS0.yyy;
        u_xlat1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[2].INTERNALTESSPOS0.xxx, u_xlat1.xyz);
        u_xlat1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[2].INTERNALTESSPOS0.zzz, u_xlat1.xyz);
        u_xlat1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[2].INTERNALTESSPOS0.www, u_xlat1.xyz);
        u_xlat2.xyz = u_xlat0.xyz + u_xlat1.xyz;
        u_xlat2.xyz = fma(u_xlat2.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat12 = dot(u_xlat2.xyz, u_xlat2.xyz);
        u_xlat12 = sqrt(u_xlat12);
        u_xlat12 = u_xlat12 * VGlobals._EdgeLength;
        u_xlat2.xyz = u_xlat0.xyz + (-u_xlat1.xyz);
        u_xlat13 = dot(u_xlat2.xyz, u_xlat2.xyz);
        u_xlat13 = sqrt(u_xlat13);
        u_xlat13 = u_xlat13 * VGlobals._ScreenParams.y;
        u_xlat12 = u_xlat13 / u_xlat12;
        tessFactor.edgeTessellationFactor[0] = max(u_xlat12, 1.0);
        u_xlat2.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[0].INTERNALTESSPOS0.yyy;
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[0].INTERNALTESSPOS0.xxx, u_xlat2.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[0].INTERNALTESSPOS0.zzz, u_xlat2.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[0].INTERNALTESSPOS0.www, u_xlat2.xyz);
        u_xlat3.xyz = u_xlat1.xyz + u_xlat2.xyz;
        u_xlat1.xyz = u_xlat1.xyz + (-u_xlat2.xyz);
        u_xlat12 = dot(u_xlat1.xyz, u_xlat1.xyz);
        u_xlat12 = sqrt(u_xlat12);
        u_xlat12 = u_xlat12 * VGlobals._ScreenParams.y;
        u_xlat1.xyz = fma(u_xlat3.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat1.x = dot(u_xlat1.xyz, u_xlat1.xyz);
        u_xlat1.x = sqrt(u_xlat1.x);
        u_xlat1.x = u_xlat1.x * VGlobals._EdgeLength;
        u_xlat12 = u_xlat12 / u_xlat1.x;
        tessFactor.edgeTessellationFactor[1] = max(u_xlat12, 1.0);
        u_xlat1.xyz = u_xlat0.xyz + u_xlat2.xyz;
        u_xlat0.xyz = (-u_xlat0.xyz) + u_xlat2.xyz;
        u_xlat0.x = dot(u_xlat0.xyz, u_xlat0.xyz);
        u_xlat0.x = sqrt(u_xlat0.x);
        u_xlat0.x = u_xlat0.x * VGlobals._ScreenParams.y;
        u_xlat4.xyz = fma(u_xlat1.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat4.x = dot(u_xlat4.xyz, u_xlat4.xyz);
        u_xlat4.x = sqrt(u_xlat4.x);
        u_xlat4.x = u_xlat4.x * VGlobals._EdgeLength;
        u_xlat0.x = u_xlat0.x / u_xlat4.x;
        tessFactor.edgeTessellationFactor[2] = max(u_xlat0.x, 1.0);
    }
    // join_phase3
    {
        u_xlat0.x = tessFactor.edgeTessellationFactor[0] + tessFactor.edgeTessellationFactor[1];
        u_xlat0.x = u_xlat0.x + tessFactor.edgeTessellationFactor[2];
        tessFactor.insideTessellationFactor = u_xlat0.x * 0.333333343;
    }
    controlPoints[mtl_VertexID] = output;
    tessFactors[internalPatchID] = tessFactor;
}
// SHADER_STAGE_HULL_end
// SHADER_STAGE_DOMAIN_begin
struct Mtl_VertexInPostTess
{
    patch_control_point<Mtl_ControlPointIn> cp;
};
struct Mtl_VertexOutPostTess
{
    float4 mtl_Position [[ position ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float4 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float4 TEXCOORD3 [[ user(TEXCOORD3) ]];
    float4 TEXCOORD6 [[ user(TEXCOORD6) ]];
    float4 TEXCOORD7 [[ user(TEXCOORD7) ]];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    sampler sampler_Height [[ sampler (0) ]],
    texture2d<float, access::sample > _Height [[ texture(0) ]] ,
    float3 mtl_TessCoord [[ position_in_patch ]],
    uint patchID [[ patch_id ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    Mtl_VertexInPostTess input [[ stage_in ]])
{
#pragma clang diagnostic pop
    Mtl_VertexOutPostTess output;
    MTLTriangleTessellationFactorsHalf tessFactor;
    tessFactor = tessFactors[patchID];
    float4 u_xlat0;
    float4 u_xlat1;
    float4 u_xlat2;
    float4 u_xlat3;
    float2 u_xlat9;
    float u_xlat12;
    float u_xlat13;
    u_xlat0 = mtl_TessCoord.yyyy * input.cp[1].INTERNALTESSPOS0;
    u_xlat0 = fma(input.cp[0].INTERNALTESSPOS0, mtl_TessCoord.xxxx, u_xlat0);
    u_xlat0 = fma(input.cp[2].INTERNALTESSPOS0, mtl_TessCoord.zzzz, u_xlat0);
    u_xlat1.xy = mtl_TessCoord.yy * input.cp[1].TEXCOORD0.xy;
    u_xlat1.xy = fma(input.cp[0].TEXCOORD0.xy, mtl_TessCoord.xx, u_xlat1.xy);
    u_xlat1.xy = fma(input.cp[2].TEXCOORD0.xy, mtl_TessCoord.zz, u_xlat1.xy);
    u_xlat9.xy = u_xlat1.xy * float2(VGlobals._Tile);
    output.TEXCOORD0.xy = fma(u_xlat1.xy, VGlobals._texcoord_ST.xy, VGlobals._texcoord_ST.zw);
    u_xlat1.xyz = _Height.sample(sampler_Height, u_xlat9.xy, level(1.0)).xyz;
    u_xlat2.xyz = mtl_TessCoord.yyy * input.cp[1].NORMAL0.xyz;
    u_xlat2.xyz = fma(input.cp[0].NORMAL0.xyz, mtl_TessCoord.xxx, u_xlat2.xyz);
    u_xlat2.xyz = fma(input.cp[2].NORMAL0.xyz, mtl_TessCoord.zzz, u_xlat2.xyz);
    u_xlat1.xyz = u_xlat1.xyz * u_xlat2.xyz;
    u_xlat0.xyz = fma(u_xlat1.xyz, float3(VGlobals._HeightDisplacement), u_xlat0.xyz);
    u_xlat1 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], u_xlat0.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], u_xlat0.zzzz, u_xlat1);
    u_xlat3 = u_xlat1 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, u_xlat0.www, u_xlat1.xyz);
    u_xlat1 = u_xlat3.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat3.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat3.zzzz, u_xlat1);
    output.mtl_Position = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat3.wwww, u_xlat1);
    u_xlat1.y = dot(u_xlat2.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat1.z = dot(u_xlat2.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat1.x = dot(u_xlat2.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat12 = dot(u_xlat1.xyz, u_xlat1.xyz);
    u_xlat12 = rsqrt(u_xlat12);
    u_xlat1.xyz = float3(u_xlat12) * u_xlat1.xyz;
    output.TEXCOORD1.z = u_xlat1.y;
    u_xlat2 = mtl_TessCoord.yyyy * input.cp[1].TANGENT0;
    u_xlat2 = fma(input.cp[0].TANGENT0, mtl_TessCoord.xxxx, u_xlat2);
    u_xlat2 = fma(input.cp[2].TANGENT0, mtl_TessCoord.zzzz, u_xlat2);
    u_xlat3.xyz = u_xlat2.yyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].yzx;
    u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].yzx, u_xlat2.xxx, u_xlat3.xyz);
    u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].yzx, u_xlat2.zzz, u_xlat3.xyz);
    u_xlat12 = u_xlat2.w * VGlobals.unity_WorldTransformParams.w;
    u_xlat13 = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat13 = rsqrt(u_xlat13);
    u_xlat2.xyz = float3(u_xlat13) * u_xlat2.xyz;
    u_xlat3.xyz = u_xlat1.xyz * u_xlat2.xyz;
    u_xlat3.xyz = fma(u_xlat1.zxy, u_xlat2.yzx, (-u_xlat3.xyz));
    u_xlat3.xyz = float3(u_xlat12) * u_xlat3.xyz;
    output.TEXCOORD1.y = u_xlat3.x;
    output.TEXCOORD1.w = u_xlat0.x;
    output.TEXCOORD1.x = u_xlat2.z;
    output.TEXCOORD2.w = u_xlat0.y;
    output.TEXCOORD3.w = u_xlat0.z;
    output.TEXCOORD2.x = u_xlat2.x;
    output.TEXCOORD3.x = u_xlat2.y;
    output.TEXCOORD2.z = u_xlat1.z;
    output.TEXCOORD3.z = u_xlat1.x;
    output.TEXCOORD2.y = u_xlat3.y;
    output.TEXCOORD3.y = u_xlat3.z;
    output.TEXCOORD6 = float4(0.0, 0.0, 0.0, 0.0);
    output.TEXCOORD7 = float4(0.0, 0.0, 0.0, 0.0);
    return output;
}
// SHADER_STAGE_DOMAIN_end
Compilation succeeded with: 

program_source:301:53: warning: writable resources in non-void post-tessellation vertex function
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
                                                    ^
program_source:307:30: note: writable buffer defined here
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
                             ^
program_source:308:48: note: writable buffer defined here
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
                                               ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float4 TEXCOORD0 [[ attribute(3) ]] ;
    float4 TEXCOORD1 [[ attribute(4) ]] ;
    float4 TEXCOORD2 [[ attribute(5) ]] ;
    float4 TEXCOORD3 [[ attribute(6) ]] ;
    float4 COLOR0 [[ attribute(7) ]] ;
};
struct Mtl_VertexOut
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float4 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float4 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float4 TEXCOORD3 [[ user(TEXCOORD3) ]];
    float4 COLOR0 [[ user(COLOR0) ]];
};
static Mtl_VertexOut vertexFunction(
    Mtl_VertexIn input)
{
    Mtl_VertexOut output;
    output.INTERNALTESSPOS0 = input.POSITION0;
    output.TANGENT0 = input.TANGENT0;
    output.NORMAL0.xyz = input.NORMAL0.xyz;
    output.TEXCOORD0 = input.TEXCOORD0;
    output.TEXCOORD1 = input.TEXCOORD1;
    output.TEXCOORD2 = input.TEXCOORD2;
    output.TEXCOORD3 = input.TEXCOORD3;
    output.COLOR0 = input.COLOR0;
    return output;
}
// SHADER_STAGE_HULL_begin
struct Mtl_ControlPoint
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float4 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float4 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float4 TEXCOORD3 [[ user(TEXCOORD3) ]];
    float4 COLOR0 [[ user(COLOR0) ]];
};
struct Mtl_ControlPointIn
{
    float4 INTERNALTESSPOS0 [[ attribute(8) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float4 TEXCOORD0 [[ attribute(3) ]] ;
    float4 TEXCOORD1 [[ attribute(4) ]] ;
    float4 TEXCOORD2 [[ attribute(5) ]] ;
    float4 TEXCOORD3 [[ attribute(6) ]] ;
    float4 COLOR0 [[ attribute(7) ]] ;
};
struct Mtl_KernelPatchInfo
{
    uint numPatches;
    ushort numControlPointsPerPatch;
};
struct VGlobals_Type
{
    float4 _Time;
    float4 _SinTime;
    float4 _CosTime;
    float4 unity_DeltaTime;
    float3 _WorldSpaceCameraPos;
    float4 _ProjectionParams;
    float4 _ScreenParams;
    float4 _ZBufferParams;
    float4 unity_OrthoParams;
    float4 unity_CameraWorldClipPlanes[6];
    float4 hlslcc_mtx4x4unity_CameraProjection[4];
    float4 hlslcc_mtx4x4unity_CameraInvProjection[4];
    float4 hlslcc_mtx4x4unity_WorldToCamera[4];
    float4 hlslcc_mtx4x4unity_CameraToWorld[4];
    float4 _WorldSpaceLightPos0;
    float4 _LightPositionRange;
    float4 _LightProjectionParams;
    float4 unity_4LightPosX0;
    float4 unity_4LightPosY0;
    float4 unity_4LightPosZ0;
    float4 unity_4LightAtten0;
    float4 unity_LightColor[8];
    float4 unity_LightPosition[8];
    float4 unity_LightAtten[8];
    float4 unity_SpotDirection[8];
    float4 unity_SHAr;
    float4 unity_SHAg;
    float4 unity_SHAb;
    float4 unity_SHBr;
    float4 unity_SHBg;
    float4 unity_SHBb;
    float4 unity_SHC;
    float4 unity_OcclusionMaskSelector;
    float4 unity_ProbesOcclusion;
    float3 unity_LightColor0;
    float3 unity_LightColor1;
    float3 unity_LightColor2;
    float3 unity_LightColor3;
    float4 unity_ShadowSplitSpheres[4];
    float4 unity_ShadowSplitSqRadii;
    float4 unity_LightShadowBias;
    float4 _LightSplitsNear;
    float4 _LightSplitsFar;
    float4 hlslcc_mtx4x4unity_WorldToShadow[16];
    float4 _LightShadowData;
    float4 unity_ShadowFadeCenterAndType;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 unity_LODFade;
    float4 unity_WorldTransformParams;
    float4 unity_RenderingLayer;
    float4 hlslcc_mtx4x4glstate_matrix_transpose_modelview0[4];
    float4 glstate_lightmodel_ambient;
    float4 unity_AmbientSky;
    float4 unity_AmbientEquator;
    float4 unity_AmbientGround;
    float4 unity_IndirectSpecColor;
    float4 hlslcc_mtx4x4glstate_matrix_projection[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixInvV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    int unity_StereoEyeIndex;
    float4 unity_ShadowColor;
    float4 unity_FogColor;
    float4 unity_FogParams;
    float4 unity_LightmapST;
    float4 unity_DynamicLightmapST;
    float4 unity_SpecCube0_BoxMax;
    float4 unity_SpecCube0_BoxMin;
    float4 unity_SpecCube0_ProbePosition;
    float4 unity_SpecCube0_HDR;
    float4 unity_SpecCube1_BoxMax;
    float4 unity_SpecCube1_BoxMin;
    float4 unity_SpecCube1_ProbePosition;
    float4 unity_SpecCube1_HDR;
    float4 unity_ProbeVolumeParams;
    float4 hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[4];
    float3 unity_ProbeVolumeSizeInv;
    float3 unity_ProbeVolumeMin;
    float4 unity_Lightmap_HDR;
    float4 unity_DynamicLightmap_HDR;
    float4 _LightColor0;
    float4 _SpecColor;
    float4 hlslcc_mtx4x4unity_WorldToLight[4];
    float _Tile;
    float _HeightDisplacement;
    float _NormalScale;
    float4 _ColorTint;
    float _MetallicStrength;
    float _SmoothnessStrength;
    float _EdgeLength;
    float4 _texcoord_ST;
};
struct Mtl_HullIn
{
    Mtl_VertexOut cp[3];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
kernel void patchKernel(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn vertexInput [[ stage_in ]],
    uint2 tID [[ thread_position_in_grid ]],
    ushort2 groupID [[ threadgroup_position_in_grid ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    constant Mtl_KernelPatchInfo &patchInfo [[ buffer(3) ]])
{
#pragma clang diagnostic pop
    Mtl_ControlPoint output;
    const uint numPatchesInThreadGroup = 10;
    const uint patchID = (tID.x / patchInfo.numControlPointsPerPatch);
    const bool patchValid = (patchID < patchInfo.numPatches);
    const uint mtl_BaseInstance = 0;
    const uint mtl_InstanceID = groupID.y - mtl_BaseInstance;
    const uint internalPatchID = mtl_InstanceID * patchInfo.numPatches + patchID;
    const uint patchIDInThreadGroup = (patchID % numPatchesInThreadGroup);
    const uint controlPointID = (tID.x % patchInfo.numControlPointsPerPatch);
    const uint mtl_BaseVertex = 0;
    const uint mtl_VertexID = ((mtl_InstanceID * (patchInfo.numControlPointsPerPatch * patchInfo.numPatches)) + tID.x) - mtl_BaseVertex;
    threadgroup Mtl_HullIn inputGroup[numPatchesInThreadGroup];
    threadgroup Mtl_HullIn &input = inputGroup[patchIDInThreadGroup];
    MTLTriangleTessellationFactorsHalf tessFactor;
    if (patchValid) {
        input.cp[controlPointID] = vertexFunction(vertexInput);
        output.INTERNALTESSPOS0 = input.cp[controlPointID].INTERNALTESSPOS0;
        output.TANGENT0 = input.cp[controlPointID].TANGENT0;
        output.NORMAL0 = input.cp[controlPointID].NORMAL0;
        output.TEXCOORD0 = input.cp[controlPointID].TEXCOORD0;
        output.TEXCOORD1 = input.cp[controlPointID].TEXCOORD1;
        output.TEXCOORD2 = input.cp[controlPointID].TEXCOORD2;
        output.TEXCOORD3 = input.cp[controlPointID].TEXCOORD3;
        output.COLOR0 = input.cp[controlPointID].COLOR0;
    }
    threadgroup_barrier(mem_flags::mem_threadgroup);
    if (!patchValid) {
        return;
    }
    float3 u_xlat0;
    float3 u_xlat1;
    float3 u_xlat2;
    float3 u_xlat3;
    float3 u_xlat4;
    float u_xlat12;
    float u_xlat13;
    // fork_phase2
    {
        u_xlat0.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[1].INTERNALTESSPOS0.yyy;
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[1].INTERNALTESSPOS0.xxx, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[1].INTERNALTESSPOS0.zzz, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[1].INTERNALTESSPOS0.www, u_xlat0.xyz);
        u_xlat1.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[2].INTERNALTESSPOS0.yyy;
        u_xlat1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[2].INTERNALTESSPOS0.xxx, u_xlat1.xyz);
        u_xlat1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[2].INTERNALTESSPOS0.zzz, u_xlat1.xyz);
        u_xlat1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[2].INTERNALTESSPOS0.www, u_xlat1.xyz);
        u_xlat2.xyz = u_xlat0.xyz + u_xlat1.xyz;
        u_xlat2.xyz = fma(u_xlat2.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat12 = dot(u_xlat2.xyz, u_xlat2.xyz);
        u_xlat12 = sqrt(u_xlat12);
        u_xlat12 = u_xlat12 * VGlobals._EdgeLength;
        u_xlat2.xyz = u_xlat0.xyz + (-u_xlat1.xyz);
        u_xlat13 = dot(u_xlat2.xyz, u_xlat2.xyz);
        u_xlat13 = sqrt(u_xlat13);
        u_xlat13 = u_xlat13 * VGlobals._ScreenParams.y;
        u_xlat12 = u_xlat13 / u_xlat12;
        tessFactor.edgeTessellationFactor[0] = max(u_xlat12, 1.0);
        u_xlat2.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[0].INTERNALTESSPOS0.yyy;
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[0].INTERNALTESSPOS0.xxx, u_xlat2.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[0].INTERNALTESSPOS0.zzz, u_xlat2.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[0].INTERNALTESSPOS0.www, u_xlat2.xyz);
        u_xlat3.xyz = u_xlat1.xyz + u_xlat2.xyz;
        u_xlat1.xyz = u_xlat1.xyz + (-u_xlat2.xyz);
        u_xlat12 = dot(u_xlat1.xyz, u_xlat1.xyz);
        u_xlat12 = sqrt(u_xlat12);
        u_xlat12 = u_xlat12 * VGlobals._ScreenParams.y;
        u_xlat1.xyz = fma(u_xlat3.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat1.x = dot(u_xlat1.xyz, u_xlat1.xyz);
        u_xlat1.x = sqrt(u_xlat1.x);
        u_xlat1.x = u_xlat1.x * VGlobals._EdgeLength;
        u_xlat12 = u_xlat12 / u_xlat1.x;
        tessFactor.edgeTessellationFactor[1] = max(u_xlat12, 1.0);
        u_xlat1.xyz = u_xlat0.xyz + u_xlat2.xyz;
        u_xlat0.xyz = (-u_xlat0.xyz) + u_xlat2.xyz;
        u_xlat0.x = dot(u_xlat0.xyz, u_xlat0.xyz);
        u_xlat0.x = sqrt(u_xlat0.x);
        u_xlat0.x = u_xlat0.x * VGlobals._ScreenParams.y;
        u_xlat4.xyz = fma(u_xlat1.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat4.x = dot(u_xlat4.xyz, u_xlat4.xyz);
        u_xlat4.x = sqrt(u_xlat4.x);
        u_xlat4.x = u_xlat4.x * VGlobals._EdgeLength;
        u_xlat0.x = u_xlat0.x / u_xlat4.x;
        tessFactor.edgeTessellationFactor[2] = max(u_xlat0.x, 1.0);
    }
    // join_phase3
    {
        u_xlat0.x = tessFactor.edgeTessellationFactor[0] + tessFactor.edgeTessellationFactor[1];
        u_xlat0.x = u_xlat0.x + tessFactor.edgeTessellationFactor[2];
        tessFactor.insideTessellationFactor = u_xlat0.x * 0.333333343;
    }
    controlPoints[mtl_VertexID] = output;
    tessFactors[internalPatchID] = tessFactor;
}
// SHADER_STAGE_HULL_end
// SHADER_STAGE_DOMAIN_begin
struct Mtl_VertexInPostTess
{
    patch_control_point<Mtl_ControlPointIn> cp;
};
struct Mtl_VertexOutPostTess
{
    float4 mtl_Position [[ position ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float3 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float3 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float3 TEXCOORD3 [[ user(TEXCOORD3) ]];
    float3 TEXCOORD4 [[ user(TEXCOORD4) ]];
    float3 TEXCOORD5 [[ user(TEXCOORD5) ]];
    float4 TEXCOORD6 [[ user(TEXCOORD6) ]];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    sampler sampler_Height [[ sampler (0) ]],
    texture2d<float, access::sample > _Height [[ texture(0) ]] ,
    float3 mtl_TessCoord [[ position_in_patch ]],
    uint patchID [[ patch_id ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    Mtl_VertexInPostTess input [[ stage_in ]])
{
#pragma clang diagnostic pop
    Mtl_VertexOutPostTess output;
    MTLTriangleTessellationFactorsHalf tessFactor;
    tessFactor = tessFactors[patchID];
    float4 u_xlat0;
    float3 u_xlat1;
    float4 u_xlat2;
    float4 u_xlat3;
    float4 u_xlat4;
    float2 u_xlat10;
    float u_xlat16;
    u_xlat0.xy = mtl_TessCoord.yy * input.cp[1].TEXCOORD0.xy;
    u_xlat0.xy = fma(input.cp[0].TEXCOORD0.xy, mtl_TessCoord.xx, u_xlat0.xy);
    u_xlat0.xy = fma(input.cp[2].TEXCOORD0.xy, mtl_TessCoord.zz, u_xlat0.xy);
    u_xlat10.xy = u_xlat0.xy * float2(VGlobals._Tile);
    output.TEXCOORD0.xy = fma(u_xlat0.xy, VGlobals._texcoord_ST.xy, VGlobals._texcoord_ST.zw);
    u_xlat0.xyz = _Height.sample(sampler_Height, u_xlat10.xy, level(1.0)).xyz;
    u_xlat1.xyz = mtl_TessCoord.yyy * input.cp[1].NORMAL0.xyz;
    u_xlat1.xyz = fma(input.cp[0].NORMAL0.xyz, mtl_TessCoord.xxx, u_xlat1.xyz);
    u_xlat1.xyz = fma(input.cp[2].NORMAL0.xyz, mtl_TessCoord.zzz, u_xlat1.xyz);
    u_xlat0.xyz = u_xlat0.xyz * u_xlat1.xyz;
    u_xlat2 = mtl_TessCoord.yyyy * input.cp[1].INTERNALTESSPOS0;
    u_xlat2 = fma(input.cp[0].INTERNALTESSPOS0, mtl_TessCoord.xxxx, u_xlat2);
    u_xlat2 = fma(input.cp[2].INTERNALTESSPOS0, mtl_TessCoord.zzzz, u_xlat2);
    u_xlat0.xyz = fma(u_xlat0.xyz, float3(VGlobals._HeightDisplacement), u_xlat2.xyz);
    u_xlat3 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], u_xlat0.xxxx, u_xlat3);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], u_xlat0.zzzz, u_xlat3);
    u_xlat3 = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat4 = u_xlat3.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat4 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat3.xxxx, u_xlat4);
    u_xlat4 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat3.zzzz, u_xlat4);
    output.mtl_Position = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat3.wwww, u_xlat4);
    u_xlat2.y = dot(u_xlat1.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat2.z = dot(u_xlat1.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat2.x = dot(u_xlat1.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat1.x = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat1.x = rsqrt(u_xlat1.x);
    u_xlat1.xyz = u_xlat1.xxx * u_xlat2.xyz;
    output.TEXCOORD1.z = u_xlat1.y;
    u_xlat3 = mtl_TessCoord.yyyy * input.cp[1].TANGENT0;
    u_xlat3 = fma(input.cp[0].TANGENT0, mtl_TessCoord.xxxx, u_xlat3);
    u_xlat3 = fma(input.cp[2].TANGENT0, mtl_TessCoord.zzzz, u_xlat3);
    u_xlat2.xyz = u_xlat3.yyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].yzx;
    u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].yzx, u_xlat3.xxx, u_xlat2.xyz);
    u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].yzx, u_xlat3.zzz, u_xlat2.xyz);
    u_xlat16 = u_xlat3.w * VGlobals.unity_WorldTransformParams.w;
    u_xlat3.x = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat3.x = rsqrt(u_xlat3.x);
    u_xlat2.xyz = u_xlat2.xyz * u_xlat3.xxx;
    u_xlat3.xyz = u_xlat1.xyz * u_xlat2.xyz;
    u_xlat3.xyz = fma(u_xlat1.zxy, u_xlat2.yzx, (-u_xlat3.xyz));
    u_xlat3.xyz = float3(u_xlat16) * u_xlat3.xyz;
    output.TEXCOORD1.y = u_xlat3.x;
    output.TEXCOORD1.x = u_xlat2.z;
    output.TEXCOORD2.x = u_xlat2.x;
    output.TEXCOORD3.x = u_xlat2.y;
    output.TEXCOORD2.z = u_xlat1.z;
    output.TEXCOORD3.z = u_xlat1.x;
    output.TEXCOORD2.y = u_xlat3.y;
    output.TEXCOORD3.y = u_xlat3.z;
    output.TEXCOORD4.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, u_xlat2.www, u_xlat0.xyz);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3], u_xlat2.wwww, u_xlat0);
    u_xlat1.xyz = u_xlat0.yyy * VGlobals.hlslcc_mtx4x4unity_WorldToLight[1].xyz;
    u_xlat1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_WorldToLight[0].xyz, u_xlat0.xxx, u_xlat1.xyz);
    u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_WorldToLight[2].xyz, u_xlat0.zzz, u_xlat1.xyz);
    output.TEXCOORD5.xyz = fma(VGlobals.hlslcc_mtx4x4unity_WorldToLight[3].xyz, u_xlat0.www, u_xlat0.xyz);
    output.TEXCOORD6 = float4(0.0, 0.0, 0.0, 0.0);
    return output;
}
// SHADER_STAGE_DOMAIN_end
Compilation succeeded with: 

program_source:293:53: warning: writable resources in non-void post-tessellation vertex function
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
                                                    ^
program_source:299:30: note: writable buffer defined here
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
                             ^
program_source:300:48: note: writable buffer defined here
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
                                               ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float4 TEXCOORD0 [[ attribute(3) ]] ;
    float4 TEXCOORD1 [[ attribute(4) ]] ;
    float4 TEXCOORD2 [[ attribute(5) ]] ;
    float4 TEXCOORD3 [[ attribute(6) ]] ;
    float4 COLOR0 [[ attribute(7) ]] ;
};
struct Mtl_VertexOut
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float4 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float4 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float4 TEXCOORD3 [[ user(TEXCOORD3) ]];
    float4 COLOR0 [[ user(COLOR0) ]];
};
static Mtl_VertexOut vertexFunction(
    Mtl_VertexIn input)
{
    Mtl_VertexOut output;
    output.INTERNALTESSPOS0 = input.POSITION0;
    output.TANGENT0 = input.TANGENT0;
    output.NORMAL0.xyz = input.NORMAL0.xyz;
    output.TEXCOORD0 = input.TEXCOORD0;
    output.TEXCOORD1 = input.TEXCOORD1;
    output.TEXCOORD2 = input.TEXCOORD2;
    output.TEXCOORD3 = input.TEXCOORD3;
    output.COLOR0 = input.COLOR0;
    return output;
}
// SHADER_STAGE_HULL_begin
struct Mtl_ControlPoint
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float4 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float4 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float4 TEXCOORD3 [[ user(TEXCOORD3) ]];
    float4 COLOR0 [[ user(COLOR0) ]];
};
struct Mtl_ControlPointIn
{
    float4 INTERNALTESSPOS0 [[ attribute(8) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float4 TEXCOORD0 [[ attribute(3) ]] ;
    float4 TEXCOORD1 [[ attribute(4) ]] ;
    float4 TEXCOORD2 [[ attribute(5) ]] ;
    float4 TEXCOORD3 [[ attribute(6) ]] ;
    float4 COLOR0 [[ attribute(7) ]] ;
};
struct Mtl_KernelPatchInfo
{
    uint numPatches;
    ushort numControlPointsPerPatch;
};
struct VGlobals_Type
{
    float4 _Time;
    float4 _SinTime;
    float4 _CosTime;
    float4 unity_DeltaTime;
    float3 _WorldSpaceCameraPos;
    float4 _ProjectionParams;
    float4 _ScreenParams;
    float4 _ZBufferParams;
    float4 unity_OrthoParams;
    float4 unity_CameraWorldClipPlanes[6];
    float4 hlslcc_mtx4x4unity_CameraProjection[4];
    float4 hlslcc_mtx4x4unity_CameraInvProjection[4];
    float4 hlslcc_mtx4x4unity_WorldToCamera[4];
    float4 hlslcc_mtx4x4unity_CameraToWorld[4];
    float4 _WorldSpaceLightPos0;
    float4 _LightPositionRange;
    float4 _LightProjectionParams;
    float4 unity_4LightPosX0;
    float4 unity_4LightPosY0;
    float4 unity_4LightPosZ0;
    float4 unity_4LightAtten0;
    float4 unity_LightColor[8];
    float4 unity_LightPosition[8];
    float4 unity_LightAtten[8];
    float4 unity_SpotDirection[8];
    float4 unity_SHAr;
    float4 unity_SHAg;
    float4 unity_SHAb;
    float4 unity_SHBr;
    float4 unity_SHBg;
    float4 unity_SHBb;
    float4 unity_SHC;
    float4 unity_OcclusionMaskSelector;
    float4 unity_ProbesOcclusion;
    float3 unity_LightColor0;
    float3 unity_LightColor1;
    float3 unity_LightColor2;
    float3 unity_LightColor3;
    float4 unity_ShadowSplitSpheres[4];
    float4 unity_ShadowSplitSqRadii;
    float4 unity_LightShadowBias;
    float4 _LightSplitsNear;
    float4 _LightSplitsFar;
    float4 hlslcc_mtx4x4unity_WorldToShadow[16];
    float4 _LightShadowData;
    float4 unity_ShadowFadeCenterAndType;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 unity_LODFade;
    float4 unity_WorldTransformParams;
    float4 unity_RenderingLayer;
    float4 hlslcc_mtx4x4glstate_matrix_transpose_modelview0[4];
    float4 glstate_lightmodel_ambient;
    float4 unity_AmbientSky;
    float4 unity_AmbientEquator;
    float4 unity_AmbientGround;
    float4 unity_IndirectSpecColor;
    float4 hlslcc_mtx4x4glstate_matrix_projection[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixInvV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    int unity_StereoEyeIndex;
    float4 unity_ShadowColor;
    float4 unity_FogColor;
    float4 unity_FogParams;
    float4 unity_LightmapST;
    float4 unity_DynamicLightmapST;
    float4 unity_SpecCube0_BoxMax;
    float4 unity_SpecCube0_BoxMin;
    float4 unity_SpecCube0_ProbePosition;
    float4 unity_SpecCube0_HDR;
    float4 unity_SpecCube1_BoxMax;
    float4 unity_SpecCube1_BoxMin;
    float4 unity_SpecCube1_ProbePosition;
    float4 unity_SpecCube1_HDR;
    float4 unity_ProbeVolumeParams;
    float4 hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[4];
    float3 unity_ProbeVolumeSizeInv;
    float3 unity_ProbeVolumeMin;
    float4 unity_Lightmap_HDR;
    float4 unity_DynamicLightmap_HDR;
    float4 _LightColor0;
    float4 _SpecColor;
    float _Tile;
    float _HeightDisplacement;
    float _NormalScale;
    float4 _ColorTint;
    float _MetallicStrength;
    float _SmoothnessStrength;
    float _EdgeLength;
};
struct Mtl_HullIn
{
    Mtl_VertexOut cp[3];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
kernel void patchKernel(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn vertexInput [[ stage_in ]],
    uint2 tID [[ thread_position_in_grid ]],
    ushort2 groupID [[ threadgroup_position_in_grid ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    constant Mtl_KernelPatchInfo &patchInfo [[ buffer(3) ]])
{
#pragma clang diagnostic pop
    Mtl_ControlPoint output;
    const uint numPatchesInThreadGroup = 10;
    const uint patchID = (tID.x / patchInfo.numControlPointsPerPatch);
    const bool patchValid = (patchID < patchInfo.numPatches);
    const uint mtl_BaseInstance = 0;
    const uint mtl_InstanceID = groupID.y - mtl_BaseInstance;
    const uint internalPatchID = mtl_InstanceID * patchInfo.numPatches + patchID;
    const uint patchIDInThreadGroup = (patchID % numPatchesInThreadGroup);
    const uint controlPointID = (tID.x % patchInfo.numControlPointsPerPatch);
    const uint mtl_BaseVertex = 0;
    const uint mtl_VertexID = ((mtl_InstanceID * (patchInfo.numControlPointsPerPatch * patchInfo.numPatches)) + tID.x) - mtl_BaseVertex;
    threadgroup Mtl_HullIn inputGroup[numPatchesInThreadGroup];
    threadgroup Mtl_HullIn &input = inputGroup[patchIDInThreadGroup];
    MTLTriangleTessellationFactorsHalf tessFactor;
    if (patchValid) {
        input.cp[controlPointID] = vertexFunction(vertexInput);
        output.INTERNALTESSPOS0 = input.cp[controlPointID].INTERNALTESSPOS0;
        output.TANGENT0 = input.cp[controlPointID].TANGENT0;
        output.NORMAL0 = input.cp[controlPointID].NORMAL0;
        output.TEXCOORD0 = input.cp[controlPointID].TEXCOORD0;
        output.TEXCOORD1 = input.cp[controlPointID].TEXCOORD1;
        output.TEXCOORD2 = input.cp[controlPointID].TEXCOORD2;
        output.TEXCOORD3 = input.cp[controlPointID].TEXCOORD3;
        output.COLOR0 = input.cp[controlPointID].COLOR0;
    }
    threadgroup_barrier(mem_flags::mem_threadgroup);
    if (!patchValid) {
        return;
    }
    float3 u_xlat0;
    float3 u_xlat1;
    float3 u_xlat2;
    float3 u_xlat3;
    float3 u_xlat4;
    float u_xlat12;
    float u_xlat13;
    // fork_phase2
    {
        u_xlat0.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[1].INTERNALTESSPOS0.yyy;
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[1].INTERNALTESSPOS0.xxx, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[1].INTERNALTESSPOS0.zzz, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[1].INTERNALTESSPOS0.www, u_xlat0.xyz);
        u_xlat1.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[2].INTERNALTESSPOS0.yyy;
        u_xlat1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[2].INTERNALTESSPOS0.xxx, u_xlat1.xyz);
        u_xlat1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[2].INTERNALTESSPOS0.zzz, u_xlat1.xyz);
        u_xlat1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[2].INTERNALTESSPOS0.www, u_xlat1.xyz);
        u_xlat2.xyz = u_xlat0.xyz + u_xlat1.xyz;
        u_xlat2.xyz = fma(u_xlat2.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat12 = dot(u_xlat2.xyz, u_xlat2.xyz);
        u_xlat12 = sqrt(u_xlat12);
        u_xlat12 = u_xlat12 * VGlobals._EdgeLength;
        u_xlat2.xyz = u_xlat0.xyz + (-u_xlat1.xyz);
        u_xlat13 = dot(u_xlat2.xyz, u_xlat2.xyz);
        u_xlat13 = sqrt(u_xlat13);
        u_xlat13 = u_xlat13 * VGlobals._ScreenParams.y;
        u_xlat12 = u_xlat13 / u_xlat12;
        tessFactor.edgeTessellationFactor[0] = max(u_xlat12, 1.0);
        u_xlat2.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[0].INTERNALTESSPOS0.yyy;
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[0].INTERNALTESSPOS0.xxx, u_xlat2.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[0].INTERNALTESSPOS0.zzz, u_xlat2.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[0].INTERNALTESSPOS0.www, u_xlat2.xyz);
        u_xlat3.xyz = u_xlat1.xyz + u_xlat2.xyz;
        u_xlat1.xyz = u_xlat1.xyz + (-u_xlat2.xyz);
        u_xlat12 = dot(u_xlat1.xyz, u_xlat1.xyz);
        u_xlat12 = sqrt(u_xlat12);
        u_xlat12 = u_xlat12 * VGlobals._ScreenParams.y;
        u_xlat1.xyz = fma(u_xlat3.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat1.x = dot(u_xlat1.xyz, u_xlat1.xyz);
        u_xlat1.x = sqrt(u_xlat1.x);
        u_xlat1.x = u_xlat1.x * VGlobals._EdgeLength;
        u_xlat12 = u_xlat12 / u_xlat1.x;
        tessFactor.edgeTessellationFactor[1] = max(u_xlat12, 1.0);
        u_xlat1.xyz = u_xlat0.xyz + u_xlat2.xyz;
        u_xlat0.xyz = (-u_xlat0.xyz) + u_xlat2.xyz;
        u_xlat0.x = dot(u_xlat0.xyz, u_xlat0.xyz);
        u_xlat0.x = sqrt(u_xlat0.x);
        u_xlat0.x = u_xlat0.x * VGlobals._ScreenParams.y;
        u_xlat4.xyz = fma(u_xlat1.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat4.x = dot(u_xlat4.xyz, u_xlat4.xyz);
        u_xlat4.x = sqrt(u_xlat4.x);
        u_xlat4.x = u_xlat4.x * VGlobals._EdgeLength;
        u_xlat0.x = u_xlat0.x / u_xlat4.x;
        tessFactor.edgeTessellationFactor[2] = max(u_xlat0.x, 1.0);
    }
    // join_phase3
    {
        u_xlat0.x = tessFactor.edgeTessellationFactor[0] + tessFactor.edgeTessellationFactor[1];
        u_xlat0.x = u_xlat0.x + tessFactor.edgeTessellationFactor[2];
        tessFactor.insideTessellationFactor = u_xlat0.x * 0.333333343;
    }
    controlPoints[mtl_VertexID] = output;
    tessFactors[internalPatchID] = tessFactor;
}
// SHADER_STAGE_HULL_end
// SHADER_STAGE_DOMAIN_begin
struct Mtl_VertexInPostTess
{
    patch_control_point<Mtl_ControlPointIn> cp;
};
struct Mtl_VertexOutPostTess
{
    float4 mtl_Position [[ position ]];
    float3 TEXCOORD1 [[ user(TEXCOORD1) ]];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    sampler sampler_Height [[ sampler (0) ]],
    texture2d<float, access::sample > _Height [[ texture(0) ]] ,
    float3 mtl_TessCoord [[ position_in_patch ]],
    uint patchID [[ patch_id ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    Mtl_VertexInPostTess input [[ stage_in ]])
{
#pragma clang diagnostic pop
    Mtl_VertexOutPostTess output;
    MTLTriangleTessellationFactorsHalf tessFactor;
    tessFactor = tessFactors[patchID];
    float4 u_xlat0;
    float4 u_xlat1;
    float4 u_xlat2;
    float4 u_xlat3;
    float4 u_xlat4;
    float u_xlat11;
    float u_xlat15;
    bool u_xlatb15;
    u_xlat0.xyz = mtl_TessCoord.yyy * input.cp[1].NORMAL0.xyz;
    u_xlat0.xyz = fma(input.cp[0].NORMAL0.xyz, mtl_TessCoord.xxx, u_xlat0.xyz);
    u_xlat0.xyz = fma(input.cp[2].NORMAL0.xyz, mtl_TessCoord.zzz, u_xlat0.xyz);
    u_xlat1.x = dot(u_xlat0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat1.y = dot(u_xlat0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat1.z = dot(u_xlat0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat15 = dot(u_xlat1.xyz, u_xlat1.xyz);
    u_xlat15 = rsqrt(u_xlat15);
    u_xlat1.xyz = float3(u_xlat15) * u_xlat1.xyz;
    u_xlat2.xy = mtl_TessCoord.yy * input.cp[1].TEXCOORD0.xy;
    u_xlat2.xy = fma(input.cp[0].TEXCOORD0.xy, mtl_TessCoord.xx, u_xlat2.xy);
    u_xlat2.xy = fma(input.cp[2].TEXCOORD0.xy, mtl_TessCoord.zz, u_xlat2.xy);
    u_xlat2.xy = u_xlat2.xy * float2(VGlobals._Tile);
    u_xlat2.xyz = _Height.sample(sampler_Height, u_xlat2.xy, level(1.0)).xyz;
    u_xlat0.xyz = u_xlat0.xyz * u_xlat2.xyz;
    u_xlat2 = mtl_TessCoord.yyyy * input.cp[1].INTERNALTESSPOS0;
    u_xlat2 = fma(input.cp[0].INTERNALTESSPOS0, mtl_TessCoord.xxxx, u_xlat2);
    u_xlat2 = fma(input.cp[2].INTERNALTESSPOS0, mtl_TessCoord.zzzz, u_xlat2);
    u_xlat0.xyz = fma(u_xlat0.xyz, float3(VGlobals._HeightDisplacement), u_xlat2.xyz);
    u_xlat3 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], u_xlat0.xxxx, u_xlat3);
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], u_xlat0.zzzz, u_xlat3);
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3], u_xlat2.wwww, u_xlat3);
    u_xlat2.xyz = fma((-u_xlat3.xyz), VGlobals._WorldSpaceLightPos0.www, VGlobals._WorldSpaceLightPos0.xyz);
    u_xlat15 = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat15 = rsqrt(u_xlat15);
    u_xlat2.xyz = float3(u_xlat15) * u_xlat2.xyz;
    u_xlat15 = dot(u_xlat1.xyz, u_xlat2.xyz);
    u_xlat15 = fma((-u_xlat15), u_xlat15, 1.0);
    u_xlat15 = sqrt(u_xlat15);
    u_xlat15 = u_xlat15 * VGlobals.unity_LightShadowBias.z;
    u_xlat1.xyz = fma((-u_xlat1.xyz), float3(u_xlat15), u_xlat3.xyz);
    u_xlatb15 = VGlobals.unity_LightShadowBias.z!=0.0;
    u_xlat1.xyz = (bool(u_xlatb15)) ? u_xlat1.xyz : u_xlat3.xyz;
    u_xlat4 = u_xlat1.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat4 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat1.xxxx, u_xlat4);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat1.zzzz, u_xlat4);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat3.wwww, u_xlat1);
    u_xlat15 = VGlobals.unity_LightShadowBias.x / u_xlat1.w;
    u_xlat15 = min(u_xlat15, 0.0);
    u_xlat15 = max(u_xlat15, -1.0);
    u_xlat15 = u_xlat15 + u_xlat1.z;
    u_xlat11 = min(u_xlat1.w, u_xlat15);
    output.mtl_Position.xyw = u_xlat1.xyw;
    u_xlat1.x = (-u_xlat15) + u_xlat11;
    output.mtl_Position.z = fma(VGlobals.unity_LightShadowBias.y, u_xlat1.x, u_xlat15);
    u_xlat1.xyz = u_xlat0.yyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz;
    u_xlat0.xyw = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, u_xlat0.xxx, u_xlat1.xyz);
    u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, u_xlat0.zzz, u_xlat0.xyw);
    output.TEXCOORD1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, u_xlat2.www, u_xlat0.xyz);
    return output;
}
// SHADER_STAGE_DOMAIN_end
Compilation succeeded with: 

program_source:299:53: warning: writable resources in non-void post-tessellation vertex function
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
                                                    ^
program_source:305:30: note: writable buffer defined here
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
                             ^
program_source:306:48: note: writable buffer defined here
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
                                               ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float4 TEXCOORD0 [[ attribute(3) ]] ;
    float4 TEXCOORD1 [[ attribute(4) ]] ;
    float4 TEXCOORD2 [[ attribute(5) ]] ;
    float4 TEXCOORD3 [[ attribute(6) ]] ;
    float4 COLOR0 [[ attribute(7) ]] ;
};
struct Mtl_VertexOut
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float4 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float4 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float4 TEXCOORD3 [[ user(TEXCOORD3) ]];
    float4 COLOR0 [[ user(COLOR0) ]];
};
static Mtl_VertexOut vertexFunction(
    Mtl_VertexIn input)
{
    Mtl_VertexOut output;
    output.INTERNALTESSPOS0 = input.POSITION0;
    output.TANGENT0 = input.TANGENT0;
    output.NORMAL0.xyz = input.NORMAL0.xyz;
    output.TEXCOORD0 = input.TEXCOORD0;
    output.TEXCOORD1 = input.TEXCOORD1;
    output.TEXCOORD2 = input.TEXCOORD2;
    output.TEXCOORD3 = input.TEXCOORD3;
    output.COLOR0 = input.COLOR0;
    return output;
}
// SHADER_STAGE_HULL_begin
struct Mtl_ControlPoint
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float4 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float4 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float4 TEXCOORD3 [[ user(TEXCOORD3) ]];
    float4 COLOR0 [[ user(COLOR0) ]];
};
struct Mtl_ControlPointIn
{
    float4 INTERNALTESSPOS0 [[ attribute(8) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float4 TEXCOORD0 [[ attribute(3) ]] ;
    float4 TEXCOORD1 [[ attribute(4) ]] ;
    float4 TEXCOORD2 [[ attribute(5) ]] ;
    float4 TEXCOORD3 [[ attribute(6) ]] ;
    float4 COLOR0 [[ attribute(7) ]] ;
};
struct Mtl_KernelPatchInfo
{
    uint numPatches;
    ushort numControlPointsPerPatch;
};
struct VGlobals_Type
{
    float4 _Time;
    float4 _SinTime;
    float4 _CosTime;
    float4 unity_DeltaTime;
    float3 _WorldSpaceCameraPos;
    float4 _ProjectionParams;
    float4 _ScreenParams;
    float4 _ZBufferParams;
    float4 unity_OrthoParams;
    float4 unity_CameraWorldClipPlanes[6];
    float4 hlslcc_mtx4x4unity_CameraProjection[4];
    float4 hlslcc_mtx4x4unity_CameraInvProjection[4];
    float4 hlslcc_mtx4x4unity_WorldToCamera[4];
    float4 hlslcc_mtx4x4unity_CameraToWorld[4];
    float4 _WorldSpaceLightPos0;
    float4 _LightPositionRange;
    float4 _LightProjectionParams;
    float4 unity_4LightPosX0;
    float4 unity_4LightPosY0;
    float4 unity_4LightPosZ0;
    float4 unity_4LightAtten0;
    float4 unity_LightColor[8];
    float4 unity_LightPosition[8];
    float4 unity_LightAtten[8];
    float4 unity_SpotDirection[8];
    float4 unity_SHAr;
    float4 unity_SHAg;
    float4 unity_SHAb;
    float4 unity_SHBr;
    float4 unity_SHBg;
    float4 unity_SHBb;
    float4 unity_SHC;
    float4 unity_OcclusionMaskSelector;
    float4 unity_ProbesOcclusion;
    float3 unity_LightColor0;
    float3 unity_LightColor1;
    float3 unity_LightColor2;
    float3 unity_LightColor3;
    float4 unity_ShadowSplitSpheres[4];
    float4 unity_ShadowSplitSqRadii;
    float4 unity_LightShadowBias;
    float4 _LightSplitsNear;
    float4 _LightSplitsFar;
    float4 hlslcc_mtx4x4unity_WorldToShadow[16];
    float4 _LightShadowData;
    float4 unity_ShadowFadeCenterAndType;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 unity_LODFade;
    float4 unity_WorldTransformParams;
    float4 unity_RenderingLayer;
    float4 hlslcc_mtx4x4glstate_matrix_transpose_modelview0[4];
    float4 glstate_lightmodel_ambient;
    float4 unity_AmbientSky;
    float4 unity_AmbientEquator;
    float4 unity_AmbientGround;
    float4 unity_IndirectSpecColor;
    float4 hlslcc_mtx4x4glstate_matrix_projection[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixInvV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    int unity_StereoEyeIndex;
    float4 unity_ShadowColor;
    float4 unity_FogColor;
    float4 unity_FogParams;
    float4 unity_LightmapST;
    float4 unity_DynamicLightmapST;
    float4 unity_SpecCube0_BoxMax;
    float4 unity_SpecCube0_BoxMin;
    float4 unity_SpecCube0_ProbePosition;
    float4 unity_SpecCube0_HDR;
    float4 unity_SpecCube1_BoxMax;
    float4 unity_SpecCube1_BoxMin;
    float4 unity_SpecCube1_ProbePosition;
    float4 unity_SpecCube1_HDR;
    float4 unity_ProbeVolumeParams;
    float4 hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[4];
    float3 unity_ProbeVolumeSizeInv;
    float3 unity_ProbeVolumeMin;
    float4 unity_Lightmap_HDR;
    float4 unity_DynamicLightmap_HDR;
    float4 _LightColor0;
    float4 _SpecColor;
    float _Tile;
    float _HeightDisplacement;
    float _NormalScale;
    float4 _ColorTint;
    float _MetallicStrength;
    float _SmoothnessStrength;
    float _EdgeLength;
    float4 _texcoord_ST;
    float4 unity_Ambient;
};
struct Mtl_HullIn
{
    Mtl_VertexOut cp[3];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
kernel void patchKernel(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn vertexInput [[ stage_in ]],
    uint2 tID [[ thread_position_in_grid ]],
    ushort2 groupID [[ threadgroup_position_in_grid ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    constant Mtl_KernelPatchInfo &patchInfo [[ buffer(3) ]])
{
#pragma clang diagnostic pop
    Mtl_ControlPoint output;
    const uint numPatchesInThreadGroup = 10;
    const uint patchID = (tID.x / patchInfo.numControlPointsPerPatch);
    const bool patchValid = (patchID < patchInfo.numPatches);
    const uint mtl_BaseInstance = 0;
    const uint mtl_InstanceID = groupID.y - mtl_BaseInstance;
    const uint internalPatchID = mtl_InstanceID * patchInfo.numPatches + patchID;
    const uint patchIDInThreadGroup = (patchID % numPatchesInThreadGroup);
    const uint controlPointID = (tID.x % patchInfo.numControlPointsPerPatch);
    const uint mtl_BaseVertex = 0;
    const uint mtl_VertexID = ((mtl_InstanceID * (patchInfo.numControlPointsPerPatch * patchInfo.numPatches)) + tID.x) - mtl_BaseVertex;
    threadgroup Mtl_HullIn inputGroup[numPatchesInThreadGroup];
    threadgroup Mtl_HullIn &input = inputGroup[patchIDInThreadGroup];
    MTLTriangleTessellationFactorsHalf tessFactor;
    if (patchValid) {
        input.cp[controlPointID] = vertexFunction(vertexInput);
        output.INTERNALTESSPOS0 = input.cp[controlPointID].INTERNALTESSPOS0;
        output.TANGENT0 = input.cp[controlPointID].TANGENT0;
        output.NORMAL0 = input.cp[controlPointID].NORMAL0;
        output.TEXCOORD0 = input.cp[controlPointID].TEXCOORD0;
        output.TEXCOORD1 = input.cp[controlPointID].TEXCOORD1;
        output.TEXCOORD2 = input.cp[controlPointID].TEXCOORD2;
        output.TEXCOORD3 = input.cp[controlPointID].TEXCOORD3;
        output.COLOR0 = input.cp[controlPointID].COLOR0;
    }
    threadgroup_barrier(mem_flags::mem_threadgroup);
    if (!patchValid) {
        return;
    }
    float3 u_xlat0;
    float3 u_xlat1;
    float3 u_xlat2;
    float3 u_xlat3;
    float3 u_xlat4;
    float u_xlat12;
    float u_xlat13;
    // fork_phase2
    {
        u_xlat0.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[1].INTERNALTESSPOS0.yyy;
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[1].INTERNALTESSPOS0.xxx, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[1].INTERNALTESSPOS0.zzz, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[1].INTERNALTESSPOS0.www, u_xlat0.xyz);
        u_xlat1.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[2].INTERNALTESSPOS0.yyy;
        u_xlat1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[2].INTERNALTESSPOS0.xxx, u_xlat1.xyz);
        u_xlat1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[2].INTERNALTESSPOS0.zzz, u_xlat1.xyz);
        u_xlat1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[2].INTERNALTESSPOS0.www, u_xlat1.xyz);
        u_xlat2.xyz = u_xlat0.xyz + u_xlat1.xyz;
        u_xlat2.xyz = fma(u_xlat2.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat12 = dot(u_xlat2.xyz, u_xlat2.xyz);
        u_xlat12 = sqrt(u_xlat12);
        u_xlat12 = u_xlat12 * VGlobals._EdgeLength;
        u_xlat2.xyz = u_xlat0.xyz + (-u_xlat1.xyz);
        u_xlat13 = dot(u_xlat2.xyz, u_xlat2.xyz);
        u_xlat13 = sqrt(u_xlat13);
        u_xlat13 = u_xlat13 * VGlobals._ScreenParams.y;
        u_xlat12 = u_xlat13 / u_xlat12;
        tessFactor.edgeTessellationFactor[0] = max(u_xlat12, 1.0);
        u_xlat2.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[0].INTERNALTESSPOS0.yyy;
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[0].INTERNALTESSPOS0.xxx, u_xlat2.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[0].INTERNALTESSPOS0.zzz, u_xlat2.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[0].INTERNALTESSPOS0.www, u_xlat2.xyz);
        u_xlat3.xyz = u_xlat1.xyz + u_xlat2.xyz;
        u_xlat1.xyz = u_xlat1.xyz + (-u_xlat2.xyz);
        u_xlat12 = dot(u_xlat1.xyz, u_xlat1.xyz);
        u_xlat12 = sqrt(u_xlat12);
        u_xlat12 = u_xlat12 * VGlobals._ScreenParams.y;
        u_xlat1.xyz = fma(u_xlat3.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat1.x = dot(u_xlat1.xyz, u_xlat1.xyz);
        u_xlat1.x = sqrt(u_xlat1.x);
        u_xlat1.x = u_xlat1.x * VGlobals._EdgeLength;
        u_xlat12 = u_xlat12 / u_xlat1.x;
        tessFactor.edgeTessellationFactor[1] = max(u_xlat12, 1.0);
        u_xlat1.xyz = u_xlat0.xyz + u_xlat2.xyz;
        u_xlat0.xyz = (-u_xlat0.xyz) + u_xlat2.xyz;
        u_xlat0.x = dot(u_xlat0.xyz, u_xlat0.xyz);
        u_xlat0.x = sqrt(u_xlat0.x);
        u_xlat0.x = u_xlat0.x * VGlobals._ScreenParams.y;
        u_xlat4.xyz = fma(u_xlat1.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat4.x = dot(u_xlat4.xyz, u_xlat4.xyz);
        u_xlat4.x = sqrt(u_xlat4.x);
        u_xlat4.x = u_xlat4.x * VGlobals._EdgeLength;
        u_xlat0.x = u_xlat0.x / u_xlat4.x;
        tessFactor.edgeTessellationFactor[2] = max(u_xlat0.x, 1.0);
    }
    // join_phase3
    {
        u_xlat0.x = tessFactor.edgeTessellationFactor[0] + tessFactor.edgeTessellationFactor[1];
        u_xlat0.x = u_xlat0.x + tessFactor.edgeTessellationFactor[2];
        tessFactor.insideTessellationFactor = u_xlat0.x * 0.333333343;
    }
    controlPoints[mtl_VertexID] = output;
    tessFactors[internalPatchID] = tessFactor;
}
// SHADER_STAGE_HULL_end
// SHADER_STAGE_DOMAIN_begin
struct Mtl_VertexInPostTess
{
    patch_control_point<Mtl_ControlPointIn> cp;
};
struct Mtl_VertexOutPostTess
{
    float4 mtl_Position [[ position ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float4 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float4 TEXCOORD3 [[ user(TEXCOORD3) ]];
    float4 TEXCOORD5 [[ user(TEXCOORD5) ]];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    sampler sampler_Height [[ sampler (0) ]],
    texture2d<float, access::sample > _Height [[ texture(0) ]] ,
    float3 mtl_TessCoord [[ position_in_patch ]],
    uint patchID [[ patch_id ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    Mtl_VertexInPostTess input [[ stage_in ]])
{
#pragma clang diagnostic pop
    Mtl_VertexOutPostTess output;
    MTLTriangleTessellationFactorsHalf tessFactor;
    tessFactor = tessFactors[patchID];
    float4 u_xlat0;
    float4 u_xlat1;
    float4 u_xlat2;
    float4 u_xlat3;
    float2 u_xlat9;
    float u_xlat12;
    float u_xlat13;
    u_xlat0 = mtl_TessCoord.yyyy * input.cp[1].INTERNALTESSPOS0;
    u_xlat0 = fma(input.cp[0].INTERNALTESSPOS0, mtl_TessCoord.xxxx, u_xlat0);
    u_xlat0 = fma(input.cp[2].INTERNALTESSPOS0, mtl_TessCoord.zzzz, u_xlat0);
    u_xlat1.xy = mtl_TessCoord.yy * input.cp[1].TEXCOORD0.xy;
    u_xlat1.xy = fma(input.cp[0].TEXCOORD0.xy, mtl_TessCoord.xx, u_xlat1.xy);
    u_xlat1.xy = fma(input.cp[2].TEXCOORD0.xy, mtl_TessCoord.zz, u_xlat1.xy);
    u_xlat9.xy = u_xlat1.xy * float2(VGlobals._Tile);
    output.TEXCOORD0.xy = fma(u_xlat1.xy, VGlobals._texcoord_ST.xy, VGlobals._texcoord_ST.zw);
    u_xlat1.xyz = _Height.sample(sampler_Height, u_xlat9.xy, level(1.0)).xyz;
    u_xlat2.xyz = mtl_TessCoord.yyy * input.cp[1].NORMAL0.xyz;
    u_xlat2.xyz = fma(input.cp[0].NORMAL0.xyz, mtl_TessCoord.xxx, u_xlat2.xyz);
    u_xlat2.xyz = fma(input.cp[2].NORMAL0.xyz, mtl_TessCoord.zzz, u_xlat2.xyz);
    u_xlat1.xyz = u_xlat1.xyz * u_xlat2.xyz;
    u_xlat0.xyz = fma(u_xlat1.xyz, float3(VGlobals._HeightDisplacement), u_xlat0.xyz);
    u_xlat1 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], u_xlat0.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], u_xlat0.zzzz, u_xlat1);
    u_xlat3 = u_xlat1 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, u_xlat0.www, u_xlat1.xyz);
    u_xlat1 = u_xlat3.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat3.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat3.zzzz, u_xlat1);
    output.mtl_Position = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat3.wwww, u_xlat1);
    u_xlat1.y = dot(u_xlat2.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat1.z = dot(u_xlat2.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat1.x = dot(u_xlat2.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat12 = dot(u_xlat1.xyz, u_xlat1.xyz);
    u_xlat12 = rsqrt(u_xlat12);
    u_xlat1.xyz = float3(u_xlat12) * u_xlat1.xyz;
    output.TEXCOORD1.z = u_xlat1.y;
    u_xlat2 = mtl_TessCoord.yyyy * input.cp[1].TANGENT0;
    u_xlat2 = fma(input.cp[0].TANGENT0, mtl_TessCoord.xxxx, u_xlat2);
    u_xlat2 = fma(input.cp[2].TANGENT0, mtl_TessCoord.zzzz, u_xlat2);
    u_xlat3.xyz = u_xlat2.yyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].yzx;
    u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].yzx, u_xlat2.xxx, u_xlat3.xyz);
    u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].yzx, u_xlat2.zzz, u_xlat3.xyz);
    u_xlat12 = u_xlat2.w * VGlobals.unity_WorldTransformParams.w;
    u_xlat13 = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat13 = rsqrt(u_xlat13);
    u_xlat2.xyz = float3(u_xlat13) * u_xlat2.xyz;
    u_xlat3.xyz = u_xlat1.xyz * u_xlat2.xyz;
    u_xlat3.xyz = fma(u_xlat1.zxy, u_xlat2.yzx, (-u_xlat3.xyz));
    u_xlat3.xyz = float3(u_xlat12) * u_xlat3.xyz;
    output.TEXCOORD1.y = u_xlat3.x;
    output.TEXCOORD1.w = u_xlat0.x;
    output.TEXCOORD1.x = u_xlat2.z;
    output.TEXCOORD2.w = u_xlat0.y;
    output.TEXCOORD3.w = u_xlat0.z;
    output.TEXCOORD2.x = u_xlat2.x;
    output.TEXCOORD3.x = u_xlat2.y;
    output.TEXCOORD2.z = u_xlat1.z;
    output.TEXCOORD3.z = u_xlat1.x;
    output.TEXCOORD2.y = u_xlat3.y;
    output.TEXCOORD3.y = u_xlat3.z;
    output.TEXCOORD5 = float4(0.0, 0.0, 0.0, 0.0);
    return output;
}
// SHADER_STAGE_DOMAIN_end
Compilation succeeded with: 

program_source:303:53: warning: writable resources in non-void post-tessellation vertex function
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
                                                    ^
program_source:309:30: note: writable buffer defined here
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
                             ^
program_source:310:48: note: writable buffer defined here
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
                                               ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float4 TEXCOORD0 [[ attribute(3) ]] ;
    float4 TEXCOORD1 [[ attribute(4) ]] ;
    float4 TEXCOORD2 [[ attribute(5) ]] ;
    float4 TEXCOORD3 [[ attribute(6) ]] ;
    float4 COLOR0 [[ attribute(7) ]] ;
};
struct Mtl_VertexOut
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float4 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float4 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float4 TEXCOORD3 [[ user(TEXCOORD3) ]];
    float4 COLOR0 [[ user(COLOR0) ]];
};
static Mtl_VertexOut vertexFunction(
    Mtl_VertexIn input)
{
    Mtl_VertexOut output;
    output.INTERNALTESSPOS0 = input.POSITION0;
    output.TANGENT0 = input.TANGENT0;
    output.NORMAL0.xyz = input.NORMAL0.xyz;
    output.TEXCOORD0 = input.TEXCOORD0;
    output.TEXCOORD1 = input.TEXCOORD1;
    output.TEXCOORD2 = input.TEXCOORD2;
    output.TEXCOORD3 = input.TEXCOORD3;
    output.COLOR0 = input.COLOR0;
    return output;
}
// SHADER_STAGE_HULL_begin
struct Mtl_ControlPoint
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float4 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float4 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float4 TEXCOORD3 [[ user(TEXCOORD3) ]];
    float4 COLOR0 [[ user(COLOR0) ]];
};
struct Mtl_ControlPointIn
{
    float4 INTERNALTESSPOS0 [[ attribute(8) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float4 TEXCOORD0 [[ attribute(3) ]] ;
    float4 TEXCOORD1 [[ attribute(4) ]] ;
    float4 TEXCOORD2 [[ attribute(5) ]] ;
    float4 TEXCOORD3 [[ attribute(6) ]] ;
    float4 COLOR0 [[ attribute(7) ]] ;
};
struct Mtl_KernelPatchInfo
{
    uint numPatches;
    ushort numControlPointsPerPatch;
};
struct VGlobals_Type
{
    float4 _Time;
    float4 _SinTime;
    float4 _CosTime;
    float4 unity_DeltaTime;
    float3 _WorldSpaceCameraPos;
    float4 _ProjectionParams;
    float4 _ScreenParams;
    float4 _ZBufferParams;
    float4 unity_OrthoParams;
    float4 unity_CameraWorldClipPlanes[6];
    float4 hlslcc_mtx4x4unity_CameraProjection[4];
    float4 hlslcc_mtx4x4unity_CameraInvProjection[4];
    float4 hlslcc_mtx4x4unity_WorldToCamera[4];
    float4 hlslcc_mtx4x4unity_CameraToWorld[4];
    float4 _WorldSpaceLightPos0;
    float4 _LightPositionRange;
    float4 _LightProjectionParams;
    float4 unity_4LightPosX0;
    float4 unity_4LightPosY0;
    float4 unity_4LightPosZ0;
    float4 unity_4LightAtten0;
    float4 unity_LightColor[8];
    float4 unity_LightPosition[8];
    float4 unity_LightAtten[8];
    float4 unity_SpotDirection[8];
    float4 unity_SHAr;
    float4 unity_SHAg;
    float4 unity_SHAb;
    float4 unity_SHBr;
    float4 unity_SHBg;
    float4 unity_SHBb;
    float4 unity_SHC;
    float4 unity_OcclusionMaskSelector;
    float4 unity_ProbesOcclusion;
    float3 unity_LightColor0;
    float3 unity_LightColor1;
    float3 unity_LightColor2;
    float3 unity_LightColor3;
    float4 unity_ShadowSplitSpheres[4];
    float4 unity_ShadowSplitSqRadii;
    float4 unity_LightShadowBias;
    float4 _LightSplitsNear;
    float4 _LightSplitsFar;
    float4 hlslcc_mtx4x4unity_WorldToShadow[16];
    float4 _LightShadowData;
    float4 unity_ShadowFadeCenterAndType;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 unity_LODFade;
    float4 unity_WorldTransformParams;
    float4 unity_RenderingLayer;
    float4 hlslcc_mtx4x4glstate_matrix_transpose_modelview0[4];
    float4 glstate_lightmodel_ambient;
    float4 unity_AmbientSky;
    float4 unity_AmbientEquator;
    float4 unity_AmbientGround;
    float4 unity_IndirectSpecColor;
    float4 hlslcc_mtx4x4glstate_matrix_projection[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixInvV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    int unity_StereoEyeIndex;
    float4 unity_ShadowColor;
    float4 unity_FogColor;
    float4 unity_FogParams;
    float4 unity_LightmapST;
    float4 unity_DynamicLightmapST;
    float4 unity_SpecCube0_BoxMax;
    float4 unity_SpecCube0_BoxMin;
    float4 unity_SpecCube0_ProbePosition;
    float4 unity_SpecCube0_HDR;
    float4 unity_SpecCube1_BoxMax;
    float4 unity_SpecCube1_BoxMin;
    float4 unity_SpecCube1_ProbePosition;
    float4 unity_SpecCube1_HDR;
    float4 unity_ProbeVolumeParams;
    float4 hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[4];
    float3 unity_ProbeVolumeSizeInv;
    float3 unity_ProbeVolumeMin;
    float4 unity_Lightmap_HDR;
    float4 unity_DynamicLightmap_HDR;
    float4 _LightColor0;
    float4 _SpecColor;
    float _Tile;
    float _HeightDisplacement;
    float _NormalScale;
    float4 _ColorTint;
    float _MetallicStrength;
    float _SmoothnessStrength;
    float _EdgeLength;
    bool4 unity_MetaVertexControl;
    bool4 unity_MetaFragmentControl;
    int unity_VisualizationMode;
    float unity_OneOverOutputBoost;
    float unity_MaxOutputValue;
    float unity_UseLinearSpace;
    float4 _texcoord_ST;
};
struct Mtl_HullIn
{
    Mtl_VertexOut cp[3];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
kernel void patchKernel(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn vertexInput [[ stage_in ]],
    uint2 tID [[ thread_position_in_grid ]],
    ushort2 groupID [[ threadgroup_position_in_grid ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    constant Mtl_KernelPatchInfo &patchInfo [[ buffer(3) ]])
{
#pragma clang diagnostic pop
    Mtl_ControlPoint output;
    const uint numPatchesInThreadGroup = 10;
    const uint patchID = (tID.x / patchInfo.numControlPointsPerPatch);
    const bool patchValid = (patchID < patchInfo.numPatches);
    const uint mtl_BaseInstance = 0;
    const uint mtl_InstanceID = groupID.y - mtl_BaseInstance;
    const uint internalPatchID = mtl_InstanceID * patchInfo.numPatches + patchID;
    const uint patchIDInThreadGroup = (patchID % numPatchesInThreadGroup);
    const uint controlPointID = (tID.x % patchInfo.numControlPointsPerPatch);
    const uint mtl_BaseVertex = 0;
    const uint mtl_VertexID = ((mtl_InstanceID * (patchInfo.numControlPointsPerPatch * patchInfo.numPatches)) + tID.x) - mtl_BaseVertex;
    threadgroup Mtl_HullIn inputGroup[numPatchesInThreadGroup];
    threadgroup Mtl_HullIn &input = inputGroup[patchIDInThreadGroup];
    MTLTriangleTessellationFactorsHalf tessFactor;
    if (patchValid) {
        input.cp[controlPointID] = vertexFunction(vertexInput);
        output.INTERNALTESSPOS0 = input.cp[controlPointID].INTERNALTESSPOS0;
        output.TANGENT0 = input.cp[controlPointID].TANGENT0;
        output.NORMAL0 = input.cp[controlPointID].NORMAL0;
        output.TEXCOORD0 = input.cp[controlPointID].TEXCOORD0;
        output.TEXCOORD1 = input.cp[controlPointID].TEXCOORD1;
        output.TEXCOORD2 = input.cp[controlPointID].TEXCOORD2;
        output.TEXCOORD3 = input.cp[controlPointID].TEXCOORD3;
        output.COLOR0 = input.cp[controlPointID].COLOR0;
    }
    threadgroup_barrier(mem_flags::mem_threadgroup);
    if (!patchValid) {
        return;
    }
    float3 u_xlat0;
    float3 u_xlat1;
    float3 u_xlat2;
    float3 u_xlat3;
    float3 u_xlat4;
    float u_xlat12;
    float u_xlat13;
    // fork_phase2
    {
        u_xlat0.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[1].INTERNALTESSPOS0.yyy;
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[1].INTERNALTESSPOS0.xxx, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[1].INTERNALTESSPOS0.zzz, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[1].INTERNALTESSPOS0.www, u_xlat0.xyz);
        u_xlat1.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[2].INTERNALTESSPOS0.yyy;
        u_xlat1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[2].INTERNALTESSPOS0.xxx, u_xlat1.xyz);
        u_xlat1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[2].INTERNALTESSPOS0.zzz, u_xlat1.xyz);
        u_xlat1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[2].INTERNALTESSPOS0.www, u_xlat1.xyz);
        u_xlat2.xyz = u_xlat0.xyz + u_xlat1.xyz;
        u_xlat2.xyz = fma(u_xlat2.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat12 = dot(u_xlat2.xyz, u_xlat2.xyz);
        u_xlat12 = sqrt(u_xlat12);
        u_xlat12 = u_xlat12 * VGlobals._EdgeLength;
        u_xlat2.xyz = u_xlat0.xyz + (-u_xlat1.xyz);
        u_xlat13 = dot(u_xlat2.xyz, u_xlat2.xyz);
        u_xlat13 = sqrt(u_xlat13);
        u_xlat13 = u_xlat13 * VGlobals._ScreenParams.y;
        u_xlat12 = u_xlat13 / u_xlat12;
        tessFactor.edgeTessellationFactor[0] = max(u_xlat12, 1.0);
        u_xlat2.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[0].INTERNALTESSPOS0.yyy;
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[0].INTERNALTESSPOS0.xxx, u_xlat2.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[0].INTERNALTESSPOS0.zzz, u_xlat2.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[0].INTERNALTESSPOS0.www, u_xlat2.xyz);
        u_xlat3.xyz = u_xlat1.xyz + u_xlat2.xyz;
        u_xlat1.xyz = u_xlat1.xyz + (-u_xlat2.xyz);
        u_xlat12 = dot(u_xlat1.xyz, u_xlat1.xyz);
        u_xlat12 = sqrt(u_xlat12);
        u_xlat12 = u_xlat12 * VGlobals._ScreenParams.y;
        u_xlat1.xyz = fma(u_xlat3.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat1.x = dot(u_xlat1.xyz, u_xlat1.xyz);
        u_xlat1.x = sqrt(u_xlat1.x);
        u_xlat1.x = u_xlat1.x * VGlobals._EdgeLength;
        u_xlat12 = u_xlat12 / u_xlat1.x;
        tessFactor.edgeTessellationFactor[1] = max(u_xlat12, 1.0);
        u_xlat1.xyz = u_xlat0.xyz + u_xlat2.xyz;
        u_xlat0.xyz = (-u_xlat0.xyz) + u_xlat2.xyz;
        u_xlat0.x = dot(u_xlat0.xyz, u_xlat0.xyz);
        u_xlat0.x = sqrt(u_xlat0.x);
        u_xlat0.x = u_xlat0.x * VGlobals._ScreenParams.y;
        u_xlat4.xyz = fma(u_xlat1.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat4.x = dot(u_xlat4.xyz, u_xlat4.xyz);
        u_xlat4.x = sqrt(u_xlat4.x);
        u_xlat4.x = u_xlat4.x * VGlobals._EdgeLength;
        u_xlat0.x = u_xlat0.x / u_xlat4.x;
        tessFactor.edgeTessellationFactor[2] = max(u_xlat0.x, 1.0);
    }
    // join_phase3
    {
        u_xlat0.x = tessFactor.edgeTessellationFactor[0] + tessFactor.edgeTessellationFactor[1];
        u_xlat0.x = u_xlat0.x + tessFactor.edgeTessellationFactor[2];
        tessFactor.insideTessellationFactor = u_xlat0.x * 0.333333343;
    }
    controlPoints[mtl_VertexID] = output;
    tessFactors[internalPatchID] = tessFactor;
}
// SHADER_STAGE_HULL_end
// SHADER_STAGE_DOMAIN_begin
struct Mtl_VertexInPostTess
{
    patch_control_point<Mtl_ControlPointIn> cp;
};
struct Mtl_VertexOutPostTess
{
    float4 mtl_Position [[ position ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float4 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float4 TEXCOORD3 [[ user(TEXCOORD3) ]];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    sampler sampler_Height [[ sampler (0) ]],
    texture2d<float, access::sample > _Height [[ texture(0) ]] ,
    float3 mtl_TessCoord [[ position_in_patch ]],
    uint patchID [[ patch_id ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    Mtl_VertexInPostTess input [[ stage_in ]])
{
#pragma clang diagnostic pop
    Mtl_VertexOutPostTess output;
    MTLTriangleTessellationFactorsHalf tessFactor;
    tessFactor = tessFactors[patchID];
    float4 u_xlat0;
    float4 u_xlat1;
    float4 u_xlat2;
    float3 u_xlat3;
    float3 u_xlat4;
    float2 u_xlat13;
    float u_xlat15;
    bool u_xlatb15;
    u_xlat0.xy = mtl_TessCoord.yy * input.cp[1].TEXCOORD2.xy;
    u_xlat0.xy = fma(input.cp[0].TEXCOORD2.xy, mtl_TessCoord.xx, u_xlat0.xy);
    u_xlat0.xy = fma(input.cp[2].TEXCOORD2.xy, mtl_TessCoord.zz, u_xlat0.xy);
    u_xlat0.xy = fma(u_xlat0.xy, VGlobals.unity_DynamicLightmapST.xy, VGlobals.unity_DynamicLightmapST.zw);
    u_xlat1.xy = mtl_TessCoord.yy * input.cp[1].TEXCOORD1.xy;
    u_xlat1.xy = fma(input.cp[0].TEXCOORD1.xy, mtl_TessCoord.xx, u_xlat1.xy);
    u_xlat1.xy = fma(input.cp[2].TEXCOORD1.xy, mtl_TessCoord.zz, u_xlat1.xy);
    u_xlat1.xy = fma(u_xlat1.xy, VGlobals.unity_LightmapST.xy, VGlobals.unity_LightmapST.zw);
    u_xlat2 = mtl_TessCoord.yyyy * input.cp[1].INTERNALTESSPOS0;
    u_xlat2 = fma(input.cp[0].INTERNALTESSPOS0, mtl_TessCoord.xxxx, u_xlat2);
    u_xlat2 = fma(input.cp[2].INTERNALTESSPOS0, mtl_TessCoord.zzzz, u_xlat2);
    u_xlat3.xy = mtl_TessCoord.yy * input.cp[1].TEXCOORD0.xy;
    u_xlat3.xy = fma(input.cp[0].TEXCOORD0.xy, mtl_TessCoord.xx, u_xlat3.xy);
    u_xlat3.xy = fma(input.cp[2].TEXCOORD0.xy, mtl_TessCoord.zz, u_xlat3.xy);
    u_xlat13.xy = u_xlat3.xy * float2(VGlobals._Tile);
    output.TEXCOORD0.xy = fma(u_xlat3.xy, VGlobals._texcoord_ST.xy, VGlobals._texcoord_ST.zw);
    u_xlat3.xyz = _Height.sample(sampler_Height, u_xlat13.xy, level(1.0)).xyz;
    u_xlat4.xyz = mtl_TessCoord.yyy * input.cp[1].NORMAL0.xyz;
    u_xlat4.xyz = fma(input.cp[0].NORMAL0.xyz, mtl_TessCoord.xxx, u_xlat4.xyz);
    u_xlat4.xyz = fma(input.cp[2].NORMAL0.xyz, mtl_TessCoord.zzz, u_xlat4.xyz);
    u_xlat3.xyz = u_xlat3.xyz * u_xlat4.xyz;
    u_xlat2.xyz = fma(u_xlat3.xyz, float3(VGlobals._HeightDisplacement), u_xlat2.xyz);
    u_xlatb15 = 0.0<u_xlat2.z;
    u_xlat1.z = u_xlatb15 ? 9.99999975e-05 : float(0.0);
    u_xlat1.xyz = (VGlobals.unity_MetaVertexControl.x) ? u_xlat1.xyz : u_xlat2.xyz;
    u_xlatb15 = 0.0<u_xlat1.z;
    u_xlat0.z = u_xlatb15 ? 9.99999975e-05 : float(0.0);
    u_xlat0.xyz = (VGlobals.unity_MetaVertexControl.y) ? u_xlat0.xyz : u_xlat1.xyz;
    u_xlat1 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat0.xxxx, u_xlat1);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat0.zzzz, u_xlat1);
    output.mtl_Position = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_MatrixVP[3];
    u_xlat0.xyz = u_xlat2.yyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz;
    u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, u_xlat2.xxx, u_xlat0.xyz);
    u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, u_xlat2.zzz, u_xlat0.xyz);
    u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, u_xlat2.www, u_xlat0.xyz);
    output.TEXCOORD1.w = u_xlat0.x;
    u_xlat1.y = dot(u_xlat4.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat1.z = dot(u_xlat4.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat1.x = dot(u_xlat4.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat0.x = dot(u_xlat1.xyz, u_xlat1.xyz);
    u_xlat0.x = rsqrt(u_xlat0.x);
    u_xlat1.xyz = u_xlat0.xxx * u_xlat1.xyz;
    output.TEXCOORD1.z = u_xlat1.y;
    u_xlat2 = mtl_TessCoord.yyyy * input.cp[1].TANGENT0;
    u_xlat2 = fma(input.cp[0].TANGENT0, mtl_TessCoord.xxxx, u_xlat2);
    u_xlat2 = fma(input.cp[2].TANGENT0, mtl_TessCoord.zzzz, u_xlat2);
    u_xlat3.xyz = u_xlat2.yyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].yzx;
    u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].yzx, u_xlat2.xxx, u_xlat3.xyz);
    u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].yzx, u_xlat2.zzz, u_xlat3.xyz);
    u_xlat0.x = u_xlat2.w * VGlobals.unity_WorldTransformParams.w;
    u_xlat15 = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat15 = rsqrt(u_xlat15);
    u_xlat2.xyz = float3(u_xlat15) * u_xlat2.xyz;
    u_xlat3.xyz = u_xlat1.xyz * u_xlat2.xyz;
    u_xlat3.xyz = fma(u_xlat1.zxy, u_xlat2.yzx, (-u_xlat3.xyz));
    u_xlat3.xyz = u_xlat0.xxx * u_xlat3.xyz;
    output.TEXCOORD1.y = u_xlat3.x;
    output.TEXCOORD1.x = u_xlat2.z;
    output.TEXCOORD2.w = u_xlat0.y;
    output.TEXCOORD3.w = u_xlat0.z;
    output.TEXCOORD2.x = u_xlat2.x;
    output.TEXCOORD3.x = u_xlat2.y;
    output.TEXCOORD2.z = u_xlat1.z;
    output.TEXCOORD3.z = u_xlat1.x;
    output.TEXCOORD2.y = u_xlat3.y;
    output.TEXCOORD3.y = u_xlat3.z;
    return output;
}
// SHADER_STAGE_DOMAIN_end
Refreshing native plugins compatible for Editor in 2.12 ms, found 2 plugins.
Preloading 0 native plugins for Editor in 0.00 ms.
Unloading 3375 Unused Serialized files (Serialized files now loaded: 0)
Unloading 20 unused Assets / (0.6 MB). Loaded Objects now: 3898.
Memory consumption went from 136.4 MB to 135.8 MB.
Total: 5.600763 ms (FindLiveObjects: 0.476998 ms CreateObjectMapping: 0.407055 ms MarkObjects: 4.234383 ms  DeleteObjects: 0.479901 ms)

AssetImportParameters requested are different than current active one (requested -> active):
  custom:video-decoder-ogg-theora: a1e56fd34408186e4bbccfd4996cb3dc -> 
  custom:container-muxer-webm: aa71ff27fc2769a1b78a27578f13a17b -> 
  custom:container-demuxer-webm: 4f35f7cbe854078d1ac9338744f61a02 -> 
  custom:video-encoder-webm-vp8: eb34c28f22e8b96e1ab97ce403110664 -> 
  custom:framework-osx-AVFoundation: b23960f63f64bdc6ff669e2cdcee2391 -> 
  custom:audio-encoder-webm-vorbis: bf7c407c2cedff20999df2af8eb42d56 -> 
  custom:container-demuxer-ogg: 62fdf1f143b41e24485cea50d1cbac27 -> 
  custom:video-decoder-webm-vp8: 9c59270c3fd7afecdb556c50c9e8de78 -> 
  custom:audio-decoder-ogg-vorbis: bf7c407c2cedff20999df2af8eb42d56 -> 
========================================================================
Received Prepare
Registering precompiled user dll's ...
Registered in 0.003705 seconds.
Begin MonoManager ReloadAssembly
Symbol file LoadedFromMemory doesn't match image /Users/kamilaamendolagine/Desktop/Staugen Raug v2 - Prefab - Map 1.01/Library/PackageCache/com.unity.visualscripting@1.7.8/Editor/VisualScripting.Core/Dependencies/YamlDotNet/Unity.VisualScripting.YamlDotNet.dll
Symbol file LoadedFromMemory doesn't match image /Users/kamilaamendolagine/Desktop/Staugen Raug v2 - Prefab - Map 1.01/Library/PackageCache/com.unity.visualscripting@1.7.8/Editor/VisualScripting.Core/Dependencies/DotNetZip/Unity.VisualScripting.IonicZip.dll
Native extension for OSXStandalone target not found
Native extension for WebGL target not found
Refreshing native plugins compatible for Editor in 0.85 ms, found 2 plugins.
Preloading 0 native plugins for Editor in 0.00 ms.
Mono: successfully reloaded assembly
- Completed reload, in  1.833 seconds
Domain Reload Profiling:
	ReloadAssembly (1834ms)
		BeginReloadAssembly (202ms)
			ExecutionOrderSort (0ms)
			DisableScriptedObjects (10ms)
			BackupInstance (0ms)
			ReleaseScriptingObjects (0ms)
			CreateAndSetChildDomain (87ms)
		EndReloadAssembly (1461ms)
			LoadAssemblies (91ms)
			RebuildTransferFunctionScriptingTraits (0ms)
			SetupTypeCache (491ms)
			ReleaseScriptCaches (1ms)
			RebuildScriptCaches (74ms)
			SetupLoadedEditorAssemblies (691ms)
				LogAssemblyErrors (0ms)
				InitializePlatformSupportModulesInManaged (18ms)
				SetLoadedEditorAssemblies (1ms)
				RefreshPlugins (1ms)
				BeforeProcessingInitializeOnLoad (99ms)
				ProcessInitializeOnLoadAttributes (516ms)
				ProcessInitializeOnLoadMethodAttributes (52ms)
				AfterProcessingInitializeOnLoad (5ms)
				EditorAssembliesLoaded (0ms)
			ExecutionOrderSort2 (0ms)
			AwakeInstancesAfterBackupRestoration (9ms)
Platform modules already initialized, skipping
Compilation succeeded with: 

program_source:299:53: warning: writable resources in non-void post-tessellation vertex function
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
                                                    ^
program_source:305:30: note: writable buffer defined here
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
                             ^
program_source:306:48: note: writable buffer defined here
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
                                               ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float4 TEXCOORD0 [[ attribute(3) ]] ;
    float4 TEXCOORD1 [[ attribute(4) ]] ;
    float4 TEXCOORD2 [[ attribute(5) ]] ;
    float4 TEXCOORD3 [[ attribute(6) ]] ;
    float4 COLOR0 [[ attribute(7) ]] ;
};
struct Mtl_VertexOut
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float4 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float4 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float4 TEXCOORD3 [[ user(TEXCOORD3) ]];
    float4 COLOR0 [[ user(COLOR0) ]];
};
static Mtl_VertexOut vertexFunction(
    Mtl_VertexIn input)
{
    Mtl_VertexOut output;
    output.INTERNALTESSPOS0 = input.POSITION0;
    output.TANGENT0 = input.TANGENT0;
    output.NORMAL0.xyz = input.NORMAL0.xyz;
    output.TEXCOORD0 = input.TEXCOORD0;
    output.TEXCOORD1 = input.TEXCOORD1;
    output.TEXCOORD2 = input.TEXCOORD2;
    output.TEXCOORD3 = input.TEXCOORD3;
    output.COLOR0 = input.COLOR0;
    return output;
}
// SHADER_STAGE_HULL_begin
struct Mtl_ControlPoint
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float4 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float4 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float4 TEXCOORD3 [[ user(TEXCOORD3) ]];
    float4 COLOR0 [[ user(COLOR0) ]];
};
struct Mtl_ControlPointIn
{
    float4 INTERNALTESSPOS0 [[ attribute(8) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float4 TEXCOORD0 [[ attribute(3) ]] ;
    float4 TEXCOORD1 [[ attribute(4) ]] ;
    float4 TEXCOORD2 [[ attribute(5) ]] ;
    float4 TEXCOORD3 [[ attribute(6) ]] ;
    float4 COLOR0 [[ attribute(7) ]] ;
};
struct Mtl_KernelPatchInfo
{
    uint numPatches;
    ushort numControlPointsPerPatch;
};
struct VGlobals_Type
{
    float4 _Time;
    float4 _SinTime;
    float4 _CosTime;
    float4 unity_DeltaTime;
    float3 _WorldSpaceCameraPos;
    float4 _ProjectionParams;
    float4 _ScreenParams;
    float4 _ZBufferParams;
    float4 unity_OrthoParams;
    float4 unity_CameraWorldClipPlanes[6];
    float4 hlslcc_mtx4x4unity_CameraProjection[4];
    float4 hlslcc_mtx4x4unity_CameraInvProjection[4];
    float4 hlslcc_mtx4x4unity_WorldToCamera[4];
    float4 hlslcc_mtx4x4unity_CameraToWorld[4];
    float4 _WorldSpaceLightPos0;
    float4 _LightPositionRange;
    float4 _LightProjectionParams;
    float4 unity_4LightPosX0;
    float4 unity_4LightPosY0;
    float4 unity_4LightPosZ0;
    float4 unity_4LightAtten0;
    float4 unity_LightColor[8];
    float4 unity_LightPosition[8];
    float4 unity_LightAtten[8];
    float4 unity_SpotDirection[8];
    float4 unity_SHAr;
    float4 unity_SHAg;
    float4 unity_SHAb;
    float4 unity_SHBr;
    float4 unity_SHBg;
    float4 unity_SHBb;
    float4 unity_SHC;
    float4 unity_OcclusionMaskSelector;
    float4 unity_ProbesOcclusion;
    float3 unity_LightColor0;
    float3 unity_LightColor1;
    float3 unity_LightColor2;
    float3 unity_LightColor3;
    float4 unity_ShadowSplitSpheres[4];
    float4 unity_ShadowSplitSqRadii;
    float4 unity_LightShadowBias;
    float4 _LightSplitsNear;
    float4 _LightSplitsFar;
    float4 hlslcc_mtx4x4unity_WorldToShadow[16];
    float4 _LightShadowData;
    float4 unity_ShadowFadeCenterAndType;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 unity_LODFade;
    float4 unity_WorldTransformParams;
    float4 unity_RenderingLayer;
    float4 hlslcc_mtx4x4glstate_matrix_transpose_modelview0[4];
    float4 glstate_lightmodel_ambient;
    float4 unity_AmbientSky;
    float4 unity_AmbientEquator;
    float4 unity_AmbientGround;
    float4 unity_IndirectSpecColor;
    float4 hlslcc_mtx4x4glstate_matrix_projection[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixInvV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    int unity_StereoEyeIndex;
    float4 unity_ShadowColor;
    float4 unity_FogColor;
    float4 unity_FogParams;
    float4 unity_LightmapST;
    float4 unity_DynamicLightmapST;
    float4 unity_SpecCube0_BoxMax;
    float4 unity_SpecCube0_BoxMin;
    float4 unity_SpecCube0_ProbePosition;
    float4 unity_SpecCube0_HDR;
    float4 unity_SpecCube1_BoxMax;
    float4 unity_SpecCube1_BoxMin;
    float4 unity_SpecCube1_ProbePosition;
    float4 unity_SpecCube1_HDR;
    float4 unity_ProbeVolumeParams;
    float4 hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[4];
    float3 unity_ProbeVolumeSizeInv;
    float3 unity_ProbeVolumeMin;
    float4 unity_Lightmap_HDR;
    float4 unity_DynamicLightmap_HDR;
    float4 _LightColor0;
    float4 _SpecColor;
    float _Tile;
    float _HeightDisplacement;
    float _NormalScale;
    float4 _ColorTint;
    float _MetallicStrength;
    float _SmoothnessStrength;
    float _EdgeLength;
    float4 _texcoord_ST;
};
struct Mtl_HullIn
{
    Mtl_VertexOut cp[3];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
kernel void patchKernel(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn vertexInput [[ stage_in ]],
    uint2 tID [[ thread_position_in_grid ]],
    ushort2 groupID [[ threadgroup_position_in_grid ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    constant Mtl_KernelPatchInfo &patchInfo [[ buffer(3) ]])
{
#pragma clang diagnostic pop
    Mtl_ControlPoint output;
    const uint numPatchesInThreadGroup = 10;
    const uint patchID = (tID.x / patchInfo.numControlPointsPerPatch);
    const bool patchValid = (patchID < patchInfo.numPatches);
    const uint mtl_BaseInstance = 0;
    const uint mtl_InstanceID = groupID.y - mtl_BaseInstance;
    const uint internalPatchID = mtl_InstanceID * patchInfo.numPatches + patchID;
    const uint patchIDInThreadGroup = (patchID % numPatchesInThreadGroup);
    const uint controlPointID = (tID.x % patchInfo.numControlPointsPerPatch);
    const uint mtl_BaseVertex = 0;
    const uint mtl_VertexID = ((mtl_InstanceID * (patchInfo.numControlPointsPerPatch * patchInfo.numPatches)) + tID.x) - mtl_BaseVertex;
    threadgroup Mtl_HullIn inputGroup[numPatchesInThreadGroup];
    threadgroup Mtl_HullIn &input = inputGroup[patchIDInThreadGroup];
    MTLTriangleTessellationFactorsHalf tessFactor;
    if (patchValid) {
        input.cp[controlPointID] = vertexFunction(vertexInput);
        output.INTERNALTESSPOS0 = input.cp[controlPointID].INTERNALTESSPOS0;
        output.TANGENT0 = input.cp[controlPointID].TANGENT0;
        output.NORMAL0 = input.cp[controlPointID].NORMAL0;
        output.TEXCOORD0 = input.cp[controlPointID].TEXCOORD0;
        output.TEXCOORD1 = input.cp[controlPointID].TEXCOORD1;
        output.TEXCOORD2 = input.cp[controlPointID].TEXCOORD2;
        output.TEXCOORD3 = input.cp[controlPointID].TEXCOORD3;
        output.COLOR0 = input.cp[controlPointID].COLOR0;
    }
    threadgroup_barrier(mem_flags::mem_threadgroup);
    if (!patchValid) {
        return;
    }
    float3 u_xlat0;
    float3 u_xlat1;
    float3 u_xlat2;
    float3 u_xlat3;
    float3 u_xlat4;
    float u_xlat12;
    float u_xlat13;
    // fork_phase2
    {
        u_xlat0.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[1].INTERNALTESSPOS0.yyy;
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[1].INTERNALTESSPOS0.xxx, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[1].INTERNALTESSPOS0.zzz, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[1].INTERNALTESSPOS0.www, u_xlat0.xyz);
        u_xlat1.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[2].INTERNALTESSPOS0.yyy;
        u_xlat1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[2].INTERNALTESSPOS0.xxx, u_xlat1.xyz);
        u_xlat1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[2].INTERNALTESSPOS0.zzz, u_xlat1.xyz);
        u_xlat1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[2].INTERNALTESSPOS0.www, u_xlat1.xyz);
        u_xlat2.xyz = u_xlat0.xyz + u_xlat1.xyz;
        u_xlat2.xyz = fma(u_xlat2.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat12 = dot(u_xlat2.xyz, u_xlat2.xyz);
        u_xlat12 = sqrt(u_xlat12);
        u_xlat12 = u_xlat12 * VGlobals._EdgeLength;
        u_xlat2.xyz = u_xlat0.xyz + (-u_xlat1.xyz);
        u_xlat13 = dot(u_xlat2.xyz, u_xlat2.xyz);
        u_xlat13 = sqrt(u_xlat13);
        u_xlat13 = u_xlat13 * VGlobals._ScreenParams.y;
        u_xlat12 = u_xlat13 / u_xlat12;
        tessFactor.edgeTessellationFactor[0] = max(u_xlat12, 1.0);
        u_xlat2.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[0].INTERNALTESSPOS0.yyy;
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[0].INTERNALTESSPOS0.xxx, u_xlat2.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[0].INTERNALTESSPOS0.zzz, u_xlat2.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[0].INTERNALTESSPOS0.www, u_xlat2.xyz);
        u_xlat3.xyz = u_xlat1.xyz + u_xlat2.xyz;
        u_xlat1.xyz = u_xlat1.xyz + (-u_xlat2.xyz);
        u_xlat12 = dot(u_xlat1.xyz, u_xlat1.xyz);
        u_xlat12 = sqrt(u_xlat12);
        u_xlat12 = u_xlat12 * VGlobals._ScreenParams.y;
        u_xlat1.xyz = fma(u_xlat3.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat1.x = dot(u_xlat1.xyz, u_xlat1.xyz);
        u_xlat1.x = sqrt(u_xlat1.x);
        u_xlat1.x = u_xlat1.x * VGlobals._EdgeLength;
        u_xlat12 = u_xlat12 / u_xlat1.x;
        tessFactor.edgeTessellationFactor[1] = max(u_xlat12, 1.0);
        u_xlat1.xyz = u_xlat0.xyz + u_xlat2.xyz;
        u_xlat0.xyz = (-u_xlat0.xyz) + u_xlat2.xyz;
        u_xlat0.x = dot(u_xlat0.xyz, u_xlat0.xyz);
        u_xlat0.x = sqrt(u_xlat0.x);
        u_xlat0.x = u_xlat0.x * VGlobals._ScreenParams.y;
        u_xlat4.xyz = fma(u_xlat1.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat4.x = dot(u_xlat4.xyz, u_xlat4.xyz);
        u_xlat4.x = sqrt(u_xlat4.x);
        u_xlat4.x = u_xlat4.x * VGlobals._EdgeLength;
        u_xlat0.x = u_xlat0.x / u_xlat4.x;
        tessFactor.edgeTessellationFactor[2] = max(u_xlat0.x, 1.0);
    }
    // join_phase3
    {
        u_xlat0.x = tessFactor.edgeTessellationFactor[0] + tessFactor.edgeTessellationFactor[1];
        u_xlat0.x = u_xlat0.x + tessFactor.edgeTessellationFactor[2];
        tessFactor.insideTessellationFactor = u_xlat0.x * 0.333333343;
    }
    controlPoints[mtl_VertexID] = output;
    tessFactors[internalPatchID] = tessFactor;
}
// SHADER_STAGE_HULL_end
// SHADER_STAGE_DOMAIN_begin
struct Mtl_VertexInPostTess
{
    patch_control_point<Mtl_ControlPointIn> cp;
};
struct Mtl_VertexOutPostTess
{
    float4 mtl_Position [[ position ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float4 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float4 TEXCOORD3 [[ user(TEXCOORD3) ]];
    float4 TEXCOORD6 [[ user(TEXCOORD6) ]];
    float4 TEXCOORD7 [[ user(TEXCOORD7) ]];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    sampler sampler_Height [[ sampler (0) ]],
    texture2d<float, access::sample > _Height [[ texture(0) ]] ,
    float3 mtl_TessCoord [[ position_in_patch ]],
    uint patchID [[ patch_id ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    Mtl_VertexInPostTess input [[ stage_in ]])
{
#pragma clang diagnostic pop
    Mtl_VertexOutPostTess output;
    MTLTriangleTessellationFactorsHalf tessFactor;
    tessFactor = tessFactors[patchID];
    float4 u_xlat0;
    float4 u_xlat1;
    float4 u_xlat2;
    float4 u_xlat3;
    float2 u_xlat9;
    float u_xlat12;
    float u_xlat13;
    u_xlat0 = mtl_TessCoord.yyyy * input.cp[1].INTERNALTESSPOS0;
    u_xlat0 = fma(input.cp[0].INTERNALTESSPOS0, mtl_TessCoord.xxxx, u_xlat0);
    u_xlat0 = fma(input.cp[2].INTERNALTESSPOS0, mtl_TessCoord.zzzz, u_xlat0);
    u_xlat1.xy = mtl_TessCoord.yy * input.cp[1].TEXCOORD0.xy;
    u_xlat1.xy = fma(input.cp[0].TEXCOORD0.xy, mtl_TessCoord.xx, u_xlat1.xy);
    u_xlat1.xy = fma(input.cp[2].TEXCOORD0.xy, mtl_TessCoord.zz, u_xlat1.xy);
    u_xlat9.xy = u_xlat1.xy * float2(VGlobals._Tile);
    output.TEXCOORD0.xy = fma(u_xlat1.xy, VGlobals._texcoord_ST.xy, VGlobals._texcoord_ST.zw);
    u_xlat1.xyz = _Height.sample(sampler_Height, u_xlat9.xy, level(1.0)).xyz;
    u_xlat2.xyz = mtl_TessCoord.yyy * input.cp[1].NORMAL0.xyz;
    u_xlat2.xyz = fma(input.cp[0].NORMAL0.xyz, mtl_TessCoord.xxx, u_xlat2.xyz);
    u_xlat2.xyz = fma(input.cp[2].NORMAL0.xyz, mtl_TessCoord.zzz, u_xlat2.xyz);
    u_xlat1.xyz = u_xlat1.xyz * u_xlat2.xyz;
    u_xlat0.xyz = fma(u_xlat1.xyz, float3(VGlobals._HeightDisplacement), u_xlat0.xyz);
    u_xlat1 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], u_xlat0.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], u_xlat0.zzzz, u_xlat1);
    u_xlat3 = u_xlat1 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, u_xlat0.www, u_xlat1.xyz);
    u_xlat1 = u_xlat3.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat3.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat3.zzzz, u_xlat1);
    output.mtl_Position = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat3.wwww, u_xlat1);
    u_xlat1.y = dot(u_xlat2.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat1.z = dot(u_xlat2.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat1.x = dot(u_xlat2.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat12 = dot(u_xlat1.xyz, u_xlat1.xyz);
    u_xlat12 = rsqrt(u_xlat12);
    u_xlat1.xyz = float3(u_xlat12) * u_xlat1.xyz;
    output.TEXCOORD1.z = u_xlat1.y;
    u_xlat2 = mtl_TessCoord.yyyy * input.cp[1].TANGENT0;
    u_xlat2 = fma(input.cp[0].TANGENT0, mtl_TessCoord.xxxx, u_xlat2);
    u_xlat2 = fma(input.cp[2].TANGENT0, mtl_TessCoord.zzzz, u_xlat2);
    u_xlat3.xyz = u_xlat2.yyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].yzx;
    u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].yzx, u_xlat2.xxx, u_xlat3.xyz);
    u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].yzx, u_xlat2.zzz, u_xlat3.xyz);
    u_xlat12 = u_xlat2.w * VGlobals.unity_WorldTransformParams.w;
    u_xlat13 = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat13 = rsqrt(u_xlat13);
    u_xlat2.xyz = float3(u_xlat13) * u_xlat2.xyz;
    u_xlat3.xyz = u_xlat1.xyz * u_xlat2.xyz;
    u_xlat3.xyz = fma(u_xlat1.zxy, u_xlat2.yzx, (-u_xlat3.xyz));
    u_xlat3.xyz = float3(u_xlat12) * u_xlat3.xyz;
    output.TEXCOORD1.y = u_xlat3.x;
    output.TEXCOORD1.w = u_xlat0.x;
    output.TEXCOORD1.x = u_xlat2.z;
    output.TEXCOORD2.w = u_xlat0.y;
    output.TEXCOORD3.w = u_xlat0.z;
    output.TEXCOORD2.x = u_xlat2.x;
    output.TEXCOORD3.x = u_xlat2.y;
    output.TEXCOORD2.z = u_xlat1.z;
    output.TEXCOORD3.z = u_xlat1.x;
    output.TEXCOORD2.y = u_xlat3.y;
    output.TEXCOORD3.y = u_xlat3.z;
    output.TEXCOORD6 = float4(0.0, 0.0, 0.0, 0.0);
    output.TEXCOORD7 = float4(0.0, 0.0, 0.0, 0.0);
    return output;
}
// SHADER_STAGE_DOMAIN_end
Compilation succeeded with: 

program_source:301:53: warning: writable resources in non-void post-tessellation vertex function
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
                                                    ^
program_source:307:30: note: writable buffer defined here
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
                             ^
program_source:308:48: note: writable buffer defined here
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
                                               ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float4 TEXCOORD0 [[ attribute(3) ]] ;
    float4 TEXCOORD1 [[ attribute(4) ]] ;
    float4 TEXCOORD2 [[ attribute(5) ]] ;
    float4 TEXCOORD3 [[ attribute(6) ]] ;
    float4 COLOR0 [[ attribute(7) ]] ;
};
struct Mtl_VertexOut
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float4 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float4 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float4 TEXCOORD3 [[ user(TEXCOORD3) ]];
    float4 COLOR0 [[ user(COLOR0) ]];
};
static Mtl_VertexOut vertexFunction(
    Mtl_VertexIn input)
{
    Mtl_VertexOut output;
    output.INTERNALTESSPOS0 = input.POSITION0;
    output.TANGENT0 = input.TANGENT0;
    output.NORMAL0.xyz = input.NORMAL0.xyz;
    output.TEXCOORD0 = input.TEXCOORD0;
    output.TEXCOORD1 = input.TEXCOORD1;
    output.TEXCOORD2 = input.TEXCOORD2;
    output.TEXCOORD3 = input.TEXCOORD3;
    output.COLOR0 = input.COLOR0;
    return output;
}
// SHADER_STAGE_HULL_begin
struct Mtl_ControlPoint
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float4 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float4 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float4 TEXCOORD3 [[ user(TEXCOORD3) ]];
    float4 COLOR0 [[ user(COLOR0) ]];
};
struct Mtl_ControlPointIn
{
    float4 INTERNALTESSPOS0 [[ attribute(8) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float4 TEXCOORD0 [[ attribute(3) ]] ;
    float4 TEXCOORD1 [[ attribute(4) ]] ;
    float4 TEXCOORD2 [[ attribute(5) ]] ;
    float4 TEXCOORD3 [[ attribute(6) ]] ;
    float4 COLOR0 [[ attribute(7) ]] ;
};
struct Mtl_KernelPatchInfo
{
    uint numPatches;
    ushort numControlPointsPerPatch;
};
struct VGlobals_Type
{
    float4 _Time;
    float4 _SinTime;
    float4 _CosTime;
    float4 unity_DeltaTime;
    float3 _WorldSpaceCameraPos;
    float4 _ProjectionParams;
    float4 _ScreenParams;
    float4 _ZBufferParams;
    float4 unity_OrthoParams;
    float4 unity_CameraWorldClipPlanes[6];
    float4 hlslcc_mtx4x4unity_CameraProjection[4];
    float4 hlslcc_mtx4x4unity_CameraInvProjection[4];
    float4 hlslcc_mtx4x4unity_WorldToCamera[4];
    float4 hlslcc_mtx4x4unity_CameraToWorld[4];
    float4 _WorldSpaceLightPos0;
    float4 _LightPositionRange;
    float4 _LightProjectionParams;
    float4 unity_4LightPosX0;
    float4 unity_4LightPosY0;
    float4 unity_4LightPosZ0;
    float4 unity_4LightAtten0;
    float4 unity_LightColor[8];
    float4 unity_LightPosition[8];
    float4 unity_LightAtten[8];
    float4 unity_SpotDirection[8];
    float4 unity_SHAr;
    float4 unity_SHAg;
    float4 unity_SHAb;
    float4 unity_SHBr;
    float4 unity_SHBg;
    float4 unity_SHBb;
    float4 unity_SHC;
    float4 unity_OcclusionMaskSelector;
    float4 unity_ProbesOcclusion;
    float3 unity_LightColor0;
    float3 unity_LightColor1;
    float3 unity_LightColor2;
    float3 unity_LightColor3;
    float4 unity_ShadowSplitSpheres[4];
    float4 unity_ShadowSplitSqRadii;
    float4 unity_LightShadowBias;
    float4 _LightSplitsNear;
    float4 _LightSplitsFar;
    float4 hlslcc_mtx4x4unity_WorldToShadow[16];
    float4 _LightShadowData;
    float4 unity_ShadowFadeCenterAndType;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 unity_LODFade;
    float4 unity_WorldTransformParams;
    float4 unity_RenderingLayer;
    float4 hlslcc_mtx4x4glstate_matrix_transpose_modelview0[4];
    float4 glstate_lightmodel_ambient;
    float4 unity_AmbientSky;
    float4 unity_AmbientEquator;
    float4 unity_AmbientGround;
    float4 unity_IndirectSpecColor;
    float4 hlslcc_mtx4x4glstate_matrix_projection[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixInvV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    int unity_StereoEyeIndex;
    float4 unity_ShadowColor;
    float4 unity_FogColor;
    float4 unity_FogParams;
    float4 unity_LightmapST;
    float4 unity_DynamicLightmapST;
    float4 unity_SpecCube0_BoxMax;
    float4 unity_SpecCube0_BoxMin;
    float4 unity_SpecCube0_ProbePosition;
    float4 unity_SpecCube0_HDR;
    float4 unity_SpecCube1_BoxMax;
    float4 unity_SpecCube1_BoxMin;
    float4 unity_SpecCube1_ProbePosition;
    float4 unity_SpecCube1_HDR;
    float4 unity_ProbeVolumeParams;
    float4 hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[4];
    float3 unity_ProbeVolumeSizeInv;
    float3 unity_ProbeVolumeMin;
    float4 unity_Lightmap_HDR;
    float4 unity_DynamicLightmap_HDR;
    float4 _LightColor0;
    float4 _SpecColor;
    float4 hlslcc_mtx4x4unity_WorldToLight[4];
    float _Tile;
    float _HeightDisplacement;
    float _NormalScale;
    float4 _ColorTint;
    float _MetallicStrength;
    float _SmoothnessStrength;
    float _EdgeLength;
    float4 _texcoord_ST;
};
struct Mtl_HullIn
{
    Mtl_VertexOut cp[3];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
kernel void patchKernel(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn vertexInput [[ stage_in ]],
    uint2 tID [[ thread_position_in_grid ]],
    ushort2 groupID [[ threadgroup_position_in_grid ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    constant Mtl_KernelPatchInfo &patchInfo [[ buffer(3) ]])
{
#pragma clang diagnostic pop
    Mtl_ControlPoint output;
    const uint numPatchesInThreadGroup = 10;
    const uint patchID = (tID.x / patchInfo.numControlPointsPerPatch);
    const bool patchValid = (patchID < patchInfo.numPatches);
    const uint mtl_BaseInstance = 0;
    const uint mtl_InstanceID = groupID.y - mtl_BaseInstance;
    const uint internalPatchID = mtl_InstanceID * patchInfo.numPatches + patchID;
    const uint patchIDInThreadGroup = (patchID % numPatchesInThreadGroup);
    const uint controlPointID = (tID.x % patchInfo.numControlPointsPerPatch);
    const uint mtl_BaseVertex = 0;
    const uint mtl_VertexID = ((mtl_InstanceID * (patchInfo.numControlPointsPerPatch * patchInfo.numPatches)) + tID.x) - mtl_BaseVertex;
    threadgroup Mtl_HullIn inputGroup[numPatchesInThreadGroup];
    threadgroup Mtl_HullIn &input = inputGroup[patchIDInThreadGroup];
    MTLTriangleTessellationFactorsHalf tessFactor;
    if (patchValid) {
        input.cp[controlPointID] = vertexFunction(vertexInput);
        output.INTERNALTESSPOS0 = input.cp[controlPointID].INTERNALTESSPOS0;
        output.TANGENT0 = input.cp[controlPointID].TANGENT0;
        output.NORMAL0 = input.cp[controlPointID].NORMAL0;
        output.TEXCOORD0 = input.cp[controlPointID].TEXCOORD0;
        output.TEXCOORD1 = input.cp[controlPointID].TEXCOORD1;
        output.TEXCOORD2 = input.cp[controlPointID].TEXCOORD2;
        output.TEXCOORD3 = input.cp[controlPointID].TEXCOORD3;
        output.COLOR0 = input.cp[controlPointID].COLOR0;
    }
    threadgroup_barrier(mem_flags::mem_threadgroup);
    if (!patchValid) {
        return;
    }
    float3 u_xlat0;
    float3 u_xlat1;
    float3 u_xlat2;
    float3 u_xlat3;
    float3 u_xlat4;
    float u_xlat12;
    float u_xlat13;
    // fork_phase2
    {
        u_xlat0.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[1].INTERNALTESSPOS0.yyy;
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[1].INTERNALTESSPOS0.xxx, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[1].INTERNALTESSPOS0.zzz, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[1].INTERNALTESSPOS0.www, u_xlat0.xyz);
        u_xlat1.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[2].INTERNALTESSPOS0.yyy;
        u_xlat1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[2].INTERNALTESSPOS0.xxx, u_xlat1.xyz);
        u_xlat1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[2].INTERNALTESSPOS0.zzz, u_xlat1.xyz);
        u_xlat1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[2].INTERNALTESSPOS0.www, u_xlat1.xyz);
        u_xlat2.xyz = u_xlat0.xyz + u_xlat1.xyz;
        u_xlat2.xyz = fma(u_xlat2.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat12 = dot(u_xlat2.xyz, u_xlat2.xyz);
        u_xlat12 = sqrt(u_xlat12);
        u_xlat12 = u_xlat12 * VGlobals._EdgeLength;
        u_xlat2.xyz = u_xlat0.xyz + (-u_xlat1.xyz);
        u_xlat13 = dot(u_xlat2.xyz, u_xlat2.xyz);
        u_xlat13 = sqrt(u_xlat13);
        u_xlat13 = u_xlat13 * VGlobals._ScreenParams.y;
        u_xlat12 = u_xlat13 / u_xlat12;
        tessFactor.edgeTessellationFactor[0] = max(u_xlat12, 1.0);
        u_xlat2.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[0].INTERNALTESSPOS0.yyy;
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[0].INTERNALTESSPOS0.xxx, u_xlat2.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[0].INTERNALTESSPOS0.zzz, u_xlat2.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[0].INTERNALTESSPOS0.www, u_xlat2.xyz);
        u_xlat3.xyz = u_xlat1.xyz + u_xlat2.xyz;
        u_xlat1.xyz = u_xlat1.xyz + (-u_xlat2.xyz);
        u_xlat12 = dot(u_xlat1.xyz, u_xlat1.xyz);
        u_xlat12 = sqrt(u_xlat12);
        u_xlat12 = u_xlat12 * VGlobals._ScreenParams.y;
        u_xlat1.xyz = fma(u_xlat3.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat1.x = dot(u_xlat1.xyz, u_xlat1.xyz);
        u_xlat1.x = sqrt(u_xlat1.x);
        u_xlat1.x = u_xlat1.x * VGlobals._EdgeLength;
        u_xlat12 = u_xlat12 / u_xlat1.x;
        tessFactor.edgeTessellationFactor[1] = max(u_xlat12, 1.0);
        u_xlat1.xyz = u_xlat0.xyz + u_xlat2.xyz;
        u_xlat0.xyz = (-u_xlat0.xyz) + u_xlat2.xyz;
        u_xlat0.x = dot(u_xlat0.xyz, u_xlat0.xyz);
        u_xlat0.x = sqrt(u_xlat0.x);
        u_xlat0.x = u_xlat0.x * VGlobals._ScreenParams.y;
        u_xlat4.xyz = fma(u_xlat1.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat4.x = dot(u_xlat4.xyz, u_xlat4.xyz);
        u_xlat4.x = sqrt(u_xlat4.x);
        u_xlat4.x = u_xlat4.x * VGlobals._EdgeLength;
        u_xlat0.x = u_xlat0.x / u_xlat4.x;
        tessFactor.edgeTessellationFactor[2] = max(u_xlat0.x, 1.0);
    }
    // join_phase3
    {
        u_xlat0.x = tessFactor.edgeTessellationFactor[0] + tessFactor.edgeTessellationFactor[1];
        u_xlat0.x = u_xlat0.x + tessFactor.edgeTessellationFactor[2];
        tessFactor.insideTessellationFactor = u_xlat0.x * 0.333333343;
    }
    controlPoints[mtl_VertexID] = output;
    tessFactors[internalPatchID] = tessFactor;
}
// SHADER_STAGE_HULL_end
// SHADER_STAGE_DOMAIN_begin
struct Mtl_VertexInPostTess
{
    patch_control_point<Mtl_ControlPointIn> cp;
};
struct Mtl_VertexOutPostTess
{
    float4 mtl_Position [[ position ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float3 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float3 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float3 TEXCOORD3 [[ user(TEXCOORD3) ]];
    float3 TEXCOORD4 [[ user(TEXCOORD4) ]];
    float3 TEXCOORD5 [[ user(TEXCOORD5) ]];
    float4 TEXCOORD6 [[ user(TEXCOORD6) ]];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    sampler sampler_Height [[ sampler (0) ]],
    texture2d<float, access::sample > _Height [[ texture(0) ]] ,
    float3 mtl_TessCoord [[ position_in_patch ]],
    uint patchID [[ patch_id ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    Mtl_VertexInPostTess input [[ stage_in ]])
{
#pragma clang diagnostic pop
    Mtl_VertexOutPostTess output;
    MTLTriangleTessellationFactorsHalf tessFactor;
    tessFactor = tessFactors[patchID];
    float4 u_xlat0;
    float3 u_xlat1;
    float4 u_xlat2;
    float4 u_xlat3;
    float4 u_xlat4;
    float2 u_xlat10;
    float u_xlat16;
    u_xlat0.xy = mtl_TessCoord.yy * input.cp[1].TEXCOORD0.xy;
    u_xlat0.xy = fma(input.cp[0].TEXCOORD0.xy, mtl_TessCoord.xx, u_xlat0.xy);
    u_xlat0.xy = fma(input.cp[2].TEXCOORD0.xy, mtl_TessCoord.zz, u_xlat0.xy);
    u_xlat10.xy = u_xlat0.xy * float2(VGlobals._Tile);
    output.TEXCOORD0.xy = fma(u_xlat0.xy, VGlobals._texcoord_ST.xy, VGlobals._texcoord_ST.zw);
    u_xlat0.xyz = _Height.sample(sampler_Height, u_xlat10.xy, level(1.0)).xyz;
    u_xlat1.xyz = mtl_TessCoord.yyy * input.cp[1].NORMAL0.xyz;
    u_xlat1.xyz = fma(input.cp[0].NORMAL0.xyz, mtl_TessCoord.xxx, u_xlat1.xyz);
    u_xlat1.xyz = fma(input.cp[2].NORMAL0.xyz, mtl_TessCoord.zzz, u_xlat1.xyz);
    u_xlat0.xyz = u_xlat0.xyz * u_xlat1.xyz;
    u_xlat2 = mtl_TessCoord.yyyy * input.cp[1].INTERNALTESSPOS0;
    u_xlat2 = fma(input.cp[0].INTERNALTESSPOS0, mtl_TessCoord.xxxx, u_xlat2);
    u_xlat2 = fma(input.cp[2].INTERNALTESSPOS0, mtl_TessCoord.zzzz, u_xlat2);
    u_xlat0.xyz = fma(u_xlat0.xyz, float3(VGlobals._HeightDisplacement), u_xlat2.xyz);
    u_xlat3 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], u_xlat0.xxxx, u_xlat3);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], u_xlat0.zzzz, u_xlat3);
    u_xlat3 = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat4 = u_xlat3.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat4 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat3.xxxx, u_xlat4);
    u_xlat4 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat3.zzzz, u_xlat4);
    output.mtl_Position = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat3.wwww, u_xlat4);
    u_xlat2.y = dot(u_xlat1.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat2.z = dot(u_xlat1.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat2.x = dot(u_xlat1.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat1.x = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat1.x = rsqrt(u_xlat1.x);
    u_xlat1.xyz = u_xlat1.xxx * u_xlat2.xyz;
    output.TEXCOORD1.z = u_xlat1.y;
    u_xlat3 = mtl_TessCoord.yyyy * input.cp[1].TANGENT0;
    u_xlat3 = fma(input.cp[0].TANGENT0, mtl_TessCoord.xxxx, u_xlat3);
    u_xlat3 = fma(input.cp[2].TANGENT0, mtl_TessCoord.zzzz, u_xlat3);
    u_xlat2.xyz = u_xlat3.yyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].yzx;
    u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].yzx, u_xlat3.xxx, u_xlat2.xyz);
    u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].yzx, u_xlat3.zzz, u_xlat2.xyz);
    u_xlat16 = u_xlat3.w * VGlobals.unity_WorldTransformParams.w;
    u_xlat3.x = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat3.x = rsqrt(u_xlat3.x);
    u_xlat2.xyz = u_xlat2.xyz * u_xlat3.xxx;
    u_xlat3.xyz = u_xlat1.xyz * u_xlat2.xyz;
    u_xlat3.xyz = fma(u_xlat1.zxy, u_xlat2.yzx, (-u_xlat3.xyz));
    u_xlat3.xyz = float3(u_xlat16) * u_xlat3.xyz;
    output.TEXCOORD1.y = u_xlat3.x;
    output.TEXCOORD1.x = u_xlat2.z;
    output.TEXCOORD2.x = u_xlat2.x;
    output.TEXCOORD3.x = u_xlat2.y;
    output.TEXCOORD2.z = u_xlat1.z;
    output.TEXCOORD3.z = u_xlat1.x;
    output.TEXCOORD2.y = u_xlat3.y;
    output.TEXCOORD3.y = u_xlat3.z;
    output.TEXCOORD4.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, u_xlat2.www, u_xlat0.xyz);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3], u_xlat2.wwww, u_xlat0);
    u_xlat1.xyz = u_xlat0.yyy * VGlobals.hlslcc_mtx4x4unity_WorldToLight[1].xyz;
    u_xlat1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_WorldToLight[0].xyz, u_xlat0.xxx, u_xlat1.xyz);
    u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_WorldToLight[2].xyz, u_xlat0.zzz, u_xlat1.xyz);
    output.TEXCOORD5.xyz = fma(VGlobals.hlslcc_mtx4x4unity_WorldToLight[3].xyz, u_xlat0.www, u_xlat0.xyz);
    output.TEXCOORD6 = float4(0.0, 0.0, 0.0, 0.0);
    return output;
}
// SHADER_STAGE_DOMAIN_end
Compilation succeeded with: 

program_source:293:53: warning: writable resources in non-void post-tessellation vertex function
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
                                                    ^
program_source:299:30: note: writable buffer defined here
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
                             ^
program_source:300:48: note: writable buffer defined here
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
                                               ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float4 TEXCOORD0 [[ attribute(3) ]] ;
    float4 TEXCOORD1 [[ attribute(4) ]] ;
    float4 TEXCOORD2 [[ attribute(5) ]] ;
    float4 TEXCOORD3 [[ attribute(6) ]] ;
    float4 COLOR0 [[ attribute(7) ]] ;
};
struct Mtl_VertexOut
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float4 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float4 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float4 TEXCOORD3 [[ user(TEXCOORD3) ]];
    float4 COLOR0 [[ user(COLOR0) ]];
};
static Mtl_VertexOut vertexFunction(
    Mtl_VertexIn input)
{
    Mtl_VertexOut output;
    output.INTERNALTESSPOS0 = input.POSITION0;
    output.TANGENT0 = input.TANGENT0;
    output.NORMAL0.xyz = input.NORMAL0.xyz;
    output.TEXCOORD0 = input.TEXCOORD0;
    output.TEXCOORD1 = input.TEXCOORD1;
    output.TEXCOORD2 = input.TEXCOORD2;
    output.TEXCOORD3 = input.TEXCOORD3;
    output.COLOR0 = input.COLOR0;
    return output;
}
// SHADER_STAGE_HULL_begin
struct Mtl_ControlPoint
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float4 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float4 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float4 TEXCOORD3 [[ user(TEXCOORD3) ]];
    float4 COLOR0 [[ user(COLOR0) ]];
};
struct Mtl_ControlPointIn
{
    float4 INTERNALTESSPOS0 [[ attribute(8) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float4 TEXCOORD0 [[ attribute(3) ]] ;
    float4 TEXCOORD1 [[ attribute(4) ]] ;
    float4 TEXCOORD2 [[ attribute(5) ]] ;
    float4 TEXCOORD3 [[ attribute(6) ]] ;
    float4 COLOR0 [[ attribute(7) ]] ;
};
struct Mtl_KernelPatchInfo
{
    uint numPatches;
    ushort numControlPointsPerPatch;
};
struct VGlobals_Type
{
    float4 _Time;
    float4 _SinTime;
    float4 _CosTime;
    float4 unity_DeltaTime;
    float3 _WorldSpaceCameraPos;
    float4 _ProjectionParams;
    float4 _ScreenParams;
    float4 _ZBufferParams;
    float4 unity_OrthoParams;
    float4 unity_CameraWorldClipPlanes[6];
    float4 hlslcc_mtx4x4unity_CameraProjection[4];
    float4 hlslcc_mtx4x4unity_CameraInvProjection[4];
    float4 hlslcc_mtx4x4unity_WorldToCamera[4];
    float4 hlslcc_mtx4x4unity_CameraToWorld[4];
    float4 _WorldSpaceLightPos0;
    float4 _LightPositionRange;
    float4 _LightProjectionParams;
    float4 unity_4LightPosX0;
    float4 unity_4LightPosY0;
    float4 unity_4LightPosZ0;
    float4 unity_4LightAtten0;
    float4 unity_LightColor[8];
    float4 unity_LightPosition[8];
    float4 unity_LightAtten[8];
    float4 unity_SpotDirection[8];
    float4 unity_SHAr;
    float4 unity_SHAg;
    float4 unity_SHAb;
    float4 unity_SHBr;
    float4 unity_SHBg;
    float4 unity_SHBb;
    float4 unity_SHC;
    float4 unity_OcclusionMaskSelector;
    float4 unity_ProbesOcclusion;
    float3 unity_LightColor0;
    float3 unity_LightColor1;
    float3 unity_LightColor2;
    float3 unity_LightColor3;
    float4 unity_ShadowSplitSpheres[4];
    float4 unity_ShadowSplitSqRadii;
    float4 unity_LightShadowBias;
    float4 _LightSplitsNear;
    float4 _LightSplitsFar;
    float4 hlslcc_mtx4x4unity_WorldToShadow[16];
    float4 _LightShadowData;
    float4 unity_ShadowFadeCenterAndType;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 unity_LODFade;
    float4 unity_WorldTransformParams;
    float4 unity_RenderingLayer;
    float4 hlslcc_mtx4x4glstate_matrix_transpose_modelview0[4];
    float4 glstate_lightmodel_ambient;
    float4 unity_AmbientSky;
    float4 unity_AmbientEquator;
    float4 unity_AmbientGround;
    float4 unity_IndirectSpecColor;
    float4 hlslcc_mtx4x4glstate_matrix_projection[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixInvV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    int unity_StereoEyeIndex;
    float4 unity_ShadowColor;
    float4 unity_FogColor;
    float4 unity_FogParams;
    float4 unity_LightmapST;
    float4 unity_DynamicLightmapST;
    float4 unity_SpecCube0_BoxMax;
    float4 unity_SpecCube0_BoxMin;
    float4 unity_SpecCube0_ProbePosition;
    float4 unity_SpecCube0_HDR;
    float4 unity_SpecCube1_BoxMax;
    float4 unity_SpecCube1_BoxMin;
    float4 unity_SpecCube1_ProbePosition;
    float4 unity_SpecCube1_HDR;
    float4 unity_ProbeVolumeParams;
    float4 hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[4];
    float3 unity_ProbeVolumeSizeInv;
    float3 unity_ProbeVolumeMin;
    float4 unity_Lightmap_HDR;
    float4 unity_DynamicLightmap_HDR;
    float4 _LightColor0;
    float4 _SpecColor;
    float _Tile;
    float _HeightDisplacement;
    float _NormalScale;
    float4 _ColorTint;
    float _MetallicStrength;
    float _SmoothnessStrength;
    float _EdgeLength;
};
struct Mtl_HullIn
{
    Mtl_VertexOut cp[3];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
kernel void patchKernel(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn vertexInput [[ stage_in ]],
    uint2 tID [[ thread_position_in_grid ]],
    ushort2 groupID [[ threadgroup_position_in_grid ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    constant Mtl_KernelPatchInfo &patchInfo [[ buffer(3) ]])
{
#pragma clang diagnostic pop
    Mtl_ControlPoint output;
    const uint numPatchesInThreadGroup = 10;
    const uint patchID = (tID.x / patchInfo.numControlPointsPerPatch);
    const bool patchValid = (patchID < patchInfo.numPatches);
    const uint mtl_BaseInstance = 0;
    const uint mtl_InstanceID = groupID.y - mtl_BaseInstance;
    const uint internalPatchID = mtl_InstanceID * patchInfo.numPatches + patchID;
    const uint patchIDInThreadGroup = (patchID % numPatchesInThreadGroup);
    const uint controlPointID = (tID.x % patchInfo.numControlPointsPerPatch);
    const uint mtl_BaseVertex = 0;
    const uint mtl_VertexID = ((mtl_InstanceID * (patchInfo.numControlPointsPerPatch * patchInfo.numPatches)) + tID.x) - mtl_BaseVertex;
    threadgroup Mtl_HullIn inputGroup[numPatchesInThreadGroup];
    threadgroup Mtl_HullIn &input = inputGroup[patchIDInThreadGroup];
    MTLTriangleTessellationFactorsHalf tessFactor;
    if (patchValid) {
        input.cp[controlPointID] = vertexFunction(vertexInput);
        output.INTERNALTESSPOS0 = input.cp[controlPointID].INTERNALTESSPOS0;
        output.TANGENT0 = input.cp[controlPointID].TANGENT0;
        output.NORMAL0 = input.cp[controlPointID].NORMAL0;
        output.TEXCOORD0 = input.cp[controlPointID].TEXCOORD0;
        output.TEXCOORD1 = input.cp[controlPointID].TEXCOORD1;
        output.TEXCOORD2 = input.cp[controlPointID].TEXCOORD2;
        output.TEXCOORD3 = input.cp[controlPointID].TEXCOORD3;
        output.COLOR0 = input.cp[controlPointID].COLOR0;
    }
    threadgroup_barrier(mem_flags::mem_threadgroup);
    if (!patchValid) {
        return;
    }
    float3 u_xlat0;
    float3 u_xlat1;
    float3 u_xlat2;
    float3 u_xlat3;
    float3 u_xlat4;
    float u_xlat12;
    float u_xlat13;
    // fork_phase2
    {
        u_xlat0.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[1].INTERNALTESSPOS0.yyy;
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[1].INTERNALTESSPOS0.xxx, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[1].INTERNALTESSPOS0.zzz, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[1].INTERNALTESSPOS0.www, u_xlat0.xyz);
        u_xlat1.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[2].INTERNALTESSPOS0.yyy;
        u_xlat1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[2].INTERNALTESSPOS0.xxx, u_xlat1.xyz);
        u_xlat1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[2].INTERNALTESSPOS0.zzz, u_xlat1.xyz);
        u_xlat1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[2].INTERNALTESSPOS0.www, u_xlat1.xyz);
        u_xlat2.xyz = u_xlat0.xyz + u_xlat1.xyz;
        u_xlat2.xyz = fma(u_xlat2.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat12 = dot(u_xlat2.xyz, u_xlat2.xyz);
        u_xlat12 = sqrt(u_xlat12);
        u_xlat12 = u_xlat12 * VGlobals._EdgeLength;
        u_xlat2.xyz = u_xlat0.xyz + (-u_xlat1.xyz);
        u_xlat13 = dot(u_xlat2.xyz, u_xlat2.xyz);
        u_xlat13 = sqrt(u_xlat13);
        u_xlat13 = u_xlat13 * VGlobals._ScreenParams.y;
        u_xlat12 = u_xlat13 / u_xlat12;
        tessFactor.edgeTessellationFactor[0] = max(u_xlat12, 1.0);
        u_xlat2.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[0].INTERNALTESSPOS0.yyy;
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[0].INTERNALTESSPOS0.xxx, u_xlat2.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[0].INTERNALTESSPOS0.zzz, u_xlat2.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[0].INTERNALTESSPOS0.www, u_xlat2.xyz);
        u_xlat3.xyz = u_xlat1.xyz + u_xlat2.xyz;
        u_xlat1.xyz = u_xlat1.xyz + (-u_xlat2.xyz);
        u_xlat12 = dot(u_xlat1.xyz, u_xlat1.xyz);
        u_xlat12 = sqrt(u_xlat12);
        u_xlat12 = u_xlat12 * VGlobals._ScreenParams.y;
        u_xlat1.xyz = fma(u_xlat3.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat1.x = dot(u_xlat1.xyz, u_xlat1.xyz);
        u_xlat1.x = sqrt(u_xlat1.x);
        u_xlat1.x = u_xlat1.x * VGlobals._EdgeLength;
        u_xlat12 = u_xlat12 / u_xlat1.x;
        tessFactor.edgeTessellationFactor[1] = max(u_xlat12, 1.0);
        u_xlat1.xyz = u_xlat0.xyz + u_xlat2.xyz;
        u_xlat0.xyz = (-u_xlat0.xyz) + u_xlat2.xyz;
        u_xlat0.x = dot(u_xlat0.xyz, u_xlat0.xyz);
        u_xlat0.x = sqrt(u_xlat0.x);
        u_xlat0.x = u_xlat0.x * VGlobals._ScreenParams.y;
        u_xlat4.xyz = fma(u_xlat1.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat4.x = dot(u_xlat4.xyz, u_xlat4.xyz);
        u_xlat4.x = sqrt(u_xlat4.x);
        u_xlat4.x = u_xlat4.x * VGlobals._EdgeLength;
        u_xlat0.x = u_xlat0.x / u_xlat4.x;
        tessFactor.edgeTessellationFactor[2] = max(u_xlat0.x, 1.0);
    }
    // join_phase3
    {
        u_xlat0.x = tessFactor.edgeTessellationFactor[0] + tessFactor.edgeTessellationFactor[1];
        u_xlat0.x = u_xlat0.x + tessFactor.edgeTessellationFactor[2];
        tessFactor.insideTessellationFactor = u_xlat0.x * 0.333333343;
    }
    controlPoints[mtl_VertexID] = output;
    tessFactors[internalPatchID] = tessFactor;
}
// SHADER_STAGE_HULL_end
// SHADER_STAGE_DOMAIN_begin
struct Mtl_VertexInPostTess
{
    patch_control_point<Mtl_ControlPointIn> cp;
};
struct Mtl_VertexOutPostTess
{
    float4 mtl_Position [[ position ]];
    float3 TEXCOORD1 [[ user(TEXCOORD1) ]];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    sampler sampler_Height [[ sampler (0) ]],
    texture2d<float, access::sample > _Height [[ texture(0) ]] ,
    float3 mtl_TessCoord [[ position_in_patch ]],
    uint patchID [[ patch_id ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    Mtl_VertexInPostTess input [[ stage_in ]])
{
#pragma clang diagnostic pop
    Mtl_VertexOutPostTess output;
    MTLTriangleTessellationFactorsHalf tessFactor;
    tessFactor = tessFactors[patchID];
    float4 u_xlat0;
    float4 u_xlat1;
    float4 u_xlat2;
    float4 u_xlat3;
    float4 u_xlat4;
    float u_xlat11;
    float u_xlat15;
    bool u_xlatb15;
    u_xlat0.xyz = mtl_TessCoord.yyy * input.cp[1].NORMAL0.xyz;
    u_xlat0.xyz = fma(input.cp[0].NORMAL0.xyz, mtl_TessCoord.xxx, u_xlat0.xyz);
    u_xlat0.xyz = fma(input.cp[2].NORMAL0.xyz, mtl_TessCoord.zzz, u_xlat0.xyz);
    u_xlat1.x = dot(u_xlat0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat1.y = dot(u_xlat0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat1.z = dot(u_xlat0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat15 = dot(u_xlat1.xyz, u_xlat1.xyz);
    u_xlat15 = rsqrt(u_xlat15);
    u_xlat1.xyz = float3(u_xlat15) * u_xlat1.xyz;
    u_xlat2.xy = mtl_TessCoord.yy * input.cp[1].TEXCOORD0.xy;
    u_xlat2.xy = fma(input.cp[0].TEXCOORD0.xy, mtl_TessCoord.xx, u_xlat2.xy);
    u_xlat2.xy = fma(input.cp[2].TEXCOORD0.xy, mtl_TessCoord.zz, u_xlat2.xy);
    u_xlat2.xy = u_xlat2.xy * float2(VGlobals._Tile);
    u_xlat2.xyz = _Height.sample(sampler_Height, u_xlat2.xy, level(1.0)).xyz;
    u_xlat0.xyz = u_xlat0.xyz * u_xlat2.xyz;
    u_xlat2 = mtl_TessCoord.yyyy * input.cp[1].INTERNALTESSPOS0;
    u_xlat2 = fma(input.cp[0].INTERNALTESSPOS0, mtl_TessCoord.xxxx, u_xlat2);
    u_xlat2 = fma(input.cp[2].INTERNALTESSPOS0, mtl_TessCoord.zzzz, u_xlat2);
    u_xlat0.xyz = fma(u_xlat0.xyz, float3(VGlobals._HeightDisplacement), u_xlat2.xyz);
    u_xlat3 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], u_xlat0.xxxx, u_xlat3);
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], u_xlat0.zzzz, u_xlat3);
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3], u_xlat2.wwww, u_xlat3);
    u_xlat2.xyz = fma((-u_xlat3.xyz), VGlobals._WorldSpaceLightPos0.www, VGlobals._WorldSpaceLightPos0.xyz);
    u_xlat15 = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat15 = rsqrt(u_xlat15);
    u_xlat2.xyz = float3(u_xlat15) * u_xlat2.xyz;
    u_xlat15 = dot(u_xlat1.xyz, u_xlat2.xyz);
    u_xlat15 = fma((-u_xlat15), u_xlat15, 1.0);
    u_xlat15 = sqrt(u_xlat15);
    u_xlat15 = u_xlat15 * VGlobals.unity_LightShadowBias.z;
    u_xlat1.xyz = fma((-u_xlat1.xyz), float3(u_xlat15), u_xlat3.xyz);
    u_xlatb15 = VGlobals.unity_LightShadowBias.z!=0.0;
    u_xlat1.xyz = (bool(u_xlatb15)) ? u_xlat1.xyz : u_xlat3.xyz;
    u_xlat4 = u_xlat1.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat4 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat1.xxxx, u_xlat4);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat1.zzzz, u_xlat4);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat3.wwww, u_xlat1);
    u_xlat15 = VGlobals.unity_LightShadowBias.x / u_xlat1.w;
    u_xlat15 = min(u_xlat15, 0.0);
    u_xlat15 = max(u_xlat15, -1.0);
    u_xlat15 = u_xlat15 + u_xlat1.z;
    u_xlat11 = min(u_xlat1.w, u_xlat15);
    output.mtl_Position.xyw = u_xlat1.xyw;
    u_xlat1.x = (-u_xlat15) + u_xlat11;
    output.mtl_Position.z = fma(VGlobals.unity_LightShadowBias.y, u_xlat1.x, u_xlat15);
    u_xlat1.xyz = u_xlat0.yyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz;
    u_xlat0.xyw = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, u_xlat0.xxx, u_xlat1.xyz);
    u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, u_xlat0.zzz, u_xlat0.xyw);
    output.TEXCOORD1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, u_xlat2.www, u_xlat0.xyz);
    return output;
}
// SHADER_STAGE_DOMAIN_end
Compilation succeeded with: 

program_source:299:53: warning: writable resources in non-void post-tessellation vertex function
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
                                                    ^
program_source:305:30: note: writable buffer defined here
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
                             ^
program_source:306:48: note: writable buffer defined here
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
                                               ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float4 TEXCOORD0 [[ attribute(3) ]] ;
    float4 TEXCOORD1 [[ attribute(4) ]] ;
    float4 TEXCOORD2 [[ attribute(5) ]] ;
    float4 TEXCOORD3 [[ attribute(6) ]] ;
    float4 COLOR0 [[ attribute(7) ]] ;
};
struct Mtl_VertexOut
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float4 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float4 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float4 TEXCOORD3 [[ user(TEXCOORD3) ]];
    float4 COLOR0 [[ user(COLOR0) ]];
};
static Mtl_VertexOut vertexFunction(
    Mtl_VertexIn input)
{
    Mtl_VertexOut output;
    output.INTERNALTESSPOS0 = input.POSITION0;
    output.TANGENT0 = input.TANGENT0;
    output.NORMAL0.xyz = input.NORMAL0.xyz;
    output.TEXCOORD0 = input.TEXCOORD0;
    output.TEXCOORD1 = input.TEXCOORD1;
    output.TEXCOORD2 = input.TEXCOORD2;
    output.TEXCOORD3 = input.TEXCOORD3;
    output.COLOR0 = input.COLOR0;
    return output;
}
// SHADER_STAGE_HULL_begin
struct Mtl_ControlPoint
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float4 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float4 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float4 TEXCOORD3 [[ user(TEXCOORD3) ]];
    float4 COLOR0 [[ user(COLOR0) ]];
};
struct Mtl_ControlPointIn
{
    float4 INTERNALTESSPOS0 [[ attribute(8) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float4 TEXCOORD0 [[ attribute(3) ]] ;
    float4 TEXCOORD1 [[ attribute(4) ]] ;
    float4 TEXCOORD2 [[ attribute(5) ]] ;
    float4 TEXCOORD3 [[ attribute(6) ]] ;
    float4 COLOR0 [[ attribute(7) ]] ;
};
struct Mtl_KernelPatchInfo
{
    uint numPatches;
    ushort numControlPointsPerPatch;
};
struct VGlobals_Type
{
    float4 _Time;
    float4 _SinTime;
    float4 _CosTime;
    float4 unity_DeltaTime;
    float3 _WorldSpaceCameraPos;
    float4 _ProjectionParams;
    float4 _ScreenParams;
    float4 _ZBufferParams;
    float4 unity_OrthoParams;
    float4 unity_CameraWorldClipPlanes[6];
    float4 hlslcc_mtx4x4unity_CameraProjection[4];
    float4 hlslcc_mtx4x4unity_CameraInvProjection[4];
    float4 hlslcc_mtx4x4unity_WorldToCamera[4];
    float4 hlslcc_mtx4x4unity_CameraToWorld[4];
    float4 _WorldSpaceLightPos0;
    float4 _LightPositionRange;
    float4 _LightProjectionParams;
    float4 unity_4LightPosX0;
    float4 unity_4LightPosY0;
    float4 unity_4LightPosZ0;
    float4 unity_4LightAtten0;
    float4 unity_LightColor[8];
    float4 unity_LightPosition[8];
    float4 unity_LightAtten[8];
    float4 unity_SpotDirection[8];
    float4 unity_SHAr;
    float4 unity_SHAg;
    float4 unity_SHAb;
    float4 unity_SHBr;
    float4 unity_SHBg;
    float4 unity_SHBb;
    float4 unity_SHC;
    float4 unity_OcclusionMaskSelector;
    float4 unity_ProbesOcclusion;
    float3 unity_LightColor0;
    float3 unity_LightColor1;
    float3 unity_LightColor2;
    float3 unity_LightColor3;
    float4 unity_ShadowSplitSpheres[4];
    float4 unity_ShadowSplitSqRadii;
    float4 unity_LightShadowBias;
    float4 _LightSplitsNear;
    float4 _LightSplitsFar;
    float4 hlslcc_mtx4x4unity_WorldToShadow[16];
    float4 _LightShadowData;
    float4 unity_ShadowFadeCenterAndType;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 unity_LODFade;
    float4 unity_WorldTransformParams;
    float4 unity_RenderingLayer;
    float4 hlslcc_mtx4x4glstate_matrix_transpose_modelview0[4];
    float4 glstate_lightmodel_ambient;
    float4 unity_AmbientSky;
    float4 unity_AmbientEquator;
    float4 unity_AmbientGround;
    float4 unity_IndirectSpecColor;
    float4 hlslcc_mtx4x4glstate_matrix_projection[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixInvV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    int unity_StereoEyeIndex;
    float4 unity_ShadowColor;
    float4 unity_FogColor;
    float4 unity_FogParams;
    float4 unity_LightmapST;
    float4 unity_DynamicLightmapST;
    float4 unity_SpecCube0_BoxMax;
    float4 unity_SpecCube0_BoxMin;
    float4 unity_SpecCube0_ProbePosition;
    float4 unity_SpecCube0_HDR;
    float4 unity_SpecCube1_BoxMax;
    float4 unity_SpecCube1_BoxMin;
    float4 unity_SpecCube1_ProbePosition;
    float4 unity_SpecCube1_HDR;
    float4 unity_ProbeVolumeParams;
    float4 hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[4];
    float3 unity_ProbeVolumeSizeInv;
    float3 unity_ProbeVolumeMin;
    float4 unity_Lightmap_HDR;
    float4 unity_DynamicLightmap_HDR;
    float4 _LightColor0;
    float4 _SpecColor;
    float _Tile;
    float _HeightDisplacement;
    float _NormalScale;
    float4 _ColorTint;
    float _MetallicStrength;
    float _SmoothnessStrength;
    float _EdgeLength;
    float4 _texcoord_ST;
    float4 unity_Ambient;
};
struct Mtl_HullIn
{
    Mtl_VertexOut cp[3];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
kernel void patchKernel(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn vertexInput [[ stage_in ]],
    uint2 tID [[ thread_position_in_grid ]],
    ushort2 groupID [[ threadgroup_position_in_grid ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    constant Mtl_KernelPatchInfo &patchInfo [[ buffer(3) ]])
{
#pragma clang diagnostic pop
    Mtl_ControlPoint output;
    const uint numPatchesInThreadGroup = 10;
    const uint patchID = (tID.x / patchInfo.numControlPointsPerPatch);
    const bool patchValid = (patchID < patchInfo.numPatches);
    const uint mtl_BaseInstance = 0;
    const uint mtl_InstanceID = groupID.y - mtl_BaseInstance;
    const uint internalPatchID = mtl_InstanceID * patchInfo.numPatches + patchID;
    const uint patchIDInThreadGroup = (patchID % numPatchesInThreadGroup);
    const uint controlPointID = (tID.x % patchInfo.numControlPointsPerPatch);
    const uint mtl_BaseVertex = 0;
    const uint mtl_VertexID = ((mtl_InstanceID * (patchInfo.numControlPointsPerPatch * patchInfo.numPatches)) + tID.x) - mtl_BaseVertex;
    threadgroup Mtl_HullIn inputGroup[numPatchesInThreadGroup];
    threadgroup Mtl_HullIn &input = inputGroup[patchIDInThreadGroup];
    MTLTriangleTessellationFactorsHalf tessFactor;
    if (patchValid) {
        input.cp[controlPointID] = vertexFunction(vertexInput);
        output.INTERNALTESSPOS0 = input.cp[controlPointID].INTERNALTESSPOS0;
        output.TANGENT0 = input.cp[controlPointID].TANGENT0;
        output.NORMAL0 = input.cp[controlPointID].NORMAL0;
        output.TEXCOORD0 = input.cp[controlPointID].TEXCOORD0;
        output.TEXCOORD1 = input.cp[controlPointID].TEXCOORD1;
        output.TEXCOORD2 = input.cp[controlPointID].TEXCOORD2;
        output.TEXCOORD3 = input.cp[controlPointID].TEXCOORD3;
        output.COLOR0 = input.cp[controlPointID].COLOR0;
    }
    threadgroup_barrier(mem_flags::mem_threadgroup);
    if (!patchValid) {
        return;
    }
    float3 u_xlat0;
    float3 u_xlat1;
    float3 u_xlat2;
    float3 u_xlat3;
    float3 u_xlat4;
    float u_xlat12;
    float u_xlat13;
    // fork_phase2
    {
        u_xlat0.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[1].INTERNALTESSPOS0.yyy;
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[1].INTERNALTESSPOS0.xxx, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[1].INTERNALTESSPOS0.zzz, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[1].INTERNALTESSPOS0.www, u_xlat0.xyz);
        u_xlat1.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[2].INTERNALTESSPOS0.yyy;
        u_xlat1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[2].INTERNALTESSPOS0.xxx, u_xlat1.xyz);
        u_xlat1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[2].INTERNALTESSPOS0.zzz, u_xlat1.xyz);
        u_xlat1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[2].INTERNALTESSPOS0.www, u_xlat1.xyz);
        u_xlat2.xyz = u_xlat0.xyz + u_xlat1.xyz;
        u_xlat2.xyz = fma(u_xlat2.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat12 = dot(u_xlat2.xyz, u_xlat2.xyz);
        u_xlat12 = sqrt(u_xlat12);
        u_xlat12 = u_xlat12 * VGlobals._EdgeLength;
        u_xlat2.xyz = u_xlat0.xyz + (-u_xlat1.xyz);
        u_xlat13 = dot(u_xlat2.xyz, u_xlat2.xyz);
        u_xlat13 = sqrt(u_xlat13);
        u_xlat13 = u_xlat13 * VGlobals._ScreenParams.y;
        u_xlat12 = u_xlat13 / u_xlat12;
        tessFactor.edgeTessellationFactor[0] = max(u_xlat12, 1.0);
        u_xlat2.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[0].INTERNALTESSPOS0.yyy;
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[0].INTERNALTESSPOS0.xxx, u_xlat2.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[0].INTERNALTESSPOS0.zzz, u_xlat2.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[0].INTERNALTESSPOS0.www, u_xlat2.xyz);
        u_xlat3.xyz = u_xlat1.xyz + u_xlat2.xyz;
        u_xlat1.xyz = u_xlat1.xyz + (-u_xlat2.xyz);
        u_xlat12 = dot(u_xlat1.xyz, u_xlat1.xyz);
        u_xlat12 = sqrt(u_xlat12);
        u_xlat12 = u_xlat12 * VGlobals._ScreenParams.y;
        u_xlat1.xyz = fma(u_xlat3.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat1.x = dot(u_xlat1.xyz, u_xlat1.xyz);
        u_xlat1.x = sqrt(u_xlat1.x);
        u_xlat1.x = u_xlat1.x * VGlobals._EdgeLength;
        u_xlat12 = u_xlat12 / u_xlat1.x;
        tessFactor.edgeTessellationFactor[1] = max(u_xlat12, 1.0);
        u_xlat1.xyz = u_xlat0.xyz + u_xlat2.xyz;
        u_xlat0.xyz = (-u_xlat0.xyz) + u_xlat2.xyz;
        u_xlat0.x = dot(u_xlat0.xyz, u_xlat0.xyz);
        u_xlat0.x = sqrt(u_xlat0.x);
        u_xlat0.x = u_xlat0.x * VGlobals._ScreenParams.y;
        u_xlat4.xyz = fma(u_xlat1.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat4.x = dot(u_xlat4.xyz, u_xlat4.xyz);
        u_xlat4.x = sqrt(u_xlat4.x);
        u_xlat4.x = u_xlat4.x * VGlobals._EdgeLength;
        u_xlat0.x = u_xlat0.x / u_xlat4.x;
        tessFactor.edgeTessellationFactor[2] = max(u_xlat0.x, 1.0);
    }
    // join_phase3
    {
        u_xlat0.x = tessFactor.edgeTessellationFactor[0] + tessFactor.edgeTessellationFactor[1];
        u_xlat0.x = u_xlat0.x + tessFactor.edgeTessellationFactor[2];
        tessFactor.insideTessellationFactor = u_xlat0.x * 0.333333343;
    }
    controlPoints[mtl_VertexID] = output;
    tessFactors[internalPatchID] = tessFactor;
}
// SHADER_STAGE_HULL_end
// SHADER_STAGE_DOMAIN_begin
struct Mtl_VertexInPostTess
{
    patch_control_point<Mtl_ControlPointIn> cp;
};
struct Mtl_VertexOutPostTess
{
    float4 mtl_Position [[ position ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float4 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float4 TEXCOORD3 [[ user(TEXCOORD3) ]];
    float4 TEXCOORD5 [[ user(TEXCOORD5) ]];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    sampler sampler_Height [[ sampler (0) ]],
    texture2d<float, access::sample > _Height [[ texture(0) ]] ,
    float3 mtl_TessCoord [[ position_in_patch ]],
    uint patchID [[ patch_id ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    Mtl_VertexInPostTess input [[ stage_in ]])
{
#pragma clang diagnostic pop
    Mtl_VertexOutPostTess output;
    MTLTriangleTessellationFactorsHalf tessFactor;
    tessFactor = tessFactors[patchID];
    float4 u_xlat0;
    float4 u_xlat1;
    float4 u_xlat2;
    float4 u_xlat3;
    float2 u_xlat9;
    float u_xlat12;
    float u_xlat13;
    u_xlat0 = mtl_TessCoord.yyyy * input.cp[1].INTERNALTESSPOS0;
    u_xlat0 = fma(input.cp[0].INTERNALTESSPOS0, mtl_TessCoord.xxxx, u_xlat0);
    u_xlat0 = fma(input.cp[2].INTERNALTESSPOS0, mtl_TessCoord.zzzz, u_xlat0);
    u_xlat1.xy = mtl_TessCoord.yy * input.cp[1].TEXCOORD0.xy;
    u_xlat1.xy = fma(input.cp[0].TEXCOORD0.xy, mtl_TessCoord.xx, u_xlat1.xy);
    u_xlat1.xy = fma(input.cp[2].TEXCOORD0.xy, mtl_TessCoord.zz, u_xlat1.xy);
    u_xlat9.xy = u_xlat1.xy * float2(VGlobals._Tile);
    output.TEXCOORD0.xy = fma(u_xlat1.xy, VGlobals._texcoord_ST.xy, VGlobals._texcoord_ST.zw);
    u_xlat1.xyz = _Height.sample(sampler_Height, u_xlat9.xy, level(1.0)).xyz;
    u_xlat2.xyz = mtl_TessCoord.yyy * input.cp[1].NORMAL0.xyz;
    u_xlat2.xyz = fma(input.cp[0].NORMAL0.xyz, mtl_TessCoord.xxx, u_xlat2.xyz);
    u_xlat2.xyz = fma(input.cp[2].NORMAL0.xyz, mtl_TessCoord.zzz, u_xlat2.xyz);
    u_xlat1.xyz = u_xlat1.xyz * u_xlat2.xyz;
    u_xlat0.xyz = fma(u_xlat1.xyz, float3(VGlobals._HeightDisplacement), u_xlat0.xyz);
    u_xlat1 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], u_xlat0.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], u_xlat0.zzzz, u_xlat1);
    u_xlat3 = u_xlat1 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, u_xlat0.www, u_xlat1.xyz);
    u_xlat1 = u_xlat3.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat3.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat3.zzzz, u_xlat1);
    output.mtl_Position = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat3.wwww, u_xlat1);
    u_xlat1.y = dot(u_xlat2.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat1.z = dot(u_xlat2.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat1.x = dot(u_xlat2.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat12 = dot(u_xlat1.xyz, u_xlat1.xyz);
    u_xlat12 = rsqrt(u_xlat12);
    u_xlat1.xyz = float3(u_xlat12) * u_xlat1.xyz;
    output.TEXCOORD1.z = u_xlat1.y;
    u_xlat2 = mtl_TessCoord.yyyy * input.cp[1].TANGENT0;
    u_xlat2 = fma(input.cp[0].TANGENT0, mtl_TessCoord.xxxx, u_xlat2);
    u_xlat2 = fma(input.cp[2].TANGENT0, mtl_TessCoord.zzzz, u_xlat2);
    u_xlat3.xyz = u_xlat2.yyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].yzx;
    u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].yzx, u_xlat2.xxx, u_xlat3.xyz);
    u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].yzx, u_xlat2.zzz, u_xlat3.xyz);
    u_xlat12 = u_xlat2.w * VGlobals.unity_WorldTransformParams.w;
    u_xlat13 = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat13 = rsqrt(u_xlat13);
    u_xlat2.xyz = float3(u_xlat13) * u_xlat2.xyz;
    u_xlat3.xyz = u_xlat1.xyz * u_xlat2.xyz;
    u_xlat3.xyz = fma(u_xlat1.zxy, u_xlat2.yzx, (-u_xlat3.xyz));
    u_xlat3.xyz = float3(u_xlat12) * u_xlat3.xyz;
    output.TEXCOORD1.y = u_xlat3.x;
    output.TEXCOORD1.w = u_xlat0.x;
    output.TEXCOORD1.x = u_xlat2.z;
    output.TEXCOORD2.w = u_xlat0.y;
    output.TEXCOORD3.w = u_xlat0.z;
    output.TEXCOORD2.x = u_xlat2.x;
    output.TEXCOORD3.x = u_xlat2.y;
    output.TEXCOORD2.z = u_xlat1.z;
    output.TEXCOORD3.z = u_xlat1.x;
    output.TEXCOORD2.y = u_xlat3.y;
    output.TEXCOORD3.y = u_xlat3.z;
    output.TEXCOORD5 = float4(0.0, 0.0, 0.0, 0.0);
    return output;
}
// SHADER_STAGE_DOMAIN_end
Compilation succeeded with: 

program_source:303:53: warning: writable resources in non-void post-tessellation vertex function
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
                                                    ^
program_source:309:30: note: writable buffer defined here
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
                             ^
program_source:310:48: note: writable buffer defined here
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
                                               ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float4 TEXCOORD0 [[ attribute(3) ]] ;
    float4 TEXCOORD1 [[ attribute(4) ]] ;
    float4 TEXCOORD2 [[ attribute(5) ]] ;
    float4 TEXCOORD3 [[ attribute(6) ]] ;
    float4 COLOR0 [[ attribute(7) ]] ;
};
struct Mtl_VertexOut
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float4 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float4 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float4 TEXCOORD3 [[ user(TEXCOORD3) ]];
    float4 COLOR0 [[ user(COLOR0) ]];
};
static Mtl_VertexOut vertexFunction(
    Mtl_VertexIn input)
{
    Mtl_VertexOut output;
    output.INTERNALTESSPOS0 = input.POSITION0;
    output.TANGENT0 = input.TANGENT0;
    output.NORMAL0.xyz = input.NORMAL0.xyz;
    output.TEXCOORD0 = input.TEXCOORD0;
    output.TEXCOORD1 = input.TEXCOORD1;
    output.TEXCOORD2 = input.TEXCOORD2;
    output.TEXCOORD3 = input.TEXCOORD3;
    output.COLOR0 = input.COLOR0;
    return output;
}
// SHADER_STAGE_HULL_begin
struct Mtl_ControlPoint
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float4 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float4 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float4 TEXCOORD3 [[ user(TEXCOORD3) ]];
    float4 COLOR0 [[ user(COLOR0) ]];
};
struct Mtl_ControlPointIn
{
    float4 INTERNALTESSPOS0 [[ attribute(8) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float4 TEXCOORD0 [[ attribute(3) ]] ;
    float4 TEXCOORD1 [[ attribute(4) ]] ;
    float4 TEXCOORD2 [[ attribute(5) ]] ;
    float4 TEXCOORD3 [[ attribute(6) ]] ;
    float4 COLOR0 [[ attribute(7) ]] ;
};
struct Mtl_KernelPatchInfo
{
    uint numPatches;
    ushort numControlPointsPerPatch;
};
struct VGlobals_Type
{
    float4 _Time;
    float4 _SinTime;
    float4 _CosTime;
    float4 unity_DeltaTime;
    float3 _WorldSpaceCameraPos;
    float4 _ProjectionParams;
    float4 _ScreenParams;
    float4 _ZBufferParams;
    float4 unity_OrthoParams;
    float4 unity_CameraWorldClipPlanes[6];
    float4 hlslcc_mtx4x4unity_CameraProjection[4];
    float4 hlslcc_mtx4x4unity_CameraInvProjection[4];
    float4 hlslcc_mtx4x4unity_WorldToCamera[4];
    float4 hlslcc_mtx4x4unity_CameraToWorld[4];
    float4 _WorldSpaceLightPos0;
    float4 _LightPositionRange;
    float4 _LightProjectionParams;
    float4 unity_4LightPosX0;
    float4 unity_4LightPosY0;
    float4 unity_4LightPosZ0;
    float4 unity_4LightAtten0;
    float4 unity_LightColor[8];
    float4 unity_LightPosition[8];
    float4 unity_LightAtten[8];
    float4 unity_SpotDirection[8];
    float4 unity_SHAr;
    float4 unity_SHAg;
    float4 unity_SHAb;
    float4 unity_SHBr;
    float4 unity_SHBg;
    float4 unity_SHBb;
    float4 unity_SHC;
    float4 unity_OcclusionMaskSelector;
    float4 unity_ProbesOcclusion;
    float3 unity_LightColor0;
    float3 unity_LightColor1;
    float3 unity_LightColor2;
    float3 unity_LightColor3;
    float4 unity_ShadowSplitSpheres[4];
    float4 unity_ShadowSplitSqRadii;
    float4 unity_LightShadowBias;
    float4 _LightSplitsNear;
    float4 _LightSplitsFar;
    float4 hlslcc_mtx4x4unity_WorldToShadow[16];
    float4 _LightShadowData;
    float4 unity_ShadowFadeCenterAndType;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 unity_LODFade;
    float4 unity_WorldTransformParams;
    float4 unity_RenderingLayer;
    float4 hlslcc_mtx4x4glstate_matrix_transpose_modelview0[4];
    float4 glstate_lightmodel_ambient;
    float4 unity_AmbientSky;
    float4 unity_AmbientEquator;
    float4 unity_AmbientGround;
    float4 unity_IndirectSpecColor;
    float4 hlslcc_mtx4x4glstate_matrix_projection[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixInvV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    int unity_StereoEyeIndex;
    float4 unity_ShadowColor;
    float4 unity_FogColor;
    float4 unity_FogParams;
    float4 unity_LightmapST;
    float4 unity_DynamicLightmapST;
    float4 unity_SpecCube0_BoxMax;
    float4 unity_SpecCube0_BoxMin;
    float4 unity_SpecCube0_ProbePosition;
    float4 unity_SpecCube0_HDR;
    float4 unity_SpecCube1_BoxMax;
    float4 unity_SpecCube1_BoxMin;
    float4 unity_SpecCube1_ProbePosition;
    float4 unity_SpecCube1_HDR;
    float4 unity_ProbeVolumeParams;
    float4 hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[4];
    float3 unity_ProbeVolumeSizeInv;
    float3 unity_ProbeVolumeMin;
    float4 unity_Lightmap_HDR;
    float4 unity_DynamicLightmap_HDR;
    float4 _LightColor0;
    float4 _SpecColor;
    float _Tile;
    float _HeightDisplacement;
    float _NormalScale;
    float4 _ColorTint;
    float _MetallicStrength;
    float _SmoothnessStrength;
    float _EdgeLength;
    bool4 unity_MetaVertexControl;
    bool4 unity_MetaFragmentControl;
    int unity_VisualizationMode;
    float unity_OneOverOutputBoost;
    float unity_MaxOutputValue;
    float unity_UseLinearSpace;
    float4 _texcoord_ST;
};
struct Mtl_HullIn
{
    Mtl_VertexOut cp[3];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
kernel void patchKernel(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn vertexInput [[ stage_in ]],
    uint2 tID [[ thread_position_in_grid ]],
    ushort2 groupID [[ threadgroup_position_in_grid ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    constant Mtl_KernelPatchInfo &patchInfo [[ buffer(3) ]])
{
#pragma clang diagnostic pop
    Mtl_ControlPoint output;
    const uint numPatchesInThreadGroup = 10;
    const uint patchID = (tID.x / patchInfo.numControlPointsPerPatch);
    const bool patchValid = (patchID < patchInfo.numPatches);
    const uint mtl_BaseInstance = 0;
    const uint mtl_InstanceID = groupID.y - mtl_BaseInstance;
    const uint internalPatchID = mtl_InstanceID * patchInfo.numPatches + patchID;
    const uint patchIDInThreadGroup = (patchID % numPatchesInThreadGroup);
    const uint controlPointID = (tID.x % patchInfo.numControlPointsPerPatch);
    const uint mtl_BaseVertex = 0;
    const uint mtl_VertexID = ((mtl_InstanceID * (patchInfo.numControlPointsPerPatch * patchInfo.numPatches)) + tID.x) - mtl_BaseVertex;
    threadgroup Mtl_HullIn inputGroup[numPatchesInThreadGroup];
    threadgroup Mtl_HullIn &input = inputGroup[patchIDInThreadGroup];
    MTLTriangleTessellationFactorsHalf tessFactor;
    if (patchValid) {
        input.cp[controlPointID] = vertexFunction(vertexInput);
        output.INTERNALTESSPOS0 = input.cp[controlPointID].INTERNALTESSPOS0;
        output.TANGENT0 = input.cp[controlPointID].TANGENT0;
        output.NORMAL0 = input.cp[controlPointID].NORMAL0;
        output.TEXCOORD0 = input.cp[controlPointID].TEXCOORD0;
        output.TEXCOORD1 = input.cp[controlPointID].TEXCOORD1;
        output.TEXCOORD2 = input.cp[controlPointID].TEXCOORD2;
        output.TEXCOORD3 = input.cp[controlPointID].TEXCOORD3;
        output.COLOR0 = input.cp[controlPointID].COLOR0;
    }
    threadgroup_barrier(mem_flags::mem_threadgroup);
    if (!patchValid) {
        return;
    }
    float3 u_xlat0;
    float3 u_xlat1;
    float3 u_xlat2;
    float3 u_xlat3;
    float3 u_xlat4;
    float u_xlat12;
    float u_xlat13;
    // fork_phase2
    {
        u_xlat0.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[1].INTERNALTESSPOS0.yyy;
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[1].INTERNALTESSPOS0.xxx, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[1].INTERNALTESSPOS0.zzz, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[1].INTERNALTESSPOS0.www, u_xlat0.xyz);
        u_xlat1.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[2].INTERNALTESSPOS0.yyy;
        u_xlat1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[2].INTERNALTESSPOS0.xxx, u_xlat1.xyz);
        u_xlat1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[2].INTERNALTESSPOS0.zzz, u_xlat1.xyz);
        u_xlat1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[2].INTERNALTESSPOS0.www, u_xlat1.xyz);
        u_xlat2.xyz = u_xlat0.xyz + u_xlat1.xyz;
        u_xlat2.xyz = fma(u_xlat2.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat12 = dot(u_xlat2.xyz, u_xlat2.xyz);
        u_xlat12 = sqrt(u_xlat12);
        u_xlat12 = u_xlat12 * VGlobals._EdgeLength;
        u_xlat2.xyz = u_xlat0.xyz + (-u_xlat1.xyz);
        u_xlat13 = dot(u_xlat2.xyz, u_xlat2.xyz);
        u_xlat13 = sqrt(u_xlat13);
        u_xlat13 = u_xlat13 * VGlobals._ScreenParams.y;
        u_xlat12 = u_xlat13 / u_xlat12;
        tessFactor.edgeTessellationFactor[0] = max(u_xlat12, 1.0);
        u_xlat2.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[0].INTERNALTESSPOS0.yyy;
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[0].INTERNALTESSPOS0.xxx, u_xlat2.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[0].INTERNALTESSPOS0.zzz, u_xlat2.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[0].INTERNALTESSPOS0.www, u_xlat2.xyz);
        u_xlat3.xyz = u_xlat1.xyz + u_xlat2.xyz;
        u_xlat1.xyz = u_xlat1.xyz + (-u_xlat2.xyz);
        u_xlat12 = dot(u_xlat1.xyz, u_xlat1.xyz);
        u_xlat12 = sqrt(u_xlat12);
        u_xlat12 = u_xlat12 * VGlobals._ScreenParams.y;
        u_xlat1.xyz = fma(u_xlat3.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat1.x = dot(u_xlat1.xyz, u_xlat1.xyz);
        u_xlat1.x = sqrt(u_xlat1.x);
        u_xlat1.x = u_xlat1.x * VGlobals._EdgeLength;
        u_xlat12 = u_xlat12 / u_xlat1.x;
        tessFactor.edgeTessellationFactor[1] = max(u_xlat12, 1.0);
        u_xlat1.xyz = u_xlat0.xyz + u_xlat2.xyz;
        u_xlat0.xyz = (-u_xlat0.xyz) + u_xlat2.xyz;
        u_xlat0.x = dot(u_xlat0.xyz, u_xlat0.xyz);
        u_xlat0.x = sqrt(u_xlat0.x);
        u_xlat0.x = u_xlat0.x * VGlobals._ScreenParams.y;
        u_xlat4.xyz = fma(u_xlat1.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat4.x = dot(u_xlat4.xyz, u_xlat4.xyz);
        u_xlat4.x = sqrt(u_xlat4.x);
        u_xlat4.x = u_xlat4.x * VGlobals._EdgeLength;
        u_xlat0.x = u_xlat0.x / u_xlat4.x;
        tessFactor.edgeTessellationFactor[2] = max(u_xlat0.x, 1.0);
    }
    // join_phase3
    {
        u_xlat0.x = tessFactor.edgeTessellationFactor[0] + tessFactor.edgeTessellationFactor[1];
        u_xlat0.x = u_xlat0.x + tessFactor.edgeTessellationFactor[2];
        tessFactor.insideTessellationFactor = u_xlat0.x * 0.333333343;
    }
    controlPoints[mtl_VertexID] = output;
    tessFactors[internalPatchID] = tessFactor;
}
// SHADER_STAGE_HULL_end
// SHADER_STAGE_DOMAIN_begin
struct Mtl_VertexInPostTess
{
    patch_control_point<Mtl_ControlPointIn> cp;
};
struct Mtl_VertexOutPostTess
{
    float4 mtl_Position [[ position ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float4 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float4 TEXCOORD3 [[ user(TEXCOORD3) ]];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    sampler sampler_Height [[ sampler (0) ]],
    texture2d<float, access::sample > _Height [[ texture(0) ]] ,
    float3 mtl_TessCoord [[ position_in_patch ]],
    uint patchID [[ patch_id ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    Mtl_VertexInPostTess input [[ stage_in ]])
{
#pragma clang diagnostic pop
    Mtl_VertexOutPostTess output;
    MTLTriangleTessellationFactorsHalf tessFactor;
    tessFactor = tessFactors[patchID];
    float4 u_xlat0;
    float4 u_xlat1;
    float4 u_xlat2;
    float3 u_xlat3;
    float3 u_xlat4;
    float2 u_xlat13;
    float u_xlat15;
    bool u_xlatb15;
    u_xlat0.xy = mtl_TessCoord.yy * input.cp[1].TEXCOORD2.xy;
    u_xlat0.xy = fma(input.cp[0].TEXCOORD2.xy, mtl_TessCoord.xx, u_xlat0.xy);
    u_xlat0.xy = fma(input.cp[2].TEXCOORD2.xy, mtl_TessCoord.zz, u_xlat0.xy);
    u_xlat0.xy = fma(u_xlat0.xy, VGlobals.unity_DynamicLightmapST.xy, VGlobals.unity_DynamicLightmapST.zw);
    u_xlat1.xy = mtl_TessCoord.yy * input.cp[1].TEXCOORD1.xy;
    u_xlat1.xy = fma(input.cp[0].TEXCOORD1.xy, mtl_TessCoord.xx, u_xlat1.xy);
    u_xlat1.xy = fma(input.cp[2].TEXCOORD1.xy, mtl_TessCoord.zz, u_xlat1.xy);
    u_xlat1.xy = fma(u_xlat1.xy, VGlobals.unity_LightmapST.xy, VGlobals.unity_LightmapST.zw);
    u_xlat2 = mtl_TessCoord.yyyy * input.cp[1].INTERNALTESSPOS0;
    u_xlat2 = fma(input.cp[0].INTERNALTESSPOS0, mtl_TessCoord.xxxx, u_xlat2);
    u_xlat2 = fma(input.cp[2].INTERNALTESSPOS0, mtl_TessCoord.zzzz, u_xlat2);
    u_xlat3.xy = mtl_TessCoord.yy * input.cp[1].TEXCOORD0.xy;
    u_xlat3.xy = fma(input.cp[0].TEXCOORD0.xy, mtl_TessCoord.xx, u_xlat3.xy);
    u_xlat3.xy = fma(input.cp[2].TEXCOORD0.xy, mtl_TessCoord.zz, u_xlat3.xy);
    u_xlat13.xy = u_xlat3.xy * float2(VGlobals._Tile);
    output.TEXCOORD0.xy = fma(u_xlat3.xy, VGlobals._texcoord_ST.xy, VGlobals._texcoord_ST.zw);
    u_xlat3.xyz = _Height.sample(sampler_Height, u_xlat13.xy, level(1.0)).xyz;
    u_xlat4.xyz = mtl_TessCoord.yyy * input.cp[1].NORMAL0.xyz;
    u_xlat4.xyz = fma(input.cp[0].NORMAL0.xyz, mtl_TessCoord.xxx, u_xlat4.xyz);
    u_xlat4.xyz = fma(input.cp[2].NORMAL0.xyz, mtl_TessCoord.zzz, u_xlat4.xyz);
    u_xlat3.xyz = u_xlat3.xyz * u_xlat4.xyz;
    u_xlat2.xyz = fma(u_xlat3.xyz, float3(VGlobals._HeightDisplacement), u_xlat2.xyz);
    u_xlatb15 = 0.0<u_xlat2.z;
    u_xlat1.z = u_xlatb15 ? 9.99999975e-05 : float(0.0);
    u_xlat1.xyz = (VGlobals.unity_MetaVertexControl.x) ? u_xlat1.xyz : u_xlat2.xyz;
    u_xlatb15 = 0.0<u_xlat1.z;
    u_xlat0.z = u_xlatb15 ? 9.99999975e-05 : float(0.0);
    u_xlat0.xyz = (VGlobals.unity_MetaVertexControl.y) ? u_xlat0.xyz : u_xlat1.xyz;
    u_xlat1 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat0.xxxx, u_xlat1);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat0.zzzz, u_xlat1);
    output.mtl_Position = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_MatrixVP[3];
    u_xlat0.xyz = u_xlat2.yyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz;
    u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, u_xlat2.xxx, u_xlat0.xyz);
    u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, u_xlat2.zzz, u_xlat0.xyz);
    u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, u_xlat2.www, u_xlat0.xyz);
    output.TEXCOORD1.w = u_xlat0.x;
    u_xlat1.y = dot(u_xlat4.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat1.z = dot(u_xlat4.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat1.x = dot(u_xlat4.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat0.x = dot(u_xlat1.xyz, u_xlat1.xyz);
    u_xlat0.x = rsqrt(u_xlat0.x);
    u_xlat1.xyz = u_xlat0.xxx * u_xlat1.xyz;
    output.TEXCOORD1.z = u_xlat1.y;
    u_xlat2 = mtl_TessCoord.yyyy * input.cp[1].TANGENT0;
    u_xlat2 = fma(input.cp[0].TANGENT0, mtl_TessCoord.xxxx, u_xlat2);
    u_xlat2 = fma(input.cp[2].TANGENT0, mtl_TessCoord.zzzz, u_xlat2);
    u_xlat3.xyz = u_xlat2.yyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].yzx;
    u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].yzx, u_xlat2.xxx, u_xlat3.xyz);
    u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].yzx, u_xlat2.zzz, u_xlat3.xyz);
    u_xlat0.x = u_xlat2.w * VGlobals.unity_WorldTransformParams.w;
    u_xlat15 = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat15 = rsqrt(u_xlat15);
    u_xlat2.xyz = float3(u_xlat15) * u_xlat2.xyz;
    u_xlat3.xyz = u_xlat1.xyz * u_xlat2.xyz;
    u_xlat3.xyz = fma(u_xlat1.zxy, u_xlat2.yzx, (-u_xlat3.xyz));
    u_xlat3.xyz = u_xlat0.xxx * u_xlat3.xyz;
    output.TEXCOORD1.y = u_xlat3.x;
    output.TEXCOORD1.x = u_xlat2.z;
    output.TEXCOORD2.w = u_xlat0.y;
    output.TEXCOORD3.w = u_xlat0.z;
    output.TEXCOORD2.x = u_xlat2.x;
    output.TEXCOORD3.x = u_xlat2.y;
    output.TEXCOORD2.z = u_xlat1.z;
    output.TEXCOORD3.z = u_xlat1.x;
    output.TEXCOORD2.y = u_xlat3.y;
    output.TEXCOORD3.y = u_xlat3.z;
    return output;
}
// SHADER_STAGE_DOMAIN_end
Refreshing native plugins compatible for Editor in 2.46 ms, found 2 plugins.
Preloading 0 native plugins for Editor in 0.00 ms.
Unloading 3375 Unused Serialized files (Serialized files now loaded: 0)
Unloading 20 unused Assets / (0.6 MB). Loaded Objects now: 3901.
Memory consumption went from 136.5 MB to 135.8 MB.
Total: 5.252872 ms (FindLiveObjects: 0.360913 ms CreateObjectMapping: 0.430990 ms MarkObjects: 3.954903 ms  DeleteObjects: 0.504667 ms)

AssetImportParameters requested are different than current active one (requested -> active):
  custom:video-decoder-ogg-theora: a1e56fd34408186e4bbccfd4996cb3dc -> 
  custom:container-muxer-webm: aa71ff27fc2769a1b78a27578f13a17b -> 
  custom:container-demuxer-webm: 4f35f7cbe854078d1ac9338744f61a02 -> 
  custom:video-encoder-webm-vp8: eb34c28f22e8b96e1ab97ce403110664 -> 
  custom:framework-osx-AVFoundation: b23960f63f64bdc6ff669e2cdcee2391 -> 
  custom:audio-encoder-webm-vorbis: bf7c407c2cedff20999df2af8eb42d56 -> 
  custom:container-demuxer-ogg: 62fdf1f143b41e24485cea50d1cbac27 -> 
  custom:video-decoder-webm-vp8: 9c59270c3fd7afecdb556c50c9e8de78 -> 
  custom:audio-decoder-ogg-vorbis: bf7c407c2cedff20999df2af8eb42d56 -> 
========================================================================
Received Prepare
Registering precompiled user dll's ...
Registered in 0.003418 seconds.
Begin MonoManager ReloadAssembly
Symbol file LoadedFromMemory doesn't match image /Users/kamilaamendolagine/Desktop/Staugen Raug v2 - Prefab - Map 1.01/Library/PackageCache/com.unity.visualscripting@1.7.8/Editor/VisualScripting.Core/Dependencies/YamlDotNet/Unity.VisualScripting.YamlDotNet.dll
Symbol file LoadedFromMemory doesn't match image /Users/kamilaamendolagine/Desktop/Staugen Raug v2 - Prefab - Map 1.01/Library/PackageCache/com.unity.visualscripting@1.7.8/Editor/VisualScripting.Core/Dependencies/DotNetZip/Unity.VisualScripting.IonicZip.dll
Native extension for OSXStandalone target not found
Native extension for WebGL target not found
Refreshing native plugins compatible for Editor in 1.12 ms, found 2 plugins.
Preloading 0 native plugins for Editor in 0.00 ms.
Mono: successfully reloaded assembly
- Completed reload, in  1.887 seconds
Domain Reload Profiling:
	ReloadAssembly (1889ms)
		BeginReloadAssembly (205ms)
			ExecutionOrderSort (0ms)
			DisableScriptedObjects (10ms)
			BackupInstance (0ms)
			ReleaseScriptingObjects (0ms)
			CreateAndSetChildDomain (89ms)
		EndReloadAssembly (1512ms)
			LoadAssemblies (92ms)
			RebuildTransferFunctionScriptingTraits (0ms)
			SetupTypeCache (505ms)
			ReleaseScriptCaches (2ms)
			RebuildScriptCaches (87ms)
			SetupLoadedEditorAssemblies (710ms)
				LogAssemblyErrors (0ms)
				InitializePlatformSupportModulesInManaged (20ms)
				SetLoadedEditorAssemblies (1ms)
				RefreshPlugins (1ms)
				BeforeProcessingInitializeOnLoad (120ms)
				ProcessInitializeOnLoadAttributes (513ms)
				ProcessInitializeOnLoadMethodAttributes (50ms)
				AfterProcessingInitializeOnLoad (3ms)
				EditorAssembliesLoaded (0ms)
			ExecutionOrderSort2 (0ms)
			AwakeInstancesAfterBackupRestoration (10ms)
Platform modules already initialized, skipping
Compilation succeeded with: 

program_source:299:53: warning: writable resources in non-void post-tessellation vertex function
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
                                                    ^
program_source:305:30: note: writable buffer defined here
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
                             ^
program_source:306:48: note: writable buffer defined here
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
                                               ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float4 TEXCOORD0 [[ attribute(3) ]] ;
    float4 TEXCOORD1 [[ attribute(4) ]] ;
    float4 TEXCOORD2 [[ attribute(5) ]] ;
    float4 TEXCOORD3 [[ attribute(6) ]] ;
    float4 COLOR0 [[ attribute(7) ]] ;
};
struct Mtl_VertexOut
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float4 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float4 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float4 TEXCOORD3 [[ user(TEXCOORD3) ]];
    float4 COLOR0 [[ user(COLOR0) ]];
};
static Mtl_VertexOut vertexFunction(
    Mtl_VertexIn input)
{
    Mtl_VertexOut output;
    output.INTERNALTESSPOS0 = input.POSITION0;
    output.TANGENT0 = input.TANGENT0;
    output.NORMAL0.xyz = input.NORMAL0.xyz;
    output.TEXCOORD0 = input.TEXCOORD0;
    output.TEXCOORD1 = input.TEXCOORD1;
    output.TEXCOORD2 = input.TEXCOORD2;
    output.TEXCOORD3 = input.TEXCOORD3;
    output.COLOR0 = input.COLOR0;
    return output;
}
// SHADER_STAGE_HULL_begin
struct Mtl_ControlPoint
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float4 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float4 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float4 TEXCOORD3 [[ user(TEXCOORD3) ]];
    float4 COLOR0 [[ user(COLOR0) ]];
};
struct Mtl_ControlPointIn
{
    float4 INTERNALTESSPOS0 [[ attribute(8) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float4 TEXCOORD0 [[ attribute(3) ]] ;
    float4 TEXCOORD1 [[ attribute(4) ]] ;
    float4 TEXCOORD2 [[ attribute(5) ]] ;
    float4 TEXCOORD3 [[ attribute(6) ]] ;
    float4 COLOR0 [[ attribute(7) ]] ;
};
struct Mtl_KernelPatchInfo
{
    uint numPatches;
    ushort numControlPointsPerPatch;
};
struct VGlobals_Type
{
    float4 _Time;
    float4 _SinTime;
    float4 _CosTime;
    float4 unity_DeltaTime;
    float3 _WorldSpaceCameraPos;
    float4 _ProjectionParams;
    float4 _ScreenParams;
    float4 _ZBufferParams;
    float4 unity_OrthoParams;
    float4 unity_CameraWorldClipPlanes[6];
    float4 hlslcc_mtx4x4unity_CameraProjection[4];
    float4 hlslcc_mtx4x4unity_CameraInvProjection[4];
    float4 hlslcc_mtx4x4unity_WorldToCamera[4];
    float4 hlslcc_mtx4x4unity_CameraToWorld[4];
    float4 _WorldSpaceLightPos0;
    float4 _LightPositionRange;
    float4 _LightProjectionParams;
    float4 unity_4LightPosX0;
    float4 unity_4LightPosY0;
    float4 unity_4LightPosZ0;
    float4 unity_4LightAtten0;
    float4 unity_LightColor[8];
    float4 unity_LightPosition[8];
    float4 unity_LightAtten[8];
    float4 unity_SpotDirection[8];
    float4 unity_SHAr;
    float4 unity_SHAg;
    float4 unity_SHAb;
    float4 unity_SHBr;
    float4 unity_SHBg;
    float4 unity_SHBb;
    float4 unity_SHC;
    float4 unity_OcclusionMaskSelector;
    float4 unity_ProbesOcclusion;
    float3 unity_LightColor0;
    float3 unity_LightColor1;
    float3 unity_LightColor2;
    float3 unity_LightColor3;
    float4 unity_ShadowSplitSpheres[4];
    float4 unity_ShadowSplitSqRadii;
    float4 unity_LightShadowBias;
    float4 _LightSplitsNear;
    float4 _LightSplitsFar;
    float4 hlslcc_mtx4x4unity_WorldToShadow[16];
    float4 _LightShadowData;
    float4 unity_ShadowFadeCenterAndType;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 unity_LODFade;
    float4 unity_WorldTransformParams;
    float4 unity_RenderingLayer;
    float4 hlslcc_mtx4x4glstate_matrix_transpose_modelview0[4];
    float4 glstate_lightmodel_ambient;
    float4 unity_AmbientSky;
    float4 unity_AmbientEquator;
    float4 unity_AmbientGround;
    float4 unity_IndirectSpecColor;
    float4 hlslcc_mtx4x4glstate_matrix_projection[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixInvV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    int unity_StereoEyeIndex;
    float4 unity_ShadowColor;
    float4 unity_FogColor;
    float4 unity_FogParams;
    float4 unity_LightmapST;
    float4 unity_DynamicLightmapST;
    float4 unity_SpecCube0_BoxMax;
    float4 unity_SpecCube0_BoxMin;
    float4 unity_SpecCube0_ProbePosition;
    float4 unity_SpecCube0_HDR;
    float4 unity_SpecCube1_BoxMax;
    float4 unity_SpecCube1_BoxMin;
    float4 unity_SpecCube1_ProbePosition;
    float4 unity_SpecCube1_HDR;
    float4 unity_ProbeVolumeParams;
    float4 hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[4];
    float3 unity_ProbeVolumeSizeInv;
    float3 unity_ProbeVolumeMin;
    float4 unity_Lightmap_HDR;
    float4 unity_DynamicLightmap_HDR;
    float4 _LightColor0;
    float4 _SpecColor;
    float _Tile;
    float _HeightDisplacement;
    float _NormalScale;
    float4 _ColorTint;
    float _MetallicStrength;
    float _SmoothnessStrength;
    float _EdgeLength;
    float4 _texcoord_ST;
};
struct Mtl_HullIn
{
    Mtl_VertexOut cp[3];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
kernel void patchKernel(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn vertexInput [[ stage_in ]],
    uint2 tID [[ thread_position_in_grid ]],
    ushort2 groupID [[ threadgroup_position_in_grid ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    constant Mtl_KernelPatchInfo &patchInfo [[ buffer(3) ]])
{
#pragma clang diagnostic pop
    Mtl_ControlPoint output;
    const uint numPatchesInThreadGroup = 10;
    const uint patchID = (tID.x / patchInfo.numControlPointsPerPatch);
    const bool patchValid = (patchID < patchInfo.numPatches);
    const uint mtl_BaseInstance = 0;
    const uint mtl_InstanceID = groupID.y - mtl_BaseInstance;
    const uint internalPatchID = mtl_InstanceID * patchInfo.numPatches + patchID;
    const uint patchIDInThreadGroup = (patchID % numPatchesInThreadGroup);
    const uint controlPointID = (tID.x % patchInfo.numControlPointsPerPatch);
    const uint mtl_BaseVertex = 0;
    const uint mtl_VertexID = ((mtl_InstanceID * (patchInfo.numControlPointsPerPatch * patchInfo.numPatches)) + tID.x) - mtl_BaseVertex;
    threadgroup Mtl_HullIn inputGroup[numPatchesInThreadGroup];
    threadgroup Mtl_HullIn &input = inputGroup[patchIDInThreadGroup];
    MTLTriangleTessellationFactorsHalf tessFactor;
    if (patchValid) {
        input.cp[controlPointID] = vertexFunction(vertexInput);
        output.INTERNALTESSPOS0 = input.cp[controlPointID].INTERNALTESSPOS0;
        output.TANGENT0 = input.cp[controlPointID].TANGENT0;
        output.NORMAL0 = input.cp[controlPointID].NORMAL0;
        output.TEXCOORD0 = input.cp[controlPointID].TEXCOORD0;
        output.TEXCOORD1 = input.cp[controlPointID].TEXCOORD1;
        output.TEXCOORD2 = input.cp[controlPointID].TEXCOORD2;
        output.TEXCOORD3 = input.cp[controlPointID].TEXCOORD3;
        output.COLOR0 = input.cp[controlPointID].COLOR0;
    }
    threadgroup_barrier(mem_flags::mem_threadgroup);
    if (!patchValid) {
        return;
    }
    float3 u_xlat0;
    float3 u_xlat1;
    float3 u_xlat2;
    float3 u_xlat3;
    float3 u_xlat4;
    float u_xlat12;
    float u_xlat13;
    // fork_phase2
    {
        u_xlat0.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[1].INTERNALTESSPOS0.yyy;
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[1].INTERNALTESSPOS0.xxx, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[1].INTERNALTESSPOS0.zzz, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[1].INTERNALTESSPOS0.www, u_xlat0.xyz);
        u_xlat1.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[2].INTERNALTESSPOS0.yyy;
        u_xlat1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[2].INTERNALTESSPOS0.xxx, u_xlat1.xyz);
        u_xlat1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[2].INTERNALTESSPOS0.zzz, u_xlat1.xyz);
        u_xlat1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[2].INTERNALTESSPOS0.www, u_xlat1.xyz);
        u_xlat2.xyz = u_xlat0.xyz + u_xlat1.xyz;
        u_xlat2.xyz = fma(u_xlat2.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat12 = dot(u_xlat2.xyz, u_xlat2.xyz);
        u_xlat12 = sqrt(u_xlat12);
        u_xlat12 = u_xlat12 * VGlobals._EdgeLength;
        u_xlat2.xyz = u_xlat0.xyz + (-u_xlat1.xyz);
        u_xlat13 = dot(u_xlat2.xyz, u_xlat2.xyz);
        u_xlat13 = sqrt(u_xlat13);
        u_xlat13 = u_xlat13 * VGlobals._ScreenParams.y;
        u_xlat12 = u_xlat13 / u_xlat12;
        tessFactor.edgeTessellationFactor[0] = max(u_xlat12, 1.0);
        u_xlat2.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[0].INTERNALTESSPOS0.yyy;
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[0].INTERNALTESSPOS0.xxx, u_xlat2.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[0].INTERNALTESSPOS0.zzz, u_xlat2.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[0].INTERNALTESSPOS0.www, u_xlat2.xyz);
        u_xlat3.xyz = u_xlat1.xyz + u_xlat2.xyz;
        u_xlat1.xyz = u_xlat1.xyz + (-u_xlat2.xyz);
        u_xlat12 = dot(u_xlat1.xyz, u_xlat1.xyz);
        u_xlat12 = sqrt(u_xlat12);
        u_xlat12 = u_xlat12 * VGlobals._ScreenParams.y;
        u_xlat1.xyz = fma(u_xlat3.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat1.x = dot(u_xlat1.xyz, u_xlat1.xyz);
        u_xlat1.x = sqrt(u_xlat1.x);
        u_xlat1.x = u_xlat1.x * VGlobals._EdgeLength;
        u_xlat12 = u_xlat12 / u_xlat1.x;
        tessFactor.edgeTessellationFactor[1] = max(u_xlat12, 1.0);
        u_xlat1.xyz = u_xlat0.xyz + u_xlat2.xyz;
        u_xlat0.xyz = (-u_xlat0.xyz) + u_xlat2.xyz;
        u_xlat0.x = dot(u_xlat0.xyz, u_xlat0.xyz);
        u_xlat0.x = sqrt(u_xlat0.x);
        u_xlat0.x = u_xlat0.x * VGlobals._ScreenParams.y;
        u_xlat4.xyz = fma(u_xlat1.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat4.x = dot(u_xlat4.xyz, u_xlat4.xyz);
        u_xlat4.x = sqrt(u_xlat4.x);
        u_xlat4.x = u_xlat4.x * VGlobals._EdgeLength;
        u_xlat0.x = u_xlat0.x / u_xlat4.x;
        tessFactor.edgeTessellationFactor[2] = max(u_xlat0.x, 1.0);
    }
    // join_phase3
    {
        u_xlat0.x = tessFactor.edgeTessellationFactor[0] + tessFactor.edgeTessellationFactor[1];
        u_xlat0.x = u_xlat0.x + tessFactor.edgeTessellationFactor[2];
        tessFactor.insideTessellationFactor = u_xlat0.x * 0.333333343;
    }
    controlPoints[mtl_VertexID] = output;
    tessFactors[internalPatchID] = tessFactor;
}
// SHADER_STAGE_HULL_end
// SHADER_STAGE_DOMAIN_begin
struct Mtl_VertexInPostTess
{
    patch_control_point<Mtl_ControlPointIn> cp;
};
struct Mtl_VertexOutPostTess
{
    float4 mtl_Position [[ position ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float4 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float4 TEXCOORD3 [[ user(TEXCOORD3) ]];
    float4 TEXCOORD6 [[ user(TEXCOORD6) ]];
    float4 TEXCOORD7 [[ user(TEXCOORD7) ]];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    sampler sampler_Height [[ sampler (0) ]],
    texture2d<float, access::sample > _Height [[ texture(0) ]] ,
    float3 mtl_TessCoord [[ position_in_patch ]],
    uint patchID [[ patch_id ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    Mtl_VertexInPostTess input [[ stage_in ]])
{
#pragma clang diagnostic pop
    Mtl_VertexOutPostTess output;
    MTLTriangleTessellationFactorsHalf tessFactor;
    tessFactor = tessFactors[patchID];
    float4 u_xlat0;
    float4 u_xlat1;
    float4 u_xlat2;
    float4 u_xlat3;
    float2 u_xlat9;
    float u_xlat12;
    float u_xlat13;
    u_xlat0 = mtl_TessCoord.yyyy * input.cp[1].INTERNALTESSPOS0;
    u_xlat0 = fma(input.cp[0].INTERNALTESSPOS0, mtl_TessCoord.xxxx, u_xlat0);
    u_xlat0 = fma(input.cp[2].INTERNALTESSPOS0, mtl_TessCoord.zzzz, u_xlat0);
    u_xlat1.xy = mtl_TessCoord.yy * input.cp[1].TEXCOORD0.xy;
    u_xlat1.xy = fma(input.cp[0].TEXCOORD0.xy, mtl_TessCoord.xx, u_xlat1.xy);
    u_xlat1.xy = fma(input.cp[2].TEXCOORD0.xy, mtl_TessCoord.zz, u_xlat1.xy);
    u_xlat9.xy = u_xlat1.xy * float2(VGlobals._Tile);
    output.TEXCOORD0.xy = fma(u_xlat1.xy, VGlobals._texcoord_ST.xy, VGlobals._texcoord_ST.zw);
    u_xlat1.xyz = _Height.sample(sampler_Height, u_xlat9.xy, level(1.0)).xyz;
    u_xlat2.xyz = mtl_TessCoord.yyy * input.cp[1].NORMAL0.xyz;
    u_xlat2.xyz = fma(input.cp[0].NORMAL0.xyz, mtl_TessCoord.xxx, u_xlat2.xyz);
    u_xlat2.xyz = fma(input.cp[2].NORMAL0.xyz, mtl_TessCoord.zzz, u_xlat2.xyz);
    u_xlat1.xyz = u_xlat1.xyz * u_xlat2.xyz;
    u_xlat0.xyz = fma(u_xlat1.xyz, float3(VGlobals._HeightDisplacement), u_xlat0.xyz);
    u_xlat1 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], u_xlat0.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], u_xlat0.zzzz, u_xlat1);
    u_xlat3 = u_xlat1 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, u_xlat0.www, u_xlat1.xyz);
    u_xlat1 = u_xlat3.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat3.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat3.zzzz, u_xlat1);
    output.mtl_Position = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat3.wwww, u_xlat1);
    u_xlat1.y = dot(u_xlat2.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat1.z = dot(u_xlat2.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat1.x = dot(u_xlat2.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat12 = dot(u_xlat1.xyz, u_xlat1.xyz);
    u_xlat12 = rsqrt(u_xlat12);
    u_xlat1.xyz = float3(u_xlat12) * u_xlat1.xyz;
    output.TEXCOORD1.z = u_xlat1.y;
    u_xlat2 = mtl_TessCoord.yyyy * input.cp[1].TANGENT0;
    u_xlat2 = fma(input.cp[0].TANGENT0, mtl_TessCoord.xxxx, u_xlat2);
    u_xlat2 = fma(input.cp[2].TANGENT0, mtl_TessCoord.zzzz, u_xlat2);
    u_xlat3.xyz = u_xlat2.yyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].yzx;
    u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].yzx, u_xlat2.xxx, u_xlat3.xyz);
    u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].yzx, u_xlat2.zzz, u_xlat3.xyz);
    u_xlat12 = u_xlat2.w * VGlobals.unity_WorldTransformParams.w;
    u_xlat13 = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat13 = rsqrt(u_xlat13);
    u_xlat2.xyz = float3(u_xlat13) * u_xlat2.xyz;
    u_xlat3.xyz = u_xlat1.xyz * u_xlat2.xyz;
    u_xlat3.xyz = fma(u_xlat1.zxy, u_xlat2.yzx, (-u_xlat3.xyz));
    u_xlat3.xyz = float3(u_xlat12) * u_xlat3.xyz;
    output.TEXCOORD1.y = u_xlat3.x;
    output.TEXCOORD1.w = u_xlat0.x;
    output.TEXCOORD1.x = u_xlat2.z;
    output.TEXCOORD2.w = u_xlat0.y;
    output.TEXCOORD3.w = u_xlat0.z;
    output.TEXCOORD2.x = u_xlat2.x;
    output.TEXCOORD3.x = u_xlat2.y;
    output.TEXCOORD2.z = u_xlat1.z;
    output.TEXCOORD3.z = u_xlat1.x;
    output.TEXCOORD2.y = u_xlat3.y;
    output.TEXCOORD3.y = u_xlat3.z;
    output.TEXCOORD6 = float4(0.0, 0.0, 0.0, 0.0);
    output.TEXCOORD7 = float4(0.0, 0.0, 0.0, 0.0);
    return output;
}
// SHADER_STAGE_DOMAIN_end
Compilation succeeded with: 

program_source:301:53: warning: writable resources in non-void post-tessellation vertex function
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
                                                    ^
program_source:307:30: note: writable buffer defined here
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
                             ^
program_source:308:48: note: writable buffer defined here
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
                                               ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float4 TEXCOORD0 [[ attribute(3) ]] ;
    float4 TEXCOORD1 [[ attribute(4) ]] ;
    float4 TEXCOORD2 [[ attribute(5) ]] ;
    float4 TEXCOORD3 [[ attribute(6) ]] ;
    float4 COLOR0 [[ attribute(7) ]] ;
};
struct Mtl_VertexOut
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float4 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float4 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float4 TEXCOORD3 [[ user(TEXCOORD3) ]];
    float4 COLOR0 [[ user(COLOR0) ]];
};
static Mtl_VertexOut vertexFunction(
    Mtl_VertexIn input)
{
    Mtl_VertexOut output;
    output.INTERNALTESSPOS0 = input.POSITION0;
    output.TANGENT0 = input.TANGENT0;
    output.NORMAL0.xyz = input.NORMAL0.xyz;
    output.TEXCOORD0 = input.TEXCOORD0;
    output.TEXCOORD1 = input.TEXCOORD1;
    output.TEXCOORD2 = input.TEXCOORD2;
    output.TEXCOORD3 = input.TEXCOORD3;
    output.COLOR0 = input.COLOR0;
    return output;
}
// SHADER_STAGE_HULL_begin
struct Mtl_ControlPoint
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float4 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float4 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float4 TEXCOORD3 [[ user(TEXCOORD3) ]];
    float4 COLOR0 [[ user(COLOR0) ]];
};
struct Mtl_ControlPointIn
{
    float4 INTERNALTESSPOS0 [[ attribute(8) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float4 TEXCOORD0 [[ attribute(3) ]] ;
    float4 TEXCOORD1 [[ attribute(4) ]] ;
    float4 TEXCOORD2 [[ attribute(5) ]] ;
    float4 TEXCOORD3 [[ attribute(6) ]] ;
    float4 COLOR0 [[ attribute(7) ]] ;
};
struct Mtl_KernelPatchInfo
{
    uint numPatches;
    ushort numControlPointsPerPatch;
};
struct VGlobals_Type
{
    float4 _Time;
    float4 _SinTime;
    float4 _CosTime;
    float4 unity_DeltaTime;
    float3 _WorldSpaceCameraPos;
    float4 _ProjectionParams;
    float4 _ScreenParams;
    float4 _ZBufferParams;
    float4 unity_OrthoParams;
    float4 unity_CameraWorldClipPlanes[6];
    float4 hlslcc_mtx4x4unity_CameraProjection[4];
    float4 hlslcc_mtx4x4unity_CameraInvProjection[4];
    float4 hlslcc_mtx4x4unity_WorldToCamera[4];
    float4 hlslcc_mtx4x4unity_CameraToWorld[4];
    float4 _WorldSpaceLightPos0;
    float4 _LightPositionRange;
    float4 _LightProjectionParams;
    float4 unity_4LightPosX0;
    float4 unity_4LightPosY0;
    float4 unity_4LightPosZ0;
    float4 unity_4LightAtten0;
    float4 unity_LightColor[8];
    float4 unity_LightPosition[8];
    float4 unity_LightAtten[8];
    float4 unity_SpotDirection[8];
    float4 unity_SHAr;
    float4 unity_SHAg;
    float4 unity_SHAb;
    float4 unity_SHBr;
    float4 unity_SHBg;
    float4 unity_SHBb;
    float4 unity_SHC;
    float4 unity_OcclusionMaskSelector;
    float4 unity_ProbesOcclusion;
    float3 unity_LightColor0;
    float3 unity_LightColor1;
    float3 unity_LightColor2;
    float3 unity_LightColor3;
    float4 unity_ShadowSplitSpheres[4];
    float4 unity_ShadowSplitSqRadii;
    float4 unity_LightShadowBias;
    float4 _LightSplitsNear;
    float4 _LightSplitsFar;
    float4 hlslcc_mtx4x4unity_WorldToShadow[16];
    float4 _LightShadowData;
    float4 unity_ShadowFadeCenterAndType;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 unity_LODFade;
    float4 unity_WorldTransformParams;
    float4 unity_RenderingLayer;
    float4 hlslcc_mtx4x4glstate_matrix_transpose_modelview0[4];
    float4 glstate_lightmodel_ambient;
    float4 unity_AmbientSky;
    float4 unity_AmbientEquator;
    float4 unity_AmbientGround;
    float4 unity_IndirectSpecColor;
    float4 hlslcc_mtx4x4glstate_matrix_projection[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixInvV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    int unity_StereoEyeIndex;
    float4 unity_ShadowColor;
    float4 unity_FogColor;
    float4 unity_FogParams;
    float4 unity_LightmapST;
    float4 unity_DynamicLightmapST;
    float4 unity_SpecCube0_BoxMax;
    float4 unity_SpecCube0_BoxMin;
    float4 unity_SpecCube0_ProbePosition;
    float4 unity_SpecCube0_HDR;
    float4 unity_SpecCube1_BoxMax;
    float4 unity_SpecCube1_BoxMin;
    float4 unity_SpecCube1_ProbePosition;
    float4 unity_SpecCube1_HDR;
    float4 unity_ProbeVolumeParams;
    float4 hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[4];
    float3 unity_ProbeVolumeSizeInv;
    float3 unity_ProbeVolumeMin;
    float4 unity_Lightmap_HDR;
    float4 unity_DynamicLightmap_HDR;
    float4 _LightColor0;
    float4 _SpecColor;
    float4 hlslcc_mtx4x4unity_WorldToLight[4];
    float _Tile;
    float _HeightDisplacement;
    float _NormalScale;
    float4 _ColorTint;
    float _MetallicStrength;
    float _SmoothnessStrength;
    float _EdgeLength;
    float4 _texcoord_ST;
};
struct Mtl_HullIn
{
    Mtl_VertexOut cp[3];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
kernel void patchKernel(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn vertexInput [[ stage_in ]],
    uint2 tID [[ thread_position_in_grid ]],
    ushort2 groupID [[ threadgroup_position_in_grid ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    constant Mtl_KernelPatchInfo &patchInfo [[ buffer(3) ]])
{
#pragma clang diagnostic pop
    Mtl_ControlPoint output;
    const uint numPatchesInThreadGroup = 10;
    const uint patchID = (tID.x / patchInfo.numControlPointsPerPatch);
    const bool patchValid = (patchID < patchInfo.numPatches);
    const uint mtl_BaseInstance = 0;
    const uint mtl_InstanceID = groupID.y - mtl_BaseInstance;
    const uint internalPatchID = mtl_InstanceID * patchInfo.numPatches + patchID;
    const uint patchIDInThreadGroup = (patchID % numPatchesInThreadGroup);
    const uint controlPointID = (tID.x % patchInfo.numControlPointsPerPatch);
    const uint mtl_BaseVertex = 0;
    const uint mtl_VertexID = ((mtl_InstanceID * (patchInfo.numControlPointsPerPatch * patchInfo.numPatches)) + tID.x) - mtl_BaseVertex;
    threadgroup Mtl_HullIn inputGroup[numPatchesInThreadGroup];
    threadgroup Mtl_HullIn &input = inputGroup[patchIDInThreadGroup];
    MTLTriangleTessellationFactorsHalf tessFactor;
    if (patchValid) {
        input.cp[controlPointID] = vertexFunction(vertexInput);
        output.INTERNALTESSPOS0 = input.cp[controlPointID].INTERNALTESSPOS0;
        output.TANGENT0 = input.cp[controlPointID].TANGENT0;
        output.NORMAL0 = input.cp[controlPointID].NORMAL0;
        output.TEXCOORD0 = input.cp[controlPointID].TEXCOORD0;
        output.TEXCOORD1 = input.cp[controlPointID].TEXCOORD1;
        output.TEXCOORD2 = input.cp[controlPointID].TEXCOORD2;
        output.TEXCOORD3 = input.cp[controlPointID].TEXCOORD3;
        output.COLOR0 = input.cp[controlPointID].COLOR0;
    }
    threadgroup_barrier(mem_flags::mem_threadgroup);
    if (!patchValid) {
        return;
    }
    float3 u_xlat0;
    float3 u_xlat1;
    float3 u_xlat2;
    float3 u_xlat3;
    float3 u_xlat4;
    float u_xlat12;
    float u_xlat13;
    // fork_phase2
    {
        u_xlat0.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[1].INTERNALTESSPOS0.yyy;
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[1].INTERNALTESSPOS0.xxx, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[1].INTERNALTESSPOS0.zzz, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[1].INTERNALTESSPOS0.www, u_xlat0.xyz);
        u_xlat1.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[2].INTERNALTESSPOS0.yyy;
        u_xlat1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[2].INTERNALTESSPOS0.xxx, u_xlat1.xyz);
        u_xlat1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[2].INTERNALTESSPOS0.zzz, u_xlat1.xyz);
        u_xlat1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[2].INTERNALTESSPOS0.www, u_xlat1.xyz);
        u_xlat2.xyz = u_xlat0.xyz + u_xlat1.xyz;
        u_xlat2.xyz = fma(u_xlat2.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat12 = dot(u_xlat2.xyz, u_xlat2.xyz);
        u_xlat12 = sqrt(u_xlat12);
        u_xlat12 = u_xlat12 * VGlobals._EdgeLength;
        u_xlat2.xyz = u_xlat0.xyz + (-u_xlat1.xyz);
        u_xlat13 = dot(u_xlat2.xyz, u_xlat2.xyz);
        u_xlat13 = sqrt(u_xlat13);
        u_xlat13 = u_xlat13 * VGlobals._ScreenParams.y;
        u_xlat12 = u_xlat13 / u_xlat12;
        tessFactor.edgeTessellationFactor[0] = max(u_xlat12, 1.0);
        u_xlat2.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[0].INTERNALTESSPOS0.yyy;
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[0].INTERNALTESSPOS0.xxx, u_xlat2.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[0].INTERNALTESSPOS0.zzz, u_xlat2.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[0].INTERNALTESSPOS0.www, u_xlat2.xyz);
        u_xlat3.xyz = u_xlat1.xyz + u_xlat2.xyz;
        u_xlat1.xyz = u_xlat1.xyz + (-u_xlat2.xyz);
        u_xlat12 = dot(u_xlat1.xyz, u_xlat1.xyz);
        u_xlat12 = sqrt(u_xlat12);
        u_xlat12 = u_xlat12 * VGlobals._ScreenParams.y;
        u_xlat1.xyz = fma(u_xlat3.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat1.x = dot(u_xlat1.xyz, u_xlat1.xyz);
        u_xlat1.x = sqrt(u_xlat1.x);
        u_xlat1.x = u_xlat1.x * VGlobals._EdgeLength;
        u_xlat12 = u_xlat12 / u_xlat1.x;
        tessFactor.edgeTessellationFactor[1] = max(u_xlat12, 1.0);
        u_xlat1.xyz = u_xlat0.xyz + u_xlat2.xyz;
        u_xlat0.xyz = (-u_xlat0.xyz) + u_xlat2.xyz;
        u_xlat0.x = dot(u_xlat0.xyz, u_xlat0.xyz);
        u_xlat0.x = sqrt(u_xlat0.x);
        u_xlat0.x = u_xlat0.x * VGlobals._ScreenParams.y;
        u_xlat4.xyz = fma(u_xlat1.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat4.x = dot(u_xlat4.xyz, u_xlat4.xyz);
        u_xlat4.x = sqrt(u_xlat4.x);
        u_xlat4.x = u_xlat4.x * VGlobals._EdgeLength;
        u_xlat0.x = u_xlat0.x / u_xlat4.x;
        tessFactor.edgeTessellationFactor[2] = max(u_xlat0.x, 1.0);
    }
    // join_phase3
    {
        u_xlat0.x = tessFactor.edgeTessellationFactor[0] + tessFactor.edgeTessellationFactor[1];
        u_xlat0.x = u_xlat0.x + tessFactor.edgeTessellationFactor[2];
        tessFactor.insideTessellationFactor = u_xlat0.x * 0.333333343;
    }
    controlPoints[mtl_VertexID] = output;
    tessFactors[internalPatchID] = tessFactor;
}
// SHADER_STAGE_HULL_end
// SHADER_STAGE_DOMAIN_begin
struct Mtl_VertexInPostTess
{
    patch_control_point<Mtl_ControlPointIn> cp;
};
struct Mtl_VertexOutPostTess
{
    float4 mtl_Position [[ position ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float3 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float3 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float3 TEXCOORD3 [[ user(TEXCOORD3) ]];
    float3 TEXCOORD4 [[ user(TEXCOORD4) ]];
    float3 TEXCOORD5 [[ user(TEXCOORD5) ]];
    float4 TEXCOORD6 [[ user(TEXCOORD6) ]];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    sampler sampler_Height [[ sampler (0) ]],
    texture2d<float, access::sample > _Height [[ texture(0) ]] ,
    float3 mtl_TessCoord [[ position_in_patch ]],
    uint patchID [[ patch_id ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    Mtl_VertexInPostTess input [[ stage_in ]])
{
#pragma clang diagnostic pop
    Mtl_VertexOutPostTess output;
    MTLTriangleTessellationFactorsHalf tessFactor;
    tessFactor = tessFactors[patchID];
    float4 u_xlat0;
    float3 u_xlat1;
    float4 u_xlat2;
    float4 u_xlat3;
    float4 u_xlat4;
    float2 u_xlat10;
    float u_xlat16;
    u_xlat0.xy = mtl_TessCoord.yy * input.cp[1].TEXCOORD0.xy;
    u_xlat0.xy = fma(input.cp[0].TEXCOORD0.xy, mtl_TessCoord.xx, u_xlat0.xy);
    u_xlat0.xy = fma(input.cp[2].TEXCOORD0.xy, mtl_TessCoord.zz, u_xlat0.xy);
    u_xlat10.xy = u_xlat0.xy * float2(VGlobals._Tile);
    output.TEXCOORD0.xy = fma(u_xlat0.xy, VGlobals._texcoord_ST.xy, VGlobals._texcoord_ST.zw);
    u_xlat0.xyz = _Height.sample(sampler_Height, u_xlat10.xy, level(1.0)).xyz;
    u_xlat1.xyz = mtl_TessCoord.yyy * input.cp[1].NORMAL0.xyz;
    u_xlat1.xyz = fma(input.cp[0].NORMAL0.xyz, mtl_TessCoord.xxx, u_xlat1.xyz);
    u_xlat1.xyz = fma(input.cp[2].NORMAL0.xyz, mtl_TessCoord.zzz, u_xlat1.xyz);
    u_xlat0.xyz = u_xlat0.xyz * u_xlat1.xyz;
    u_xlat2 = mtl_TessCoord.yyyy * input.cp[1].INTERNALTESSPOS0;
    u_xlat2 = fma(input.cp[0].INTERNALTESSPOS0, mtl_TessCoord.xxxx, u_xlat2);
    u_xlat2 = fma(input.cp[2].INTERNALTESSPOS0, mtl_TessCoord.zzzz, u_xlat2);
    u_xlat0.xyz = fma(u_xlat0.xyz, float3(VGlobals._HeightDisplacement), u_xlat2.xyz);
    u_xlat3 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], u_xlat0.xxxx, u_xlat3);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], u_xlat0.zzzz, u_xlat3);
    u_xlat3 = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat4 = u_xlat3.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat4 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat3.xxxx, u_xlat4);
    u_xlat4 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat3.zzzz, u_xlat4);
    output.mtl_Position = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat3.wwww, u_xlat4);
    u_xlat2.y = dot(u_xlat1.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat2.z = dot(u_xlat1.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat2.x = dot(u_xlat1.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat1.x = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat1.x = rsqrt(u_xlat1.x);
    u_xlat1.xyz = u_xlat1.xxx * u_xlat2.xyz;
    output.TEXCOORD1.z = u_xlat1.y;
    u_xlat3 = mtl_TessCoord.yyyy * input.cp[1].TANGENT0;
    u_xlat3 = fma(input.cp[0].TANGENT0, mtl_TessCoord.xxxx, u_xlat3);
    u_xlat3 = fma(input.cp[2].TANGENT0, mtl_TessCoord.zzzz, u_xlat3);
    u_xlat2.xyz = u_xlat3.yyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].yzx;
    u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].yzx, u_xlat3.xxx, u_xlat2.xyz);
    u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].yzx, u_xlat3.zzz, u_xlat2.xyz);
    u_xlat16 = u_xlat3.w * VGlobals.unity_WorldTransformParams.w;
    u_xlat3.x = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat3.x = rsqrt(u_xlat3.x);
    u_xlat2.xyz = u_xlat2.xyz * u_xlat3.xxx;
    u_xlat3.xyz = u_xlat1.xyz * u_xlat2.xyz;
    u_xlat3.xyz = fma(u_xlat1.zxy, u_xlat2.yzx, (-u_xlat3.xyz));
    u_xlat3.xyz = float3(u_xlat16) * u_xlat3.xyz;
    output.TEXCOORD1.y = u_xlat3.x;
    output.TEXCOORD1.x = u_xlat2.z;
    output.TEXCOORD2.x = u_xlat2.x;
    output.TEXCOORD3.x = u_xlat2.y;
    output.TEXCOORD2.z = u_xlat1.z;
    output.TEXCOORD3.z = u_xlat1.x;
    output.TEXCOORD2.y = u_xlat3.y;
    output.TEXCOORD3.y = u_xlat3.z;
    output.TEXCOORD4.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, u_xlat2.www, u_xlat0.xyz);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3], u_xlat2.wwww, u_xlat0);
    u_xlat1.xyz = u_xlat0.yyy * VGlobals.hlslcc_mtx4x4unity_WorldToLight[1].xyz;
    u_xlat1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_WorldToLight[0].xyz, u_xlat0.xxx, u_xlat1.xyz);
    u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_WorldToLight[2].xyz, u_xlat0.zzz, u_xlat1.xyz);
    output.TEXCOORD5.xyz = fma(VGlobals.hlslcc_mtx4x4unity_WorldToLight[3].xyz, u_xlat0.www, u_xlat0.xyz);
    output.TEXCOORD6 = float4(0.0, 0.0, 0.0, 0.0);
    return output;
}
// SHADER_STAGE_DOMAIN_end
Compilation succeeded with: 

program_source:293:53: warning: writable resources in non-void post-tessellation vertex function
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
                                                    ^
program_source:299:30: note: writable buffer defined here
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
                             ^
program_source:300:48: note: writable buffer defined here
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
                                               ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float4 TEXCOORD0 [[ attribute(3) ]] ;
    float4 TEXCOORD1 [[ attribute(4) ]] ;
    float4 TEXCOORD2 [[ attribute(5) ]] ;
    float4 TEXCOORD3 [[ attribute(6) ]] ;
    float4 COLOR0 [[ attribute(7) ]] ;
};
struct Mtl_VertexOut
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float4 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float4 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float4 TEXCOORD3 [[ user(TEXCOORD3) ]];
    float4 COLOR0 [[ user(COLOR0) ]];
};
static Mtl_VertexOut vertexFunction(
    Mtl_VertexIn input)
{
    Mtl_VertexOut output;
    output.INTERNALTESSPOS0 = input.POSITION0;
    output.TANGENT0 = input.TANGENT0;
    output.NORMAL0.xyz = input.NORMAL0.xyz;
    output.TEXCOORD0 = input.TEXCOORD0;
    output.TEXCOORD1 = input.TEXCOORD1;
    output.TEXCOORD2 = input.TEXCOORD2;
    output.TEXCOORD3 = input.TEXCOORD3;
    output.COLOR0 = input.COLOR0;
    return output;
}
// SHADER_STAGE_HULL_begin
struct Mtl_ControlPoint
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float4 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float4 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float4 TEXCOORD3 [[ user(TEXCOORD3) ]];
    float4 COLOR0 [[ user(COLOR0) ]];
};
struct Mtl_ControlPointIn
{
    float4 INTERNALTESSPOS0 [[ attribute(8) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float4 TEXCOORD0 [[ attribute(3) ]] ;
    float4 TEXCOORD1 [[ attribute(4) ]] ;
    float4 TEXCOORD2 [[ attribute(5) ]] ;
    float4 TEXCOORD3 [[ attribute(6) ]] ;
    float4 COLOR0 [[ attribute(7) ]] ;
};
struct Mtl_KernelPatchInfo
{
    uint numPatches;
    ushort numControlPointsPerPatch;
};
struct VGlobals_Type
{
    float4 _Time;
    float4 _SinTime;
    float4 _CosTime;
    float4 unity_DeltaTime;
    float3 _WorldSpaceCameraPos;
    float4 _ProjectionParams;
    float4 _ScreenParams;
    float4 _ZBufferParams;
    float4 unity_OrthoParams;
    float4 unity_CameraWorldClipPlanes[6];
    float4 hlslcc_mtx4x4unity_CameraProjection[4];
    float4 hlslcc_mtx4x4unity_CameraInvProjection[4];
    float4 hlslcc_mtx4x4unity_WorldToCamera[4];
    float4 hlslcc_mtx4x4unity_CameraToWorld[4];
    float4 _WorldSpaceLightPos0;
    float4 _LightPositionRange;
    float4 _LightProjectionParams;
    float4 unity_4LightPosX0;
    float4 unity_4LightPosY0;
    float4 unity_4LightPosZ0;
    float4 unity_4LightAtten0;
    float4 unity_LightColor[8];
    float4 unity_LightPosition[8];
    float4 unity_LightAtten[8];
    float4 unity_SpotDirection[8];
    float4 unity_SHAr;
    float4 unity_SHAg;
    float4 unity_SHAb;
    float4 unity_SHBr;
    float4 unity_SHBg;
    float4 unity_SHBb;
    float4 unity_SHC;
    float4 unity_OcclusionMaskSelector;
    float4 unity_ProbesOcclusion;
    float3 unity_LightColor0;
    float3 unity_LightColor1;
    float3 unity_LightColor2;
    float3 unity_LightColor3;
    float4 unity_ShadowSplitSpheres[4];
    float4 unity_ShadowSplitSqRadii;
    float4 unity_LightShadowBias;
    float4 _LightSplitsNear;
    float4 _LightSplitsFar;
    float4 hlslcc_mtx4x4unity_WorldToShadow[16];
    float4 _LightShadowData;
    float4 unity_ShadowFadeCenterAndType;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 unity_LODFade;
    float4 unity_WorldTransformParams;
    float4 unity_RenderingLayer;
    float4 hlslcc_mtx4x4glstate_matrix_transpose_modelview0[4];
    float4 glstate_lightmodel_ambient;
    float4 unity_AmbientSky;
    float4 unity_AmbientEquator;
    float4 unity_AmbientGround;
    float4 unity_IndirectSpecColor;
    float4 hlslcc_mtx4x4glstate_matrix_projection[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixInvV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    int unity_StereoEyeIndex;
    float4 unity_ShadowColor;
    float4 unity_FogColor;
    float4 unity_FogParams;
    float4 unity_LightmapST;
    float4 unity_DynamicLightmapST;
    float4 unity_SpecCube0_BoxMax;
    float4 unity_SpecCube0_BoxMin;
    float4 unity_SpecCube0_ProbePosition;
    float4 unity_SpecCube0_HDR;
    float4 unity_SpecCube1_BoxMax;
    float4 unity_SpecCube1_BoxMin;
    float4 unity_SpecCube1_ProbePosition;
    float4 unity_SpecCube1_HDR;
    float4 unity_ProbeVolumeParams;
    float4 hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[4];
    float3 unity_ProbeVolumeSizeInv;
    float3 unity_ProbeVolumeMin;
    float4 unity_Lightmap_HDR;
    float4 unity_DynamicLightmap_HDR;
    float4 _LightColor0;
    float4 _SpecColor;
    float _Tile;
    float _HeightDisplacement;
    float _NormalScale;
    float4 _ColorTint;
    float _MetallicStrength;
    float _SmoothnessStrength;
    float _EdgeLength;
};
struct Mtl_HullIn
{
    Mtl_VertexOut cp[3];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
kernel void patchKernel(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn vertexInput [[ stage_in ]],
    uint2 tID [[ thread_position_in_grid ]],
    ushort2 groupID [[ threadgroup_position_in_grid ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    constant Mtl_KernelPatchInfo &patchInfo [[ buffer(3) ]])
{
#pragma clang diagnostic pop
    Mtl_ControlPoint output;
    const uint numPatchesInThreadGroup = 10;
    const uint patchID = (tID.x / patchInfo.numControlPointsPerPatch);
    const bool patchValid = (patchID < patchInfo.numPatches);
    const uint mtl_BaseInstance = 0;
    const uint mtl_InstanceID = groupID.y - mtl_BaseInstance;
    const uint internalPatchID = mtl_InstanceID * patchInfo.numPatches + patchID;
    const uint patchIDInThreadGroup = (patchID % numPatchesInThreadGroup);
    const uint controlPointID = (tID.x % patchInfo.numControlPointsPerPatch);
    const uint mtl_BaseVertex = 0;
    const uint mtl_VertexID = ((mtl_InstanceID * (patchInfo.numControlPointsPerPatch * patchInfo.numPatches)) + tID.x) - mtl_BaseVertex;
    threadgroup Mtl_HullIn inputGroup[numPatchesInThreadGroup];
    threadgroup Mtl_HullIn &input = inputGroup[patchIDInThreadGroup];
    MTLTriangleTessellationFactorsHalf tessFactor;
    if (patchValid) {
        input.cp[controlPointID] = vertexFunction(vertexInput);
        output.INTERNALTESSPOS0 = input.cp[controlPointID].INTERNALTESSPOS0;
        output.TANGENT0 = input.cp[controlPointID].TANGENT0;
        output.NORMAL0 = input.cp[controlPointID].NORMAL0;
        output.TEXCOORD0 = input.cp[controlPointID].TEXCOORD0;
        output.TEXCOORD1 = input.cp[controlPointID].TEXCOORD1;
        output.TEXCOORD2 = input.cp[controlPointID].TEXCOORD2;
        output.TEXCOORD3 = input.cp[controlPointID].TEXCOORD3;
        output.COLOR0 = input.cp[controlPointID].COLOR0;
    }
    threadgroup_barrier(mem_flags::mem_threadgroup);
    if (!patchValid) {
        return;
    }
    float3 u_xlat0;
    float3 u_xlat1;
    float3 u_xlat2;
    float3 u_xlat3;
    float3 u_xlat4;
    float u_xlat12;
    float u_xlat13;
    // fork_phase2
    {
        u_xlat0.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[1].INTERNALTESSPOS0.yyy;
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[1].INTERNALTESSPOS0.xxx, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[1].INTERNALTESSPOS0.zzz, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[1].INTERNALTESSPOS0.www, u_xlat0.xyz);
        u_xlat1.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[2].INTERNALTESSPOS0.yyy;
        u_xlat1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[2].INTERNALTESSPOS0.xxx, u_xlat1.xyz);
        u_xlat1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[2].INTERNALTESSPOS0.zzz, u_xlat1.xyz);
        u_xlat1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[2].INTERNALTESSPOS0.www, u_xlat1.xyz);
        u_xlat2.xyz = u_xlat0.xyz + u_xlat1.xyz;
        u_xlat2.xyz = fma(u_xlat2.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat12 = dot(u_xlat2.xyz, u_xlat2.xyz);
        u_xlat12 = sqrt(u_xlat12);
        u_xlat12 = u_xlat12 * VGlobals._EdgeLength;
        u_xlat2.xyz = u_xlat0.xyz + (-u_xlat1.xyz);
        u_xlat13 = dot(u_xlat2.xyz, u_xlat2.xyz);
        u_xlat13 = sqrt(u_xlat13);
        u_xlat13 = u_xlat13 * VGlobals._ScreenParams.y;
        u_xlat12 = u_xlat13 / u_xlat12;
        tessFactor.edgeTessellationFactor[0] = max(u_xlat12, 1.0);
        u_xlat2.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[0].INTERNALTESSPOS0.yyy;
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[0].INTERNALTESSPOS0.xxx, u_xlat2.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[0].INTERNALTESSPOS0.zzz, u_xlat2.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[0].INTERNALTESSPOS0.www, u_xlat2.xyz);
        u_xlat3.xyz = u_xlat1.xyz + u_xlat2.xyz;
        u_xlat1.xyz = u_xlat1.xyz + (-u_xlat2.xyz);
        u_xlat12 = dot(u_xlat1.xyz, u_xlat1.xyz);
        u_xlat12 = sqrt(u_xlat12);
        u_xlat12 = u_xlat12 * VGlobals._ScreenParams.y;
        u_xlat1.xyz = fma(u_xlat3.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat1.x = dot(u_xlat1.xyz, u_xlat1.xyz);
        u_xlat1.x = sqrt(u_xlat1.x);
        u_xlat1.x = u_xlat1.x * VGlobals._EdgeLength;
        u_xlat12 = u_xlat12 / u_xlat1.x;
        tessFactor.edgeTessellationFactor[1] = max(u_xlat12, 1.0);
        u_xlat1.xyz = u_xlat0.xyz + u_xlat2.xyz;
        u_xlat0.xyz = (-u_xlat0.xyz) + u_xlat2.xyz;
        u_xlat0.x = dot(u_xlat0.xyz, u_xlat0.xyz);
        u_xlat0.x = sqrt(u_xlat0.x);
        u_xlat0.x = u_xlat0.x * VGlobals._ScreenParams.y;
        u_xlat4.xyz = fma(u_xlat1.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat4.x = dot(u_xlat4.xyz, u_xlat4.xyz);
        u_xlat4.x = sqrt(u_xlat4.x);
        u_xlat4.x = u_xlat4.x * VGlobals._EdgeLength;
        u_xlat0.x = u_xlat0.x / u_xlat4.x;
        tessFactor.edgeTessellationFactor[2] = max(u_xlat0.x, 1.0);
    }
    // join_phase3
    {
        u_xlat0.x = tessFactor.edgeTessellationFactor[0] + tessFactor.edgeTessellationFactor[1];
        u_xlat0.x = u_xlat0.x + tessFactor.edgeTessellationFactor[2];
        tessFactor.insideTessellationFactor = u_xlat0.x * 0.333333343;
    }
    controlPoints[mtl_VertexID] = output;
    tessFactors[internalPatchID] = tessFactor;
}
// SHADER_STAGE_HULL_end
// SHADER_STAGE_DOMAIN_begin
struct Mtl_VertexInPostTess
{
    patch_control_point<Mtl_ControlPointIn> cp;
};
struct Mtl_VertexOutPostTess
{
    float4 mtl_Position [[ position ]];
    float3 TEXCOORD1 [[ user(TEXCOORD1) ]];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    sampler sampler_Height [[ sampler (0) ]],
    texture2d<float, access::sample > _Height [[ texture(0) ]] ,
    float3 mtl_TessCoord [[ position_in_patch ]],
    uint patchID [[ patch_id ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    Mtl_VertexInPostTess input [[ stage_in ]])
{
#pragma clang diagnostic pop
    Mtl_VertexOutPostTess output;
    MTLTriangleTessellationFactorsHalf tessFactor;
    tessFactor = tessFactors[patchID];
    float4 u_xlat0;
    float4 u_xlat1;
    float4 u_xlat2;
    float4 u_xlat3;
    float4 u_xlat4;
    float u_xlat11;
    float u_xlat15;
    bool u_xlatb15;
    u_xlat0.xyz = mtl_TessCoord.yyy * input.cp[1].NORMAL0.xyz;
    u_xlat0.xyz = fma(input.cp[0].NORMAL0.xyz, mtl_TessCoord.xxx, u_xlat0.xyz);
    u_xlat0.xyz = fma(input.cp[2].NORMAL0.xyz, mtl_TessCoord.zzz, u_xlat0.xyz);
    u_xlat1.x = dot(u_xlat0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat1.y = dot(u_xlat0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat1.z = dot(u_xlat0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat15 = dot(u_xlat1.xyz, u_xlat1.xyz);
    u_xlat15 = rsqrt(u_xlat15);
    u_xlat1.xyz = float3(u_xlat15) * u_xlat1.xyz;
    u_xlat2.xy = mtl_TessCoord.yy * input.cp[1].TEXCOORD0.xy;
    u_xlat2.xy = fma(input.cp[0].TEXCOORD0.xy, mtl_TessCoord.xx, u_xlat2.xy);
    u_xlat2.xy = fma(input.cp[2].TEXCOORD0.xy, mtl_TessCoord.zz, u_xlat2.xy);
    u_xlat2.xy = u_xlat2.xy * float2(VGlobals._Tile);
    u_xlat2.xyz = _Height.sample(sampler_Height, u_xlat2.xy, level(1.0)).xyz;
    u_xlat0.xyz = u_xlat0.xyz * u_xlat2.xyz;
    u_xlat2 = mtl_TessCoord.yyyy * input.cp[1].INTERNALTESSPOS0;
    u_xlat2 = fma(input.cp[0].INTERNALTESSPOS0, mtl_TessCoord.xxxx, u_xlat2);
    u_xlat2 = fma(input.cp[2].INTERNALTESSPOS0, mtl_TessCoord.zzzz, u_xlat2);
    u_xlat0.xyz = fma(u_xlat0.xyz, float3(VGlobals._HeightDisplacement), u_xlat2.xyz);
    u_xlat3 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], u_xlat0.xxxx, u_xlat3);
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], u_xlat0.zzzz, u_xlat3);
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3], u_xlat2.wwww, u_xlat3);
    u_xlat2.xyz = fma((-u_xlat3.xyz), VGlobals._WorldSpaceLightPos0.www, VGlobals._WorldSpaceLightPos0.xyz);
    u_xlat15 = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat15 = rsqrt(u_xlat15);
    u_xlat2.xyz = float3(u_xlat15) * u_xlat2.xyz;
    u_xlat15 = dot(u_xlat1.xyz, u_xlat2.xyz);
    u_xlat15 = fma((-u_xlat15), u_xlat15, 1.0);
    u_xlat15 = sqrt(u_xlat15);
    u_xlat15 = u_xlat15 * VGlobals.unity_LightShadowBias.z;
    u_xlat1.xyz = fma((-u_xlat1.xyz), float3(u_xlat15), u_xlat3.xyz);
    u_xlatb15 = VGlobals.unity_LightShadowBias.z!=0.0;
    u_xlat1.xyz = (bool(u_xlatb15)) ? u_xlat1.xyz : u_xlat3.xyz;
    u_xlat4 = u_xlat1.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat4 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat1.xxxx, u_xlat4);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat1.zzzz, u_xlat4);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat3.wwww, u_xlat1);
    u_xlat15 = VGlobals.unity_LightShadowBias.x / u_xlat1.w;
    u_xlat15 = min(u_xlat15, 0.0);
    u_xlat15 = max(u_xlat15, -1.0);
    u_xlat15 = u_xlat15 + u_xlat1.z;
    u_xlat11 = min(u_xlat1.w, u_xlat15);
    output.mtl_Position.xyw = u_xlat1.xyw;
    u_xlat1.x = (-u_xlat15) + u_xlat11;
    output.mtl_Position.z = fma(VGlobals.unity_LightShadowBias.y, u_xlat1.x, u_xlat15);
    u_xlat1.xyz = u_xlat0.yyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz;
    u_xlat0.xyw = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, u_xlat0.xxx, u_xlat1.xyz);
    u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, u_xlat0.zzz, u_xlat0.xyw);
    output.TEXCOORD1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, u_xlat2.www, u_xlat0.xyz);
    return output;
}
// SHADER_STAGE_DOMAIN_end
Compilation succeeded with: 

program_source:299:53: warning: writable resources in non-void post-tessellation vertex function
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
                                                    ^
program_source:305:30: note: writable buffer defined here
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
                             ^
program_source:306:48: note: writable buffer defined here
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
                                               ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float4 TEXCOORD0 [[ attribute(3) ]] ;
    float4 TEXCOORD1 [[ attribute(4) ]] ;
    float4 TEXCOORD2 [[ attribute(5) ]] ;
    float4 TEXCOORD3 [[ attribute(6) ]] ;
    float4 COLOR0 [[ attribute(7) ]] ;
};
struct Mtl_VertexOut
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float4 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float4 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float4 TEXCOORD3 [[ user(TEXCOORD3) ]];
    float4 COLOR0 [[ user(COLOR0) ]];
};
static Mtl_VertexOut vertexFunction(
    Mtl_VertexIn input)
{
    Mtl_VertexOut output;
    output.INTERNALTESSPOS0 = input.POSITION0;
    output.TANGENT0 = input.TANGENT0;
    output.NORMAL0.xyz = input.NORMAL0.xyz;
    output.TEXCOORD0 = input.TEXCOORD0;
    output.TEXCOORD1 = input.TEXCOORD1;
    output.TEXCOORD2 = input.TEXCOORD2;
    output.TEXCOORD3 = input.TEXCOORD3;
    output.COLOR0 = input.COLOR0;
    return output;
}
// SHADER_STAGE_HULL_begin
struct Mtl_ControlPoint
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float4 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float4 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float4 TEXCOORD3 [[ user(TEXCOORD3) ]];
    float4 COLOR0 [[ user(COLOR0) ]];
};
struct Mtl_ControlPointIn
{
    float4 INTERNALTESSPOS0 [[ attribute(8) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float4 TEXCOORD0 [[ attribute(3) ]] ;
    float4 TEXCOORD1 [[ attribute(4) ]] ;
    float4 TEXCOORD2 [[ attribute(5) ]] ;
    float4 TEXCOORD3 [[ attribute(6) ]] ;
    float4 COLOR0 [[ attribute(7) ]] ;
};
struct Mtl_KernelPatchInfo
{
    uint numPatches;
    ushort numControlPointsPerPatch;
};
struct VGlobals_Type
{
    float4 _Time;
    float4 _SinTime;
    float4 _CosTime;
    float4 unity_DeltaTime;
    float3 _WorldSpaceCameraPos;
    float4 _ProjectionParams;
    float4 _ScreenParams;
    float4 _ZBufferParams;
    float4 unity_OrthoParams;
    float4 unity_CameraWorldClipPlanes[6];
    float4 hlslcc_mtx4x4unity_CameraProjection[4];
    float4 hlslcc_mtx4x4unity_CameraInvProjection[4];
    float4 hlslcc_mtx4x4unity_WorldToCamera[4];
    float4 hlslcc_mtx4x4unity_CameraToWorld[4];
    float4 _WorldSpaceLightPos0;
    float4 _LightPositionRange;
    float4 _LightProjectionParams;
    float4 unity_4LightPosX0;
    float4 unity_4LightPosY0;
    float4 unity_4LightPosZ0;
    float4 unity_4LightAtten0;
    float4 unity_LightColor[8];
    float4 unity_LightPosition[8];
    float4 unity_LightAtten[8];
    float4 unity_SpotDirection[8];
    float4 unity_SHAr;
    float4 unity_SHAg;
    float4 unity_SHAb;
    float4 unity_SHBr;
    float4 unity_SHBg;
    float4 unity_SHBb;
    float4 unity_SHC;
    float4 unity_OcclusionMaskSelector;
    float4 unity_ProbesOcclusion;
    float3 unity_LightColor0;
    float3 unity_LightColor1;
    float3 unity_LightColor2;
    float3 unity_LightColor3;
    float4 unity_ShadowSplitSpheres[4];
    float4 unity_ShadowSplitSqRadii;
    float4 unity_LightShadowBias;
    float4 _LightSplitsNear;
    float4 _LightSplitsFar;
    float4 hlslcc_mtx4x4unity_WorldToShadow[16];
    float4 _LightShadowData;
    float4 unity_ShadowFadeCenterAndType;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 unity_LODFade;
    float4 unity_WorldTransformParams;
    float4 unity_RenderingLayer;
    float4 hlslcc_mtx4x4glstate_matrix_transpose_modelview0[4];
    float4 glstate_lightmodel_ambient;
    float4 unity_AmbientSky;
    float4 unity_AmbientEquator;
    float4 unity_AmbientGround;
    float4 unity_IndirectSpecColor;
    float4 hlslcc_mtx4x4glstate_matrix_projection[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixInvV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    int unity_StereoEyeIndex;
    float4 unity_ShadowColor;
    float4 unity_FogColor;
    float4 unity_FogParams;
    float4 unity_LightmapST;
    float4 unity_DynamicLightmapST;
    float4 unity_SpecCube0_BoxMax;
    float4 unity_SpecCube0_BoxMin;
    float4 unity_SpecCube0_ProbePosition;
    float4 unity_SpecCube0_HDR;
    float4 unity_SpecCube1_BoxMax;
    float4 unity_SpecCube1_BoxMin;
    float4 unity_SpecCube1_ProbePosition;
    float4 unity_SpecCube1_HDR;
    float4 unity_ProbeVolumeParams;
    float4 hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[4];
    float3 unity_ProbeVolumeSizeInv;
    float3 unity_ProbeVolumeMin;
    float4 unity_Lightmap_HDR;
    float4 unity_DynamicLightmap_HDR;
    float4 _LightColor0;
    float4 _SpecColor;
    float _Tile;
    float _HeightDisplacement;
    float _NormalScale;
    float4 _ColorTint;
    float _MetallicStrength;
    float _SmoothnessStrength;
    float _EdgeLength;
    float4 _texcoord_ST;
    float4 unity_Ambient;
};
struct Mtl_HullIn
{
    Mtl_VertexOut cp[3];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
kernel void patchKernel(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn vertexInput [[ stage_in ]],
    uint2 tID [[ thread_position_in_grid ]],
    ushort2 groupID [[ threadgroup_position_in_grid ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    constant Mtl_KernelPatchInfo &patchInfo [[ buffer(3) ]])
{
#pragma clang diagnostic pop
    Mtl_ControlPoint output;
    const uint numPatchesInThreadGroup = 10;
    const uint patchID = (tID.x / patchInfo.numControlPointsPerPatch);
    const bool patchValid = (patchID < patchInfo.numPatches);
    const uint mtl_BaseInstance = 0;
    const uint mtl_InstanceID = groupID.y - mtl_BaseInstance;
    const uint internalPatchID = mtl_InstanceID * patchInfo.numPatches + patchID;
    const uint patchIDInThreadGroup = (patchID % numPatchesInThreadGroup);
    const uint controlPointID = (tID.x % patchInfo.numControlPointsPerPatch);
    const uint mtl_BaseVertex = 0;
    const uint mtl_VertexID = ((mtl_InstanceID * (patchInfo.numControlPointsPerPatch * patchInfo.numPatches)) + tID.x) - mtl_BaseVertex;
    threadgroup Mtl_HullIn inputGroup[numPatchesInThreadGroup];
    threadgroup Mtl_HullIn &input = inputGroup[patchIDInThreadGroup];
    MTLTriangleTessellationFactorsHalf tessFactor;
    if (patchValid) {
        input.cp[controlPointID] = vertexFunction(vertexInput);
        output.INTERNALTESSPOS0 = input.cp[controlPointID].INTERNALTESSPOS0;
        output.TANGENT0 = input.cp[controlPointID].TANGENT0;
        output.NORMAL0 = input.cp[controlPointID].NORMAL0;
        output.TEXCOORD0 = input.cp[controlPointID].TEXCOORD0;
        output.TEXCOORD1 = input.cp[controlPointID].TEXCOORD1;
        output.TEXCOORD2 = input.cp[controlPointID].TEXCOORD2;
        output.TEXCOORD3 = input.cp[controlPointID].TEXCOORD3;
        output.COLOR0 = input.cp[controlPointID].COLOR0;
    }
    threadgroup_barrier(mem_flags::mem_threadgroup);
    if (!patchValid) {
        return;
    }
    float3 u_xlat0;
    float3 u_xlat1;
    float3 u_xlat2;
    float3 u_xlat3;
    float3 u_xlat4;
    float u_xlat12;
    float u_xlat13;
    // fork_phase2
    {
        u_xlat0.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[1].INTERNALTESSPOS0.yyy;
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[1].INTERNALTESSPOS0.xxx, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[1].INTERNALTESSPOS0.zzz, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[1].INTERNALTESSPOS0.www, u_xlat0.xyz);
        u_xlat1.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[2].INTERNALTESSPOS0.yyy;
        u_xlat1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[2].INTERNALTESSPOS0.xxx, u_xlat1.xyz);
        u_xlat1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[2].INTERNALTESSPOS0.zzz, u_xlat1.xyz);
        u_xlat1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[2].INTERNALTESSPOS0.www, u_xlat1.xyz);
        u_xlat2.xyz = u_xlat0.xyz + u_xlat1.xyz;
        u_xlat2.xyz = fma(u_xlat2.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat12 = dot(u_xlat2.xyz, u_xlat2.xyz);
        u_xlat12 = sqrt(u_xlat12);
        u_xlat12 = u_xlat12 * VGlobals._EdgeLength;
        u_xlat2.xyz = u_xlat0.xyz + (-u_xlat1.xyz);
        u_xlat13 = dot(u_xlat2.xyz, u_xlat2.xyz);
        u_xlat13 = sqrt(u_xlat13);
        u_xlat13 = u_xlat13 * VGlobals._ScreenParams.y;
        u_xlat12 = u_xlat13 / u_xlat12;
        tessFactor.edgeTessellationFactor[0] = max(u_xlat12, 1.0);
        u_xlat2.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[0].INTERNALTESSPOS0.yyy;
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[0].INTERNALTESSPOS0.xxx, u_xlat2.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[0].INTERNALTESSPOS0.zzz, u_xlat2.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[0].INTERNALTESSPOS0.www, u_xlat2.xyz);
        u_xlat3.xyz = u_xlat1.xyz + u_xlat2.xyz;
        u_xlat1.xyz = u_xlat1.xyz + (-u_xlat2.xyz);
        u_xlat12 = dot(u_xlat1.xyz, u_xlat1.xyz);
        u_xlat12 = sqrt(u_xlat12);
        u_xlat12 = u_xlat12 * VGlobals._ScreenParams.y;
        u_xlat1.xyz = fma(u_xlat3.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat1.x = dot(u_xlat1.xyz, u_xlat1.xyz);
        u_xlat1.x = sqrt(u_xlat1.x);
        u_xlat1.x = u_xlat1.x * VGlobals._EdgeLength;
        u_xlat12 = u_xlat12 / u_xlat1.x;
        tessFactor.edgeTessellationFactor[1] = max(u_xlat12, 1.0);
        u_xlat1.xyz = u_xlat0.xyz + u_xlat2.xyz;
        u_xlat0.xyz = (-u_xlat0.xyz) + u_xlat2.xyz;
        u_xlat0.x = dot(u_xlat0.xyz, u_xlat0.xyz);
        u_xlat0.x = sqrt(u_xlat0.x);
        u_xlat0.x = u_xlat0.x * VGlobals._ScreenParams.y;
        u_xlat4.xyz = fma(u_xlat1.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat4.x = dot(u_xlat4.xyz, u_xlat4.xyz);
        u_xlat4.x = sqrt(u_xlat4.x);
        u_xlat4.x = u_xlat4.x * VGlobals._EdgeLength;
        u_xlat0.x = u_xlat0.x / u_xlat4.x;
        tessFactor.edgeTessellationFactor[2] = max(u_xlat0.x, 1.0);
    }
    // join_phase3
    {
        u_xlat0.x = tessFactor.edgeTessellationFactor[0] + tessFactor.edgeTessellationFactor[1];
        u_xlat0.x = u_xlat0.x + tessFactor.edgeTessellationFactor[2];
        tessFactor.insideTessellationFactor = u_xlat0.x * 0.333333343;
    }
    controlPoints[mtl_VertexID] = output;
    tessFactors[internalPatchID] = tessFactor;
}
// SHADER_STAGE_HULL_end
// SHADER_STAGE_DOMAIN_begin
struct Mtl_VertexInPostTess
{
    patch_control_point<Mtl_ControlPointIn> cp;
};
struct Mtl_VertexOutPostTess
{
    float4 mtl_Position [[ position ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float4 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float4 TEXCOORD3 [[ user(TEXCOORD3) ]];
    float4 TEXCOORD5 [[ user(TEXCOORD5) ]];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    sampler sampler_Height [[ sampler (0) ]],
    texture2d<float, access::sample > _Height [[ texture(0) ]] ,
    float3 mtl_TessCoord [[ position_in_patch ]],
    uint patchID [[ patch_id ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    Mtl_VertexInPostTess input [[ stage_in ]])
{
#pragma clang diagnostic pop
    Mtl_VertexOutPostTess output;
    MTLTriangleTessellationFactorsHalf tessFactor;
    tessFactor = tessFactors[patchID];
    float4 u_xlat0;
    float4 u_xlat1;
    float4 u_xlat2;
    float4 u_xlat3;
    float2 u_xlat9;
    float u_xlat12;
    float u_xlat13;
    u_xlat0 = mtl_TessCoord.yyyy * input.cp[1].INTERNALTESSPOS0;
    u_xlat0 = fma(input.cp[0].INTERNALTESSPOS0, mtl_TessCoord.xxxx, u_xlat0);
    u_xlat0 = fma(input.cp[2].INTERNALTESSPOS0, mtl_TessCoord.zzzz, u_xlat0);
    u_xlat1.xy = mtl_TessCoord.yy * input.cp[1].TEXCOORD0.xy;
    u_xlat1.xy = fma(input.cp[0].TEXCOORD0.xy, mtl_TessCoord.xx, u_xlat1.xy);
    u_xlat1.xy = fma(input.cp[2].TEXCOORD0.xy, mtl_TessCoord.zz, u_xlat1.xy);
    u_xlat9.xy = u_xlat1.xy * float2(VGlobals._Tile);
    output.TEXCOORD0.xy = fma(u_xlat1.xy, VGlobals._texcoord_ST.xy, VGlobals._texcoord_ST.zw);
    u_xlat1.xyz = _Height.sample(sampler_Height, u_xlat9.xy, level(1.0)).xyz;
    u_xlat2.xyz = mtl_TessCoord.yyy * input.cp[1].NORMAL0.xyz;
    u_xlat2.xyz = fma(input.cp[0].NORMAL0.xyz, mtl_TessCoord.xxx, u_xlat2.xyz);
    u_xlat2.xyz = fma(input.cp[2].NORMAL0.xyz, mtl_TessCoord.zzz, u_xlat2.xyz);
    u_xlat1.xyz = u_xlat1.xyz * u_xlat2.xyz;
    u_xlat0.xyz = fma(u_xlat1.xyz, float3(VGlobals._HeightDisplacement), u_xlat0.xyz);
    u_xlat1 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], u_xlat0.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], u_xlat0.zzzz, u_xlat1);
    u_xlat3 = u_xlat1 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, u_xlat0.www, u_xlat1.xyz);
    u_xlat1 = u_xlat3.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat3.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat3.zzzz, u_xlat1);
    output.mtl_Position = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat3.wwww, u_xlat1);
    u_xlat1.y = dot(u_xlat2.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat1.z = dot(u_xlat2.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat1.x = dot(u_xlat2.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat12 = dot(u_xlat1.xyz, u_xlat1.xyz);
    u_xlat12 = rsqrt(u_xlat12);
    u_xlat1.xyz = float3(u_xlat12) * u_xlat1.xyz;
    output.TEXCOORD1.z = u_xlat1.y;
    u_xlat2 = mtl_TessCoord.yyyy * input.cp[1].TANGENT0;
    u_xlat2 = fma(input.cp[0].TANGENT0, mtl_TessCoord.xxxx, u_xlat2);
    u_xlat2 = fma(input.cp[2].TANGENT0, mtl_TessCoord.zzzz, u_xlat2);
    u_xlat3.xyz = u_xlat2.yyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].yzx;
    u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].yzx, u_xlat2.xxx, u_xlat3.xyz);
    u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].yzx, u_xlat2.zzz, u_xlat3.xyz);
    u_xlat12 = u_xlat2.w * VGlobals.unity_WorldTransformParams.w;
    u_xlat13 = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat13 = rsqrt(u_xlat13);
    u_xlat2.xyz = float3(u_xlat13) * u_xlat2.xyz;
    u_xlat3.xyz = u_xlat1.xyz * u_xlat2.xyz;
    u_xlat3.xyz = fma(u_xlat1.zxy, u_xlat2.yzx, (-u_xlat3.xyz));
    u_xlat3.xyz = float3(u_xlat12) * u_xlat3.xyz;
    output.TEXCOORD1.y = u_xlat3.x;
    output.TEXCOORD1.w = u_xlat0.x;
    output.TEXCOORD1.x = u_xlat2.z;
    output.TEXCOORD2.w = u_xlat0.y;
    output.TEXCOORD3.w = u_xlat0.z;
    output.TEXCOORD2.x = u_xlat2.x;
    output.TEXCOORD3.x = u_xlat2.y;
    output.TEXCOORD2.z = u_xlat1.z;
    output.TEXCOORD3.z = u_xlat1.x;
    output.TEXCOORD2.y = u_xlat3.y;
    output.TEXCOORD3.y = u_xlat3.z;
    output.TEXCOORD5 = float4(0.0, 0.0, 0.0, 0.0);
    return output;
}
// SHADER_STAGE_DOMAIN_end
Compilation succeeded with: 

program_source:303:53: warning: writable resources in non-void post-tessellation vertex function
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
                                                    ^
program_source:309:30: note: writable buffer defined here
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
                             ^
program_source:310:48: note: writable buffer defined here
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
                                               ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float4 TEXCOORD0 [[ attribute(3) ]] ;
    float4 TEXCOORD1 [[ attribute(4) ]] ;
    float4 TEXCOORD2 [[ attribute(5) ]] ;
    float4 TEXCOORD3 [[ attribute(6) ]] ;
    float4 COLOR0 [[ attribute(7) ]] ;
};
struct Mtl_VertexOut
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float4 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float4 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float4 TEXCOORD3 [[ user(TEXCOORD3) ]];
    float4 COLOR0 [[ user(COLOR0) ]];
};
static Mtl_VertexOut vertexFunction(
    Mtl_VertexIn input)
{
    Mtl_VertexOut output;
    output.INTERNALTESSPOS0 = input.POSITION0;
    output.TANGENT0 = input.TANGENT0;
    output.NORMAL0.xyz = input.NORMAL0.xyz;
    output.TEXCOORD0 = input.TEXCOORD0;
    output.TEXCOORD1 = input.TEXCOORD1;
    output.TEXCOORD2 = input.TEXCOORD2;
    output.TEXCOORD3 = input.TEXCOORD3;
    output.COLOR0 = input.COLOR0;
    return output;
}
// SHADER_STAGE_HULL_begin
struct Mtl_ControlPoint
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float4 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float4 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float4 TEXCOORD3 [[ user(TEXCOORD3) ]];
    float4 COLOR0 [[ user(COLOR0) ]];
};
struct Mtl_ControlPointIn
{
    float4 INTERNALTESSPOS0 [[ attribute(8) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float4 TEXCOORD0 [[ attribute(3) ]] ;
    float4 TEXCOORD1 [[ attribute(4) ]] ;
    float4 TEXCOORD2 [[ attribute(5) ]] ;
    float4 TEXCOORD3 [[ attribute(6) ]] ;
    float4 COLOR0 [[ attribute(7) ]] ;
};
struct Mtl_KernelPatchInfo
{
    uint numPatches;
    ushort numControlPointsPerPatch;
};
struct VGlobals_Type
{
    float4 _Time;
    float4 _SinTime;
    float4 _CosTime;
    float4 unity_DeltaTime;
    float3 _WorldSpaceCameraPos;
    float4 _ProjectionParams;
    float4 _ScreenParams;
    float4 _ZBufferParams;
    float4 unity_OrthoParams;
    float4 unity_CameraWorldClipPlanes[6];
    float4 hlslcc_mtx4x4unity_CameraProjection[4];
    float4 hlslcc_mtx4x4unity_CameraInvProjection[4];
    float4 hlslcc_mtx4x4unity_WorldToCamera[4];
    float4 hlslcc_mtx4x4unity_CameraToWorld[4];
    float4 _WorldSpaceLightPos0;
    float4 _LightPositionRange;
    float4 _LightProjectionParams;
    float4 unity_4LightPosX0;
    float4 unity_4LightPosY0;
    float4 unity_4LightPosZ0;
    float4 unity_4LightAtten0;
    float4 unity_LightColor[8];
    float4 unity_LightPosition[8];
    float4 unity_LightAtten[8];
    float4 unity_SpotDirection[8];
    float4 unity_SHAr;
    float4 unity_SHAg;
    float4 unity_SHAb;
    float4 unity_SHBr;
    float4 unity_SHBg;
    float4 unity_SHBb;
    float4 unity_SHC;
    float4 unity_OcclusionMaskSelector;
    float4 unity_ProbesOcclusion;
    float3 unity_LightColor0;
    float3 unity_LightColor1;
    float3 unity_LightColor2;
    float3 unity_LightColor3;
    float4 unity_ShadowSplitSpheres[4];
    float4 unity_ShadowSplitSqRadii;
    float4 unity_LightShadowBias;
    float4 _LightSplitsNear;
    float4 _LightSplitsFar;
    float4 hlslcc_mtx4x4unity_WorldToShadow[16];
    float4 _LightShadowData;
    float4 unity_ShadowFadeCenterAndType;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 unity_LODFade;
    float4 unity_WorldTransformParams;
    float4 unity_RenderingLayer;
    float4 hlslcc_mtx4x4glstate_matrix_transpose_modelview0[4];
    float4 glstate_lightmodel_ambient;
    float4 unity_AmbientSky;
    float4 unity_AmbientEquator;
    float4 unity_AmbientGround;
    float4 unity_IndirectSpecColor;
    float4 hlslcc_mtx4x4glstate_matrix_projection[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixInvV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    int unity_StereoEyeIndex;
    float4 unity_ShadowColor;
    float4 unity_FogColor;
    float4 unity_FogParams;
    float4 unity_LightmapST;
    float4 unity_DynamicLightmapST;
    float4 unity_SpecCube0_BoxMax;
    float4 unity_SpecCube0_BoxMin;
    float4 unity_SpecCube0_ProbePosition;
    float4 unity_SpecCube0_HDR;
    float4 unity_SpecCube1_BoxMax;
    float4 unity_SpecCube1_BoxMin;
    float4 unity_SpecCube1_ProbePosition;
    float4 unity_SpecCube1_HDR;
    float4 unity_ProbeVolumeParams;
    float4 hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[4];
    float3 unity_ProbeVolumeSizeInv;
    float3 unity_ProbeVolumeMin;
    float4 unity_Lightmap_HDR;
    float4 unity_DynamicLightmap_HDR;
    float4 _LightColor0;
    float4 _SpecColor;
    float _Tile;
    float _HeightDisplacement;
    float _NormalScale;
    float4 _ColorTint;
    float _MetallicStrength;
    float _SmoothnessStrength;
    float _EdgeLength;
    bool4 unity_MetaVertexControl;
    bool4 unity_MetaFragmentControl;
    int unity_VisualizationMode;
    float unity_OneOverOutputBoost;
    float unity_MaxOutputValue;
    float unity_UseLinearSpace;
    float4 _texcoord_ST;
};
struct Mtl_HullIn
{
    Mtl_VertexOut cp[3];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
kernel void patchKernel(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn vertexInput [[ stage_in ]],
    uint2 tID [[ thread_position_in_grid ]],
    ushort2 groupID [[ threadgroup_position_in_grid ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    constant Mtl_KernelPatchInfo &patchInfo [[ buffer(3) ]])
{
#pragma clang diagnostic pop
    Mtl_ControlPoint output;
    const uint numPatchesInThreadGroup = 10;
    const uint patchID = (tID.x / patchInfo.numControlPointsPerPatch);
    const bool patchValid = (patchID < patchInfo.numPatches);
    const uint mtl_BaseInstance = 0;
    const uint mtl_InstanceID = groupID.y - mtl_BaseInstance;
    const uint internalPatchID = mtl_InstanceID * patchInfo.numPatches + patchID;
    const uint patchIDInThreadGroup = (patchID % numPatchesInThreadGroup);
    const uint controlPointID = (tID.x % patchInfo.numControlPointsPerPatch);
    const uint mtl_BaseVertex = 0;
    const uint mtl_VertexID = ((mtl_InstanceID * (patchInfo.numControlPointsPerPatch * patchInfo.numPatches)) + tID.x) - mtl_BaseVertex;
    threadgroup Mtl_HullIn inputGroup[numPatchesInThreadGroup];
    threadgroup Mtl_HullIn &input = inputGroup[patchIDInThreadGroup];
    MTLTriangleTessellationFactorsHalf tessFactor;
    if (patchValid) {
        input.cp[controlPointID] = vertexFunction(vertexInput);
        output.INTERNALTESSPOS0 = input.cp[controlPointID].INTERNALTESSPOS0;
        output.TANGENT0 = input.cp[controlPointID].TANGENT0;
        output.NORMAL0 = input.cp[controlPointID].NORMAL0;
        output.TEXCOORD0 = input.cp[controlPointID].TEXCOORD0;
        output.TEXCOORD1 = input.cp[controlPointID].TEXCOORD1;
        output.TEXCOORD2 = input.cp[controlPointID].TEXCOORD2;
        output.TEXCOORD3 = input.cp[controlPointID].TEXCOORD3;
        output.COLOR0 = input.cp[controlPointID].COLOR0;
    }
    threadgroup_barrier(mem_flags::mem_threadgroup);
    if (!patchValid) {
        return;
    }
    float3 u_xlat0;
    float3 u_xlat1;
    float3 u_xlat2;
    float3 u_xlat3;
    float3 u_xlat4;
    float u_xlat12;
    float u_xlat13;
    // fork_phase2
    {
        u_xlat0.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[1].INTERNALTESSPOS0.yyy;
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[1].INTERNALTESSPOS0.xxx, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[1].INTERNALTESSPOS0.zzz, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[1].INTERNALTESSPOS0.www, u_xlat0.xyz);
        u_xlat1.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[2].INTERNALTESSPOS0.yyy;
        u_xlat1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[2].INTERNALTESSPOS0.xxx, u_xlat1.xyz);
        u_xlat1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[2].INTERNALTESSPOS0.zzz, u_xlat1.xyz);
        u_xlat1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[2].INTERNALTESSPOS0.www, u_xlat1.xyz);
        u_xlat2.xyz = u_xlat0.xyz + u_xlat1.xyz;
        u_xlat2.xyz = fma(u_xlat2.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat12 = dot(u_xlat2.xyz, u_xlat2.xyz);
        u_xlat12 = sqrt(u_xlat12);
        u_xlat12 = u_xlat12 * VGlobals._EdgeLength;
        u_xlat2.xyz = u_xlat0.xyz + (-u_xlat1.xyz);
        u_xlat13 = dot(u_xlat2.xyz, u_xlat2.xyz);
        u_xlat13 = sqrt(u_xlat13);
        u_xlat13 = u_xlat13 * VGlobals._ScreenParams.y;
        u_xlat12 = u_xlat13 / u_xlat12;
        tessFactor.edgeTessellationFactor[0] = max(u_xlat12, 1.0);
        u_xlat2.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[0].INTERNALTESSPOS0.yyy;
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[0].INTERNALTESSPOS0.xxx, u_xlat2.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[0].INTERNALTESSPOS0.zzz, u_xlat2.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[0].INTERNALTESSPOS0.www, u_xlat2.xyz);
        u_xlat3.xyz = u_xlat1.xyz + u_xlat2.xyz;
        u_xlat1.xyz = u_xlat1.xyz + (-u_xlat2.xyz);
        u_xlat12 = dot(u_xlat1.xyz, u_xlat1.xyz);
        u_xlat12 = sqrt(u_xlat12);
        u_xlat12 = u_xlat12 * VGlobals._ScreenParams.y;
        u_xlat1.xyz = fma(u_xlat3.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat1.x = dot(u_xlat1.xyz, u_xlat1.xyz);
        u_xlat1.x = sqrt(u_xlat1.x);
        u_xlat1.x = u_xlat1.x * VGlobals._EdgeLength;
        u_xlat12 = u_xlat12 / u_xlat1.x;
        tessFactor.edgeTessellationFactor[1] = max(u_xlat12, 1.0);
        u_xlat1.xyz = u_xlat0.xyz + u_xlat2.xyz;
        u_xlat0.xyz = (-u_xlat0.xyz) + u_xlat2.xyz;
        u_xlat0.x = dot(u_xlat0.xyz, u_xlat0.xyz);
        u_xlat0.x = sqrt(u_xlat0.x);
        u_xlat0.x = u_xlat0.x * VGlobals._ScreenParams.y;
        u_xlat4.xyz = fma(u_xlat1.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat4.x = dot(u_xlat4.xyz, u_xlat4.xyz);
        u_xlat4.x = sqrt(u_xlat4.x);
        u_xlat4.x = u_xlat4.x * VGlobals._EdgeLength;
        u_xlat0.x = u_xlat0.x / u_xlat4.x;
        tessFactor.edgeTessellationFactor[2] = max(u_xlat0.x, 1.0);
    }
    // join_phase3
    {
        u_xlat0.x = tessFactor.edgeTessellationFactor[0] + tessFactor.edgeTessellationFactor[1];
        u_xlat0.x = u_xlat0.x + tessFactor.edgeTessellationFactor[2];
        tessFactor.insideTessellationFactor = u_xlat0.x * 0.333333343;
    }
    controlPoints[mtl_VertexID] = output;
    tessFactors[internalPatchID] = tessFactor;
}
// SHADER_STAGE_HULL_end
// SHADER_STAGE_DOMAIN_begin
struct Mtl_VertexInPostTess
{
    patch_control_point<Mtl_ControlPointIn> cp;
};
struct Mtl_VertexOutPostTess
{
    float4 mtl_Position [[ position ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float4 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float4 TEXCOORD3 [[ user(TEXCOORD3) ]];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    sampler sampler_Height [[ sampler (0) ]],
    texture2d<float, access::sample > _Height [[ texture(0) ]] ,
    float3 mtl_TessCoord [[ position_in_patch ]],
    uint patchID [[ patch_id ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    Mtl_VertexInPostTess input [[ stage_in ]])
{
#pragma clang diagnostic pop
    Mtl_VertexOutPostTess output;
    MTLTriangleTessellationFactorsHalf tessFactor;
    tessFactor = tessFactors[patchID];
    float4 u_xlat0;
    float4 u_xlat1;
    float4 u_xlat2;
    float3 u_xlat3;
    float3 u_xlat4;
    float2 u_xlat13;
    float u_xlat15;
    bool u_xlatb15;
    u_xlat0.xy = mtl_TessCoord.yy * input.cp[1].TEXCOORD2.xy;
    u_xlat0.xy = fma(input.cp[0].TEXCOORD2.xy, mtl_TessCoord.xx, u_xlat0.xy);
    u_xlat0.xy = fma(input.cp[2].TEXCOORD2.xy, mtl_TessCoord.zz, u_xlat0.xy);
    u_xlat0.xy = fma(u_xlat0.xy, VGlobals.unity_DynamicLightmapST.xy, VGlobals.unity_DynamicLightmapST.zw);
    u_xlat1.xy = mtl_TessCoord.yy * input.cp[1].TEXCOORD1.xy;
    u_xlat1.xy = fma(input.cp[0].TEXCOORD1.xy, mtl_TessCoord.xx, u_xlat1.xy);
    u_xlat1.xy = fma(input.cp[2].TEXCOORD1.xy, mtl_TessCoord.zz, u_xlat1.xy);
    u_xlat1.xy = fma(u_xlat1.xy, VGlobals.unity_LightmapST.xy, VGlobals.unity_LightmapST.zw);
    u_xlat2 = mtl_TessCoord.yyyy * input.cp[1].INTERNALTESSPOS0;
    u_xlat2 = fma(input.cp[0].INTERNALTESSPOS0, mtl_TessCoord.xxxx, u_xlat2);
    u_xlat2 = fma(input.cp[2].INTERNALTESSPOS0, mtl_TessCoord.zzzz, u_xlat2);
    u_xlat3.xy = mtl_TessCoord.yy * input.cp[1].TEXCOORD0.xy;
    u_xlat3.xy = fma(input.cp[0].TEXCOORD0.xy, mtl_TessCoord.xx, u_xlat3.xy);
    u_xlat3.xy = fma(input.cp[2].TEXCOORD0.xy, mtl_TessCoord.zz, u_xlat3.xy);
    u_xlat13.xy = u_xlat3.xy * float2(VGlobals._Tile);
    output.TEXCOORD0.xy = fma(u_xlat3.xy, VGlobals._texcoord_ST.xy, VGlobals._texcoord_ST.zw);
    u_xlat3.xyz = _Height.sample(sampler_Height, u_xlat13.xy, level(1.0)).xyz;
    u_xlat4.xyz = mtl_TessCoord.yyy * input.cp[1].NORMAL0.xyz;
    u_xlat4.xyz = fma(input.cp[0].NORMAL0.xyz, mtl_TessCoord.xxx, u_xlat4.xyz);
    u_xlat4.xyz = fma(input.cp[2].NORMAL0.xyz, mtl_TessCoord.zzz, u_xlat4.xyz);
    u_xlat3.xyz = u_xlat3.xyz * u_xlat4.xyz;
    u_xlat2.xyz = fma(u_xlat3.xyz, float3(VGlobals._HeightDisplacement), u_xlat2.xyz);
    u_xlatb15 = 0.0<u_xlat2.z;
    u_xlat1.z = u_xlatb15 ? 9.99999975e-05 : float(0.0);
    u_xlat1.xyz = (VGlobals.unity_MetaVertexControl.x) ? u_xlat1.xyz : u_xlat2.xyz;
    u_xlatb15 = 0.0<u_xlat1.z;
    u_xlat0.z = u_xlatb15 ? 9.99999975e-05 : float(0.0);
    u_xlat0.xyz = (VGlobals.unity_MetaVertexControl.y) ? u_xlat0.xyz : u_xlat1.xyz;
    u_xlat1 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat0.xxxx, u_xlat1);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat0.zzzz, u_xlat1);
    output.mtl_Position = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_MatrixVP[3];
    u_xlat0.xyz = u_xlat2.yyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz;
    u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, u_xlat2.xxx, u_xlat0.xyz);
    u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, u_xlat2.zzz, u_xlat0.xyz);
    u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, u_xlat2.www, u_xlat0.xyz);
    output.TEXCOORD1.w = u_xlat0.x;
    u_xlat1.y = dot(u_xlat4.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat1.z = dot(u_xlat4.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat1.x = dot(u_xlat4.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat0.x = dot(u_xlat1.xyz, u_xlat1.xyz);
    u_xlat0.x = rsqrt(u_xlat0.x);
    u_xlat1.xyz = u_xlat0.xxx * u_xlat1.xyz;
    output.TEXCOORD1.z = u_xlat1.y;
    u_xlat2 = mtl_TessCoord.yyyy * input.cp[1].TANGENT0;
    u_xlat2 = fma(input.cp[0].TANGENT0, mtl_TessCoord.xxxx, u_xlat2);
    u_xlat2 = fma(input.cp[2].TANGENT0, mtl_TessCoord.zzzz, u_xlat2);
    u_xlat3.xyz = u_xlat2.yyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].yzx;
    u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].yzx, u_xlat2.xxx, u_xlat3.xyz);
    u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].yzx, u_xlat2.zzz, u_xlat3.xyz);
    u_xlat0.x = u_xlat2.w * VGlobals.unity_WorldTransformParams.w;
    u_xlat15 = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat15 = rsqrt(u_xlat15);
    u_xlat2.xyz = float3(u_xlat15) * u_xlat2.xyz;
    u_xlat3.xyz = u_xlat1.xyz * u_xlat2.xyz;
    u_xlat3.xyz = fma(u_xlat1.zxy, u_xlat2.yzx, (-u_xlat3.xyz));
    u_xlat3.xyz = u_xlat0.xxx * u_xlat3.xyz;
    output.TEXCOORD1.y = u_xlat3.x;
    output.TEXCOORD1.x = u_xlat2.z;
    output.TEXCOORD2.w = u_xlat0.y;
    output.TEXCOORD3.w = u_xlat0.z;
    output.TEXCOORD2.x = u_xlat2.x;
    output.TEXCOORD3.x = u_xlat2.y;
    output.TEXCOORD2.z = u_xlat1.z;
    output.TEXCOORD3.z = u_xlat1.x;
    output.TEXCOORD2.y = u_xlat3.y;
    output.TEXCOORD3.y = u_xlat3.z;
    return output;
}
// SHADER_STAGE_DOMAIN_end
Refreshing native plugins compatible for Editor in 2.38 ms, found 2 plugins.
Preloading 0 native plugins for Editor in 0.00 ms.
Unloading 3375 Unused Serialized files (Serialized files now loaded: 0)
Unloading 20 unused Assets / (0.6 MB). Loaded Objects now: 3904.
Memory consumption went from 136.4 MB to 135.7 MB.
Total: 5.798290 ms (FindLiveObjects: 0.342795 ms CreateObjectMapping: 0.453392 ms MarkObjects: 4.525319 ms  DeleteObjects: 0.475440 ms)

AssetImportParameters requested are different than current active one (requested -> active):
  custom:video-decoder-ogg-theora: a1e56fd34408186e4bbccfd4996cb3dc -> 
  custom:container-muxer-webm: aa71ff27fc2769a1b78a27578f13a17b -> 
  custom:container-demuxer-webm: 4f35f7cbe854078d1ac9338744f61a02 -> 
  custom:video-encoder-webm-vp8: eb34c28f22e8b96e1ab97ce403110664 -> 
  custom:framework-osx-AVFoundation: b23960f63f64bdc6ff669e2cdcee2391 -> 
  custom:audio-encoder-webm-vorbis: bf7c407c2cedff20999df2af8eb42d56 -> 
  custom:container-demuxer-ogg: 62fdf1f143b41e24485cea50d1cbac27 -> 
  custom:video-decoder-webm-vp8: 9c59270c3fd7afecdb556c50c9e8de78 -> 
  custom:audio-decoder-ogg-vorbis: bf7c407c2cedff20999df2af8eb42d56 -> 
========================================================================
Received Prepare
Registering precompiled user dll's ...
Registered in 0.003717 seconds.
Begin MonoManager ReloadAssembly
Symbol file LoadedFromMemory doesn't match image /Users/kamilaamendolagine/Desktop/Staugen Raug v2 - Prefab - Map 1.01/Library/PackageCache/com.unity.visualscripting@1.7.8/Editor/VisualScripting.Core/Dependencies/YamlDotNet/Unity.VisualScripting.YamlDotNet.dll
Symbol file LoadedFromMemory doesn't match image /Users/kamilaamendolagine/Desktop/Staugen Raug v2 - Prefab - Map 1.01/Library/PackageCache/com.unity.visualscripting@1.7.8/Editor/VisualScripting.Core/Dependencies/DotNetZip/Unity.VisualScripting.IonicZip.dll
Native extension for OSXStandalone target not found
Native extension for WebGL target not found
Refreshing native plugins compatible for Editor in 1.14 ms, found 2 plugins.
Preloading 0 native plugins for Editor in 0.00 ms.
Mono: successfully reloaded assembly
- Completed reload, in  1.868 seconds
Domain Reload Profiling:
	ReloadAssembly (1869ms)
		BeginReloadAssembly (205ms)
			ExecutionOrderSort (0ms)
			DisableScriptedObjects (10ms)
			BackupInstance (0ms)
			ReleaseScriptingObjects (0ms)
			CreateAndSetChildDomain (88ms)
		EndReloadAssembly (1495ms)
			LoadAssemblies (92ms)
			RebuildTransferFunctionScriptingTraits (0ms)
			SetupTypeCache (496ms)
			ReleaseScriptCaches (2ms)
			RebuildScriptCaches (87ms)
			SetupLoadedEditorAssemblies (705ms)
				LogAssemblyErrors (0ms)
				InitializePlatformSupportModulesInManaged (20ms)
				SetLoadedEditorAssemblies (1ms)
				RefreshPlugins (1ms)
				BeforeProcessingInitializeOnLoad (105ms)
				ProcessInitializeOnLoadAttributes (522ms)
				ProcessInitializeOnLoadMethodAttributes (52ms)
				AfterProcessingInitializeOnLoad (4ms)
				EditorAssembliesLoaded (0ms)
			ExecutionOrderSort2 (0ms)
			AwakeInstancesAfterBackupRestoration (8ms)
Platform modules already initialized, skipping
Compilation succeeded with: 

program_source:299:53: warning: writable resources in non-void post-tessellation vertex function
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
                                                    ^
program_source:305:30: note: writable buffer defined here
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
                             ^
program_source:306:48: note: writable buffer defined here
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
                                               ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float4 TEXCOORD0 [[ attribute(3) ]] ;
    float4 TEXCOORD1 [[ attribute(4) ]] ;
    float4 TEXCOORD2 [[ attribute(5) ]] ;
    float4 TEXCOORD3 [[ attribute(6) ]] ;
    float4 COLOR0 [[ attribute(7) ]] ;
};
struct Mtl_VertexOut
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float4 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float4 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float4 TEXCOORD3 [[ user(TEXCOORD3) ]];
    float4 COLOR0 [[ user(COLOR0) ]];
};
static Mtl_VertexOut vertexFunction(
    Mtl_VertexIn input)
{
    Mtl_VertexOut output;
    output.INTERNALTESSPOS0 = input.POSITION0;
    output.TANGENT0 = input.TANGENT0;
    output.NORMAL0.xyz = input.NORMAL0.xyz;
    output.TEXCOORD0 = input.TEXCOORD0;
    output.TEXCOORD1 = input.TEXCOORD1;
    output.TEXCOORD2 = input.TEXCOORD2;
    output.TEXCOORD3 = input.TEXCOORD3;
    output.COLOR0 = input.COLOR0;
    return output;
}
// SHADER_STAGE_HULL_begin
struct Mtl_ControlPoint
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float4 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float4 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float4 TEXCOORD3 [[ user(TEXCOORD3) ]];
    float4 COLOR0 [[ user(COLOR0) ]];
};
struct Mtl_ControlPointIn
{
    float4 INTERNALTESSPOS0 [[ attribute(8) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float4 TEXCOORD0 [[ attribute(3) ]] ;
    float4 TEXCOORD1 [[ attribute(4) ]] ;
    float4 TEXCOORD2 [[ attribute(5) ]] ;
    float4 TEXCOORD3 [[ attribute(6) ]] ;
    float4 COLOR0 [[ attribute(7) ]] ;
};
struct Mtl_KernelPatchInfo
{
    uint numPatches;
    ushort numControlPointsPerPatch;
};
struct VGlobals_Type
{
    float4 _Time;
    float4 _SinTime;
    float4 _CosTime;
    float4 unity_DeltaTime;
    float3 _WorldSpaceCameraPos;
    float4 _ProjectionParams;
    float4 _ScreenParams;
    float4 _ZBufferParams;
    float4 unity_OrthoParams;
    float4 unity_CameraWorldClipPlanes[6];
    float4 hlslcc_mtx4x4unity_CameraProjection[4];
    float4 hlslcc_mtx4x4unity_CameraInvProjection[4];
    float4 hlslcc_mtx4x4unity_WorldToCamera[4];
    float4 hlslcc_mtx4x4unity_CameraToWorld[4];
    float4 _WorldSpaceLightPos0;
    float4 _LightPositionRange;
    float4 _LightProjectionParams;
    float4 unity_4LightPosX0;
    float4 unity_4LightPosY0;
    float4 unity_4LightPosZ0;
    float4 unity_4LightAtten0;
    float4 unity_LightColor[8];
    float4 unity_LightPosition[8];
    float4 unity_LightAtten[8];
    float4 unity_SpotDirection[8];
    float4 unity_SHAr;
    float4 unity_SHAg;
    float4 unity_SHAb;
    float4 unity_SHBr;
    float4 unity_SHBg;
    float4 unity_SHBb;
    float4 unity_SHC;
    float4 unity_OcclusionMaskSelector;
    float4 unity_ProbesOcclusion;
    float3 unity_LightColor0;
    float3 unity_LightColor1;
    float3 unity_LightColor2;
    float3 unity_LightColor3;
    float4 unity_ShadowSplitSpheres[4];
    float4 unity_ShadowSplitSqRadii;
    float4 unity_LightShadowBias;
    float4 _LightSplitsNear;
    float4 _LightSplitsFar;
    float4 hlslcc_mtx4x4unity_WorldToShadow[16];
    float4 _LightShadowData;
    float4 unity_ShadowFadeCenterAndType;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 unity_LODFade;
    float4 unity_WorldTransformParams;
    float4 unity_RenderingLayer;
    float4 hlslcc_mtx4x4glstate_matrix_transpose_modelview0[4];
    float4 glstate_lightmodel_ambient;
    float4 unity_AmbientSky;
    float4 unity_AmbientEquator;
    float4 unity_AmbientGround;
    float4 unity_IndirectSpecColor;
    float4 hlslcc_mtx4x4glstate_matrix_projection[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixInvV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    int unity_StereoEyeIndex;
    float4 unity_ShadowColor;
    float4 unity_FogColor;
    float4 unity_FogParams;
    float4 unity_LightmapST;
    float4 unity_DynamicLightmapST;
    float4 unity_SpecCube0_BoxMax;
    float4 unity_SpecCube0_BoxMin;
    float4 unity_SpecCube0_ProbePosition;
    float4 unity_SpecCube0_HDR;
    float4 unity_SpecCube1_BoxMax;
    float4 unity_SpecCube1_BoxMin;
    float4 unity_SpecCube1_ProbePosition;
    float4 unity_SpecCube1_HDR;
    float4 unity_ProbeVolumeParams;
    float4 hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[4];
    float3 unity_ProbeVolumeSizeInv;
    float3 unity_ProbeVolumeMin;
    float4 unity_Lightmap_HDR;
    float4 unity_DynamicLightmap_HDR;
    float4 _LightColor0;
    float4 _SpecColor;
    float _Tile;
    float _HeightDisplacement;
    float _NormalScale;
    float4 _ColorTint;
    float _MetallicStrength;
    float _SmoothnessStrength;
    float _EdgeLength;
    float4 _texcoord_ST;
};
struct Mtl_HullIn
{
    Mtl_VertexOut cp[3];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
kernel void patchKernel(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn vertexInput [[ stage_in ]],
    uint2 tID [[ thread_position_in_grid ]],
    ushort2 groupID [[ threadgroup_position_in_grid ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    constant Mtl_KernelPatchInfo &patchInfo [[ buffer(3) ]])
{
#pragma clang diagnostic pop
    Mtl_ControlPoint output;
    const uint numPatchesInThreadGroup = 10;
    const uint patchID = (tID.x / patchInfo.numControlPointsPerPatch);
    const bool patchValid = (patchID < patchInfo.numPatches);
    const uint mtl_BaseInstance = 0;
    const uint mtl_InstanceID = groupID.y - mtl_BaseInstance;
    const uint internalPatchID = mtl_InstanceID * patchInfo.numPatches + patchID;
    const uint patchIDInThreadGroup = (patchID % numPatchesInThreadGroup);
    const uint controlPointID = (tID.x % patchInfo.numControlPointsPerPatch);
    const uint mtl_BaseVertex = 0;
    const uint mtl_VertexID = ((mtl_InstanceID * (patchInfo.numControlPointsPerPatch * patchInfo.numPatches)) + tID.x) - mtl_BaseVertex;
    threadgroup Mtl_HullIn inputGroup[numPatchesInThreadGroup];
    threadgroup Mtl_HullIn &input = inputGroup[patchIDInThreadGroup];
    MTLTriangleTessellationFactorsHalf tessFactor;
    if (patchValid) {
        input.cp[controlPointID] = vertexFunction(vertexInput);
        output.INTERNALTESSPOS0 = input.cp[controlPointID].INTERNALTESSPOS0;
        output.TANGENT0 = input.cp[controlPointID].TANGENT0;
        output.NORMAL0 = input.cp[controlPointID].NORMAL0;
        output.TEXCOORD0 = input.cp[controlPointID].TEXCOORD0;
        output.TEXCOORD1 = input.cp[controlPointID].TEXCOORD1;
        output.TEXCOORD2 = input.cp[controlPointID].TEXCOORD2;
        output.TEXCOORD3 = input.cp[controlPointID].TEXCOORD3;
        output.COLOR0 = input.cp[controlPointID].COLOR0;
    }
    threadgroup_barrier(mem_flags::mem_threadgroup);
    if (!patchValid) {
        return;
    }
    float3 u_xlat0;
    float3 u_xlat1;
    float3 u_xlat2;
    float3 u_xlat3;
    float3 u_xlat4;
    float u_xlat12;
    float u_xlat13;
    // fork_phase2
    {
        u_xlat0.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[1].INTERNALTESSPOS0.yyy;
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[1].INTERNALTESSPOS0.xxx, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[1].INTERNALTESSPOS0.zzz, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[1].INTERNALTESSPOS0.www, u_xlat0.xyz);
        u_xlat1.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[2].INTERNALTESSPOS0.yyy;
        u_xlat1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[2].INTERNALTESSPOS0.xxx, u_xlat1.xyz);
        u_xlat1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[2].INTERNALTESSPOS0.zzz, u_xlat1.xyz);
        u_xlat1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[2].INTERNALTESSPOS0.www, u_xlat1.xyz);
        u_xlat2.xyz = u_xlat0.xyz + u_xlat1.xyz;
        u_xlat2.xyz = fma(u_xlat2.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat12 = dot(u_xlat2.xyz, u_xlat2.xyz);
        u_xlat12 = sqrt(u_xlat12);
        u_xlat12 = u_xlat12 * VGlobals._EdgeLength;
        u_xlat2.xyz = u_xlat0.xyz + (-u_xlat1.xyz);
        u_xlat13 = dot(u_xlat2.xyz, u_xlat2.xyz);
        u_xlat13 = sqrt(u_xlat13);
        u_xlat13 = u_xlat13 * VGlobals._ScreenParams.y;
        u_xlat12 = u_xlat13 / u_xlat12;
        tessFactor.edgeTessellationFactor[0] = max(u_xlat12, 1.0);
        u_xlat2.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[0].INTERNALTESSPOS0.yyy;
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[0].INTERNALTESSPOS0.xxx, u_xlat2.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[0].INTERNALTESSPOS0.zzz, u_xlat2.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[0].INTERNALTESSPOS0.www, u_xlat2.xyz);
        u_xlat3.xyz = u_xlat1.xyz + u_xlat2.xyz;
        u_xlat1.xyz = u_xlat1.xyz + (-u_xlat2.xyz);
        u_xlat12 = dot(u_xlat1.xyz, u_xlat1.xyz);
        u_xlat12 = sqrt(u_xlat12);
        u_xlat12 = u_xlat12 * VGlobals._ScreenParams.y;
        u_xlat1.xyz = fma(u_xlat3.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat1.x = dot(u_xlat1.xyz, u_xlat1.xyz);
        u_xlat1.x = sqrt(u_xlat1.x);
        u_xlat1.x = u_xlat1.x * VGlobals._EdgeLength;
        u_xlat12 = u_xlat12 / u_xlat1.x;
        tessFactor.edgeTessellationFactor[1] = max(u_xlat12, 1.0);
        u_xlat1.xyz = u_xlat0.xyz + u_xlat2.xyz;
        u_xlat0.xyz = (-u_xlat0.xyz) + u_xlat2.xyz;
        u_xlat0.x = dot(u_xlat0.xyz, u_xlat0.xyz);
        u_xlat0.x = sqrt(u_xlat0.x);
        u_xlat0.x = u_xlat0.x * VGlobals._ScreenParams.y;
        u_xlat4.xyz = fma(u_xlat1.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat4.x = dot(u_xlat4.xyz, u_xlat4.xyz);
        u_xlat4.x = sqrt(u_xlat4.x);
        u_xlat4.x = u_xlat4.x * VGlobals._EdgeLength;
        u_xlat0.x = u_xlat0.x / u_xlat4.x;
        tessFactor.edgeTessellationFactor[2] = max(u_xlat0.x, 1.0);
    }
    // join_phase3
    {
        u_xlat0.x = tessFactor.edgeTessellationFactor[0] + tessFactor.edgeTessellationFactor[1];
        u_xlat0.x = u_xlat0.x + tessFactor.edgeTessellationFactor[2];
        tessFactor.insideTessellationFactor = u_xlat0.x * 0.333333343;
    }
    controlPoints[mtl_VertexID] = output;
    tessFactors[internalPatchID] = tessFactor;
}
// SHADER_STAGE_HULL_end
// SHADER_STAGE_DOMAIN_begin
struct Mtl_VertexInPostTess
{
    patch_control_point<Mtl_ControlPointIn> cp;
};
struct Mtl_VertexOutPostTess
{
    float4 mtl_Position [[ position ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float4 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float4 TEXCOORD3 [[ user(TEXCOORD3) ]];
    float4 TEXCOORD6 [[ user(TEXCOORD6) ]];
    float4 TEXCOORD7 [[ user(TEXCOORD7) ]];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    sampler sampler_Height [[ sampler (0) ]],
    texture2d<float, access::sample > _Height [[ texture(0) ]] ,
    float3 mtl_TessCoord [[ position_in_patch ]],
    uint patchID [[ patch_id ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    Mtl_VertexInPostTess input [[ stage_in ]])
{
#pragma clang diagnostic pop
    Mtl_VertexOutPostTess output;
    MTLTriangleTessellationFactorsHalf tessFactor;
    tessFactor = tessFactors[patchID];
    float4 u_xlat0;
    float4 u_xlat1;
    float4 u_xlat2;
    float4 u_xlat3;
    float2 u_xlat9;
    float u_xlat12;
    float u_xlat13;
    u_xlat0 = mtl_TessCoord.yyyy * input.cp[1].INTERNALTESSPOS0;
    u_xlat0 = fma(input.cp[0].INTERNALTESSPOS0, mtl_TessCoord.xxxx, u_xlat0);
    u_xlat0 = fma(input.cp[2].INTERNALTESSPOS0, mtl_TessCoord.zzzz, u_xlat0);
    u_xlat1.xy = mtl_TessCoord.yy * input.cp[1].TEXCOORD0.xy;
    u_xlat1.xy = fma(input.cp[0].TEXCOORD0.xy, mtl_TessCoord.xx, u_xlat1.xy);
    u_xlat1.xy = fma(input.cp[2].TEXCOORD0.xy, mtl_TessCoord.zz, u_xlat1.xy);
    u_xlat9.xy = u_xlat1.xy * float2(VGlobals._Tile);
    output.TEXCOORD0.xy = fma(u_xlat1.xy, VGlobals._texcoord_ST.xy, VGlobals._texcoord_ST.zw);
    u_xlat1.xyz = _Height.sample(sampler_Height, u_xlat9.xy, level(1.0)).xyz;
    u_xlat2.xyz = mtl_TessCoord.yyy * input.cp[1].NORMAL0.xyz;
    u_xlat2.xyz = fma(input.cp[0].NORMAL0.xyz, mtl_TessCoord.xxx, u_xlat2.xyz);
    u_xlat2.xyz = fma(input.cp[2].NORMAL0.xyz, mtl_TessCoord.zzz, u_xlat2.xyz);
    u_xlat1.xyz = u_xlat1.xyz * u_xlat2.xyz;
    u_xlat0.xyz = fma(u_xlat1.xyz, float3(VGlobals._HeightDisplacement), u_xlat0.xyz);
    u_xlat1 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], u_xlat0.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], u_xlat0.zzzz, u_xlat1);
    u_xlat3 = u_xlat1 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, u_xlat0.www, u_xlat1.xyz);
    u_xlat1 = u_xlat3.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat3.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat3.zzzz, u_xlat1);
    output.mtl_Position = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat3.wwww, u_xlat1);
    u_xlat1.y = dot(u_xlat2.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat1.z = dot(u_xlat2.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat1.x = dot(u_xlat2.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat12 = dot(u_xlat1.xyz, u_xlat1.xyz);
    u_xlat12 = rsqrt(u_xlat12);
    u_xlat1.xyz = float3(u_xlat12) * u_xlat1.xyz;
    output.TEXCOORD1.z = u_xlat1.y;
    u_xlat2 = mtl_TessCoord.yyyy * input.cp[1].TANGENT0;
    u_xlat2 = fma(input.cp[0].TANGENT0, mtl_TessCoord.xxxx, u_xlat2);
    u_xlat2 = fma(input.cp[2].TANGENT0, mtl_TessCoord.zzzz, u_xlat2);
    u_xlat3.xyz = u_xlat2.yyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].yzx;
    u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].yzx, u_xlat2.xxx, u_xlat3.xyz);
    u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].yzx, u_xlat2.zzz, u_xlat3.xyz);
    u_xlat12 = u_xlat2.w * VGlobals.unity_WorldTransformParams.w;
    u_xlat13 = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat13 = rsqrt(u_xlat13);
    u_xlat2.xyz = float3(u_xlat13) * u_xlat2.xyz;
    u_xlat3.xyz = u_xlat1.xyz * u_xlat2.xyz;
    u_xlat3.xyz = fma(u_xlat1.zxy, u_xlat2.yzx, (-u_xlat3.xyz));
    u_xlat3.xyz = float3(u_xlat12) * u_xlat3.xyz;
    output.TEXCOORD1.y = u_xlat3.x;
    output.TEXCOORD1.w = u_xlat0.x;
    output.TEXCOORD1.x = u_xlat2.z;
    output.TEXCOORD2.w = u_xlat0.y;
    output.TEXCOORD3.w = u_xlat0.z;
    output.TEXCOORD2.x = u_xlat2.x;
    output.TEXCOORD3.x = u_xlat2.y;
    output.TEXCOORD2.z = u_xlat1.z;
    output.TEXCOORD3.z = u_xlat1.x;
    output.TEXCOORD2.y = u_xlat3.y;
    output.TEXCOORD3.y = u_xlat3.z;
    output.TEXCOORD6 = float4(0.0, 0.0, 0.0, 0.0);
    output.TEXCOORD7 = float4(0.0, 0.0, 0.0, 0.0);
    return output;
}
// SHADER_STAGE_DOMAIN_end
Compilation succeeded with: 

program_source:301:53: warning: writable resources in non-void post-tessellation vertex function
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
                                                    ^
program_source:307:30: note: writable buffer defined here
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
                             ^
program_source:308:48: note: writable buffer defined here
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
                                               ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float4 TEXCOORD0 [[ attribute(3) ]] ;
    float4 TEXCOORD1 [[ attribute(4) ]] ;
    float4 TEXCOORD2 [[ attribute(5) ]] ;
    float4 TEXCOORD3 [[ attribute(6) ]] ;
    float4 COLOR0 [[ attribute(7) ]] ;
};
struct Mtl_VertexOut
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float4 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float4 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float4 TEXCOORD3 [[ user(TEXCOORD3) ]];
    float4 COLOR0 [[ user(COLOR0) ]];
};
static Mtl_VertexOut vertexFunction(
    Mtl_VertexIn input)
{
    Mtl_VertexOut output;
    output.INTERNALTESSPOS0 = input.POSITION0;
    output.TANGENT0 = input.TANGENT0;
    output.NORMAL0.xyz = input.NORMAL0.xyz;
    output.TEXCOORD0 = input.TEXCOORD0;
    output.TEXCOORD1 = input.TEXCOORD1;
    output.TEXCOORD2 = input.TEXCOORD2;
    output.TEXCOORD3 = input.TEXCOORD3;
    output.COLOR0 = input.COLOR0;
    return output;
}
// SHADER_STAGE_HULL_begin
struct Mtl_ControlPoint
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float4 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float4 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float4 TEXCOORD3 [[ user(TEXCOORD3) ]];
    float4 COLOR0 [[ user(COLOR0) ]];
};
struct Mtl_ControlPointIn
{
    float4 INTERNALTESSPOS0 [[ attribute(8) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float4 TEXCOORD0 [[ attribute(3) ]] ;
    float4 TEXCOORD1 [[ attribute(4) ]] ;
    float4 TEXCOORD2 [[ attribute(5) ]] ;
    float4 TEXCOORD3 [[ attribute(6) ]] ;
    float4 COLOR0 [[ attribute(7) ]] ;
};
struct Mtl_KernelPatchInfo
{
    uint numPatches;
    ushort numControlPointsPerPatch;
};
struct VGlobals_Type
{
    float4 _Time;
    float4 _SinTime;
    float4 _CosTime;
    float4 unity_DeltaTime;
    float3 _WorldSpaceCameraPos;
    float4 _ProjectionParams;
    float4 _ScreenParams;
    float4 _ZBufferParams;
    float4 unity_OrthoParams;
    float4 unity_CameraWorldClipPlanes[6];
    float4 hlslcc_mtx4x4unity_CameraProjection[4];
    float4 hlslcc_mtx4x4unity_CameraInvProjection[4];
    float4 hlslcc_mtx4x4unity_WorldToCamera[4];
    float4 hlslcc_mtx4x4unity_CameraToWorld[4];
    float4 _WorldSpaceLightPos0;
    float4 _LightPositionRange;
    float4 _LightProjectionParams;
    float4 unity_4LightPosX0;
    float4 unity_4LightPosY0;
    float4 unity_4LightPosZ0;
    float4 unity_4LightAtten0;
    float4 unity_LightColor[8];
    float4 unity_LightPosition[8];
    float4 unity_LightAtten[8];
    float4 unity_SpotDirection[8];
    float4 unity_SHAr;
    float4 unity_SHAg;
    float4 unity_SHAb;
    float4 unity_SHBr;
    float4 unity_SHBg;
    float4 unity_SHBb;
    float4 unity_SHC;
    float4 unity_OcclusionMaskSelector;
    float4 unity_ProbesOcclusion;
    float3 unity_LightColor0;
    float3 unity_LightColor1;
    float3 unity_LightColor2;
    float3 unity_LightColor3;
    float4 unity_ShadowSplitSpheres[4];
    float4 unity_ShadowSplitSqRadii;
    float4 unity_LightShadowBias;
    float4 _LightSplitsNear;
    float4 _LightSplitsFar;
    float4 hlslcc_mtx4x4unity_WorldToShadow[16];
    float4 _LightShadowData;
    float4 unity_ShadowFadeCenterAndType;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 unity_LODFade;
    float4 unity_WorldTransformParams;
    float4 unity_RenderingLayer;
    float4 hlslcc_mtx4x4glstate_matrix_transpose_modelview0[4];
    float4 glstate_lightmodel_ambient;
    float4 unity_AmbientSky;
    float4 unity_AmbientEquator;
    float4 unity_AmbientGround;
    float4 unity_IndirectSpecColor;
    float4 hlslcc_mtx4x4glstate_matrix_projection[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixInvV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    int unity_StereoEyeIndex;
    float4 unity_ShadowColor;
    float4 unity_FogColor;
    float4 unity_FogParams;
    float4 unity_LightmapST;
    float4 unity_DynamicLightmapST;
    float4 unity_SpecCube0_BoxMax;
    float4 unity_SpecCube0_BoxMin;
    float4 unity_SpecCube0_ProbePosition;
    float4 unity_SpecCube0_HDR;
    float4 unity_SpecCube1_BoxMax;
    float4 unity_SpecCube1_BoxMin;
    float4 unity_SpecCube1_ProbePosition;
    float4 unity_SpecCube1_HDR;
    float4 unity_ProbeVolumeParams;
    float4 hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[4];
    float3 unity_ProbeVolumeSizeInv;
    float3 unity_ProbeVolumeMin;
    float4 unity_Lightmap_HDR;
    float4 unity_DynamicLightmap_HDR;
    float4 _LightColor0;
    float4 _SpecColor;
    float4 hlslcc_mtx4x4unity_WorldToLight[4];
    float _Tile;
    float _HeightDisplacement;
    float _NormalScale;
    float4 _ColorTint;
    float _MetallicStrength;
    float _SmoothnessStrength;
    float _EdgeLength;
    float4 _texcoord_ST;
};
struct Mtl_HullIn
{
    Mtl_VertexOut cp[3];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
kernel void patchKernel(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn vertexInput [[ stage_in ]],
    uint2 tID [[ thread_position_in_grid ]],
    ushort2 groupID [[ threadgroup_position_in_grid ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    constant Mtl_KernelPatchInfo &patchInfo [[ buffer(3) ]])
{
#pragma clang diagnostic pop
    Mtl_ControlPoint output;
    const uint numPatchesInThreadGroup = 10;
    const uint patchID = (tID.x / patchInfo.numControlPointsPerPatch);
    const bool patchValid = (patchID < patchInfo.numPatches);
    const uint mtl_BaseInstance = 0;
    const uint mtl_InstanceID = groupID.y - mtl_BaseInstance;
    const uint internalPatchID = mtl_InstanceID * patchInfo.numPatches + patchID;
    const uint patchIDInThreadGroup = (patchID % numPatchesInThreadGroup);
    const uint controlPointID = (tID.x % patchInfo.numControlPointsPerPatch);
    const uint mtl_BaseVertex = 0;
    const uint mtl_VertexID = ((mtl_InstanceID * (patchInfo.numControlPointsPerPatch * patchInfo.numPatches)) + tID.x) - mtl_BaseVertex;
    threadgroup Mtl_HullIn inputGroup[numPatchesInThreadGroup];
    threadgroup Mtl_HullIn &input = inputGroup[patchIDInThreadGroup];
    MTLTriangleTessellationFactorsHalf tessFactor;
    if (patchValid) {
        input.cp[controlPointID] = vertexFunction(vertexInput);
        output.INTERNALTESSPOS0 = input.cp[controlPointID].INTERNALTESSPOS0;
        output.TANGENT0 = input.cp[controlPointID].TANGENT0;
        output.NORMAL0 = input.cp[controlPointID].NORMAL0;
        output.TEXCOORD0 = input.cp[controlPointID].TEXCOORD0;
        output.TEXCOORD1 = input.cp[controlPointID].TEXCOORD1;
        output.TEXCOORD2 = input.cp[controlPointID].TEXCOORD2;
        output.TEXCOORD3 = input.cp[controlPointID].TEXCOORD3;
        output.COLOR0 = input.cp[controlPointID].COLOR0;
    }
    threadgroup_barrier(mem_flags::mem_threadgroup);
    if (!patchValid) {
        return;
    }
    float3 u_xlat0;
    float3 u_xlat1;
    float3 u_xlat2;
    float3 u_xlat3;
    float3 u_xlat4;
    float u_xlat12;
    float u_xlat13;
    // fork_phase2
    {
        u_xlat0.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[1].INTERNALTESSPOS0.yyy;
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[1].INTERNALTESSPOS0.xxx, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[1].INTERNALTESSPOS0.zzz, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[1].INTERNALTESSPOS0.www, u_xlat0.xyz);
        u_xlat1.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[2].INTERNALTESSPOS0.yyy;
        u_xlat1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[2].INTERNALTESSPOS0.xxx, u_xlat1.xyz);
        u_xlat1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[2].INTERNALTESSPOS0.zzz, u_xlat1.xyz);
        u_xlat1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[2].INTERNALTESSPOS0.www, u_xlat1.xyz);
        u_xlat2.xyz = u_xlat0.xyz + u_xlat1.xyz;
        u_xlat2.xyz = fma(u_xlat2.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat12 = dot(u_xlat2.xyz, u_xlat2.xyz);
        u_xlat12 = sqrt(u_xlat12);
        u_xlat12 = u_xlat12 * VGlobals._EdgeLength;
        u_xlat2.xyz = u_xlat0.xyz + (-u_xlat1.xyz);
        u_xlat13 = dot(u_xlat2.xyz, u_xlat2.xyz);
        u_xlat13 = sqrt(u_xlat13);
        u_xlat13 = u_xlat13 * VGlobals._ScreenParams.y;
        u_xlat12 = u_xlat13 / u_xlat12;
        tessFactor.edgeTessellationFactor[0] = max(u_xlat12, 1.0);
        u_xlat2.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[0].INTERNALTESSPOS0.yyy;
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[0].INTERNALTESSPOS0.xxx, u_xlat2.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[0].INTERNALTESSPOS0.zzz, u_xlat2.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[0].INTERNALTESSPOS0.www, u_xlat2.xyz);
        u_xlat3.xyz = u_xlat1.xyz + u_xlat2.xyz;
        u_xlat1.xyz = u_xlat1.xyz + (-u_xlat2.xyz);
        u_xlat12 = dot(u_xlat1.xyz, u_xlat1.xyz);
        u_xlat12 = sqrt(u_xlat12);
        u_xlat12 = u_xlat12 * VGlobals._ScreenParams.y;
        u_xlat1.xyz = fma(u_xlat3.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat1.x = dot(u_xlat1.xyz, u_xlat1.xyz);
        u_xlat1.x = sqrt(u_xlat1.x);
        u_xlat1.x = u_xlat1.x * VGlobals._EdgeLength;
        u_xlat12 = u_xlat12 / u_xlat1.x;
        tessFactor.edgeTessellationFactor[1] = max(u_xlat12, 1.0);
        u_xlat1.xyz = u_xlat0.xyz + u_xlat2.xyz;
        u_xlat0.xyz = (-u_xlat0.xyz) + u_xlat2.xyz;
        u_xlat0.x = dot(u_xlat0.xyz, u_xlat0.xyz);
        u_xlat0.x = sqrt(u_xlat0.x);
        u_xlat0.x = u_xlat0.x * VGlobals._ScreenParams.y;
        u_xlat4.xyz = fma(u_xlat1.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat4.x = dot(u_xlat4.xyz, u_xlat4.xyz);
        u_xlat4.x = sqrt(u_xlat4.x);
        u_xlat4.x = u_xlat4.x * VGlobals._EdgeLength;
        u_xlat0.x = u_xlat0.x / u_xlat4.x;
        tessFactor.edgeTessellationFactor[2] = max(u_xlat0.x, 1.0);
    }
    // join_phase3
    {
        u_xlat0.x = tessFactor.edgeTessellationFactor[0] + tessFactor.edgeTessellationFactor[1];
        u_xlat0.x = u_xlat0.x + tessFactor.edgeTessellationFactor[2];
        tessFactor.insideTessellationFactor = u_xlat0.x * 0.333333343;
    }
    controlPoints[mtl_VertexID] = output;
    tessFactors[internalPatchID] = tessFactor;
}
// SHADER_STAGE_HULL_end
// SHADER_STAGE_DOMAIN_begin
struct Mtl_VertexInPostTess
{
    patch_control_point<Mtl_ControlPointIn> cp;
};
struct Mtl_VertexOutPostTess
{
    float4 mtl_Position [[ position ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float3 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float3 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float3 TEXCOORD3 [[ user(TEXCOORD3) ]];
    float3 TEXCOORD4 [[ user(TEXCOORD4) ]];
    float3 TEXCOORD5 [[ user(TEXCOORD5) ]];
    float4 TEXCOORD6 [[ user(TEXCOORD6) ]];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    sampler sampler_Height [[ sampler (0) ]],
    texture2d<float, access::sample > _Height [[ texture(0) ]] ,
    float3 mtl_TessCoord [[ position_in_patch ]],
    uint patchID [[ patch_id ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    Mtl_VertexInPostTess input [[ stage_in ]])
{
#pragma clang diagnostic pop
    Mtl_VertexOutPostTess output;
    MTLTriangleTessellationFactorsHalf tessFactor;
    tessFactor = tessFactors[patchID];
    float4 u_xlat0;
    float3 u_xlat1;
    float4 u_xlat2;
    float4 u_xlat3;
    float4 u_xlat4;
    float2 u_xlat10;
    float u_xlat16;
    u_xlat0.xy = mtl_TessCoord.yy * input.cp[1].TEXCOORD0.xy;
    u_xlat0.xy = fma(input.cp[0].TEXCOORD0.xy, mtl_TessCoord.xx, u_xlat0.xy);
    u_xlat0.xy = fma(input.cp[2].TEXCOORD0.xy, mtl_TessCoord.zz, u_xlat0.xy);
    u_xlat10.xy = u_xlat0.xy * float2(VGlobals._Tile);
    output.TEXCOORD0.xy = fma(u_xlat0.xy, VGlobals._texcoord_ST.xy, VGlobals._texcoord_ST.zw);
    u_xlat0.xyz = _Height.sample(sampler_Height, u_xlat10.xy, level(1.0)).xyz;
    u_xlat1.xyz = mtl_TessCoord.yyy * input.cp[1].NORMAL0.xyz;
    u_xlat1.xyz = fma(input.cp[0].NORMAL0.xyz, mtl_TessCoord.xxx, u_xlat1.xyz);
    u_xlat1.xyz = fma(input.cp[2].NORMAL0.xyz, mtl_TessCoord.zzz, u_xlat1.xyz);
    u_xlat0.xyz = u_xlat0.xyz * u_xlat1.xyz;
    u_xlat2 = mtl_TessCoord.yyyy * input.cp[1].INTERNALTESSPOS0;
    u_xlat2 = fma(input.cp[0].INTERNALTESSPOS0, mtl_TessCoord.xxxx, u_xlat2);
    u_xlat2 = fma(input.cp[2].INTERNALTESSPOS0, mtl_TessCoord.zzzz, u_xlat2);
    u_xlat0.xyz = fma(u_xlat0.xyz, float3(VGlobals._HeightDisplacement), u_xlat2.xyz);
    u_xlat3 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], u_xlat0.xxxx, u_xlat3);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], u_xlat0.zzzz, u_xlat3);
    u_xlat3 = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat4 = u_xlat3.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat4 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat3.xxxx, u_xlat4);
    u_xlat4 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat3.zzzz, u_xlat4);
    output.mtl_Position = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat3.wwww, u_xlat4);
    u_xlat2.y = dot(u_xlat1.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat2.z = dot(u_xlat1.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat2.x = dot(u_xlat1.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat1.x = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat1.x = rsqrt(u_xlat1.x);
    u_xlat1.xyz = u_xlat1.xxx * u_xlat2.xyz;
    output.TEXCOORD1.z = u_xlat1.y;
    u_xlat3 = mtl_TessCoord.yyyy * input.cp[1].TANGENT0;
    u_xlat3 = fma(input.cp[0].TANGENT0, mtl_TessCoord.xxxx, u_xlat3);
    u_xlat3 = fma(input.cp[2].TANGENT0, mtl_TessCoord.zzzz, u_xlat3);
    u_xlat2.xyz = u_xlat3.yyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].yzx;
    u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].yzx, u_xlat3.xxx, u_xlat2.xyz);
    u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].yzx, u_xlat3.zzz, u_xlat2.xyz);
    u_xlat16 = u_xlat3.w * VGlobals.unity_WorldTransformParams.w;
    u_xlat3.x = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat3.x = rsqrt(u_xlat3.x);
    u_xlat2.xyz = u_xlat2.xyz * u_xlat3.xxx;
    u_xlat3.xyz = u_xlat1.xyz * u_xlat2.xyz;
    u_xlat3.xyz = fma(u_xlat1.zxy, u_xlat2.yzx, (-u_xlat3.xyz));
    u_xlat3.xyz = float3(u_xlat16) * u_xlat3.xyz;
    output.TEXCOORD1.y = u_xlat3.x;
    output.TEXCOORD1.x = u_xlat2.z;
    output.TEXCOORD2.x = u_xlat2.x;
    output.TEXCOORD3.x = u_xlat2.y;
    output.TEXCOORD2.z = u_xlat1.z;
    output.TEXCOORD3.z = u_xlat1.x;
    output.TEXCOORD2.y = u_xlat3.y;
    output.TEXCOORD3.y = u_xlat3.z;
    output.TEXCOORD4.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, u_xlat2.www, u_xlat0.xyz);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3], u_xlat2.wwww, u_xlat0);
    u_xlat1.xyz = u_xlat0.yyy * VGlobals.hlslcc_mtx4x4unity_WorldToLight[1].xyz;
    u_xlat1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_WorldToLight[0].xyz, u_xlat0.xxx, u_xlat1.xyz);
    u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_WorldToLight[2].xyz, u_xlat0.zzz, u_xlat1.xyz);
    output.TEXCOORD5.xyz = fma(VGlobals.hlslcc_mtx4x4unity_WorldToLight[3].xyz, u_xlat0.www, u_xlat0.xyz);
    output.TEXCOORD6 = float4(0.0, 0.0, 0.0, 0.0);
    return output;
}
// SHADER_STAGE_DOMAIN_end
Compilation succeeded with: 

program_source:293:53: warning: writable resources in non-void post-tessellation vertex function
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
                                                    ^
program_source:299:30: note: writable buffer defined here
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
                             ^
program_source:300:48: note: writable buffer defined here
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
                                               ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float4 TEXCOORD0 [[ attribute(3) ]] ;
    float4 TEXCOORD1 [[ attribute(4) ]] ;
    float4 TEXCOORD2 [[ attribute(5) ]] ;
    float4 TEXCOORD3 [[ attribute(6) ]] ;
    float4 COLOR0 [[ attribute(7) ]] ;
};
struct Mtl_VertexOut
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float4 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float4 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float4 TEXCOORD3 [[ user(TEXCOORD3) ]];
    float4 COLOR0 [[ user(COLOR0) ]];
};
static Mtl_VertexOut vertexFunction(
    Mtl_VertexIn input)
{
    Mtl_VertexOut output;
    output.INTERNALTESSPOS0 = input.POSITION0;
    output.TANGENT0 = input.TANGENT0;
    output.NORMAL0.xyz = input.NORMAL0.xyz;
    output.TEXCOORD0 = input.TEXCOORD0;
    output.TEXCOORD1 = input.TEXCOORD1;
    output.TEXCOORD2 = input.TEXCOORD2;
    output.TEXCOORD3 = input.TEXCOORD3;
    output.COLOR0 = input.COLOR0;
    return output;
}
// SHADER_STAGE_HULL_begin
struct Mtl_ControlPoint
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float4 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float4 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float4 TEXCOORD3 [[ user(TEXCOORD3) ]];
    float4 COLOR0 [[ user(COLOR0) ]];
};
struct Mtl_ControlPointIn
{
    float4 INTERNALTESSPOS0 [[ attribute(8) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float4 TEXCOORD0 [[ attribute(3) ]] ;
    float4 TEXCOORD1 [[ attribute(4) ]] ;
    float4 TEXCOORD2 [[ attribute(5) ]] ;
    float4 TEXCOORD3 [[ attribute(6) ]] ;
    float4 COLOR0 [[ attribute(7) ]] ;
};
struct Mtl_KernelPatchInfo
{
    uint numPatches;
    ushort numControlPointsPerPatch;
};
struct VGlobals_Type
{
    float4 _Time;
    float4 _SinTime;
    float4 _CosTime;
    float4 unity_DeltaTime;
    float3 _WorldSpaceCameraPos;
    float4 _ProjectionParams;
    float4 _ScreenParams;
    float4 _ZBufferParams;
    float4 unity_OrthoParams;
    float4 unity_CameraWorldClipPlanes[6];
    float4 hlslcc_mtx4x4unity_CameraProjection[4];
    float4 hlslcc_mtx4x4unity_CameraInvProjection[4];
    float4 hlslcc_mtx4x4unity_WorldToCamera[4];
    float4 hlslcc_mtx4x4unity_CameraToWorld[4];
    float4 _WorldSpaceLightPos0;
    float4 _LightPositionRange;
    float4 _LightProjectionParams;
    float4 unity_4LightPosX0;
    float4 unity_4LightPosY0;
    float4 unity_4LightPosZ0;
    float4 unity_4LightAtten0;
    float4 unity_LightColor[8];
    float4 unity_LightPosition[8];
    float4 unity_LightAtten[8];
    float4 unity_SpotDirection[8];
    float4 unity_SHAr;
    float4 unity_SHAg;
    float4 unity_SHAb;
    float4 unity_SHBr;
    float4 unity_SHBg;
    float4 unity_SHBb;
    float4 unity_SHC;
    float4 unity_OcclusionMaskSelector;
    float4 unity_ProbesOcclusion;
    float3 unity_LightColor0;
    float3 unity_LightColor1;
    float3 unity_LightColor2;
    float3 unity_LightColor3;
    float4 unity_ShadowSplitSpheres[4];
    float4 unity_ShadowSplitSqRadii;
    float4 unity_LightShadowBias;
    float4 _LightSplitsNear;
    float4 _LightSplitsFar;
    float4 hlslcc_mtx4x4unity_WorldToShadow[16];
    float4 _LightShadowData;
    float4 unity_ShadowFadeCenterAndType;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 unity_LODFade;
    float4 unity_WorldTransformParams;
    float4 unity_RenderingLayer;
    float4 hlslcc_mtx4x4glstate_matrix_transpose_modelview0[4];
    float4 glstate_lightmodel_ambient;
    float4 unity_AmbientSky;
    float4 unity_AmbientEquator;
    float4 unity_AmbientGround;
    float4 unity_IndirectSpecColor;
    float4 hlslcc_mtx4x4glstate_matrix_projection[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixInvV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    int unity_StereoEyeIndex;
    float4 unity_ShadowColor;
    float4 unity_FogColor;
    float4 unity_FogParams;
    float4 unity_LightmapST;
    float4 unity_DynamicLightmapST;
    float4 unity_SpecCube0_BoxMax;
    float4 unity_SpecCube0_BoxMin;
    float4 unity_SpecCube0_ProbePosition;
    float4 unity_SpecCube0_HDR;
    float4 unity_SpecCube1_BoxMax;
    float4 unity_SpecCube1_BoxMin;
    float4 unity_SpecCube1_ProbePosition;
    float4 unity_SpecCube1_HDR;
    float4 unity_ProbeVolumeParams;
    float4 hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[4];
    float3 unity_ProbeVolumeSizeInv;
    float3 unity_ProbeVolumeMin;
    float4 unity_Lightmap_HDR;
    float4 unity_DynamicLightmap_HDR;
    float4 _LightColor0;
    float4 _SpecColor;
    float _Tile;
    float _HeightDisplacement;
    float _NormalScale;
    float4 _ColorTint;
    float _MetallicStrength;
    float _SmoothnessStrength;
    float _EdgeLength;
};
struct Mtl_HullIn
{
    Mtl_VertexOut cp[3];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
kernel void patchKernel(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn vertexInput [[ stage_in ]],
    uint2 tID [[ thread_position_in_grid ]],
    ushort2 groupID [[ threadgroup_position_in_grid ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    constant Mtl_KernelPatchInfo &patchInfo [[ buffer(3) ]])
{
#pragma clang diagnostic pop
    Mtl_ControlPoint output;
    const uint numPatchesInThreadGroup = 10;
    const uint patchID = (tID.x / patchInfo.numControlPointsPerPatch);
    const bool patchValid = (patchID < patchInfo.numPatches);
    const uint mtl_BaseInstance = 0;
    const uint mtl_InstanceID = groupID.y - mtl_BaseInstance;
    const uint internalPatchID = mtl_InstanceID * patchInfo.numPatches + patchID;
    const uint patchIDInThreadGroup = (patchID % numPatchesInThreadGroup);
    const uint controlPointID = (tID.x % patchInfo.numControlPointsPerPatch);
    const uint mtl_BaseVertex = 0;
    const uint mtl_VertexID = ((mtl_InstanceID * (patchInfo.numControlPointsPerPatch * patchInfo.numPatches)) + tID.x) - mtl_BaseVertex;
    threadgroup Mtl_HullIn inputGroup[numPatchesInThreadGroup];
    threadgroup Mtl_HullIn &input = inputGroup[patchIDInThreadGroup];
    MTLTriangleTessellationFactorsHalf tessFactor;
    if (patchValid) {
        input.cp[controlPointID] = vertexFunction(vertexInput);
        output.INTERNALTESSPOS0 = input.cp[controlPointID].INTERNALTESSPOS0;
        output.TANGENT0 = input.cp[controlPointID].TANGENT0;
        output.NORMAL0 = input.cp[controlPointID].NORMAL0;
        output.TEXCOORD0 = input.cp[controlPointID].TEXCOORD0;
        output.TEXCOORD1 = input.cp[controlPointID].TEXCOORD1;
        output.TEXCOORD2 = input.cp[controlPointID].TEXCOORD2;
        output.TEXCOORD3 = input.cp[controlPointID].TEXCOORD3;
        output.COLOR0 = input.cp[controlPointID].COLOR0;
    }
    threadgroup_barrier(mem_flags::mem_threadgroup);
    if (!patchValid) {
        return;
    }
    float3 u_xlat0;
    float3 u_xlat1;
    float3 u_xlat2;
    float3 u_xlat3;
    float3 u_xlat4;
    float u_xlat12;
    float u_xlat13;
    // fork_phase2
    {
        u_xlat0.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[1].INTERNALTESSPOS0.yyy;
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[1].INTERNALTESSPOS0.xxx, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[1].INTERNALTESSPOS0.zzz, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[1].INTERNALTESSPOS0.www, u_xlat0.xyz);
        u_xlat1.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[2].INTERNALTESSPOS0.yyy;
        u_xlat1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[2].INTERNALTESSPOS0.xxx, u_xlat1.xyz);
        u_xlat1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[2].INTERNALTESSPOS0.zzz, u_xlat1.xyz);
        u_xlat1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[2].INTERNALTESSPOS0.www, u_xlat1.xyz);
        u_xlat2.xyz = u_xlat0.xyz + u_xlat1.xyz;
        u_xlat2.xyz = fma(u_xlat2.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat12 = dot(u_xlat2.xyz, u_xlat2.xyz);
        u_xlat12 = sqrt(u_xlat12);
        u_xlat12 = u_xlat12 * VGlobals._EdgeLength;
        u_xlat2.xyz = u_xlat0.xyz + (-u_xlat1.xyz);
        u_xlat13 = dot(u_xlat2.xyz, u_xlat2.xyz);
        u_xlat13 = sqrt(u_xlat13);
        u_xlat13 = u_xlat13 * VGlobals._ScreenParams.y;
        u_xlat12 = u_xlat13 / u_xlat12;
        tessFactor.edgeTessellationFactor[0] = max(u_xlat12, 1.0);
        u_xlat2.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[0].INTERNALTESSPOS0.yyy;
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[0].INTERNALTESSPOS0.xxx, u_xlat2.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[0].INTERNALTESSPOS0.zzz, u_xlat2.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[0].INTERNALTESSPOS0.www, u_xlat2.xyz);
        u_xlat3.xyz = u_xlat1.xyz + u_xlat2.xyz;
        u_xlat1.xyz = u_xlat1.xyz + (-u_xlat2.xyz);
        u_xlat12 = dot(u_xlat1.xyz, u_xlat1.xyz);
        u_xlat12 = sqrt(u_xlat12);
        u_xlat12 = u_xlat12 * VGlobals._ScreenParams.y;
        u_xlat1.xyz = fma(u_xlat3.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat1.x = dot(u_xlat1.xyz, u_xlat1.xyz);
        u_xlat1.x = sqrt(u_xlat1.x);
        u_xlat1.x = u_xlat1.x * VGlobals._EdgeLength;
        u_xlat12 = u_xlat12 / u_xlat1.x;
        tessFactor.edgeTessellationFactor[1] = max(u_xlat12, 1.0);
        u_xlat1.xyz = u_xlat0.xyz + u_xlat2.xyz;
        u_xlat0.xyz = (-u_xlat0.xyz) + u_xlat2.xyz;
        u_xlat0.x = dot(u_xlat0.xyz, u_xlat0.xyz);
        u_xlat0.x = sqrt(u_xlat0.x);
        u_xlat0.x = u_xlat0.x * VGlobals._ScreenParams.y;
        u_xlat4.xyz = fma(u_xlat1.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat4.x = dot(u_xlat4.xyz, u_xlat4.xyz);
        u_xlat4.x = sqrt(u_xlat4.x);
        u_xlat4.x = u_xlat4.x * VGlobals._EdgeLength;
        u_xlat0.x = u_xlat0.x / u_xlat4.x;
        tessFactor.edgeTessellationFactor[2] = max(u_xlat0.x, 1.0);
    }
    // join_phase3
    {
        u_xlat0.x = tessFactor.edgeTessellationFactor[0] + tessFactor.edgeTessellationFactor[1];
        u_xlat0.x = u_xlat0.x + tessFactor.edgeTessellationFactor[2];
        tessFactor.insideTessellationFactor = u_xlat0.x * 0.333333343;
    }
    controlPoints[mtl_VertexID] = output;
    tessFactors[internalPatchID] = tessFactor;
}
// SHADER_STAGE_HULL_end
// SHADER_STAGE_DOMAIN_begin
struct Mtl_VertexInPostTess
{
    patch_control_point<Mtl_ControlPointIn> cp;
};
struct Mtl_VertexOutPostTess
{
    float4 mtl_Position [[ position ]];
    float3 TEXCOORD1 [[ user(TEXCOORD1) ]];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    sampler sampler_Height [[ sampler (0) ]],
    texture2d<float, access::sample > _Height [[ texture(0) ]] ,
    float3 mtl_TessCoord [[ position_in_patch ]],
    uint patchID [[ patch_id ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    Mtl_VertexInPostTess input [[ stage_in ]])
{
#pragma clang diagnostic pop
    Mtl_VertexOutPostTess output;
    MTLTriangleTessellationFactorsHalf tessFactor;
    tessFactor = tessFactors[patchID];
    float4 u_xlat0;
    float4 u_xlat1;
    float4 u_xlat2;
    float4 u_xlat3;
    float4 u_xlat4;
    float u_xlat11;
    float u_xlat15;
    bool u_xlatb15;
    u_xlat0.xyz = mtl_TessCoord.yyy * input.cp[1].NORMAL0.xyz;
    u_xlat0.xyz = fma(input.cp[0].NORMAL0.xyz, mtl_TessCoord.xxx, u_xlat0.xyz);
    u_xlat0.xyz = fma(input.cp[2].NORMAL0.xyz, mtl_TessCoord.zzz, u_xlat0.xyz);
    u_xlat1.x = dot(u_xlat0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat1.y = dot(u_xlat0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat1.z = dot(u_xlat0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat15 = dot(u_xlat1.xyz, u_xlat1.xyz);
    u_xlat15 = rsqrt(u_xlat15);
    u_xlat1.xyz = float3(u_xlat15) * u_xlat1.xyz;
    u_xlat2.xy = mtl_TessCoord.yy * input.cp[1].TEXCOORD0.xy;
    u_xlat2.xy = fma(input.cp[0].TEXCOORD0.xy, mtl_TessCoord.xx, u_xlat2.xy);
    u_xlat2.xy = fma(input.cp[2].TEXCOORD0.xy, mtl_TessCoord.zz, u_xlat2.xy);
    u_xlat2.xy = u_xlat2.xy * float2(VGlobals._Tile);
    u_xlat2.xyz = _Height.sample(sampler_Height, u_xlat2.xy, level(1.0)).xyz;
    u_xlat0.xyz = u_xlat0.xyz * u_xlat2.xyz;
    u_xlat2 = mtl_TessCoord.yyyy * input.cp[1].INTERNALTESSPOS0;
    u_xlat2 = fma(input.cp[0].INTERNALTESSPOS0, mtl_TessCoord.xxxx, u_xlat2);
    u_xlat2 = fma(input.cp[2].INTERNALTESSPOS0, mtl_TessCoord.zzzz, u_xlat2);
    u_xlat0.xyz = fma(u_xlat0.xyz, float3(VGlobals._HeightDisplacement), u_xlat2.xyz);
    u_xlat3 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], u_xlat0.xxxx, u_xlat3);
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], u_xlat0.zzzz, u_xlat3);
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3], u_xlat2.wwww, u_xlat3);
    u_xlat2.xyz = fma((-u_xlat3.xyz), VGlobals._WorldSpaceLightPos0.www, VGlobals._WorldSpaceLightPos0.xyz);
    u_xlat15 = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat15 = rsqrt(u_xlat15);
    u_xlat2.xyz = float3(u_xlat15) * u_xlat2.xyz;
    u_xlat15 = dot(u_xlat1.xyz, u_xlat2.xyz);
    u_xlat15 = fma((-u_xlat15), u_xlat15, 1.0);
    u_xlat15 = sqrt(u_xlat15);
    u_xlat15 = u_xlat15 * VGlobals.unity_LightShadowBias.z;
    u_xlat1.xyz = fma((-u_xlat1.xyz), float3(u_xlat15), u_xlat3.xyz);
    u_xlatb15 = VGlobals.unity_LightShadowBias.z!=0.0;
    u_xlat1.xyz = (bool(u_xlatb15)) ? u_xlat1.xyz : u_xlat3.xyz;
    u_xlat4 = u_xlat1.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat4 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat1.xxxx, u_xlat4);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat1.zzzz, u_xlat4);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat3.wwww, u_xlat1);
    u_xlat15 = VGlobals.unity_LightShadowBias.x / u_xlat1.w;
    u_xlat15 = min(u_xlat15, 0.0);
    u_xlat15 = max(u_xlat15, -1.0);
    u_xlat15 = u_xlat15 + u_xlat1.z;
    u_xlat11 = min(u_xlat1.w, u_xlat15);
    output.mtl_Position.xyw = u_xlat1.xyw;
    u_xlat1.x = (-u_xlat15) + u_xlat11;
    output.mtl_Position.z = fma(VGlobals.unity_LightShadowBias.y, u_xlat1.x, u_xlat15);
    u_xlat1.xyz = u_xlat0.yyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz;
    u_xlat0.xyw = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, u_xlat0.xxx, u_xlat1.xyz);
    u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, u_xlat0.zzz, u_xlat0.xyw);
    output.TEXCOORD1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, u_xlat2.www, u_xlat0.xyz);
    return output;
}
// SHADER_STAGE_DOMAIN_end
Compilation succeeded with: 

program_source:299:53: warning: writable resources in non-void post-tessellation vertex function
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
                                                    ^
program_source:305:30: note: writable buffer defined here
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
                             ^
program_source:306:48: note: writable buffer defined here
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
                                               ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float4 TEXCOORD0 [[ attribute(3) ]] ;
    float4 TEXCOORD1 [[ attribute(4) ]] ;
    float4 TEXCOORD2 [[ attribute(5) ]] ;
    float4 TEXCOORD3 [[ attribute(6) ]] ;
    float4 COLOR0 [[ attribute(7) ]] ;
};
struct Mtl_VertexOut
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float4 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float4 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float4 TEXCOORD3 [[ user(TEXCOORD3) ]];
    float4 COLOR0 [[ user(COLOR0) ]];
};
static Mtl_VertexOut vertexFunction(
    Mtl_VertexIn input)
{
    Mtl_VertexOut output;
    output.INTERNALTESSPOS0 = input.POSITION0;
    output.TANGENT0 = input.TANGENT0;
    output.NORMAL0.xyz = input.NORMAL0.xyz;
    output.TEXCOORD0 = input.TEXCOORD0;
    output.TEXCOORD1 = input.TEXCOORD1;
    output.TEXCOORD2 = input.TEXCOORD2;
    output.TEXCOORD3 = input.TEXCOORD3;
    output.COLOR0 = input.COLOR0;
    return output;
}
// SHADER_STAGE_HULL_begin
struct Mtl_ControlPoint
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float4 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float4 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float4 TEXCOORD3 [[ user(TEXCOORD3) ]];
    float4 COLOR0 [[ user(COLOR0) ]];
};
struct Mtl_ControlPointIn
{
    float4 INTERNALTESSPOS0 [[ attribute(8) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float4 TEXCOORD0 [[ attribute(3) ]] ;
    float4 TEXCOORD1 [[ attribute(4) ]] ;
    float4 TEXCOORD2 [[ attribute(5) ]] ;
    float4 TEXCOORD3 [[ attribute(6) ]] ;
    float4 COLOR0 [[ attribute(7) ]] ;
};
struct Mtl_KernelPatchInfo
{
    uint numPatches;
    ushort numControlPointsPerPatch;
};
struct VGlobals_Type
{
    float4 _Time;
    float4 _SinTime;
    float4 _CosTime;
    float4 unity_DeltaTime;
    float3 _WorldSpaceCameraPos;
    float4 _ProjectionParams;
    float4 _ScreenParams;
    float4 _ZBufferParams;
    float4 unity_OrthoParams;
    float4 unity_CameraWorldClipPlanes[6];
    float4 hlslcc_mtx4x4unity_CameraProjection[4];
    float4 hlslcc_mtx4x4unity_CameraInvProjection[4];
    float4 hlslcc_mtx4x4unity_WorldToCamera[4];
    float4 hlslcc_mtx4x4unity_CameraToWorld[4];
    float4 _WorldSpaceLightPos0;
    float4 _LightPositionRange;
    float4 _LightProjectionParams;
    float4 unity_4LightPosX0;
    float4 unity_4LightPosY0;
    float4 unity_4LightPosZ0;
    float4 unity_4LightAtten0;
    float4 unity_LightColor[8];
    float4 unity_LightPosition[8];
    float4 unity_LightAtten[8];
    float4 unity_SpotDirection[8];
    float4 unity_SHAr;
    float4 unity_SHAg;
    float4 unity_SHAb;
    float4 unity_SHBr;
    float4 unity_SHBg;
    float4 unity_SHBb;
    float4 unity_SHC;
    float4 unity_OcclusionMaskSelector;
    float4 unity_ProbesOcclusion;
    float3 unity_LightColor0;
    float3 unity_LightColor1;
    float3 unity_LightColor2;
    float3 unity_LightColor3;
    float4 unity_ShadowSplitSpheres[4];
    float4 unity_ShadowSplitSqRadii;
    float4 unity_LightShadowBias;
    float4 _LightSplitsNear;
    float4 _LightSplitsFar;
    float4 hlslcc_mtx4x4unity_WorldToShadow[16];
    float4 _LightShadowData;
    float4 unity_ShadowFadeCenterAndType;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 unity_LODFade;
    float4 unity_WorldTransformParams;
    float4 unity_RenderingLayer;
    float4 hlslcc_mtx4x4glstate_matrix_transpose_modelview0[4];
    float4 glstate_lightmodel_ambient;
    float4 unity_AmbientSky;
    float4 unity_AmbientEquator;
    float4 unity_AmbientGround;
    float4 unity_IndirectSpecColor;
    float4 hlslcc_mtx4x4glstate_matrix_projection[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixInvV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    int unity_StereoEyeIndex;
    float4 unity_ShadowColor;
    float4 unity_FogColor;
    float4 unity_FogParams;
    float4 unity_LightmapST;
    float4 unity_DynamicLightmapST;
    float4 unity_SpecCube0_BoxMax;
    float4 unity_SpecCube0_BoxMin;
    float4 unity_SpecCube0_ProbePosition;
    float4 unity_SpecCube0_HDR;
    float4 unity_SpecCube1_BoxMax;
    float4 unity_SpecCube1_BoxMin;
    float4 unity_SpecCube1_ProbePosition;
    float4 unity_SpecCube1_HDR;
    float4 unity_ProbeVolumeParams;
    float4 hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[4];
    float3 unity_ProbeVolumeSizeInv;
    float3 unity_ProbeVolumeMin;
    float4 unity_Lightmap_HDR;
    float4 unity_DynamicLightmap_HDR;
    float4 _LightColor0;
    float4 _SpecColor;
    float _Tile;
    float _HeightDisplacement;
    float _NormalScale;
    float4 _ColorTint;
    float _MetallicStrength;
    float _SmoothnessStrength;
    float _EdgeLength;
    float4 _texcoord_ST;
    float4 unity_Ambient;
};
struct Mtl_HullIn
{
    Mtl_VertexOut cp[3];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
kernel void patchKernel(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn vertexInput [[ stage_in ]],
    uint2 tID [[ thread_position_in_grid ]],
    ushort2 groupID [[ threadgroup_position_in_grid ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    constant Mtl_KernelPatchInfo &patchInfo [[ buffer(3) ]])
{
#pragma clang diagnostic pop
    Mtl_ControlPoint output;
    const uint numPatchesInThreadGroup = 10;
    const uint patchID = (tID.x / patchInfo.numControlPointsPerPatch);
    const bool patchValid = (patchID < patchInfo.numPatches);
    const uint mtl_BaseInstance = 0;
    const uint mtl_InstanceID = groupID.y - mtl_BaseInstance;
    const uint internalPatchID = mtl_InstanceID * patchInfo.numPatches + patchID;
    const uint patchIDInThreadGroup = (patchID % numPatchesInThreadGroup);
    const uint controlPointID = (tID.x % patchInfo.numControlPointsPerPatch);
    const uint mtl_BaseVertex = 0;
    const uint mtl_VertexID = ((mtl_InstanceID * (patchInfo.numControlPointsPerPatch * patchInfo.numPatches)) + tID.x) - mtl_BaseVertex;
    threadgroup Mtl_HullIn inputGroup[numPatchesInThreadGroup];
    threadgroup Mtl_HullIn &input = inputGroup[patchIDInThreadGroup];
    MTLTriangleTessellationFactorsHalf tessFactor;
    if (patchValid) {
        input.cp[controlPointID] = vertexFunction(vertexInput);
        output.INTERNALTESSPOS0 = input.cp[controlPointID].INTERNALTESSPOS0;
        output.TANGENT0 = input.cp[controlPointID].TANGENT0;
        output.NORMAL0 = input.cp[controlPointID].NORMAL0;
        output.TEXCOORD0 = input.cp[controlPointID].TEXCOORD0;
        output.TEXCOORD1 = input.cp[controlPointID].TEXCOORD1;
        output.TEXCOORD2 = input.cp[controlPointID].TEXCOORD2;
        output.TEXCOORD3 = input.cp[controlPointID].TEXCOORD3;
        output.COLOR0 = input.cp[controlPointID].COLOR0;
    }
    threadgroup_barrier(mem_flags::mem_threadgroup);
    if (!patchValid) {
        return;
    }
    float3 u_xlat0;
    float3 u_xlat1;
    float3 u_xlat2;
    float3 u_xlat3;
    float3 u_xlat4;
    float u_xlat12;
    float u_xlat13;
    // fork_phase2
    {
        u_xlat0.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[1].INTERNALTESSPOS0.yyy;
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[1].INTERNALTESSPOS0.xxx, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[1].INTERNALTESSPOS0.zzz, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[1].INTERNALTESSPOS0.www, u_xlat0.xyz);
        u_xlat1.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[2].INTERNALTESSPOS0.yyy;
        u_xlat1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[2].INTERNALTESSPOS0.xxx, u_xlat1.xyz);
        u_xlat1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[2].INTERNALTESSPOS0.zzz, u_xlat1.xyz);
        u_xlat1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[2].INTERNALTESSPOS0.www, u_xlat1.xyz);
        u_xlat2.xyz = u_xlat0.xyz + u_xlat1.xyz;
        u_xlat2.xyz = fma(u_xlat2.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat12 = dot(u_xlat2.xyz, u_xlat2.xyz);
        u_xlat12 = sqrt(u_xlat12);
        u_xlat12 = u_xlat12 * VGlobals._EdgeLength;
        u_xlat2.xyz = u_xlat0.xyz + (-u_xlat1.xyz);
        u_xlat13 = dot(u_xlat2.xyz, u_xlat2.xyz);
        u_xlat13 = sqrt(u_xlat13);
        u_xlat13 = u_xlat13 * VGlobals._ScreenParams.y;
        u_xlat12 = u_xlat13 / u_xlat12;
        tessFactor.edgeTessellationFactor[0] = max(u_xlat12, 1.0);
        u_xlat2.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[0].INTERNALTESSPOS0.yyy;
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[0].INTERNALTESSPOS0.xxx, u_xlat2.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[0].INTERNALTESSPOS0.zzz, u_xlat2.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[0].INTERNALTESSPOS0.www, u_xlat2.xyz);
        u_xlat3.xyz = u_xlat1.xyz + u_xlat2.xyz;
        u_xlat1.xyz = u_xlat1.xyz + (-u_xlat2.xyz);
        u_xlat12 = dot(u_xlat1.xyz, u_xlat1.xyz);
        u_xlat12 = sqrt(u_xlat12);
        u_xlat12 = u_xlat12 * VGlobals._ScreenParams.y;
        u_xlat1.xyz = fma(u_xlat3.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat1.x = dot(u_xlat1.xyz, u_xlat1.xyz);
        u_xlat1.x = sqrt(u_xlat1.x);
        u_xlat1.x = u_xlat1.x * VGlobals._EdgeLength;
        u_xlat12 = u_xlat12 / u_xlat1.x;
        tessFactor.edgeTessellationFactor[1] = max(u_xlat12, 1.0);
        u_xlat1.xyz = u_xlat0.xyz + u_xlat2.xyz;
        u_xlat0.xyz = (-u_xlat0.xyz) + u_xlat2.xyz;
        u_xlat0.x = dot(u_xlat0.xyz, u_xlat0.xyz);
        u_xlat0.x = sqrt(u_xlat0.x);
        u_xlat0.x = u_xlat0.x * VGlobals._ScreenParams.y;
        u_xlat4.xyz = fma(u_xlat1.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat4.x = dot(u_xlat4.xyz, u_xlat4.xyz);
        u_xlat4.x = sqrt(u_xlat4.x);
        u_xlat4.x = u_xlat4.x * VGlobals._EdgeLength;
        u_xlat0.x = u_xlat0.x / u_xlat4.x;
        tessFactor.edgeTessellationFactor[2] = max(u_xlat0.x, 1.0);
    }
    // join_phase3
    {
        u_xlat0.x = tessFactor.edgeTessellationFactor[0] + tessFactor.edgeTessellationFactor[1];
        u_xlat0.x = u_xlat0.x + tessFactor.edgeTessellationFactor[2];
        tessFactor.insideTessellationFactor = u_xlat0.x * 0.333333343;
    }
    controlPoints[mtl_VertexID] = output;
    tessFactors[internalPatchID] = tessFactor;
}
// SHADER_STAGE_HULL_end
// SHADER_STAGE_DOMAIN_begin
struct Mtl_VertexInPostTess
{
    patch_control_point<Mtl_ControlPointIn> cp;
};
struct Mtl_VertexOutPostTess
{
    float4 mtl_Position [[ position ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float4 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float4 TEXCOORD3 [[ user(TEXCOORD3) ]];
    float4 TEXCOORD5 [[ user(TEXCOORD5) ]];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    sampler sampler_Height [[ sampler (0) ]],
    texture2d<float, access::sample > _Height [[ texture(0) ]] ,
    float3 mtl_TessCoord [[ position_in_patch ]],
    uint patchID [[ patch_id ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    Mtl_VertexInPostTess input [[ stage_in ]])
{
#pragma clang diagnostic pop
    Mtl_VertexOutPostTess output;
    MTLTriangleTessellationFactorsHalf tessFactor;
    tessFactor = tessFactors[patchID];
    float4 u_xlat0;
    float4 u_xlat1;
    float4 u_xlat2;
    float4 u_xlat3;
    float2 u_xlat9;
    float u_xlat12;
    float u_xlat13;
    u_xlat0 = mtl_TessCoord.yyyy * input.cp[1].INTERNALTESSPOS0;
    u_xlat0 = fma(input.cp[0].INTERNALTESSPOS0, mtl_TessCoord.xxxx, u_xlat0);
    u_xlat0 = fma(input.cp[2].INTERNALTESSPOS0, mtl_TessCoord.zzzz, u_xlat0);
    u_xlat1.xy = mtl_TessCoord.yy * input.cp[1].TEXCOORD0.xy;
    u_xlat1.xy = fma(input.cp[0].TEXCOORD0.xy, mtl_TessCoord.xx, u_xlat1.xy);
    u_xlat1.xy = fma(input.cp[2].TEXCOORD0.xy, mtl_TessCoord.zz, u_xlat1.xy);
    u_xlat9.xy = u_xlat1.xy * float2(VGlobals._Tile);
    output.TEXCOORD0.xy = fma(u_xlat1.xy, VGlobals._texcoord_ST.xy, VGlobals._texcoord_ST.zw);
    u_xlat1.xyz = _Height.sample(sampler_Height, u_xlat9.xy, level(1.0)).xyz;
    u_xlat2.xyz = mtl_TessCoord.yyy * input.cp[1].NORMAL0.xyz;
    u_xlat2.xyz = fma(input.cp[0].NORMAL0.xyz, mtl_TessCoord.xxx, u_xlat2.xyz);
    u_xlat2.xyz = fma(input.cp[2].NORMAL0.xyz, mtl_TessCoord.zzz, u_xlat2.xyz);
    u_xlat1.xyz = u_xlat1.xyz * u_xlat2.xyz;
    u_xlat0.xyz = fma(u_xlat1.xyz, float3(VGlobals._HeightDisplacement), u_xlat0.xyz);
    u_xlat1 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], u_xlat0.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], u_xlat0.zzzz, u_xlat1);
    u_xlat3 = u_xlat1 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, u_xlat0.www, u_xlat1.xyz);
    u_xlat1 = u_xlat3.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat3.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat3.zzzz, u_xlat1);
    output.mtl_Position = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat3.wwww, u_xlat1);
    u_xlat1.y = dot(u_xlat2.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat1.z = dot(u_xlat2.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat1.x = dot(u_xlat2.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat12 = dot(u_xlat1.xyz, u_xlat1.xyz);
    u_xlat12 = rsqrt(u_xlat12);
    u_xlat1.xyz = float3(u_xlat12) * u_xlat1.xyz;
    output.TEXCOORD1.z = u_xlat1.y;
    u_xlat2 = mtl_TessCoord.yyyy * input.cp[1].TANGENT0;
    u_xlat2 = fma(input.cp[0].TANGENT0, mtl_TessCoord.xxxx, u_xlat2);
    u_xlat2 = fma(input.cp[2].TANGENT0, mtl_TessCoord.zzzz, u_xlat2);
    u_xlat3.xyz = u_xlat2.yyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].yzx;
    u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].yzx, u_xlat2.xxx, u_xlat3.xyz);
    u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].yzx, u_xlat2.zzz, u_xlat3.xyz);
    u_xlat12 = u_xlat2.w * VGlobals.unity_WorldTransformParams.w;
    u_xlat13 = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat13 = rsqrt(u_xlat13);
    u_xlat2.xyz = float3(u_xlat13) * u_xlat2.xyz;
    u_xlat3.xyz = u_xlat1.xyz * u_xlat2.xyz;
    u_xlat3.xyz = fma(u_xlat1.zxy, u_xlat2.yzx, (-u_xlat3.xyz));
    u_xlat3.xyz = float3(u_xlat12) * u_xlat3.xyz;
    output.TEXCOORD1.y = u_xlat3.x;
    output.TEXCOORD1.w = u_xlat0.x;
    output.TEXCOORD1.x = u_xlat2.z;
    output.TEXCOORD2.w = u_xlat0.y;
    output.TEXCOORD3.w = u_xlat0.z;
    output.TEXCOORD2.x = u_xlat2.x;
    output.TEXCOORD3.x = u_xlat2.y;
    output.TEXCOORD2.z = u_xlat1.z;
    output.TEXCOORD3.z = u_xlat1.x;
    output.TEXCOORD2.y = u_xlat3.y;
    output.TEXCOORD3.y = u_xlat3.z;
    output.TEXCOORD5 = float4(0.0, 0.0, 0.0, 0.0);
    return output;
}
// SHADER_STAGE_DOMAIN_end
Compilation succeeded with: 

program_source:303:53: warning: writable resources in non-void post-tessellation vertex function
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
                                                    ^
program_source:309:30: note: writable buffer defined here
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
                             ^
program_source:310:48: note: writable buffer defined here
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
                                               ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float4 TEXCOORD0 [[ attribute(3) ]] ;
    float4 TEXCOORD1 [[ attribute(4) ]] ;
    float4 TEXCOORD2 [[ attribute(5) ]] ;
    float4 TEXCOORD3 [[ attribute(6) ]] ;
    float4 COLOR0 [[ attribute(7) ]] ;
};
struct Mtl_VertexOut
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float4 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float4 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float4 TEXCOORD3 [[ user(TEXCOORD3) ]];
    float4 COLOR0 [[ user(COLOR0) ]];
};
static Mtl_VertexOut vertexFunction(
    Mtl_VertexIn input)
{
    Mtl_VertexOut output;
    output.INTERNALTESSPOS0 = input.POSITION0;
    output.TANGENT0 = input.TANGENT0;
    output.NORMAL0.xyz = input.NORMAL0.xyz;
    output.TEXCOORD0 = input.TEXCOORD0;
    output.TEXCOORD1 = input.TEXCOORD1;
    output.TEXCOORD2 = input.TEXCOORD2;
    output.TEXCOORD3 = input.TEXCOORD3;
    output.COLOR0 = input.COLOR0;
    return output;
}
// SHADER_STAGE_HULL_begin
struct Mtl_ControlPoint
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float4 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float4 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float4 TEXCOORD3 [[ user(TEXCOORD3) ]];
    float4 COLOR0 [[ user(COLOR0) ]];
};
struct Mtl_ControlPointIn
{
    float4 INTERNALTESSPOS0 [[ attribute(8) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float4 TEXCOORD0 [[ attribute(3) ]] ;
    float4 TEXCOORD1 [[ attribute(4) ]] ;
    float4 TEXCOORD2 [[ attribute(5) ]] ;
    float4 TEXCOORD3 [[ attribute(6) ]] ;
    float4 COLOR0 [[ attribute(7) ]] ;
};
struct Mtl_KernelPatchInfo
{
    uint numPatches;
    ushort numControlPointsPerPatch;
};
struct VGlobals_Type
{
    float4 _Time;
    float4 _SinTime;
    float4 _CosTime;
    float4 unity_DeltaTime;
    float3 _WorldSpaceCameraPos;
    float4 _ProjectionParams;
    float4 _ScreenParams;
    float4 _ZBufferParams;
    float4 unity_OrthoParams;
    float4 unity_CameraWorldClipPlanes[6];
    float4 hlslcc_mtx4x4unity_CameraProjection[4];
    float4 hlslcc_mtx4x4unity_CameraInvProjection[4];
    float4 hlslcc_mtx4x4unity_WorldToCamera[4];
    float4 hlslcc_mtx4x4unity_CameraToWorld[4];
    float4 _WorldSpaceLightPos0;
    float4 _LightPositionRange;
    float4 _LightProjectionParams;
    float4 unity_4LightPosX0;
    float4 unity_4LightPosY0;
    float4 unity_4LightPosZ0;
    float4 unity_4LightAtten0;
    float4 unity_LightColor[8];
    float4 unity_LightPosition[8];
    float4 unity_LightAtten[8];
    float4 unity_SpotDirection[8];
    float4 unity_SHAr;
    float4 unity_SHAg;
    float4 unity_SHAb;
    float4 unity_SHBr;
    float4 unity_SHBg;
    float4 unity_SHBb;
    float4 unity_SHC;
    float4 unity_OcclusionMaskSelector;
    float4 unity_ProbesOcclusion;
    float3 unity_LightColor0;
    float3 unity_LightColor1;
    float3 unity_LightColor2;
    float3 unity_LightColor3;
    float4 unity_ShadowSplitSpheres[4];
    float4 unity_ShadowSplitSqRadii;
    float4 unity_LightShadowBias;
    float4 _LightSplitsNear;
    float4 _LightSplitsFar;
    float4 hlslcc_mtx4x4unity_WorldToShadow[16];
    float4 _LightShadowData;
    float4 unity_ShadowFadeCenterAndType;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 unity_LODFade;
    float4 unity_WorldTransformParams;
    float4 unity_RenderingLayer;
    float4 hlslcc_mtx4x4glstate_matrix_transpose_modelview0[4];
    float4 glstate_lightmodel_ambient;
    float4 unity_AmbientSky;
    float4 unity_AmbientEquator;
    float4 unity_AmbientGround;
    float4 unity_IndirectSpecColor;
    float4 hlslcc_mtx4x4glstate_matrix_projection[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixInvV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    int unity_StereoEyeIndex;
    float4 unity_ShadowColor;
    float4 unity_FogColor;
    float4 unity_FogParams;
    float4 unity_LightmapST;
    float4 unity_DynamicLightmapST;
    float4 unity_SpecCube0_BoxMax;
    float4 unity_SpecCube0_BoxMin;
    float4 unity_SpecCube0_ProbePosition;
    float4 unity_SpecCube0_HDR;
    float4 unity_SpecCube1_BoxMax;
    float4 unity_SpecCube1_BoxMin;
    float4 unity_SpecCube1_ProbePosition;
    float4 unity_SpecCube1_HDR;
    float4 unity_ProbeVolumeParams;
    float4 hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[4];
    float3 unity_ProbeVolumeSizeInv;
    float3 unity_ProbeVolumeMin;
    float4 unity_Lightmap_HDR;
    float4 unity_DynamicLightmap_HDR;
    float4 _LightColor0;
    float4 _SpecColor;
    float _Tile;
    float _HeightDisplacement;
    float _NormalScale;
    float4 _ColorTint;
    float _MetallicStrength;
    float _SmoothnessStrength;
    float _EdgeLength;
    bool4 unity_MetaVertexControl;
    bool4 unity_MetaFragmentControl;
    int unity_VisualizationMode;
    float unity_OneOverOutputBoost;
    float unity_MaxOutputValue;
    float unity_UseLinearSpace;
    float4 _texcoord_ST;
};
struct Mtl_HullIn
{
    Mtl_VertexOut cp[3];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
kernel void patchKernel(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn vertexInput [[ stage_in ]],
    uint2 tID [[ thread_position_in_grid ]],
    ushort2 groupID [[ threadgroup_position_in_grid ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    constant Mtl_KernelPatchInfo &patchInfo [[ buffer(3) ]])
{
#pragma clang diagnostic pop
    Mtl_ControlPoint output;
    const uint numPatchesInThreadGroup = 10;
    const uint patchID = (tID.x / patchInfo.numControlPointsPerPatch);
    const bool patchValid = (patchID < patchInfo.numPatches);
    const uint mtl_BaseInstance = 0;
    const uint mtl_InstanceID = groupID.y - mtl_BaseInstance;
    const uint internalPatchID = mtl_InstanceID * patchInfo.numPatches + patchID;
    const uint patchIDInThreadGroup = (patchID % numPatchesInThreadGroup);
    const uint controlPointID = (tID.x % patchInfo.numControlPointsPerPatch);
    const uint mtl_BaseVertex = 0;
    const uint mtl_VertexID = ((mtl_InstanceID * (patchInfo.numControlPointsPerPatch * patchInfo.numPatches)) + tID.x) - mtl_BaseVertex;
    threadgroup Mtl_HullIn inputGroup[numPatchesInThreadGroup];
    threadgroup Mtl_HullIn &input = inputGroup[patchIDInThreadGroup];
    MTLTriangleTessellationFactorsHalf tessFactor;
    if (patchValid) {
        input.cp[controlPointID] = vertexFunction(vertexInput);
        output.INTERNALTESSPOS0 = input.cp[controlPointID].INTERNALTESSPOS0;
        output.TANGENT0 = input.cp[controlPointID].TANGENT0;
        output.NORMAL0 = input.cp[controlPointID].NORMAL0;
        output.TEXCOORD0 = input.cp[controlPointID].TEXCOORD0;
        output.TEXCOORD1 = input.cp[controlPointID].TEXCOORD1;
        output.TEXCOORD2 = input.cp[controlPointID].TEXCOORD2;
        output.TEXCOORD3 = input.cp[controlPointID].TEXCOORD3;
        output.COLOR0 = input.cp[controlPointID].COLOR0;
    }
    threadgroup_barrier(mem_flags::mem_threadgroup);
    if (!patchValid) {
        return;
    }
    float3 u_xlat0;
    float3 u_xlat1;
    float3 u_xlat2;
    float3 u_xlat3;
    float3 u_xlat4;
    float u_xlat12;
    float u_xlat13;
    // fork_phase2
    {
        u_xlat0.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[1].INTERNALTESSPOS0.yyy;
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[1].INTERNALTESSPOS0.xxx, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[1].INTERNALTESSPOS0.zzz, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[1].INTERNALTESSPOS0.www, u_xlat0.xyz);
        u_xlat1.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[2].INTERNALTESSPOS0.yyy;
        u_xlat1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[2].INTERNALTESSPOS0.xxx, u_xlat1.xyz);
        u_xlat1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[2].INTERNALTESSPOS0.zzz, u_xlat1.xyz);
        u_xlat1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[2].INTERNALTESSPOS0.www, u_xlat1.xyz);
        u_xlat2.xyz = u_xlat0.xyz + u_xlat1.xyz;
        u_xlat2.xyz = fma(u_xlat2.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat12 = dot(u_xlat2.xyz, u_xlat2.xyz);
        u_xlat12 = sqrt(u_xlat12);
        u_xlat12 = u_xlat12 * VGlobals._EdgeLength;
        u_xlat2.xyz = u_xlat0.xyz + (-u_xlat1.xyz);
        u_xlat13 = dot(u_xlat2.xyz, u_xlat2.xyz);
        u_xlat13 = sqrt(u_xlat13);
        u_xlat13 = u_xlat13 * VGlobals._ScreenParams.y;
        u_xlat12 = u_xlat13 / u_xlat12;
        tessFactor.edgeTessellationFactor[0] = max(u_xlat12, 1.0);
        u_xlat2.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[0].INTERNALTESSPOS0.yyy;
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[0].INTERNALTESSPOS0.xxx, u_xlat2.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[0].INTERNALTESSPOS0.zzz, u_xlat2.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[0].INTERNALTESSPOS0.www, u_xlat2.xyz);
        u_xlat3.xyz = u_xlat1.xyz + u_xlat2.xyz;
        u_xlat1.xyz = u_xlat1.xyz + (-u_xlat2.xyz);
        u_xlat12 = dot(u_xlat1.xyz, u_xlat1.xyz);
        u_xlat12 = sqrt(u_xlat12);
        u_xlat12 = u_xlat12 * VGlobals._ScreenParams.y;
        u_xlat1.xyz = fma(u_xlat3.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat1.x = dot(u_xlat1.xyz, u_xlat1.xyz);
        u_xlat1.x = sqrt(u_xlat1.x);
        u_xlat1.x = u_xlat1.x * VGlobals._EdgeLength;
        u_xlat12 = u_xlat12 / u_xlat1.x;
        tessFactor.edgeTessellationFactor[1] = max(u_xlat12, 1.0);
        u_xlat1.xyz = u_xlat0.xyz + u_xlat2.xyz;
        u_xlat0.xyz = (-u_xlat0.xyz) + u_xlat2.xyz;
        u_xlat0.x = dot(u_xlat0.xyz, u_xlat0.xyz);
        u_xlat0.x = sqrt(u_xlat0.x);
        u_xlat0.x = u_xlat0.x * VGlobals._ScreenParams.y;
        u_xlat4.xyz = fma(u_xlat1.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat4.x = dot(u_xlat4.xyz, u_xlat4.xyz);
        u_xlat4.x = sqrt(u_xlat4.x);
        u_xlat4.x = u_xlat4.x * VGlobals._EdgeLength;
        u_xlat0.x = u_xlat0.x / u_xlat4.x;
        tessFactor.edgeTessellationFactor[2] = max(u_xlat0.x, 1.0);
    }
    // join_phase3
    {
        u_xlat0.x = tessFactor.edgeTessellationFactor[0] + tessFactor.edgeTessellationFactor[1];
        u_xlat0.x = u_xlat0.x + tessFactor.edgeTessellationFactor[2];
        tessFactor.insideTessellationFactor = u_xlat0.x * 0.333333343;
    }
    controlPoints[mtl_VertexID] = output;
    tessFactors[internalPatchID] = tessFactor;
}
// SHADER_STAGE_HULL_end
// SHADER_STAGE_DOMAIN_begin
struct Mtl_VertexInPostTess
{
    patch_control_point<Mtl_ControlPointIn> cp;
};
struct Mtl_VertexOutPostTess
{
    float4 mtl_Position [[ position ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float4 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float4 TEXCOORD3 [[ user(TEXCOORD3) ]];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    sampler sampler_Height [[ sampler (0) ]],
    texture2d<float, access::sample > _Height [[ texture(0) ]] ,
    float3 mtl_TessCoord [[ position_in_patch ]],
    uint patchID [[ patch_id ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    Mtl_VertexInPostTess input [[ stage_in ]])
{
#pragma clang diagnostic pop
    Mtl_VertexOutPostTess output;
    MTLTriangleTessellationFactorsHalf tessFactor;
    tessFactor = tessFactors[patchID];
    float4 u_xlat0;
    float4 u_xlat1;
    float4 u_xlat2;
    float3 u_xlat3;
    float3 u_xlat4;
    float2 u_xlat13;
    float u_xlat15;
    bool u_xlatb15;
    u_xlat0.xy = mtl_TessCoord.yy * input.cp[1].TEXCOORD2.xy;
    u_xlat0.xy = fma(input.cp[0].TEXCOORD2.xy, mtl_TessCoord.xx, u_xlat0.xy);
    u_xlat0.xy = fma(input.cp[2].TEXCOORD2.xy, mtl_TessCoord.zz, u_xlat0.xy);
    u_xlat0.xy = fma(u_xlat0.xy, VGlobals.unity_DynamicLightmapST.xy, VGlobals.unity_DynamicLightmapST.zw);
    u_xlat1.xy = mtl_TessCoord.yy * input.cp[1].TEXCOORD1.xy;
    u_xlat1.xy = fma(input.cp[0].TEXCOORD1.xy, mtl_TessCoord.xx, u_xlat1.xy);
    u_xlat1.xy = fma(input.cp[2].TEXCOORD1.xy, mtl_TessCoord.zz, u_xlat1.xy);
    u_xlat1.xy = fma(u_xlat1.xy, VGlobals.unity_LightmapST.xy, VGlobals.unity_LightmapST.zw);
    u_xlat2 = mtl_TessCoord.yyyy * input.cp[1].INTERNALTESSPOS0;
    u_xlat2 = fma(input.cp[0].INTERNALTESSPOS0, mtl_TessCoord.xxxx, u_xlat2);
    u_xlat2 = fma(input.cp[2].INTERNALTESSPOS0, mtl_TessCoord.zzzz, u_xlat2);
    u_xlat3.xy = mtl_TessCoord.yy * input.cp[1].TEXCOORD0.xy;
    u_xlat3.xy = fma(input.cp[0].TEXCOORD0.xy, mtl_TessCoord.xx, u_xlat3.xy);
    u_xlat3.xy = fma(input.cp[2].TEXCOORD0.xy, mtl_TessCoord.zz, u_xlat3.xy);
    u_xlat13.xy = u_xlat3.xy * float2(VGlobals._Tile);
    output.TEXCOORD0.xy = fma(u_xlat3.xy, VGlobals._texcoord_ST.xy, VGlobals._texcoord_ST.zw);
    u_xlat3.xyz = _Height.sample(sampler_Height, u_xlat13.xy, level(1.0)).xyz;
    u_xlat4.xyz = mtl_TessCoord.yyy * input.cp[1].NORMAL0.xyz;
    u_xlat4.xyz = fma(input.cp[0].NORMAL0.xyz, mtl_TessCoord.xxx, u_xlat4.xyz);
    u_xlat4.xyz = fma(input.cp[2].NORMAL0.xyz, mtl_TessCoord.zzz, u_xlat4.xyz);
    u_xlat3.xyz = u_xlat3.xyz * u_xlat4.xyz;
    u_xlat2.xyz = fma(u_xlat3.xyz, float3(VGlobals._HeightDisplacement), u_xlat2.xyz);
    u_xlatb15 = 0.0<u_xlat2.z;
    u_xlat1.z = u_xlatb15 ? 9.99999975e-05 : float(0.0);
    u_xlat1.xyz = (VGlobals.unity_MetaVertexControl.x) ? u_xlat1.xyz : u_xlat2.xyz;
    u_xlatb15 = 0.0<u_xlat1.z;
    u_xlat0.z = u_xlatb15 ? 9.99999975e-05 : float(0.0);
    u_xlat0.xyz = (VGlobals.unity_MetaVertexControl.y) ? u_xlat0.xyz : u_xlat1.xyz;
    u_xlat1 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat0.xxxx, u_xlat1);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat0.zzzz, u_xlat1);
    output.mtl_Position = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_MatrixVP[3];
    u_xlat0.xyz = u_xlat2.yyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz;
    u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, u_xlat2.xxx, u_xlat0.xyz);
    u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, u_xlat2.zzz, u_xlat0.xyz);
    u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, u_xlat2.www, u_xlat0.xyz);
    output.TEXCOORD1.w = u_xlat0.x;
    u_xlat1.y = dot(u_xlat4.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat1.z = dot(u_xlat4.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat1.x = dot(u_xlat4.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat0.x = dot(u_xlat1.xyz, u_xlat1.xyz);
    u_xlat0.x = rsqrt(u_xlat0.x);
    u_xlat1.xyz = u_xlat0.xxx * u_xlat1.xyz;
    output.TEXCOORD1.z = u_xlat1.y;
    u_xlat2 = mtl_TessCoord.yyyy * input.cp[1].TANGENT0;
    u_xlat2 = fma(input.cp[0].TANGENT0, mtl_TessCoord.xxxx, u_xlat2);
    u_xlat2 = fma(input.cp[2].TANGENT0, mtl_TessCoord.zzzz, u_xlat2);
    u_xlat3.xyz = u_xlat2.yyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].yzx;
    u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].yzx, u_xlat2.xxx, u_xlat3.xyz);
    u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].yzx, u_xlat2.zzz, u_xlat3.xyz);
    u_xlat0.x = u_xlat2.w * VGlobals.unity_WorldTransformParams.w;
    u_xlat15 = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat15 = rsqrt(u_xlat15);
    u_xlat2.xyz = float3(u_xlat15) * u_xlat2.xyz;
    u_xlat3.xyz = u_xlat1.xyz * u_xlat2.xyz;
    u_xlat3.xyz = fma(u_xlat1.zxy, u_xlat2.yzx, (-u_xlat3.xyz));
    u_xlat3.xyz = u_xlat0.xxx * u_xlat3.xyz;
    output.TEXCOORD1.y = u_xlat3.x;
    output.TEXCOORD1.x = u_xlat2.z;
    output.TEXCOORD2.w = u_xlat0.y;
    output.TEXCOORD3.w = u_xlat0.z;
    output.TEXCOORD2.x = u_xlat2.x;
    output.TEXCOORD3.x = u_xlat2.y;
    output.TEXCOORD2.z = u_xlat1.z;
    output.TEXCOORD3.z = u_xlat1.x;
    output.TEXCOORD2.y = u_xlat3.y;
    output.TEXCOORD3.y = u_xlat3.z;
    return output;
}
// SHADER_STAGE_DOMAIN_end
Refreshing native plugins compatible for Editor in 2.29 ms, found 2 plugins.
Preloading 0 native plugins for Editor in 0.00 ms.
Unloading 3375 Unused Serialized files (Serialized files now loaded: 0)
Unloading 20 unused Assets / (0.6 MB). Loaded Objects now: 3907.
Memory consumption went from 136.5 MB to 135.8 MB.
Total: 5.735247 ms (FindLiveObjects: 0.470947 ms CreateObjectMapping: 0.421113 ms MarkObjects: 4.360697 ms  DeleteObjects: 0.481233 ms)

AssetImportParameters requested are different than current active one (requested -> active):
  custom:video-decoder-ogg-theora: a1e56fd34408186e4bbccfd4996cb3dc -> 
  custom:container-muxer-webm: aa71ff27fc2769a1b78a27578f13a17b -> 
  custom:container-demuxer-webm: 4f35f7cbe854078d1ac9338744f61a02 -> 
  custom:video-encoder-webm-vp8: eb34c28f22e8b96e1ab97ce403110664 -> 
  custom:framework-osx-AVFoundation: b23960f63f64bdc6ff669e2cdcee2391 -> 
  custom:audio-encoder-webm-vorbis: bf7c407c2cedff20999df2af8eb42d56 -> 
  custom:container-demuxer-ogg: 62fdf1f143b41e24485cea50d1cbac27 -> 
  custom:video-decoder-webm-vp8: 9c59270c3fd7afecdb556c50c9e8de78 -> 
  custom:audio-decoder-ogg-vorbis: bf7c407c2cedff20999df2af8eb42d56 -> 
========================================================================
Received Prepare
Registering precompiled user dll's ...
Registered in 0.003721 seconds.
Begin MonoManager ReloadAssembly
Symbol file LoadedFromMemory doesn't match image /Users/kamilaamendolagine/Desktop/Staugen Raug v2 - Prefab - Map 1.01/Library/PackageCache/com.unity.visualscripting@1.7.8/Editor/VisualScripting.Core/Dependencies/YamlDotNet/Unity.VisualScripting.YamlDotNet.dll
Symbol file LoadedFromMemory doesn't match image /Users/kamilaamendolagine/Desktop/Staugen Raug v2 - Prefab - Map 1.01/Library/PackageCache/com.unity.visualscripting@1.7.8/Editor/VisualScripting.Core/Dependencies/DotNetZip/Unity.VisualScripting.IonicZip.dll
Native extension for OSXStandalone target not found
Native extension for WebGL target not found
Refreshing native plugins compatible for Editor in 0.93 ms, found 2 plugins.
Preloading 0 native plugins for Editor in 0.00 ms.
Mono: successfully reloaded assembly
- Completed reload, in  1.782 seconds
Domain Reload Profiling:
	ReloadAssembly (1783ms)
		BeginReloadAssembly (202ms)
			ExecutionOrderSort (0ms)
			DisableScriptedObjects (10ms)
			BackupInstance (0ms)
			ReleaseScriptingObjects (0ms)
			CreateAndSetChildDomain (87ms)
		EndReloadAssembly (1412ms)
			LoadAssemblies (91ms)
			RebuildTransferFunctionScriptingTraits (0ms)
			SetupTypeCache (489ms)
			ReleaseScriptCaches (2ms)
			RebuildScriptCaches (74ms)
			SetupLoadedEditorAssemblies (659ms)
				LogAssemblyErrors (0ms)
				InitializePlatformSupportModulesInManaged (20ms)
				SetLoadedEditorAssemblies (1ms)
				RefreshPlugins (1ms)
				BeforeProcessingInitializeOnLoad (100ms)
				ProcessInitializeOnLoadAttributes (486ms)
				ProcessInitializeOnLoadMethodAttributes (47ms)
				AfterProcessingInitializeOnLoad (3ms)
				EditorAssembliesLoaded (0ms)
			ExecutionOrderSort2 (0ms)
			AwakeInstancesAfterBackupRestoration (9ms)
Platform modules already initialized, skipping
Compilation succeeded with: 

program_source:299:53: warning: writable resources in non-void post-tessellation vertex function
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
                                                    ^
program_source:305:30: note: writable buffer defined here
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
                             ^
program_source:306:48: note: writable buffer defined here
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
                                               ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float4 TEXCOORD0 [[ attribute(3) ]] ;
    float4 TEXCOORD1 [[ attribute(4) ]] ;
    float4 TEXCOORD2 [[ attribute(5) ]] ;
    float4 TEXCOORD3 [[ attribute(6) ]] ;
    float4 COLOR0 [[ attribute(7) ]] ;
};
struct Mtl_VertexOut
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float4 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float4 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float4 TEXCOORD3 [[ user(TEXCOORD3) ]];
    float4 COLOR0 [[ user(COLOR0) ]];
};
static Mtl_VertexOut vertexFunction(
    Mtl_VertexIn input)
{
    Mtl_VertexOut output;
    output.INTERNALTESSPOS0 = input.POSITION0;
    output.TANGENT0 = input.TANGENT0;
    output.NORMAL0.xyz = input.NORMAL0.xyz;
    output.TEXCOORD0 = input.TEXCOORD0;
    output.TEXCOORD1 = input.TEXCOORD1;
    output.TEXCOORD2 = input.TEXCOORD2;
    output.TEXCOORD3 = input.TEXCOORD3;
    output.COLOR0 = input.COLOR0;
    return output;
}
// SHADER_STAGE_HULL_begin
struct Mtl_ControlPoint
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float4 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float4 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float4 TEXCOORD3 [[ user(TEXCOORD3) ]];
    float4 COLOR0 [[ user(COLOR0) ]];
};
struct Mtl_ControlPointIn
{
    float4 INTERNALTESSPOS0 [[ attribute(8) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float4 TEXCOORD0 [[ attribute(3) ]] ;
    float4 TEXCOORD1 [[ attribute(4) ]] ;
    float4 TEXCOORD2 [[ attribute(5) ]] ;
    float4 TEXCOORD3 [[ attribute(6) ]] ;
    float4 COLOR0 [[ attribute(7) ]] ;
};
struct Mtl_KernelPatchInfo
{
    uint numPatches;
    ushort numControlPointsPerPatch;
};
struct VGlobals_Type
{
    float4 _Time;
    float4 _SinTime;
    float4 _CosTime;
    float4 unity_DeltaTime;
    float3 _WorldSpaceCameraPos;
    float4 _ProjectionParams;
    float4 _ScreenParams;
    float4 _ZBufferParams;
    float4 unity_OrthoParams;
    float4 unity_CameraWorldClipPlanes[6];
    float4 hlslcc_mtx4x4unity_CameraProjection[4];
    float4 hlslcc_mtx4x4unity_CameraInvProjection[4];
    float4 hlslcc_mtx4x4unity_WorldToCamera[4];
    float4 hlslcc_mtx4x4unity_CameraToWorld[4];
    float4 _WorldSpaceLightPos0;
    float4 _LightPositionRange;
    float4 _LightProjectionParams;
    float4 unity_4LightPosX0;
    float4 unity_4LightPosY0;
    float4 unity_4LightPosZ0;
    float4 unity_4LightAtten0;
    float4 unity_LightColor[8];
    float4 unity_LightPosition[8];
    float4 unity_LightAtten[8];
    float4 unity_SpotDirection[8];
    float4 unity_SHAr;
    float4 unity_SHAg;
    float4 unity_SHAb;
    float4 unity_SHBr;
    float4 unity_SHBg;
    float4 unity_SHBb;
    float4 unity_SHC;
    float4 unity_OcclusionMaskSelector;
    float4 unity_ProbesOcclusion;
    float3 unity_LightColor0;
    float3 unity_LightColor1;
    float3 unity_LightColor2;
    float3 unity_LightColor3;
    float4 unity_ShadowSplitSpheres[4];
    float4 unity_ShadowSplitSqRadii;
    float4 unity_LightShadowBias;
    float4 _LightSplitsNear;
    float4 _LightSplitsFar;
    float4 hlslcc_mtx4x4unity_WorldToShadow[16];
    float4 _LightShadowData;
    float4 unity_ShadowFadeCenterAndType;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 unity_LODFade;
    float4 unity_WorldTransformParams;
    float4 unity_RenderingLayer;
    float4 hlslcc_mtx4x4glstate_matrix_transpose_modelview0[4];
    float4 glstate_lightmodel_ambient;
    float4 unity_AmbientSky;
    float4 unity_AmbientEquator;
    float4 unity_AmbientGround;
    float4 unity_IndirectSpecColor;
    float4 hlslcc_mtx4x4glstate_matrix_projection[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixInvV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    int unity_StereoEyeIndex;
    float4 unity_ShadowColor;
    float4 unity_FogColor;
    float4 unity_FogParams;
    float4 unity_LightmapST;
    float4 unity_DynamicLightmapST;
    float4 unity_SpecCube0_BoxMax;
    float4 unity_SpecCube0_BoxMin;
    float4 unity_SpecCube0_ProbePosition;
    float4 unity_SpecCube0_HDR;
    float4 unity_SpecCube1_BoxMax;
    float4 unity_SpecCube1_BoxMin;
    float4 unity_SpecCube1_ProbePosition;
    float4 unity_SpecCube1_HDR;
    float4 unity_ProbeVolumeParams;
    float4 hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[4];
    float3 unity_ProbeVolumeSizeInv;
    float3 unity_ProbeVolumeMin;
    float4 unity_Lightmap_HDR;
    float4 unity_DynamicLightmap_HDR;
    float4 _LightColor0;
    float4 _SpecColor;
    float _Tile;
    float _HeightDisplacement;
    float _NormalScale;
    float4 _ColorTint;
    float _MetallicStrength;
    float _SmoothnessStrength;
    float _EdgeLength;
    float4 _texcoord_ST;
};
struct Mtl_HullIn
{
    Mtl_VertexOut cp[3];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
kernel void patchKernel(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn vertexInput [[ stage_in ]],
    uint2 tID [[ thread_position_in_grid ]],
    ushort2 groupID [[ threadgroup_position_in_grid ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    constant Mtl_KernelPatchInfo &patchInfo [[ buffer(3) ]])
{
#pragma clang diagnostic pop
    Mtl_ControlPoint output;
    const uint numPatchesInThreadGroup = 10;
    const uint patchID = (tID.x / patchInfo.numControlPointsPerPatch);
    const bool patchValid = (patchID < patchInfo.numPatches);
    const uint mtl_BaseInstance = 0;
    const uint mtl_InstanceID = groupID.y - mtl_BaseInstance;
    const uint internalPatchID = mtl_InstanceID * patchInfo.numPatches + patchID;
    const uint patchIDInThreadGroup = (patchID % numPatchesInThreadGroup);
    const uint controlPointID = (tID.x % patchInfo.numControlPointsPerPatch);
    const uint mtl_BaseVertex = 0;
    const uint mtl_VertexID = ((mtl_InstanceID * (patchInfo.numControlPointsPerPatch * patchInfo.numPatches)) + tID.x) - mtl_BaseVertex;
    threadgroup Mtl_HullIn inputGroup[numPatchesInThreadGroup];
    threadgroup Mtl_HullIn &input = inputGroup[patchIDInThreadGroup];
    MTLTriangleTessellationFactorsHalf tessFactor;
    if (patchValid) {
        input.cp[controlPointID] = vertexFunction(vertexInput);
        output.INTERNALTESSPOS0 = input.cp[controlPointID].INTERNALTESSPOS0;
        output.TANGENT0 = input.cp[controlPointID].TANGENT0;
        output.NORMAL0 = input.cp[controlPointID].NORMAL0;
        output.TEXCOORD0 = input.cp[controlPointID].TEXCOORD0;
        output.TEXCOORD1 = input.cp[controlPointID].TEXCOORD1;
        output.TEXCOORD2 = input.cp[controlPointID].TEXCOORD2;
        output.TEXCOORD3 = input.cp[controlPointID].TEXCOORD3;
        output.COLOR0 = input.cp[controlPointID].COLOR0;
    }
    threadgroup_barrier(mem_flags::mem_threadgroup);
    if (!patchValid) {
        return;
    }
    float3 u_xlat0;
    float3 u_xlat1;
    float3 u_xlat2;
    float3 u_xlat3;
    float3 u_xlat4;
    float u_xlat12;
    float u_xlat13;
    // fork_phase2
    {
        u_xlat0.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[1].INTERNALTESSPOS0.yyy;
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[1].INTERNALTESSPOS0.xxx, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[1].INTERNALTESSPOS0.zzz, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[1].INTERNALTESSPOS0.www, u_xlat0.xyz);
        u_xlat1.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[2].INTERNALTESSPOS0.yyy;
        u_xlat1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[2].INTERNALTESSPOS0.xxx, u_xlat1.xyz);
        u_xlat1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[2].INTERNALTESSPOS0.zzz, u_xlat1.xyz);
        u_xlat1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[2].INTERNALTESSPOS0.www, u_xlat1.xyz);
        u_xlat2.xyz = u_xlat0.xyz + u_xlat1.xyz;
        u_xlat2.xyz = fma(u_xlat2.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat12 = dot(u_xlat2.xyz, u_xlat2.xyz);
        u_xlat12 = sqrt(u_xlat12);
        u_xlat12 = u_xlat12 * VGlobals._EdgeLength;
        u_xlat2.xyz = u_xlat0.xyz + (-u_xlat1.xyz);
        u_xlat13 = dot(u_xlat2.xyz, u_xlat2.xyz);
        u_xlat13 = sqrt(u_xlat13);
        u_xlat13 = u_xlat13 * VGlobals._ScreenParams.y;
        u_xlat12 = u_xlat13 / u_xlat12;
        tessFactor.edgeTessellationFactor[0] = max(u_xlat12, 1.0);
        u_xlat2.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[0].INTERNALTESSPOS0.yyy;
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[0].INTERNALTESSPOS0.xxx, u_xlat2.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[0].INTERNALTESSPOS0.zzz, u_xlat2.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[0].INTERNALTESSPOS0.www, u_xlat2.xyz);
        u_xlat3.xyz = u_xlat1.xyz + u_xlat2.xyz;
        u_xlat1.xyz = u_xlat1.xyz + (-u_xlat2.xyz);
        u_xlat12 = dot(u_xlat1.xyz, u_xlat1.xyz);
        u_xlat12 = sqrt(u_xlat12);
        u_xlat12 = u_xlat12 * VGlobals._ScreenParams.y;
        u_xlat1.xyz = fma(u_xlat3.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat1.x = dot(u_xlat1.xyz, u_xlat1.xyz);
        u_xlat1.x = sqrt(u_xlat1.x);
        u_xlat1.x = u_xlat1.x * VGlobals._EdgeLength;
        u_xlat12 = u_xlat12 / u_xlat1.x;
        tessFactor.edgeTessellationFactor[1] = max(u_xlat12, 1.0);
        u_xlat1.xyz = u_xlat0.xyz + u_xlat2.xyz;
        u_xlat0.xyz = (-u_xlat0.xyz) + u_xlat2.xyz;
        u_xlat0.x = dot(u_xlat0.xyz, u_xlat0.xyz);
        u_xlat0.x = sqrt(u_xlat0.x);
        u_xlat0.x = u_xlat0.x * VGlobals._ScreenParams.y;
        u_xlat4.xyz = fma(u_xlat1.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat4.x = dot(u_xlat4.xyz, u_xlat4.xyz);
        u_xlat4.x = sqrt(u_xlat4.x);
        u_xlat4.x = u_xlat4.x * VGlobals._EdgeLength;
        u_xlat0.x = u_xlat0.x / u_xlat4.x;
        tessFactor.edgeTessellationFactor[2] = max(u_xlat0.x, 1.0);
    }
    // join_phase3
    {
        u_xlat0.x = tessFactor.edgeTessellationFactor[0] + tessFactor.edgeTessellationFactor[1];
        u_xlat0.x = u_xlat0.x + tessFactor.edgeTessellationFactor[2];
        tessFactor.insideTessellationFactor = u_xlat0.x * 0.333333343;
    }
    controlPoints[mtl_VertexID] = output;
    tessFactors[internalPatchID] = tessFactor;
}
// SHADER_STAGE_HULL_end
// SHADER_STAGE_DOMAIN_begin
struct Mtl_VertexInPostTess
{
    patch_control_point<Mtl_ControlPointIn> cp;
};
struct Mtl_VertexOutPostTess
{
    float4 mtl_Position [[ position ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float4 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float4 TEXCOORD3 [[ user(TEXCOORD3) ]];
    float4 TEXCOORD6 [[ user(TEXCOORD6) ]];
    float4 TEXCOORD7 [[ user(TEXCOORD7) ]];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    sampler sampler_Height [[ sampler (0) ]],
    texture2d<float, access::sample > _Height [[ texture(0) ]] ,
    float3 mtl_TessCoord [[ position_in_patch ]],
    uint patchID [[ patch_id ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    Mtl_VertexInPostTess input [[ stage_in ]])
{
#pragma clang diagnostic pop
    Mtl_VertexOutPostTess output;
    MTLTriangleTessellationFactorsHalf tessFactor;
    tessFactor = tessFactors[patchID];
    float4 u_xlat0;
    float4 u_xlat1;
    float4 u_xlat2;
    float4 u_xlat3;
    float2 u_xlat9;
    float u_xlat12;
    float u_xlat13;
    u_xlat0 = mtl_TessCoord.yyyy * input.cp[1].INTERNALTESSPOS0;
    u_xlat0 = fma(input.cp[0].INTERNALTESSPOS0, mtl_TessCoord.xxxx, u_xlat0);
    u_xlat0 = fma(input.cp[2].INTERNALTESSPOS0, mtl_TessCoord.zzzz, u_xlat0);
    u_xlat1.xy = mtl_TessCoord.yy * input.cp[1].TEXCOORD0.xy;
    u_xlat1.xy = fma(input.cp[0].TEXCOORD0.xy, mtl_TessCoord.xx, u_xlat1.xy);
    u_xlat1.xy = fma(input.cp[2].TEXCOORD0.xy, mtl_TessCoord.zz, u_xlat1.xy);
    u_xlat9.xy = u_xlat1.xy * float2(VGlobals._Tile);
    output.TEXCOORD0.xy = fma(u_xlat1.xy, VGlobals._texcoord_ST.xy, VGlobals._texcoord_ST.zw);
    u_xlat1.xyz = _Height.sample(sampler_Height, u_xlat9.xy, level(1.0)).xyz;
    u_xlat2.xyz = mtl_TessCoord.yyy * input.cp[1].NORMAL0.xyz;
    u_xlat2.xyz = fma(input.cp[0].NORMAL0.xyz, mtl_TessCoord.xxx, u_xlat2.xyz);
    u_xlat2.xyz = fma(input.cp[2].NORMAL0.xyz, mtl_TessCoord.zzz, u_xlat2.xyz);
    u_xlat1.xyz = u_xlat1.xyz * u_xlat2.xyz;
    u_xlat0.xyz = fma(u_xlat1.xyz, float3(VGlobals._HeightDisplacement), u_xlat0.xyz);
    u_xlat1 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], u_xlat0.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], u_xlat0.zzzz, u_xlat1);
    u_xlat3 = u_xlat1 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, u_xlat0.www, u_xlat1.xyz);
    u_xlat1 = u_xlat3.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat3.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat3.zzzz, u_xlat1);
    output.mtl_Position = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat3.wwww, u_xlat1);
    u_xlat1.y = dot(u_xlat2.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat1.z = dot(u_xlat2.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat1.x = dot(u_xlat2.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat12 = dot(u_xlat1.xyz, u_xlat1.xyz);
    u_xlat12 = rsqrt(u_xlat12);
    u_xlat1.xyz = float3(u_xlat12) * u_xlat1.xyz;
    output.TEXCOORD1.z = u_xlat1.y;
    u_xlat2 = mtl_TessCoord.yyyy * input.cp[1].TANGENT0;
    u_xlat2 = fma(input.cp[0].TANGENT0, mtl_TessCoord.xxxx, u_xlat2);
    u_xlat2 = fma(input.cp[2].TANGENT0, mtl_TessCoord.zzzz, u_xlat2);
    u_xlat3.xyz = u_xlat2.yyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].yzx;
    u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].yzx, u_xlat2.xxx, u_xlat3.xyz);
    u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].yzx, u_xlat2.zzz, u_xlat3.xyz);
    u_xlat12 = u_xlat2.w * VGlobals.unity_WorldTransformParams.w;
    u_xlat13 = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat13 = rsqrt(u_xlat13);
    u_xlat2.xyz = float3(u_xlat13) * u_xlat2.xyz;
    u_xlat3.xyz = u_xlat1.xyz * u_xlat2.xyz;
    u_xlat3.xyz = fma(u_xlat1.zxy, u_xlat2.yzx, (-u_xlat3.xyz));
    u_xlat3.xyz = float3(u_xlat12) * u_xlat3.xyz;
    output.TEXCOORD1.y = u_xlat3.x;
    output.TEXCOORD1.w = u_xlat0.x;
    output.TEXCOORD1.x = u_xlat2.z;
    output.TEXCOORD2.w = u_xlat0.y;
    output.TEXCOORD3.w = u_xlat0.z;
    output.TEXCOORD2.x = u_xlat2.x;
    output.TEXCOORD3.x = u_xlat2.y;
    output.TEXCOORD2.z = u_xlat1.z;
    output.TEXCOORD3.z = u_xlat1.x;
    output.TEXCOORD2.y = u_xlat3.y;
    output.TEXCOORD3.y = u_xlat3.z;
    output.TEXCOORD6 = float4(0.0, 0.0, 0.0, 0.0);
    output.TEXCOORD7 = float4(0.0, 0.0, 0.0, 0.0);
    return output;
}
// SHADER_STAGE_DOMAIN_end
Compilation succeeded with: 

program_source:301:53: warning: writable resources in non-void post-tessellation vertex function
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
                                                    ^
program_source:307:30: note: writable buffer defined here
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
                             ^
program_source:308:48: note: writable buffer defined here
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
                                               ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float4 TEXCOORD0 [[ attribute(3) ]] ;
    float4 TEXCOORD1 [[ attribute(4) ]] ;
    float4 TEXCOORD2 [[ attribute(5) ]] ;
    float4 TEXCOORD3 [[ attribute(6) ]] ;
    float4 COLOR0 [[ attribute(7) ]] ;
};
struct Mtl_VertexOut
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float4 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float4 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float4 TEXCOORD3 [[ user(TEXCOORD3) ]];
    float4 COLOR0 [[ user(COLOR0) ]];
};
static Mtl_VertexOut vertexFunction(
    Mtl_VertexIn input)
{
    Mtl_VertexOut output;
    output.INTERNALTESSPOS0 = input.POSITION0;
    output.TANGENT0 = input.TANGENT0;
    output.NORMAL0.xyz = input.NORMAL0.xyz;
    output.TEXCOORD0 = input.TEXCOORD0;
    output.TEXCOORD1 = input.TEXCOORD1;
    output.TEXCOORD2 = input.TEXCOORD2;
    output.TEXCOORD3 = input.TEXCOORD3;
    output.COLOR0 = input.COLOR0;
    return output;
}
// SHADER_STAGE_HULL_begin
struct Mtl_ControlPoint
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float4 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float4 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float4 TEXCOORD3 [[ user(TEXCOORD3) ]];
    float4 COLOR0 [[ user(COLOR0) ]];
};
struct Mtl_ControlPointIn
{
    float4 INTERNALTESSPOS0 [[ attribute(8) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float4 TEXCOORD0 [[ attribute(3) ]] ;
    float4 TEXCOORD1 [[ attribute(4) ]] ;
    float4 TEXCOORD2 [[ attribute(5) ]] ;
    float4 TEXCOORD3 [[ attribute(6) ]] ;
    float4 COLOR0 [[ attribute(7) ]] ;
};
struct Mtl_KernelPatchInfo
{
    uint numPatches;
    ushort numControlPointsPerPatch;
};
struct VGlobals_Type
{
    float4 _Time;
    float4 _SinTime;
    float4 _CosTime;
    float4 unity_DeltaTime;
    float3 _WorldSpaceCameraPos;
    float4 _ProjectionParams;
    float4 _ScreenParams;
    float4 _ZBufferParams;
    float4 unity_OrthoParams;
    float4 unity_CameraWorldClipPlanes[6];
    float4 hlslcc_mtx4x4unity_CameraProjection[4];
    float4 hlslcc_mtx4x4unity_CameraInvProjection[4];
    float4 hlslcc_mtx4x4unity_WorldToCamera[4];
    float4 hlslcc_mtx4x4unity_CameraToWorld[4];
    float4 _WorldSpaceLightPos0;
    float4 _LightPositionRange;
    float4 _LightProjectionParams;
    float4 unity_4LightPosX0;
    float4 unity_4LightPosY0;
    float4 unity_4LightPosZ0;
    float4 unity_4LightAtten0;
    float4 unity_LightColor[8];
    float4 unity_LightPosition[8];
    float4 unity_LightAtten[8];
    float4 unity_SpotDirection[8];
    float4 unity_SHAr;
    float4 unity_SHAg;
    float4 unity_SHAb;
    float4 unity_SHBr;
    float4 unity_SHBg;
    float4 unity_SHBb;
    float4 unity_SHC;
    float4 unity_OcclusionMaskSelector;
    float4 unity_ProbesOcclusion;
    float3 unity_LightColor0;
    float3 unity_LightColor1;
    float3 unity_LightColor2;
    float3 unity_LightColor3;
    float4 unity_ShadowSplitSpheres[4];
    float4 unity_ShadowSplitSqRadii;
    float4 unity_LightShadowBias;
    float4 _LightSplitsNear;
    float4 _LightSplitsFar;
    float4 hlslcc_mtx4x4unity_WorldToShadow[16];
    float4 _LightShadowData;
    float4 unity_ShadowFadeCenterAndType;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 unity_LODFade;
    float4 unity_WorldTransformParams;
    float4 unity_RenderingLayer;
    float4 hlslcc_mtx4x4glstate_matrix_transpose_modelview0[4];
    float4 glstate_lightmodel_ambient;
    float4 unity_AmbientSky;
    float4 unity_AmbientEquator;
    float4 unity_AmbientGround;
    float4 unity_IndirectSpecColor;
    float4 hlslcc_mtx4x4glstate_matrix_projection[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixInvV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    int unity_StereoEyeIndex;
    float4 unity_ShadowColor;
    float4 unity_FogColor;
    float4 unity_FogParams;
    float4 unity_LightmapST;
    float4 unity_DynamicLightmapST;
    float4 unity_SpecCube0_BoxMax;
    float4 unity_SpecCube0_BoxMin;
    float4 unity_SpecCube0_ProbePosition;
    float4 unity_SpecCube0_HDR;
    float4 unity_SpecCube1_BoxMax;
    float4 unity_SpecCube1_BoxMin;
    float4 unity_SpecCube1_ProbePosition;
    float4 unity_SpecCube1_HDR;
    float4 unity_ProbeVolumeParams;
    float4 hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[4];
    float3 unity_ProbeVolumeSizeInv;
    float3 unity_ProbeVolumeMin;
    float4 unity_Lightmap_HDR;
    float4 unity_DynamicLightmap_HDR;
    float4 _LightColor0;
    float4 _SpecColor;
    float4 hlslcc_mtx4x4unity_WorldToLight[4];
    float _Tile;
    float _HeightDisplacement;
    float _NormalScale;
    float4 _ColorTint;
    float _MetallicStrength;
    float _SmoothnessStrength;
    float _EdgeLength;
    float4 _texcoord_ST;
};
struct Mtl_HullIn
{
    Mtl_VertexOut cp[3];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
kernel void patchKernel(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn vertexInput [[ stage_in ]],
    uint2 tID [[ thread_position_in_grid ]],
    ushort2 groupID [[ threadgroup_position_in_grid ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    constant Mtl_KernelPatchInfo &patchInfo [[ buffer(3) ]])
{
#pragma clang diagnostic pop
    Mtl_ControlPoint output;
    const uint numPatchesInThreadGroup = 10;
    const uint patchID = (tID.x / patchInfo.numControlPointsPerPatch);
    const bool patchValid = (patchID < patchInfo.numPatches);
    const uint mtl_BaseInstance = 0;
    const uint mtl_InstanceID = groupID.y - mtl_BaseInstance;
    const uint internalPatchID = mtl_InstanceID * patchInfo.numPatches + patchID;
    const uint patchIDInThreadGroup = (patchID % numPatchesInThreadGroup);
    const uint controlPointID = (tID.x % patchInfo.numControlPointsPerPatch);
    const uint mtl_BaseVertex = 0;
    const uint mtl_VertexID = ((mtl_InstanceID * (patchInfo.numControlPointsPerPatch * patchInfo.numPatches)) + tID.x) - mtl_BaseVertex;
    threadgroup Mtl_HullIn inputGroup[numPatchesInThreadGroup];
    threadgroup Mtl_HullIn &input = inputGroup[patchIDInThreadGroup];
    MTLTriangleTessellationFactorsHalf tessFactor;
    if (patchValid) {
        input.cp[controlPointID] = vertexFunction(vertexInput);
        output.INTERNALTESSPOS0 = input.cp[controlPointID].INTERNALTESSPOS0;
        output.TANGENT0 = input.cp[controlPointID].TANGENT0;
        output.NORMAL0 = input.cp[controlPointID].NORMAL0;
        output.TEXCOORD0 = input.cp[controlPointID].TEXCOORD0;
        output.TEXCOORD1 = input.cp[controlPointID].TEXCOORD1;
        output.TEXCOORD2 = input.cp[controlPointID].TEXCOORD2;
        output.TEXCOORD3 = input.cp[controlPointID].TEXCOORD3;
        output.COLOR0 = input.cp[controlPointID].COLOR0;
    }
    threadgroup_barrier(mem_flags::mem_threadgroup);
    if (!patchValid) {
        return;
    }
    float3 u_xlat0;
    float3 u_xlat1;
    float3 u_xlat2;
    float3 u_xlat3;
    float3 u_xlat4;
    float u_xlat12;
    float u_xlat13;
    // fork_phase2
    {
        u_xlat0.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[1].INTERNALTESSPOS0.yyy;
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[1].INTERNALTESSPOS0.xxx, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[1].INTERNALTESSPOS0.zzz, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[1].INTERNALTESSPOS0.www, u_xlat0.xyz);
        u_xlat1.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[2].INTERNALTESSPOS0.yyy;
        u_xlat1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[2].INTERNALTESSPOS0.xxx, u_xlat1.xyz);
        u_xlat1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[2].INTERNALTESSPOS0.zzz, u_xlat1.xyz);
        u_xlat1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[2].INTERNALTESSPOS0.www, u_xlat1.xyz);
        u_xlat2.xyz = u_xlat0.xyz + u_xlat1.xyz;
        u_xlat2.xyz = fma(u_xlat2.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat12 = dot(u_xlat2.xyz, u_xlat2.xyz);
        u_xlat12 = sqrt(u_xlat12);
        u_xlat12 = u_xlat12 * VGlobals._EdgeLength;
        u_xlat2.xyz = u_xlat0.xyz + (-u_xlat1.xyz);
        u_xlat13 = dot(u_xlat2.xyz, u_xlat2.xyz);
        u_xlat13 = sqrt(u_xlat13);
        u_xlat13 = u_xlat13 * VGlobals._ScreenParams.y;
        u_xlat12 = u_xlat13 / u_xlat12;
        tessFactor.edgeTessellationFactor[0] = max(u_xlat12, 1.0);
        u_xlat2.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[0].INTERNALTESSPOS0.yyy;
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[0].INTERNALTESSPOS0.xxx, u_xlat2.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[0].INTERNALTESSPOS0.zzz, u_xlat2.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[0].INTERNALTESSPOS0.www, u_xlat2.xyz);
        u_xlat3.xyz = u_xlat1.xyz + u_xlat2.xyz;
        u_xlat1.xyz = u_xlat1.xyz + (-u_xlat2.xyz);
        u_xlat12 = dot(u_xlat1.xyz, u_xlat1.xyz);
        u_xlat12 = sqrt(u_xlat12);
        u_xlat12 = u_xlat12 * VGlobals._ScreenParams.y;
        u_xlat1.xyz = fma(u_xlat3.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat1.x = dot(u_xlat1.xyz, u_xlat1.xyz);
        u_xlat1.x = sqrt(u_xlat1.x);
        u_xlat1.x = u_xlat1.x * VGlobals._EdgeLength;
        u_xlat12 = u_xlat12 / u_xlat1.x;
        tessFactor.edgeTessellationFactor[1] = max(u_xlat12, 1.0);
        u_xlat1.xyz = u_xlat0.xyz + u_xlat2.xyz;
        u_xlat0.xyz = (-u_xlat0.xyz) + u_xlat2.xyz;
        u_xlat0.x = dot(u_xlat0.xyz, u_xlat0.xyz);
        u_xlat0.x = sqrt(u_xlat0.x);
        u_xlat0.x = u_xlat0.x * VGlobals._ScreenParams.y;
        u_xlat4.xyz = fma(u_xlat1.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat4.x = dot(u_xlat4.xyz, u_xlat4.xyz);
        u_xlat4.x = sqrt(u_xlat4.x);
        u_xlat4.x = u_xlat4.x * VGlobals._EdgeLength;
        u_xlat0.x = u_xlat0.x / u_xlat4.x;
        tessFactor.edgeTessellationFactor[2] = max(u_xlat0.x, 1.0);
    }
    // join_phase3
    {
        u_xlat0.x = tessFactor.edgeTessellationFactor[0] + tessFactor.edgeTessellationFactor[1];
        u_xlat0.x = u_xlat0.x + tessFactor.edgeTessellationFactor[2];
        tessFactor.insideTessellationFactor = u_xlat0.x * 0.333333343;
    }
    controlPoints[mtl_VertexID] = output;
    tessFactors[internalPatchID] = tessFactor;
}
// SHADER_STAGE_HULL_end
// SHADER_STAGE_DOMAIN_begin
struct Mtl_VertexInPostTess
{
    patch_control_point<Mtl_ControlPointIn> cp;
};
struct Mtl_VertexOutPostTess
{
    float4 mtl_Position [[ position ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float3 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float3 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float3 TEXCOORD3 [[ user(TEXCOORD3) ]];
    float3 TEXCOORD4 [[ user(TEXCOORD4) ]];
    float3 TEXCOORD5 [[ user(TEXCOORD5) ]];
    float4 TEXCOORD6 [[ user(TEXCOORD6) ]];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    sampler sampler_Height [[ sampler (0) ]],
    texture2d<float, access::sample > _Height [[ texture(0) ]] ,
    float3 mtl_TessCoord [[ position_in_patch ]],
    uint patchID [[ patch_id ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    Mtl_VertexInPostTess input [[ stage_in ]])
{
#pragma clang diagnostic pop
    Mtl_VertexOutPostTess output;
    MTLTriangleTessellationFactorsHalf tessFactor;
    tessFactor = tessFactors[patchID];
    float4 u_xlat0;
    float3 u_xlat1;
    float4 u_xlat2;
    float4 u_xlat3;
    float4 u_xlat4;
    float2 u_xlat10;
    float u_xlat16;
    u_xlat0.xy = mtl_TessCoord.yy * input.cp[1].TEXCOORD0.xy;
    u_xlat0.xy = fma(input.cp[0].TEXCOORD0.xy, mtl_TessCoord.xx, u_xlat0.xy);
    u_xlat0.xy = fma(input.cp[2].TEXCOORD0.xy, mtl_TessCoord.zz, u_xlat0.xy);
    u_xlat10.xy = u_xlat0.xy * float2(VGlobals._Tile);
    output.TEXCOORD0.xy = fma(u_xlat0.xy, VGlobals._texcoord_ST.xy, VGlobals._texcoord_ST.zw);
    u_xlat0.xyz = _Height.sample(sampler_Height, u_xlat10.xy, level(1.0)).xyz;
    u_xlat1.xyz = mtl_TessCoord.yyy * input.cp[1].NORMAL0.xyz;
    u_xlat1.xyz = fma(input.cp[0].NORMAL0.xyz, mtl_TessCoord.xxx, u_xlat1.xyz);
    u_xlat1.xyz = fma(input.cp[2].NORMAL0.xyz, mtl_TessCoord.zzz, u_xlat1.xyz);
    u_xlat0.xyz = u_xlat0.xyz * u_xlat1.xyz;
    u_xlat2 = mtl_TessCoord.yyyy * input.cp[1].INTERNALTESSPOS0;
    u_xlat2 = fma(input.cp[0].INTERNALTESSPOS0, mtl_TessCoord.xxxx, u_xlat2);
    u_xlat2 = fma(input.cp[2].INTERNALTESSPOS0, mtl_TessCoord.zzzz, u_xlat2);
    u_xlat0.xyz = fma(u_xlat0.xyz, float3(VGlobals._HeightDisplacement), u_xlat2.xyz);
    u_xlat3 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], u_xlat0.xxxx, u_xlat3);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], u_xlat0.zzzz, u_xlat3);
    u_xlat3 = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat4 = u_xlat3.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat4 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat3.xxxx, u_xlat4);
    u_xlat4 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat3.zzzz, u_xlat4);
    output.mtl_Position = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat3.wwww, u_xlat4);
    u_xlat2.y = dot(u_xlat1.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat2.z = dot(u_xlat1.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat2.x = dot(u_xlat1.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat1.x = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat1.x = rsqrt(u_xlat1.x);
    u_xlat1.xyz = u_xlat1.xxx * u_xlat2.xyz;
    output.TEXCOORD1.z = u_xlat1.y;
    u_xlat3 = mtl_TessCoord.yyyy * input.cp[1].TANGENT0;
    u_xlat3 = fma(input.cp[0].TANGENT0, mtl_TessCoord.xxxx, u_xlat3);
    u_xlat3 = fma(input.cp[2].TANGENT0, mtl_TessCoord.zzzz, u_xlat3);
    u_xlat2.xyz = u_xlat3.yyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].yzx;
    u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].yzx, u_xlat3.xxx, u_xlat2.xyz);
    u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].yzx, u_xlat3.zzz, u_xlat2.xyz);
    u_xlat16 = u_xlat3.w * VGlobals.unity_WorldTransformParams.w;
    u_xlat3.x = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat3.x = rsqrt(u_xlat3.x);
    u_xlat2.xyz = u_xlat2.xyz * u_xlat3.xxx;
    u_xlat3.xyz = u_xlat1.xyz * u_xlat2.xyz;
    u_xlat3.xyz = fma(u_xlat1.zxy, u_xlat2.yzx, (-u_xlat3.xyz));
    u_xlat3.xyz = float3(u_xlat16) * u_xlat3.xyz;
    output.TEXCOORD1.y = u_xlat3.x;
    output.TEXCOORD1.x = u_xlat2.z;
    output.TEXCOORD2.x = u_xlat2.x;
    output.TEXCOORD3.x = u_xlat2.y;
    output.TEXCOORD2.z = u_xlat1.z;
    output.TEXCOORD3.z = u_xlat1.x;
    output.TEXCOORD2.y = u_xlat3.y;
    output.TEXCOORD3.y = u_xlat3.z;
    output.TEXCOORD4.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, u_xlat2.www, u_xlat0.xyz);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3], u_xlat2.wwww, u_xlat0);
    u_xlat1.xyz = u_xlat0.yyy * VGlobals.hlslcc_mtx4x4unity_WorldToLight[1].xyz;
    u_xlat1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_WorldToLight[0].xyz, u_xlat0.xxx, u_xlat1.xyz);
    u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_WorldToLight[2].xyz, u_xlat0.zzz, u_xlat1.xyz);
    output.TEXCOORD5.xyz = fma(VGlobals.hlslcc_mtx4x4unity_WorldToLight[3].xyz, u_xlat0.www, u_xlat0.xyz);
    output.TEXCOORD6 = float4(0.0, 0.0, 0.0, 0.0);
    return output;
}
// SHADER_STAGE_DOMAIN_end
Compilation succeeded with: 

program_source:293:53: warning: writable resources in non-void post-tessellation vertex function
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
                                                    ^
program_source:299:30: note: writable buffer defined here
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
                             ^
program_source:300:48: note: writable buffer defined here
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
                                               ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float4 TEXCOORD0 [[ attribute(3) ]] ;
    float4 TEXCOORD1 [[ attribute(4) ]] ;
    float4 TEXCOORD2 [[ attribute(5) ]] ;
    float4 TEXCOORD3 [[ attribute(6) ]] ;
    float4 COLOR0 [[ attribute(7) ]] ;
};
struct Mtl_VertexOut
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float4 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float4 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float4 TEXCOORD3 [[ user(TEXCOORD3) ]];
    float4 COLOR0 [[ user(COLOR0) ]];
};
static Mtl_VertexOut vertexFunction(
    Mtl_VertexIn input)
{
    Mtl_VertexOut output;
    output.INTERNALTESSPOS0 = input.POSITION0;
    output.TANGENT0 = input.TANGENT0;
    output.NORMAL0.xyz = input.NORMAL0.xyz;
    output.TEXCOORD0 = input.TEXCOORD0;
    output.TEXCOORD1 = input.TEXCOORD1;
    output.TEXCOORD2 = input.TEXCOORD2;
    output.TEXCOORD3 = input.TEXCOORD3;
    output.COLOR0 = input.COLOR0;
    return output;
}
// SHADER_STAGE_HULL_begin
struct Mtl_ControlPoint
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float4 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float4 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float4 TEXCOORD3 [[ user(TEXCOORD3) ]];
    float4 COLOR0 [[ user(COLOR0) ]];
};
struct Mtl_ControlPointIn
{
    float4 INTERNALTESSPOS0 [[ attribute(8) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float4 TEXCOORD0 [[ attribute(3) ]] ;
    float4 TEXCOORD1 [[ attribute(4) ]] ;
    float4 TEXCOORD2 [[ attribute(5) ]] ;
    float4 TEXCOORD3 [[ attribute(6) ]] ;
    float4 COLOR0 [[ attribute(7) ]] ;
};
struct Mtl_KernelPatchInfo
{
    uint numPatches;
    ushort numControlPointsPerPatch;
};
struct VGlobals_Type
{
    float4 _Time;
    float4 _SinTime;
    float4 _CosTime;
    float4 unity_DeltaTime;
    float3 _WorldSpaceCameraPos;
    float4 _ProjectionParams;
    float4 _ScreenParams;
    float4 _ZBufferParams;
    float4 unity_OrthoParams;
    float4 unity_CameraWorldClipPlanes[6];
    float4 hlslcc_mtx4x4unity_CameraProjection[4];
    float4 hlslcc_mtx4x4unity_CameraInvProjection[4];
    float4 hlslcc_mtx4x4unity_WorldToCamera[4];
    float4 hlslcc_mtx4x4unity_CameraToWorld[4];
    float4 _WorldSpaceLightPos0;
    float4 _LightPositionRange;
    float4 _LightProjectionParams;
    float4 unity_4LightPosX0;
    float4 unity_4LightPosY0;
    float4 unity_4LightPosZ0;
    float4 unity_4LightAtten0;
    float4 unity_LightColor[8];
    float4 unity_LightPosition[8];
    float4 unity_LightAtten[8];
    float4 unity_SpotDirection[8];
    float4 unity_SHAr;
    float4 unity_SHAg;
    float4 unity_SHAb;
    float4 unity_SHBr;
    float4 unity_SHBg;
    float4 unity_SHBb;
    float4 unity_SHC;
    float4 unity_OcclusionMaskSelector;
    float4 unity_ProbesOcclusion;
    float3 unity_LightColor0;
    float3 unity_LightColor1;
    float3 unity_LightColor2;
    float3 unity_LightColor3;
    float4 unity_ShadowSplitSpheres[4];
    float4 unity_ShadowSplitSqRadii;
    float4 unity_LightShadowBias;
    float4 _LightSplitsNear;
    float4 _LightSplitsFar;
    float4 hlslcc_mtx4x4unity_WorldToShadow[16];
    float4 _LightShadowData;
    float4 unity_ShadowFadeCenterAndType;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 unity_LODFade;
    float4 unity_WorldTransformParams;
    float4 unity_RenderingLayer;
    float4 hlslcc_mtx4x4glstate_matrix_transpose_modelview0[4];
    float4 glstate_lightmodel_ambient;
    float4 unity_AmbientSky;
    float4 unity_AmbientEquator;
    float4 unity_AmbientGround;
    float4 unity_IndirectSpecColor;
    float4 hlslcc_mtx4x4glstate_matrix_projection[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixInvV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    int unity_StereoEyeIndex;
    float4 unity_ShadowColor;
    float4 unity_FogColor;
    float4 unity_FogParams;
    float4 unity_LightmapST;
    float4 unity_DynamicLightmapST;
    float4 unity_SpecCube0_BoxMax;
    float4 unity_SpecCube0_BoxMin;
    float4 unity_SpecCube0_ProbePosition;
    float4 unity_SpecCube0_HDR;
    float4 unity_SpecCube1_BoxMax;
    float4 unity_SpecCube1_BoxMin;
    float4 unity_SpecCube1_ProbePosition;
    float4 unity_SpecCube1_HDR;
    float4 unity_ProbeVolumeParams;
    float4 hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[4];
    float3 unity_ProbeVolumeSizeInv;
    float3 unity_ProbeVolumeMin;
    float4 unity_Lightmap_HDR;
    float4 unity_DynamicLightmap_HDR;
    float4 _LightColor0;
    float4 _SpecColor;
    float _Tile;
    float _HeightDisplacement;
    float _NormalScale;
    float4 _ColorTint;
    float _MetallicStrength;
    float _SmoothnessStrength;
    float _EdgeLength;
};
struct Mtl_HullIn
{
    Mtl_VertexOut cp[3];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
kernel void patchKernel(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn vertexInput [[ stage_in ]],
    uint2 tID [[ thread_position_in_grid ]],
    ushort2 groupID [[ threadgroup_position_in_grid ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    constant Mtl_KernelPatchInfo &patchInfo [[ buffer(3) ]])
{
#pragma clang diagnostic pop
    Mtl_ControlPoint output;
    const uint numPatchesInThreadGroup = 10;
    const uint patchID = (tID.x / patchInfo.numControlPointsPerPatch);
    const bool patchValid = (patchID < patchInfo.numPatches);
    const uint mtl_BaseInstance = 0;
    const uint mtl_InstanceID = groupID.y - mtl_BaseInstance;
    const uint internalPatchID = mtl_InstanceID * patchInfo.numPatches + patchID;
    const uint patchIDInThreadGroup = (patchID % numPatchesInThreadGroup);
    const uint controlPointID = (tID.x % patchInfo.numControlPointsPerPatch);
    const uint mtl_BaseVertex = 0;
    const uint mtl_VertexID = ((mtl_InstanceID * (patchInfo.numControlPointsPerPatch * patchInfo.numPatches)) + tID.x) - mtl_BaseVertex;
    threadgroup Mtl_HullIn inputGroup[numPatchesInThreadGroup];
    threadgroup Mtl_HullIn &input = inputGroup[patchIDInThreadGroup];
    MTLTriangleTessellationFactorsHalf tessFactor;
    if (patchValid) {
        input.cp[controlPointID] = vertexFunction(vertexInput);
        output.INTERNALTESSPOS0 = input.cp[controlPointID].INTERNALTESSPOS0;
        output.TANGENT0 = input.cp[controlPointID].TANGENT0;
        output.NORMAL0 = input.cp[controlPointID].NORMAL0;
        output.TEXCOORD0 = input.cp[controlPointID].TEXCOORD0;
        output.TEXCOORD1 = input.cp[controlPointID].TEXCOORD1;
        output.TEXCOORD2 = input.cp[controlPointID].TEXCOORD2;
        output.TEXCOORD3 = input.cp[controlPointID].TEXCOORD3;
        output.COLOR0 = input.cp[controlPointID].COLOR0;
    }
    threadgroup_barrier(mem_flags::mem_threadgroup);
    if (!patchValid) {
        return;
    }
    float3 u_xlat0;
    float3 u_xlat1;
    float3 u_xlat2;
    float3 u_xlat3;
    float3 u_xlat4;
    float u_xlat12;
    float u_xlat13;
    // fork_phase2
    {
        u_xlat0.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[1].INTERNALTESSPOS0.yyy;
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[1].INTERNALTESSPOS0.xxx, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[1].INTERNALTESSPOS0.zzz, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[1].INTERNALTESSPOS0.www, u_xlat0.xyz);
        u_xlat1.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[2].INTERNALTESSPOS0.yyy;
        u_xlat1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[2].INTERNALTESSPOS0.xxx, u_xlat1.xyz);
        u_xlat1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[2].INTERNALTESSPOS0.zzz, u_xlat1.xyz);
        u_xlat1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[2].INTERNALTESSPOS0.www, u_xlat1.xyz);
        u_xlat2.xyz = u_xlat0.xyz + u_xlat1.xyz;
        u_xlat2.xyz = fma(u_xlat2.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat12 = dot(u_xlat2.xyz, u_xlat2.xyz);
        u_xlat12 = sqrt(u_xlat12);
        u_xlat12 = u_xlat12 * VGlobals._EdgeLength;
        u_xlat2.xyz = u_xlat0.xyz + (-u_xlat1.xyz);
        u_xlat13 = dot(u_xlat2.xyz, u_xlat2.xyz);
        u_xlat13 = sqrt(u_xlat13);
        u_xlat13 = u_xlat13 * VGlobals._ScreenParams.y;
        u_xlat12 = u_xlat13 / u_xlat12;
        tessFactor.edgeTessellationFactor[0] = max(u_xlat12, 1.0);
        u_xlat2.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[0].INTERNALTESSPOS0.yyy;
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[0].INTERNALTESSPOS0.xxx, u_xlat2.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[0].INTERNALTESSPOS0.zzz, u_xlat2.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[0].INTERNALTESSPOS0.www, u_xlat2.xyz);
        u_xlat3.xyz = u_xlat1.xyz + u_xlat2.xyz;
        u_xlat1.xyz = u_xlat1.xyz + (-u_xlat2.xyz);
        u_xlat12 = dot(u_xlat1.xyz, u_xlat1.xyz);
        u_xlat12 = sqrt(u_xlat12);
        u_xlat12 = u_xlat12 * VGlobals._ScreenParams.y;
        u_xlat1.xyz = fma(u_xlat3.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat1.x = dot(u_xlat1.xyz, u_xlat1.xyz);
        u_xlat1.x = sqrt(u_xlat1.x);
        u_xlat1.x = u_xlat1.x * VGlobals._EdgeLength;
        u_xlat12 = u_xlat12 / u_xlat1.x;
        tessFactor.edgeTessellationFactor[1] = max(u_xlat12, 1.0);
        u_xlat1.xyz = u_xlat0.xyz + u_xlat2.xyz;
        u_xlat0.xyz = (-u_xlat0.xyz) + u_xlat2.xyz;
        u_xlat0.x = dot(u_xlat0.xyz, u_xlat0.xyz);
        u_xlat0.x = sqrt(u_xlat0.x);
        u_xlat0.x = u_xlat0.x * VGlobals._ScreenParams.y;
        u_xlat4.xyz = fma(u_xlat1.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat4.x = dot(u_xlat4.xyz, u_xlat4.xyz);
        u_xlat4.x = sqrt(u_xlat4.x);
        u_xlat4.x = u_xlat4.x * VGlobals._EdgeLength;
        u_xlat0.x = u_xlat0.x / u_xlat4.x;
        tessFactor.edgeTessellationFactor[2] = max(u_xlat0.x, 1.0);
    }
    // join_phase3
    {
        u_xlat0.x = tessFactor.edgeTessellationFactor[0] + tessFactor.edgeTessellationFactor[1];
        u_xlat0.x = u_xlat0.x + tessFactor.edgeTessellationFactor[2];
        tessFactor.insideTessellationFactor = u_xlat0.x * 0.333333343;
    }
    controlPoints[mtl_VertexID] = output;
    tessFactors[internalPatchID] = tessFactor;
}
// SHADER_STAGE_HULL_end
// SHADER_STAGE_DOMAIN_begin
struct Mtl_VertexInPostTess
{
    patch_control_point<Mtl_ControlPointIn> cp;
};
struct Mtl_VertexOutPostTess
{
    float4 mtl_Position [[ position ]];
    float3 TEXCOORD1 [[ user(TEXCOORD1) ]];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    sampler sampler_Height [[ sampler (0) ]],
    texture2d<float, access::sample > _Height [[ texture(0) ]] ,
    float3 mtl_TessCoord [[ position_in_patch ]],
    uint patchID [[ patch_id ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    Mtl_VertexInPostTess input [[ stage_in ]])
{
#pragma clang diagnostic pop
    Mtl_VertexOutPostTess output;
    MTLTriangleTessellationFactorsHalf tessFactor;
    tessFactor = tessFactors[patchID];
    float4 u_xlat0;
    float4 u_xlat1;
    float4 u_xlat2;
    float4 u_xlat3;
    float4 u_xlat4;
    float u_xlat11;
    float u_xlat15;
    bool u_xlatb15;
    u_xlat0.xyz = mtl_TessCoord.yyy * input.cp[1].NORMAL0.xyz;
    u_xlat0.xyz = fma(input.cp[0].NORMAL0.xyz, mtl_TessCoord.xxx, u_xlat0.xyz);
    u_xlat0.xyz = fma(input.cp[2].NORMAL0.xyz, mtl_TessCoord.zzz, u_xlat0.xyz);
    u_xlat1.x = dot(u_xlat0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat1.y = dot(u_xlat0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat1.z = dot(u_xlat0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat15 = dot(u_xlat1.xyz, u_xlat1.xyz);
    u_xlat15 = rsqrt(u_xlat15);
    u_xlat1.xyz = float3(u_xlat15) * u_xlat1.xyz;
    u_xlat2.xy = mtl_TessCoord.yy * input.cp[1].TEXCOORD0.xy;
    u_xlat2.xy = fma(input.cp[0].TEXCOORD0.xy, mtl_TessCoord.xx, u_xlat2.xy);
    u_xlat2.xy = fma(input.cp[2].TEXCOORD0.xy, mtl_TessCoord.zz, u_xlat2.xy);
    u_xlat2.xy = u_xlat2.xy * float2(VGlobals._Tile);
    u_xlat2.xyz = _Height.sample(sampler_Height, u_xlat2.xy, level(1.0)).xyz;
    u_xlat0.xyz = u_xlat0.xyz * u_xlat2.xyz;
    u_xlat2 = mtl_TessCoord.yyyy * input.cp[1].INTERNALTESSPOS0;
    u_xlat2 = fma(input.cp[0].INTERNALTESSPOS0, mtl_TessCoord.xxxx, u_xlat2);
    u_xlat2 = fma(input.cp[2].INTERNALTESSPOS0, mtl_TessCoord.zzzz, u_xlat2);
    u_xlat0.xyz = fma(u_xlat0.xyz, float3(VGlobals._HeightDisplacement), u_xlat2.xyz);
    u_xlat3 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], u_xlat0.xxxx, u_xlat3);
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], u_xlat0.zzzz, u_xlat3);
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3], u_xlat2.wwww, u_xlat3);
    u_xlat2.xyz = fma((-u_xlat3.xyz), VGlobals._WorldSpaceLightPos0.www, VGlobals._WorldSpaceLightPos0.xyz);
    u_xlat15 = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat15 = rsqrt(u_xlat15);
    u_xlat2.xyz = float3(u_xlat15) * u_xlat2.xyz;
    u_xlat15 = dot(u_xlat1.xyz, u_xlat2.xyz);
    u_xlat15 = fma((-u_xlat15), u_xlat15, 1.0);
    u_xlat15 = sqrt(u_xlat15);
    u_xlat15 = u_xlat15 * VGlobals.unity_LightShadowBias.z;
    u_xlat1.xyz = fma((-u_xlat1.xyz), float3(u_xlat15), u_xlat3.xyz);
    u_xlatb15 = VGlobals.unity_LightShadowBias.z!=0.0;
    u_xlat1.xyz = (bool(u_xlatb15)) ? u_xlat1.xyz : u_xlat3.xyz;
    u_xlat4 = u_xlat1.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat4 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat1.xxxx, u_xlat4);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat1.zzzz, u_xlat4);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat3.wwww, u_xlat1);
    u_xlat15 = VGlobals.unity_LightShadowBias.x / u_xlat1.w;
    u_xlat15 = min(u_xlat15, 0.0);
    u_xlat15 = max(u_xlat15, -1.0);
    u_xlat15 = u_xlat15 + u_xlat1.z;
    u_xlat11 = min(u_xlat1.w, u_xlat15);
    output.mtl_Position.xyw = u_xlat1.xyw;
    u_xlat1.x = (-u_xlat15) + u_xlat11;
    output.mtl_Position.z = fma(VGlobals.unity_LightShadowBias.y, u_xlat1.x, u_xlat15);
    u_xlat1.xyz = u_xlat0.yyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz;
    u_xlat0.xyw = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, u_xlat0.xxx, u_xlat1.xyz);
    u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, u_xlat0.zzz, u_xlat0.xyw);
    output.TEXCOORD1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, u_xlat2.www, u_xlat0.xyz);
    return output;
}
// SHADER_STAGE_DOMAIN_end
Compilation succeeded with: 

program_source:299:53: warning: writable resources in non-void post-tessellation vertex function
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
                                                    ^
program_source:305:30: note: writable buffer defined here
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
                             ^
program_source:306:48: note: writable buffer defined here
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
                                               ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float4 TEXCOORD0 [[ attribute(3) ]] ;
    float4 TEXCOORD1 [[ attribute(4) ]] ;
    float4 TEXCOORD2 [[ attribute(5) ]] ;
    float4 TEXCOORD3 [[ attribute(6) ]] ;
    float4 COLOR0 [[ attribute(7) ]] ;
};
struct Mtl_VertexOut
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float4 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float4 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float4 TEXCOORD3 [[ user(TEXCOORD3) ]];
    float4 COLOR0 [[ user(COLOR0) ]];
};
static Mtl_VertexOut vertexFunction(
    Mtl_VertexIn input)
{
    Mtl_VertexOut output;
    output.INTERNALTESSPOS0 = input.POSITION0;
    output.TANGENT0 = input.TANGENT0;
    output.NORMAL0.xyz = input.NORMAL0.xyz;
    output.TEXCOORD0 = input.TEXCOORD0;
    output.TEXCOORD1 = input.TEXCOORD1;
    output.TEXCOORD2 = input.TEXCOORD2;
    output.TEXCOORD3 = input.TEXCOORD3;
    output.COLOR0 = input.COLOR0;
    return output;
}
// SHADER_STAGE_HULL_begin
struct Mtl_ControlPoint
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float4 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float4 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float4 TEXCOORD3 [[ user(TEXCOORD3) ]];
    float4 COLOR0 [[ user(COLOR0) ]];
};
struct Mtl_ControlPointIn
{
    float4 INTERNALTESSPOS0 [[ attribute(8) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float4 TEXCOORD0 [[ attribute(3) ]] ;
    float4 TEXCOORD1 [[ attribute(4) ]] ;
    float4 TEXCOORD2 [[ attribute(5) ]] ;
    float4 TEXCOORD3 [[ attribute(6) ]] ;
    float4 COLOR0 [[ attribute(7) ]] ;
};
struct Mtl_KernelPatchInfo
{
    uint numPatches;
    ushort numControlPointsPerPatch;
};
struct VGlobals_Type
{
    float4 _Time;
    float4 _SinTime;
    float4 _CosTime;
    float4 unity_DeltaTime;
    float3 _WorldSpaceCameraPos;
    float4 _ProjectionParams;
    float4 _ScreenParams;
    float4 _ZBufferParams;
    float4 unity_OrthoParams;
    float4 unity_CameraWorldClipPlanes[6];
    float4 hlslcc_mtx4x4unity_CameraProjection[4];
    float4 hlslcc_mtx4x4unity_CameraInvProjection[4];
    float4 hlslcc_mtx4x4unity_WorldToCamera[4];
    float4 hlslcc_mtx4x4unity_CameraToWorld[4];
    float4 _WorldSpaceLightPos0;
    float4 _LightPositionRange;
    float4 _LightProjectionParams;
    float4 unity_4LightPosX0;
    float4 unity_4LightPosY0;
    float4 unity_4LightPosZ0;
    float4 unity_4LightAtten0;
    float4 unity_LightColor[8];
    float4 unity_LightPosition[8];
    float4 unity_LightAtten[8];
    float4 unity_SpotDirection[8];
    float4 unity_SHAr;
    float4 unity_SHAg;
    float4 unity_SHAb;
    float4 unity_SHBr;
    float4 unity_SHBg;
    float4 unity_SHBb;
    float4 unity_SHC;
    float4 unity_OcclusionMaskSelector;
    float4 unity_ProbesOcclusion;
    float3 unity_LightColor0;
    float3 unity_LightColor1;
    float3 unity_LightColor2;
    float3 unity_LightColor3;
    float4 unity_ShadowSplitSpheres[4];
    float4 unity_ShadowSplitSqRadii;
    float4 unity_LightShadowBias;
    float4 _LightSplitsNear;
    float4 _LightSplitsFar;
    float4 hlslcc_mtx4x4unity_WorldToShadow[16];
    float4 _LightShadowData;
    float4 unity_ShadowFadeCenterAndType;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 unity_LODFade;
    float4 unity_WorldTransformParams;
    float4 unity_RenderingLayer;
    float4 hlslcc_mtx4x4glstate_matrix_transpose_modelview0[4];
    float4 glstate_lightmodel_ambient;
    float4 unity_AmbientSky;
    float4 unity_AmbientEquator;
    float4 unity_AmbientGround;
    float4 unity_IndirectSpecColor;
    float4 hlslcc_mtx4x4glstate_matrix_projection[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixInvV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    int unity_StereoEyeIndex;
    float4 unity_ShadowColor;
    float4 unity_FogColor;
    float4 unity_FogParams;
    float4 unity_LightmapST;
    float4 unity_DynamicLightmapST;
    float4 unity_SpecCube0_BoxMax;
    float4 unity_SpecCube0_BoxMin;
    float4 unity_SpecCube0_ProbePosition;
    float4 unity_SpecCube0_HDR;
    float4 unity_SpecCube1_BoxMax;
    float4 unity_SpecCube1_BoxMin;
    float4 unity_SpecCube1_ProbePosition;
    float4 unity_SpecCube1_HDR;
    float4 unity_ProbeVolumeParams;
    float4 hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[4];
    float3 unity_ProbeVolumeSizeInv;
    float3 unity_ProbeVolumeMin;
    float4 unity_Lightmap_HDR;
    float4 unity_DynamicLightmap_HDR;
    float4 _LightColor0;
    float4 _SpecColor;
    float _Tile;
    float _HeightDisplacement;
    float _NormalScale;
    float4 _ColorTint;
    float _MetallicStrength;
    float _SmoothnessStrength;
    float _EdgeLength;
    float4 _texcoord_ST;
    float4 unity_Ambient;
};
struct Mtl_HullIn
{
    Mtl_VertexOut cp[3];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
kernel void patchKernel(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn vertexInput [[ stage_in ]],
    uint2 tID [[ thread_position_in_grid ]],
    ushort2 groupID [[ threadgroup_position_in_grid ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    constant Mtl_KernelPatchInfo &patchInfo [[ buffer(3) ]])
{
#pragma clang diagnostic pop
    Mtl_ControlPoint output;
    const uint numPatchesInThreadGroup = 10;
    const uint patchID = (tID.x / patchInfo.numControlPointsPerPatch);
    const bool patchValid = (patchID < patchInfo.numPatches);
    const uint mtl_BaseInstance = 0;
    const uint mtl_InstanceID = groupID.y - mtl_BaseInstance;
    const uint internalPatchID = mtl_InstanceID * patchInfo.numPatches + patchID;
    const uint patchIDInThreadGroup = (patchID % numPatchesInThreadGroup);
    const uint controlPointID = (tID.x % patchInfo.numControlPointsPerPatch);
    const uint mtl_BaseVertex = 0;
    const uint mtl_VertexID = ((mtl_InstanceID * (patchInfo.numControlPointsPerPatch * patchInfo.numPatches)) + tID.x) - mtl_BaseVertex;
    threadgroup Mtl_HullIn inputGroup[numPatchesInThreadGroup];
    threadgroup Mtl_HullIn &input = inputGroup[patchIDInThreadGroup];
    MTLTriangleTessellationFactorsHalf tessFactor;
    if (patchValid) {
        input.cp[controlPointID] = vertexFunction(vertexInput);
        output.INTERNALTESSPOS0 = input.cp[controlPointID].INTERNALTESSPOS0;
        output.TANGENT0 = input.cp[controlPointID].TANGENT0;
        output.NORMAL0 = input.cp[controlPointID].NORMAL0;
        output.TEXCOORD0 = input.cp[controlPointID].TEXCOORD0;
        output.TEXCOORD1 = input.cp[controlPointID].TEXCOORD1;
        output.TEXCOORD2 = input.cp[controlPointID].TEXCOORD2;
        output.TEXCOORD3 = input.cp[controlPointID].TEXCOORD3;
        output.COLOR0 = input.cp[controlPointID].COLOR0;
    }
    threadgroup_barrier(mem_flags::mem_threadgroup);
    if (!patchValid) {
        return;
    }
    float3 u_xlat0;
    float3 u_xlat1;
    float3 u_xlat2;
    float3 u_xlat3;
    float3 u_xlat4;
    float u_xlat12;
    float u_xlat13;
    // fork_phase2
    {
        u_xlat0.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[1].INTERNALTESSPOS0.yyy;
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[1].INTERNALTESSPOS0.xxx, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[1].INTERNALTESSPOS0.zzz, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[1].INTERNALTESSPOS0.www, u_xlat0.xyz);
        u_xlat1.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[2].INTERNALTESSPOS0.yyy;
        u_xlat1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[2].INTERNALTESSPOS0.xxx, u_xlat1.xyz);
        u_xlat1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[2].INTERNALTESSPOS0.zzz, u_xlat1.xyz);
        u_xlat1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[2].INTERNALTESSPOS0.www, u_xlat1.xyz);
        u_xlat2.xyz = u_xlat0.xyz + u_xlat1.xyz;
        u_xlat2.xyz = fma(u_xlat2.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat12 = dot(u_xlat2.xyz, u_xlat2.xyz);
        u_xlat12 = sqrt(u_xlat12);
        u_xlat12 = u_xlat12 * VGlobals._EdgeLength;
        u_xlat2.xyz = u_xlat0.xyz + (-u_xlat1.xyz);
        u_xlat13 = dot(u_xlat2.xyz, u_xlat2.xyz);
        u_xlat13 = sqrt(u_xlat13);
        u_xlat13 = u_xlat13 * VGlobals._ScreenParams.y;
        u_xlat12 = u_xlat13 / u_xlat12;
        tessFactor.edgeTessellationFactor[0] = max(u_xlat12, 1.0);
        u_xlat2.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[0].INTERNALTESSPOS0.yyy;
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[0].INTERNALTESSPOS0.xxx, u_xlat2.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[0].INTERNALTESSPOS0.zzz, u_xlat2.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[0].INTERNALTESSPOS0.www, u_xlat2.xyz);
        u_xlat3.xyz = u_xlat1.xyz + u_xlat2.xyz;
        u_xlat1.xyz = u_xlat1.xyz + (-u_xlat2.xyz);
        u_xlat12 = dot(u_xlat1.xyz, u_xlat1.xyz);
        u_xlat12 = sqrt(u_xlat12);
        u_xlat12 = u_xlat12 * VGlobals._ScreenParams.y;
        u_xlat1.xyz = fma(u_xlat3.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat1.x = dot(u_xlat1.xyz, u_xlat1.xyz);
        u_xlat1.x = sqrt(u_xlat1.x);
        u_xlat1.x = u_xlat1.x * VGlobals._EdgeLength;
        u_xlat12 = u_xlat12 / u_xlat1.x;
        tessFactor.edgeTessellationFactor[1] = max(u_xlat12, 1.0);
        u_xlat1.xyz = u_xlat0.xyz + u_xlat2.xyz;
        u_xlat0.xyz = (-u_xlat0.xyz) + u_xlat2.xyz;
        u_xlat0.x = dot(u_xlat0.xyz, u_xlat0.xyz);
        u_xlat0.x = sqrt(u_xlat0.x);
        u_xlat0.x = u_xlat0.x * VGlobals._ScreenParams.y;
        u_xlat4.xyz = fma(u_xlat1.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat4.x = dot(u_xlat4.xyz, u_xlat4.xyz);
        u_xlat4.x = sqrt(u_xlat4.x);
        u_xlat4.x = u_xlat4.x * VGlobals._EdgeLength;
        u_xlat0.x = u_xlat0.x / u_xlat4.x;
        tessFactor.edgeTessellationFactor[2] = max(u_xlat0.x, 1.0);
    }
    // join_phase3
    {
        u_xlat0.x = tessFactor.edgeTessellationFactor[0] + tessFactor.edgeTessellationFactor[1];
        u_xlat0.x = u_xlat0.x + tessFactor.edgeTessellationFactor[2];
        tessFactor.insideTessellationFactor = u_xlat0.x * 0.333333343;
    }
    controlPoints[mtl_VertexID] = output;
    tessFactors[internalPatchID] = tessFactor;
}
// SHADER_STAGE_HULL_end
// SHADER_STAGE_DOMAIN_begin
struct Mtl_VertexInPostTess
{
    patch_control_point<Mtl_ControlPointIn> cp;
};
struct Mtl_VertexOutPostTess
{
    float4 mtl_Position [[ position ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float4 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float4 TEXCOORD3 [[ user(TEXCOORD3) ]];
    float4 TEXCOORD5 [[ user(TEXCOORD5) ]];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    sampler sampler_Height [[ sampler (0) ]],
    texture2d<float, access::sample > _Height [[ texture(0) ]] ,
    float3 mtl_TessCoord [[ position_in_patch ]],
    uint patchID [[ patch_id ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    Mtl_VertexInPostTess input [[ stage_in ]])
{
#pragma clang diagnostic pop
    Mtl_VertexOutPostTess output;
    MTLTriangleTessellationFactorsHalf tessFactor;
    tessFactor = tessFactors[patchID];
    float4 u_xlat0;
    float4 u_xlat1;
    float4 u_xlat2;
    float4 u_xlat3;
    float2 u_xlat9;
    float u_xlat12;
    float u_xlat13;
    u_xlat0 = mtl_TessCoord.yyyy * input.cp[1].INTERNALTESSPOS0;
    u_xlat0 = fma(input.cp[0].INTERNALTESSPOS0, mtl_TessCoord.xxxx, u_xlat0);
    u_xlat0 = fma(input.cp[2].INTERNALTESSPOS0, mtl_TessCoord.zzzz, u_xlat0);
    u_xlat1.xy = mtl_TessCoord.yy * input.cp[1].TEXCOORD0.xy;
    u_xlat1.xy = fma(input.cp[0].TEXCOORD0.xy, mtl_TessCoord.xx, u_xlat1.xy);
    u_xlat1.xy = fma(input.cp[2].TEXCOORD0.xy, mtl_TessCoord.zz, u_xlat1.xy);
    u_xlat9.xy = u_xlat1.xy * float2(VGlobals._Tile);
    output.TEXCOORD0.xy = fma(u_xlat1.xy, VGlobals._texcoord_ST.xy, VGlobals._texcoord_ST.zw);
    u_xlat1.xyz = _Height.sample(sampler_Height, u_xlat9.xy, level(1.0)).xyz;
    u_xlat2.xyz = mtl_TessCoord.yyy * input.cp[1].NORMAL0.xyz;
    u_xlat2.xyz = fma(input.cp[0].NORMAL0.xyz, mtl_TessCoord.xxx, u_xlat2.xyz);
    u_xlat2.xyz = fma(input.cp[2].NORMAL0.xyz, mtl_TessCoord.zzz, u_xlat2.xyz);
    u_xlat1.xyz = u_xlat1.xyz * u_xlat2.xyz;
    u_xlat0.xyz = fma(u_xlat1.xyz, float3(VGlobals._HeightDisplacement), u_xlat0.xyz);
    u_xlat1 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], u_xlat0.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], u_xlat0.zzzz, u_xlat1);
    u_xlat3 = u_xlat1 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, u_xlat0.www, u_xlat1.xyz);
    u_xlat1 = u_xlat3.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat3.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat3.zzzz, u_xlat1);
    output.mtl_Position = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat3.wwww, u_xlat1);
    u_xlat1.y = dot(u_xlat2.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat1.z = dot(u_xlat2.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat1.x = dot(u_xlat2.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat12 = dot(u_xlat1.xyz, u_xlat1.xyz);
    u_xlat12 = rsqrt(u_xlat12);
    u_xlat1.xyz = float3(u_xlat12) * u_xlat1.xyz;
    output.TEXCOORD1.z = u_xlat1.y;
    u_xlat2 = mtl_TessCoord.yyyy * input.cp[1].TANGENT0;
    u_xlat2 = fma(input.cp[0].TANGENT0, mtl_TessCoord.xxxx, u_xlat2);
    u_xlat2 = fma(input.cp[2].TANGENT0, mtl_TessCoord.zzzz, u_xlat2);
    u_xlat3.xyz = u_xlat2.yyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].yzx;
    u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].yzx, u_xlat2.xxx, u_xlat3.xyz);
    u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].yzx, u_xlat2.zzz, u_xlat3.xyz);
    u_xlat12 = u_xlat2.w * VGlobals.unity_WorldTransformParams.w;
    u_xlat13 = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat13 = rsqrt(u_xlat13);
    u_xlat2.xyz = float3(u_xlat13) * u_xlat2.xyz;
    u_xlat3.xyz = u_xlat1.xyz * u_xlat2.xyz;
    u_xlat3.xyz = fma(u_xlat1.zxy, u_xlat2.yzx, (-u_xlat3.xyz));
    u_xlat3.xyz = float3(u_xlat12) * u_xlat3.xyz;
    output.TEXCOORD1.y = u_xlat3.x;
    output.TEXCOORD1.w = u_xlat0.x;
    output.TEXCOORD1.x = u_xlat2.z;
    output.TEXCOORD2.w = u_xlat0.y;
    output.TEXCOORD3.w = u_xlat0.z;
    output.TEXCOORD2.x = u_xlat2.x;
    output.TEXCOORD3.x = u_xlat2.y;
    output.TEXCOORD2.z = u_xlat1.z;
    output.TEXCOORD3.z = u_xlat1.x;
    output.TEXCOORD2.y = u_xlat3.y;
    output.TEXCOORD3.y = u_xlat3.z;
    output.TEXCOORD5 = float4(0.0, 0.0, 0.0, 0.0);
    return output;
}
// SHADER_STAGE_DOMAIN_end
Compilation succeeded with: 

program_source:303:53: warning: writable resources in non-void post-tessellation vertex function
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
                                                    ^
program_source:309:30: note: writable buffer defined here
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
                             ^
program_source:310:48: note: writable buffer defined here
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
                                               ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float4 TEXCOORD0 [[ attribute(3) ]] ;
    float4 TEXCOORD1 [[ attribute(4) ]] ;
    float4 TEXCOORD2 [[ attribute(5) ]] ;
    float4 TEXCOORD3 [[ attribute(6) ]] ;
    float4 COLOR0 [[ attribute(7) ]] ;
};
struct Mtl_VertexOut
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float4 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float4 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float4 TEXCOORD3 [[ user(TEXCOORD3) ]];
    float4 COLOR0 [[ user(COLOR0) ]];
};
static Mtl_VertexOut vertexFunction(
    Mtl_VertexIn input)
{
    Mtl_VertexOut output;
    output.INTERNALTESSPOS0 = input.POSITION0;
    output.TANGENT0 = input.TANGENT0;
    output.NORMAL0.xyz = input.NORMAL0.xyz;
    output.TEXCOORD0 = input.TEXCOORD0;
    output.TEXCOORD1 = input.TEXCOORD1;
    output.TEXCOORD2 = input.TEXCOORD2;
    output.TEXCOORD3 = input.TEXCOORD3;
    output.COLOR0 = input.COLOR0;
    return output;
}
// SHADER_STAGE_HULL_begin
struct Mtl_ControlPoint
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float4 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float4 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float4 TEXCOORD3 [[ user(TEXCOORD3) ]];
    float4 COLOR0 [[ user(COLOR0) ]];
};
struct Mtl_ControlPointIn
{
    float4 INTERNALTESSPOS0 [[ attribute(8) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float4 TEXCOORD0 [[ attribute(3) ]] ;
    float4 TEXCOORD1 [[ attribute(4) ]] ;
    float4 TEXCOORD2 [[ attribute(5) ]] ;
    float4 TEXCOORD3 [[ attribute(6) ]] ;
    float4 COLOR0 [[ attribute(7) ]] ;
};
struct Mtl_KernelPatchInfo
{
    uint numPatches;
    ushort numControlPointsPerPatch;
};
struct VGlobals_Type
{
    float4 _Time;
    float4 _SinTime;
    float4 _CosTime;
    float4 unity_DeltaTime;
    float3 _WorldSpaceCameraPos;
    float4 _ProjectionParams;
    float4 _ScreenParams;
    float4 _ZBufferParams;
    float4 unity_OrthoParams;
    float4 unity_CameraWorldClipPlanes[6];
    float4 hlslcc_mtx4x4unity_CameraProjection[4];
    float4 hlslcc_mtx4x4unity_CameraInvProjection[4];
    float4 hlslcc_mtx4x4unity_WorldToCamera[4];
    float4 hlslcc_mtx4x4unity_CameraToWorld[4];
    float4 _WorldSpaceLightPos0;
    float4 _LightPositionRange;
    float4 _LightProjectionParams;
    float4 unity_4LightPosX0;
    float4 unity_4LightPosY0;
    float4 unity_4LightPosZ0;
    float4 unity_4LightAtten0;
    float4 unity_LightColor[8];
    float4 unity_LightPosition[8];
    float4 unity_LightAtten[8];
    float4 unity_SpotDirection[8];
    float4 unity_SHAr;
    float4 unity_SHAg;
    float4 unity_SHAb;
    float4 unity_SHBr;
    float4 unity_SHBg;
    float4 unity_SHBb;
    float4 unity_SHC;
    float4 unity_OcclusionMaskSelector;
    float4 unity_ProbesOcclusion;
    float3 unity_LightColor0;
    float3 unity_LightColor1;
    float3 unity_LightColor2;
    float3 unity_LightColor3;
    float4 unity_ShadowSplitSpheres[4];
    float4 unity_ShadowSplitSqRadii;
    float4 unity_LightShadowBias;
    float4 _LightSplitsNear;
    float4 _LightSplitsFar;
    float4 hlslcc_mtx4x4unity_WorldToShadow[16];
    float4 _LightShadowData;
    float4 unity_ShadowFadeCenterAndType;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 unity_LODFade;
    float4 unity_WorldTransformParams;
    float4 unity_RenderingLayer;
    float4 hlslcc_mtx4x4glstate_matrix_transpose_modelview0[4];
    float4 glstate_lightmodel_ambient;
    float4 unity_AmbientSky;
    float4 unity_AmbientEquator;
    float4 unity_AmbientGround;
    float4 unity_IndirectSpecColor;
    float4 hlslcc_mtx4x4glstate_matrix_projection[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixInvV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    int unity_StereoEyeIndex;
    float4 unity_ShadowColor;
    float4 unity_FogColor;
    float4 unity_FogParams;
    float4 unity_LightmapST;
    float4 unity_DynamicLightmapST;
    float4 unity_SpecCube0_BoxMax;
    float4 unity_SpecCube0_BoxMin;
    float4 unity_SpecCube0_ProbePosition;
    float4 unity_SpecCube0_HDR;
    float4 unity_SpecCube1_BoxMax;
    float4 unity_SpecCube1_BoxMin;
    float4 unity_SpecCube1_ProbePosition;
    float4 unity_SpecCube1_HDR;
    float4 unity_ProbeVolumeParams;
    float4 hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[4];
    float3 unity_ProbeVolumeSizeInv;
    float3 unity_ProbeVolumeMin;
    float4 unity_Lightmap_HDR;
    float4 unity_DynamicLightmap_HDR;
    float4 _LightColor0;
    float4 _SpecColor;
    float _Tile;
    float _HeightDisplacement;
    float _NormalScale;
    float4 _ColorTint;
    float _MetallicStrength;
    float _SmoothnessStrength;
    float _EdgeLength;
    bool4 unity_MetaVertexControl;
    bool4 unity_MetaFragmentControl;
    int unity_VisualizationMode;
    float unity_OneOverOutputBoost;
    float unity_MaxOutputValue;
    float unity_UseLinearSpace;
    float4 _texcoord_ST;
};
struct Mtl_HullIn
{
    Mtl_VertexOut cp[3];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
kernel void patchKernel(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn vertexInput [[ stage_in ]],
    uint2 tID [[ thread_position_in_grid ]],
    ushort2 groupID [[ threadgroup_position_in_grid ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    constant Mtl_KernelPatchInfo &patchInfo [[ buffer(3) ]])
{
#pragma clang diagnostic pop
    Mtl_ControlPoint output;
    const uint numPatchesInThreadGroup = 10;
    const uint patchID = (tID.x / patchInfo.numControlPointsPerPatch);
    const bool patchValid = (patchID < patchInfo.numPatches);
    const uint mtl_BaseInstance = 0;
    const uint mtl_InstanceID = groupID.y - mtl_BaseInstance;
    const uint internalPatchID = mtl_InstanceID * patchInfo.numPatches + patchID;
    const uint patchIDInThreadGroup = (patchID % numPatchesInThreadGroup);
    const uint controlPointID = (tID.x % patchInfo.numControlPointsPerPatch);
    const uint mtl_BaseVertex = 0;
    const uint mtl_VertexID = ((mtl_InstanceID * (patchInfo.numControlPointsPerPatch * patchInfo.numPatches)) + tID.x) - mtl_BaseVertex;
    threadgroup Mtl_HullIn inputGroup[numPatchesInThreadGroup];
    threadgroup Mtl_HullIn &input = inputGroup[patchIDInThreadGroup];
    MTLTriangleTessellationFactorsHalf tessFactor;
    if (patchValid) {
        input.cp[controlPointID] = vertexFunction(vertexInput);
        output.INTERNALTESSPOS0 = input.cp[controlPointID].INTERNALTESSPOS0;
        output.TANGENT0 = input.cp[controlPointID].TANGENT0;
        output.NORMAL0 = input.cp[controlPointID].NORMAL0;
        output.TEXCOORD0 = input.cp[controlPointID].TEXCOORD0;
        output.TEXCOORD1 = input.cp[controlPointID].TEXCOORD1;
        output.TEXCOORD2 = input.cp[controlPointID].TEXCOORD2;
        output.TEXCOORD3 = input.cp[controlPointID].TEXCOORD3;
        output.COLOR0 = input.cp[controlPointID].COLOR0;
    }
    threadgroup_barrier(mem_flags::mem_threadgroup);
    if (!patchValid) {
        return;
    }
    float3 u_xlat0;
    float3 u_xlat1;
    float3 u_xlat2;
    float3 u_xlat3;
    float3 u_xlat4;
    float u_xlat12;
    float u_xlat13;
    // fork_phase2
    {
        u_xlat0.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[1].INTERNALTESSPOS0.yyy;
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[1].INTERNALTESSPOS0.xxx, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[1].INTERNALTESSPOS0.zzz, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[1].INTERNALTESSPOS0.www, u_xlat0.xyz);
        u_xlat1.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[2].INTERNALTESSPOS0.yyy;
        u_xlat1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[2].INTERNALTESSPOS0.xxx, u_xlat1.xyz);
        u_xlat1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[2].INTERNALTESSPOS0.zzz, u_xlat1.xyz);
        u_xlat1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[2].INTERNALTESSPOS0.www, u_xlat1.xyz);
        u_xlat2.xyz = u_xlat0.xyz + u_xlat1.xyz;
        u_xlat2.xyz = fma(u_xlat2.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat12 = dot(u_xlat2.xyz, u_xlat2.xyz);
        u_xlat12 = sqrt(u_xlat12);
        u_xlat12 = u_xlat12 * VGlobals._EdgeLength;
        u_xlat2.xyz = u_xlat0.xyz + (-u_xlat1.xyz);
        u_xlat13 = dot(u_xlat2.xyz, u_xlat2.xyz);
        u_xlat13 = sqrt(u_xlat13);
        u_xlat13 = u_xlat13 * VGlobals._ScreenParams.y;
        u_xlat12 = u_xlat13 / u_xlat12;
        tessFactor.edgeTessellationFactor[0] = max(u_xlat12, 1.0);
        u_xlat2.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[0].INTERNALTESSPOS0.yyy;
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[0].INTERNALTESSPOS0.xxx, u_xlat2.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[0].INTERNALTESSPOS0.zzz, u_xlat2.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[0].INTERNALTESSPOS0.www, u_xlat2.xyz);
        u_xlat3.xyz = u_xlat1.xyz + u_xlat2.xyz;
        u_xlat1.xyz = u_xlat1.xyz + (-u_xlat2.xyz);
        u_xlat12 = dot(u_xlat1.xyz, u_xlat1.xyz);
        u_xlat12 = sqrt(u_xlat12);
        u_xlat12 = u_xlat12 * VGlobals._ScreenParams.y;
        u_xlat1.xyz = fma(u_xlat3.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat1.x = dot(u_xlat1.xyz, u_xlat1.xyz);
        u_xlat1.x = sqrt(u_xlat1.x);
        u_xlat1.x = u_xlat1.x * VGlobals._EdgeLength;
        u_xlat12 = u_xlat12 / u_xlat1.x;
        tessFactor.edgeTessellationFactor[1] = max(u_xlat12, 1.0);
        u_xlat1.xyz = u_xlat0.xyz + u_xlat2.xyz;
        u_xlat0.xyz = (-u_xlat0.xyz) + u_xlat2.xyz;
        u_xlat0.x = dot(u_xlat0.xyz, u_xlat0.xyz);
        u_xlat0.x = sqrt(u_xlat0.x);
        u_xlat0.x = u_xlat0.x * VGlobals._ScreenParams.y;
        u_xlat4.xyz = fma(u_xlat1.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat4.x = dot(u_xlat4.xyz, u_xlat4.xyz);
        u_xlat4.x = sqrt(u_xlat4.x);
        u_xlat4.x = u_xlat4.x * VGlobals._EdgeLength;
        u_xlat0.x = u_xlat0.x / u_xlat4.x;
        tessFactor.edgeTessellationFactor[2] = max(u_xlat0.x, 1.0);
    }
    // join_phase3
    {
        u_xlat0.x = tessFactor.edgeTessellationFactor[0] + tessFactor.edgeTessellationFactor[1];
        u_xlat0.x = u_xlat0.x + tessFactor.edgeTessellationFactor[2];
        tessFactor.insideTessellationFactor = u_xlat0.x * 0.333333343;
    }
    controlPoints[mtl_VertexID] = output;
    tessFactors[internalPatchID] = tessFactor;
}
// SHADER_STAGE_HULL_end
// SHADER_STAGE_DOMAIN_begin
struct Mtl_VertexInPostTess
{
    patch_control_point<Mtl_ControlPointIn> cp;
};
struct Mtl_VertexOutPostTess
{
    float4 mtl_Position [[ position ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float4 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float4 TEXCOORD3 [[ user(TEXCOORD3) ]];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    sampler sampler_Height [[ sampler (0) ]],
    texture2d<float, access::sample > _Height [[ texture(0) ]] ,
    float3 mtl_TessCoord [[ position_in_patch ]],
    uint patchID [[ patch_id ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    Mtl_VertexInPostTess input [[ stage_in ]])
{
#pragma clang diagnostic pop
    Mtl_VertexOutPostTess output;
    MTLTriangleTessellationFactorsHalf tessFactor;
    tessFactor = tessFactors[patchID];
    float4 u_xlat0;
    float4 u_xlat1;
    float4 u_xlat2;
    float3 u_xlat3;
    float3 u_xlat4;
    float2 u_xlat13;
    float u_xlat15;
    bool u_xlatb15;
    u_xlat0.xy = mtl_TessCoord.yy * input.cp[1].TEXCOORD2.xy;
    u_xlat0.xy = fma(input.cp[0].TEXCOORD2.xy, mtl_TessCoord.xx, u_xlat0.xy);
    u_xlat0.xy = fma(input.cp[2].TEXCOORD2.xy, mtl_TessCoord.zz, u_xlat0.xy);
    u_xlat0.xy = fma(u_xlat0.xy, VGlobals.unity_DynamicLightmapST.xy, VGlobals.unity_DynamicLightmapST.zw);
    u_xlat1.xy = mtl_TessCoord.yy * input.cp[1].TEXCOORD1.xy;
    u_xlat1.xy = fma(input.cp[0].TEXCOORD1.xy, mtl_TessCoord.xx, u_xlat1.xy);
    u_xlat1.xy = fma(input.cp[2].TEXCOORD1.xy, mtl_TessCoord.zz, u_xlat1.xy);
    u_xlat1.xy = fma(u_xlat1.xy, VGlobals.unity_LightmapST.xy, VGlobals.unity_LightmapST.zw);
    u_xlat2 = mtl_TessCoord.yyyy * input.cp[1].INTERNALTESSPOS0;
    u_xlat2 = fma(input.cp[0].INTERNALTESSPOS0, mtl_TessCoord.xxxx, u_xlat2);
    u_xlat2 = fma(input.cp[2].INTERNALTESSPOS0, mtl_TessCoord.zzzz, u_xlat2);
    u_xlat3.xy = mtl_TessCoord.yy * input.cp[1].TEXCOORD0.xy;
    u_xlat3.xy = fma(input.cp[0].TEXCOORD0.xy, mtl_TessCoord.xx, u_xlat3.xy);
    u_xlat3.xy = fma(input.cp[2].TEXCOORD0.xy, mtl_TessCoord.zz, u_xlat3.xy);
    u_xlat13.xy = u_xlat3.xy * float2(VGlobals._Tile);
    output.TEXCOORD0.xy = fma(u_xlat3.xy, VGlobals._texcoord_ST.xy, VGlobals._texcoord_ST.zw);
    u_xlat3.xyz = _Height.sample(sampler_Height, u_xlat13.xy, level(1.0)).xyz;
    u_xlat4.xyz = mtl_TessCoord.yyy * input.cp[1].NORMAL0.xyz;
    u_xlat4.xyz = fma(input.cp[0].NORMAL0.xyz, mtl_TessCoord.xxx, u_xlat4.xyz);
    u_xlat4.xyz = fma(input.cp[2].NORMAL0.xyz, mtl_TessCoord.zzz, u_xlat4.xyz);
    u_xlat3.xyz = u_xlat3.xyz * u_xlat4.xyz;
    u_xlat2.xyz = fma(u_xlat3.xyz, float3(VGlobals._HeightDisplacement), u_xlat2.xyz);
    u_xlatb15 = 0.0<u_xlat2.z;
    u_xlat1.z = u_xlatb15 ? 9.99999975e-05 : float(0.0);
    u_xlat1.xyz = (VGlobals.unity_MetaVertexControl.x) ? u_xlat1.xyz : u_xlat2.xyz;
    u_xlatb15 = 0.0<u_xlat1.z;
    u_xlat0.z = u_xlatb15 ? 9.99999975e-05 : float(0.0);
    u_xlat0.xyz = (VGlobals.unity_MetaVertexControl.y) ? u_xlat0.xyz : u_xlat1.xyz;
    u_xlat1 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat0.xxxx, u_xlat1);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat0.zzzz, u_xlat1);
    output.mtl_Position = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_MatrixVP[3];
    u_xlat0.xyz = u_xlat2.yyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz;
    u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, u_xlat2.xxx, u_xlat0.xyz);
    u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, u_xlat2.zzz, u_xlat0.xyz);
    u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, u_xlat2.www, u_xlat0.xyz);
    output.TEXCOORD1.w = u_xlat0.x;
    u_xlat1.y = dot(u_xlat4.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat1.z = dot(u_xlat4.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat1.x = dot(u_xlat4.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat0.x = dot(u_xlat1.xyz, u_xlat1.xyz);
    u_xlat0.x = rsqrt(u_xlat0.x);
    u_xlat1.xyz = u_xlat0.xxx * u_xlat1.xyz;
    output.TEXCOORD1.z = u_xlat1.y;
    u_xlat2 = mtl_TessCoord.yyyy * input.cp[1].TANGENT0;
    u_xlat2 = fma(input.cp[0].TANGENT0, mtl_TessCoord.xxxx, u_xlat2);
    u_xlat2 = fma(input.cp[2].TANGENT0, mtl_TessCoord.zzzz, u_xlat2);
    u_xlat3.xyz = u_xlat2.yyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].yzx;
    u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].yzx, u_xlat2.xxx, u_xlat3.xyz);
    u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].yzx, u_xlat2.zzz, u_xlat3.xyz);
    u_xlat0.x = u_xlat2.w * VGlobals.unity_WorldTransformParams.w;
    u_xlat15 = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat15 = rsqrt(u_xlat15);
    u_xlat2.xyz = float3(u_xlat15) * u_xlat2.xyz;
    u_xlat3.xyz = u_xlat1.xyz * u_xlat2.xyz;
    u_xlat3.xyz = fma(u_xlat1.zxy, u_xlat2.yzx, (-u_xlat3.xyz));
    u_xlat3.xyz = u_xlat0.xxx * u_xlat3.xyz;
    output.TEXCOORD1.y = u_xlat3.x;
    output.TEXCOORD1.x = u_xlat2.z;
    output.TEXCOORD2.w = u_xlat0.y;
    output.TEXCOORD3.w = u_xlat0.z;
    output.TEXCOORD2.x = u_xlat2.x;
    output.TEXCOORD3.x = u_xlat2.y;
    output.TEXCOORD2.z = u_xlat1.z;
    output.TEXCOORD3.z = u_xlat1.x;
    output.TEXCOORD2.y = u_xlat3.y;
    output.TEXCOORD3.y = u_xlat3.z;
    return output;
}
// SHADER_STAGE_DOMAIN_end
Refreshing native plugins compatible for Editor in 1.88 ms, found 2 plugins.
Preloading 0 native plugins for Editor in 0.00 ms.
Unloading 3375 Unused Serialized files (Serialized files now loaded: 0)
Unloading 20 unused Assets / (0.6 MB). Loaded Objects now: 3910.
Memory consumption went from 136.5 MB to 135.9 MB.
Total: 4.919644 ms (FindLiveObjects: 0.366801 ms CreateObjectMapping: 0.310240 ms MarkObjects: 3.758186 ms  DeleteObjects: 0.482606 ms)

AssetImportParameters requested are different than current active one (requested -> active):
  custom:video-decoder-ogg-theora: a1e56fd34408186e4bbccfd4996cb3dc -> 
  custom:container-muxer-webm: aa71ff27fc2769a1b78a27578f13a17b -> 
  custom:container-demuxer-webm: 4f35f7cbe854078d1ac9338744f61a02 -> 
  custom:video-encoder-webm-vp8: eb34c28f22e8b96e1ab97ce403110664 -> 
  custom:framework-osx-AVFoundation: b23960f63f64bdc6ff669e2cdcee2391 -> 
  custom:audio-encoder-webm-vorbis: bf7c407c2cedff20999df2af8eb42d56 -> 
  custom:container-demuxer-ogg: 62fdf1f143b41e24485cea50d1cbac27 -> 
  custom:video-decoder-webm-vp8: 9c59270c3fd7afecdb556c50c9e8de78 -> 
  custom:audio-decoder-ogg-vorbis: bf7c407c2cedff20999df2af8eb42d56 -> 
========================================================================
Received Prepare
Registering precompiled user dll's ...
Registered in 0.003655 seconds.
Begin MonoManager ReloadAssembly
Symbol file LoadedFromMemory doesn't match image /Users/kamilaamendolagine/Desktop/Staugen Raug v2 - Prefab - Map 1.01/Library/PackageCache/com.unity.visualscripting@1.7.8/Editor/VisualScripting.Core/Dependencies/YamlDotNet/Unity.VisualScripting.YamlDotNet.dll
Symbol file LoadedFromMemory doesn't match image /Users/kamilaamendolagine/Desktop/Staugen Raug v2 - Prefab - Map 1.01/Library/PackageCache/com.unity.visualscripting@1.7.8/Editor/VisualScripting.Core/Dependencies/DotNetZip/Unity.VisualScripting.IonicZip.dll
Native extension for OSXStandalone target not found
Native extension for WebGL target not found
Refreshing native plugins compatible for Editor in 1.00 ms, found 2 plugins.
Preloading 0 native plugins for Editor in 0.00 ms.
Mono: successfully reloaded assembly
- Completed reload, in  1.880 seconds
Domain Reload Profiling:
	ReloadAssembly (1881ms)
		BeginReloadAssembly (205ms)
			ExecutionOrderSort (0ms)
			DisableScriptedObjects (9ms)
			BackupInstance (0ms)
			ReleaseScriptingObjects (0ms)
			CreateAndSetChildDomain (89ms)
		EndReloadAssembly (1505ms)
			LoadAssemblies (91ms)
			RebuildTransferFunctionScriptingTraits (0ms)
			SetupTypeCache (506ms)
			ReleaseScriptCaches (2ms)
			RebuildScriptCaches (85ms)
			SetupLoadedEditorAssemblies (709ms)
				LogAssemblyErrors (0ms)
				InitializePlatformSupportModulesInManaged (20ms)
				SetLoadedEditorAssemblies (1ms)
				RefreshPlugins (1ms)
				BeforeProcessingInitializeOnLoad (104ms)
				ProcessInitializeOnLoadAttributes (526ms)
				ProcessInitializeOnLoadMethodAttributes (53ms)
				AfterProcessingInitializeOnLoad (4ms)
				EditorAssembliesLoaded (0ms)
			ExecutionOrderSort2 (0ms)
			AwakeInstancesAfterBackupRestoration (9ms)
Platform modules already initialized, skipping
Compilation succeeded with: 

program_source:299:53: warning: writable resources in non-void post-tessellation vertex function
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
                                                    ^
program_source:305:30: note: writable buffer defined here
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
                             ^
program_source:306:48: note: writable buffer defined here
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
                                               ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float4 TEXCOORD0 [[ attribute(3) ]] ;
    float4 TEXCOORD1 [[ attribute(4) ]] ;
    float4 TEXCOORD2 [[ attribute(5) ]] ;
    float4 TEXCOORD3 [[ attribute(6) ]] ;
    float4 COLOR0 [[ attribute(7) ]] ;
};
struct Mtl_VertexOut
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float4 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float4 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float4 TEXCOORD3 [[ user(TEXCOORD3) ]];
    float4 COLOR0 [[ user(COLOR0) ]];
};
static Mtl_VertexOut vertexFunction(
    Mtl_VertexIn input)
{
    Mtl_VertexOut output;
    output.INTERNALTESSPOS0 = input.POSITION0;
    output.TANGENT0 = input.TANGENT0;
    output.NORMAL0.xyz = input.NORMAL0.xyz;
    output.TEXCOORD0 = input.TEXCOORD0;
    output.TEXCOORD1 = input.TEXCOORD1;
    output.TEXCOORD2 = input.TEXCOORD2;
    output.TEXCOORD3 = input.TEXCOORD3;
    output.COLOR0 = input.COLOR0;
    return output;
}
// SHADER_STAGE_HULL_begin
struct Mtl_ControlPoint
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float4 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float4 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float4 TEXCOORD3 [[ user(TEXCOORD3) ]];
    float4 COLOR0 [[ user(COLOR0) ]];
};
struct Mtl_ControlPointIn
{
    float4 INTERNALTESSPOS0 [[ attribute(8) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float4 TEXCOORD0 [[ attribute(3) ]] ;
    float4 TEXCOORD1 [[ attribute(4) ]] ;
    float4 TEXCOORD2 [[ attribute(5) ]] ;
    float4 TEXCOORD3 [[ attribute(6) ]] ;
    float4 COLOR0 [[ attribute(7) ]] ;
};
struct Mtl_KernelPatchInfo
{
    uint numPatches;
    ushort numControlPointsPerPatch;
};
struct VGlobals_Type
{
    float4 _Time;
    float4 _SinTime;
    float4 _CosTime;
    float4 unity_DeltaTime;
    float3 _WorldSpaceCameraPos;
    float4 _ProjectionParams;
    float4 _ScreenParams;
    float4 _ZBufferParams;
    float4 unity_OrthoParams;
    float4 unity_CameraWorldClipPlanes[6];
    float4 hlslcc_mtx4x4unity_CameraProjection[4];
    float4 hlslcc_mtx4x4unity_CameraInvProjection[4];
    float4 hlslcc_mtx4x4unity_WorldToCamera[4];
    float4 hlslcc_mtx4x4unity_CameraToWorld[4];
    float4 _WorldSpaceLightPos0;
    float4 _LightPositionRange;
    float4 _LightProjectionParams;
    float4 unity_4LightPosX0;
    float4 unity_4LightPosY0;
    float4 unity_4LightPosZ0;
    float4 unity_4LightAtten0;
    float4 unity_LightColor[8];
    float4 unity_LightPosition[8];
    float4 unity_LightAtten[8];
    float4 unity_SpotDirection[8];
    float4 unity_SHAr;
    float4 unity_SHAg;
    float4 unity_SHAb;
    float4 unity_SHBr;
    float4 unity_SHBg;
    float4 unity_SHBb;
    float4 unity_SHC;
    float4 unity_OcclusionMaskSelector;
    float4 unity_ProbesOcclusion;
    float3 unity_LightColor0;
    float3 unity_LightColor1;
    float3 unity_LightColor2;
    float3 unity_LightColor3;
    float4 unity_ShadowSplitSpheres[4];
    float4 unity_ShadowSplitSqRadii;
    float4 unity_LightShadowBias;
    float4 _LightSplitsNear;
    float4 _LightSplitsFar;
    float4 hlslcc_mtx4x4unity_WorldToShadow[16];
    float4 _LightShadowData;
    float4 unity_ShadowFadeCenterAndType;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 unity_LODFade;
    float4 unity_WorldTransformParams;
    float4 unity_RenderingLayer;
    float4 hlslcc_mtx4x4glstate_matrix_transpose_modelview0[4];
    float4 glstate_lightmodel_ambient;
    float4 unity_AmbientSky;
    float4 unity_AmbientEquator;
    float4 unity_AmbientGround;
    float4 unity_IndirectSpecColor;
    float4 hlslcc_mtx4x4glstate_matrix_projection[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixInvV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    int unity_StereoEyeIndex;
    float4 unity_ShadowColor;
    float4 unity_FogColor;
    float4 unity_FogParams;
    float4 unity_LightmapST;
    float4 unity_DynamicLightmapST;
    float4 unity_SpecCube0_BoxMax;
    float4 unity_SpecCube0_BoxMin;
    float4 unity_SpecCube0_ProbePosition;
    float4 unity_SpecCube0_HDR;
    float4 unity_SpecCube1_BoxMax;
    float4 unity_SpecCube1_BoxMin;
    float4 unity_SpecCube1_ProbePosition;
    float4 unity_SpecCube1_HDR;
    float4 unity_ProbeVolumeParams;
    float4 hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[4];
    float3 unity_ProbeVolumeSizeInv;
    float3 unity_ProbeVolumeMin;
    float4 unity_Lightmap_HDR;
    float4 unity_DynamicLightmap_HDR;
    float4 _LightColor0;
    float4 _SpecColor;
    float _Tile;
    float _HeightDisplacement;
    float _NormalScale;
    float4 _ColorTint;
    float _MetallicStrength;
    float _SmoothnessStrength;
    float _EdgeLength;
    float4 _texcoord_ST;
};
struct Mtl_HullIn
{
    Mtl_VertexOut cp[3];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
kernel void patchKernel(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn vertexInput [[ stage_in ]],
    uint2 tID [[ thread_position_in_grid ]],
    ushort2 groupID [[ threadgroup_position_in_grid ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    constant Mtl_KernelPatchInfo &patchInfo [[ buffer(3) ]])
{
#pragma clang diagnostic pop
    Mtl_ControlPoint output;
    const uint numPatchesInThreadGroup = 10;
    const uint patchID = (tID.x / patchInfo.numControlPointsPerPatch);
    const bool patchValid = (patchID < patchInfo.numPatches);
    const uint mtl_BaseInstance = 0;
    const uint mtl_InstanceID = groupID.y - mtl_BaseInstance;
    const uint internalPatchID = mtl_InstanceID * patchInfo.numPatches + patchID;
    const uint patchIDInThreadGroup = (patchID % numPatchesInThreadGroup);
    const uint controlPointID = (tID.x % patchInfo.numControlPointsPerPatch);
    const uint mtl_BaseVertex = 0;
    const uint mtl_VertexID = ((mtl_InstanceID * (patchInfo.numControlPointsPerPatch * patchInfo.numPatches)) + tID.x) - mtl_BaseVertex;
    threadgroup Mtl_HullIn inputGroup[numPatchesInThreadGroup];
    threadgroup Mtl_HullIn &input = inputGroup[patchIDInThreadGroup];
    MTLTriangleTessellationFactorsHalf tessFactor;
    if (patchValid) {
        input.cp[controlPointID] = vertexFunction(vertexInput);
        output.INTERNALTESSPOS0 = input.cp[controlPointID].INTERNALTESSPOS0;
        output.TANGENT0 = input.cp[controlPointID].TANGENT0;
        output.NORMAL0 = input.cp[controlPointID].NORMAL0;
        output.TEXCOORD0 = input.cp[controlPointID].TEXCOORD0;
        output.TEXCOORD1 = input.cp[controlPointID].TEXCOORD1;
        output.TEXCOORD2 = input.cp[controlPointID].TEXCOORD2;
        output.TEXCOORD3 = input.cp[controlPointID].TEXCOORD3;
        output.COLOR0 = input.cp[controlPointID].COLOR0;
    }
    threadgroup_barrier(mem_flags::mem_threadgroup);
    if (!patchValid) {
        return;
    }
    float3 u_xlat0;
    float3 u_xlat1;
    float3 u_xlat2;
    float3 u_xlat3;
    float3 u_xlat4;
    float u_xlat12;
    float u_xlat13;
    // fork_phase2
    {
        u_xlat0.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[1].INTERNALTESSPOS0.yyy;
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[1].INTERNALTESSPOS0.xxx, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[1].INTERNALTESSPOS0.zzz, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[1].INTERNALTESSPOS0.www, u_xlat0.xyz);
        u_xlat1.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[2].INTERNALTESSPOS0.yyy;
        u_xlat1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[2].INTERNALTESSPOS0.xxx, u_xlat1.xyz);
        u_xlat1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[2].INTERNALTESSPOS0.zzz, u_xlat1.xyz);
        u_xlat1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[2].INTERNALTESSPOS0.www, u_xlat1.xyz);
        u_xlat2.xyz = u_xlat0.xyz + u_xlat1.xyz;
        u_xlat2.xyz = fma(u_xlat2.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat12 = dot(u_xlat2.xyz, u_xlat2.xyz);
        u_xlat12 = sqrt(u_xlat12);
        u_xlat12 = u_xlat12 * VGlobals._EdgeLength;
        u_xlat2.xyz = u_xlat0.xyz + (-u_xlat1.xyz);
        u_xlat13 = dot(u_xlat2.xyz, u_xlat2.xyz);
        u_xlat13 = sqrt(u_xlat13);
        u_xlat13 = u_xlat13 * VGlobals._ScreenParams.y;
        u_xlat12 = u_xlat13 / u_xlat12;
        tessFactor.edgeTessellationFactor[0] = max(u_xlat12, 1.0);
        u_xlat2.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[0].INTERNALTESSPOS0.yyy;
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[0].INTERNALTESSPOS0.xxx, u_xlat2.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[0].INTERNALTESSPOS0.zzz, u_xlat2.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[0].INTERNALTESSPOS0.www, u_xlat2.xyz);
        u_xlat3.xyz = u_xlat1.xyz + u_xlat2.xyz;
        u_xlat1.xyz = u_xlat1.xyz + (-u_xlat2.xyz);
        u_xlat12 = dot(u_xlat1.xyz, u_xlat1.xyz);
        u_xlat12 = sqrt(u_xlat12);
        u_xlat12 = u_xlat12 * VGlobals._ScreenParams.y;
        u_xlat1.xyz = fma(u_xlat3.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat1.x = dot(u_xlat1.xyz, u_xlat1.xyz);
        u_xlat1.x = sqrt(u_xlat1.x);
        u_xlat1.x = u_xlat1.x * VGlobals._EdgeLength;
        u_xlat12 = u_xlat12 / u_xlat1.x;
        tessFactor.edgeTessellationFactor[1] = max(u_xlat12, 1.0);
        u_xlat1.xyz = u_xlat0.xyz + u_xlat2.xyz;
        u_xlat0.xyz = (-u_xlat0.xyz) + u_xlat2.xyz;
        u_xlat0.x = dot(u_xlat0.xyz, u_xlat0.xyz);
        u_xlat0.x = sqrt(u_xlat0.x);
        u_xlat0.x = u_xlat0.x * VGlobals._ScreenParams.y;
        u_xlat4.xyz = fma(u_xlat1.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat4.x = dot(u_xlat4.xyz, u_xlat4.xyz);
        u_xlat4.x = sqrt(u_xlat4.x);
        u_xlat4.x = u_xlat4.x * VGlobals._EdgeLength;
        u_xlat0.x = u_xlat0.x / u_xlat4.x;
        tessFactor.edgeTessellationFactor[2] = max(u_xlat0.x, 1.0);
    }
    // join_phase3
    {
        u_xlat0.x = tessFactor.edgeTessellationFactor[0] + tessFactor.edgeTessellationFactor[1];
        u_xlat0.x = u_xlat0.x + tessFactor.edgeTessellationFactor[2];
        tessFactor.insideTessellationFactor = u_xlat0.x * 0.333333343;
    }
    controlPoints[mtl_VertexID] = output;
    tessFactors[internalPatchID] = tessFactor;
}
// SHADER_STAGE_HULL_end
// SHADER_STAGE_DOMAIN_begin
struct Mtl_VertexInPostTess
{
    patch_control_point<Mtl_ControlPointIn> cp;
};
struct Mtl_VertexOutPostTess
{
    float4 mtl_Position [[ position ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float4 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float4 TEXCOORD3 [[ user(TEXCOORD3) ]];
    float4 TEXCOORD6 [[ user(TEXCOORD6) ]];
    float4 TEXCOORD7 [[ user(TEXCOORD7) ]];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    sampler sampler_Height [[ sampler (0) ]],
    texture2d<float, access::sample > _Height [[ texture(0) ]] ,
    float3 mtl_TessCoord [[ position_in_patch ]],
    uint patchID [[ patch_id ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    Mtl_VertexInPostTess input [[ stage_in ]])
{
#pragma clang diagnostic pop
    Mtl_VertexOutPostTess output;
    MTLTriangleTessellationFactorsHalf tessFactor;
    tessFactor = tessFactors[patchID];
    float4 u_xlat0;
    float4 u_xlat1;
    float4 u_xlat2;
    float4 u_xlat3;
    float2 u_xlat9;
    float u_xlat12;
    float u_xlat13;
    u_xlat0 = mtl_TessCoord.yyyy * input.cp[1].INTERNALTESSPOS0;
    u_xlat0 = fma(input.cp[0].INTERNALTESSPOS0, mtl_TessCoord.xxxx, u_xlat0);
    u_xlat0 = fma(input.cp[2].INTERNALTESSPOS0, mtl_TessCoord.zzzz, u_xlat0);
    u_xlat1.xy = mtl_TessCoord.yy * input.cp[1].TEXCOORD0.xy;
    u_xlat1.xy = fma(input.cp[0].TEXCOORD0.xy, mtl_TessCoord.xx, u_xlat1.xy);
    u_xlat1.xy = fma(input.cp[2].TEXCOORD0.xy, mtl_TessCoord.zz, u_xlat1.xy);
    u_xlat9.xy = u_xlat1.xy * float2(VGlobals._Tile);
    output.TEXCOORD0.xy = fma(u_xlat1.xy, VGlobals._texcoord_ST.xy, VGlobals._texcoord_ST.zw);
    u_xlat1.xyz = _Height.sample(sampler_Height, u_xlat9.xy, level(1.0)).xyz;
    u_xlat2.xyz = mtl_TessCoord.yyy * input.cp[1].NORMAL0.xyz;
    u_xlat2.xyz = fma(input.cp[0].NORMAL0.xyz, mtl_TessCoord.xxx, u_xlat2.xyz);
    u_xlat2.xyz = fma(input.cp[2].NORMAL0.xyz, mtl_TessCoord.zzz, u_xlat2.xyz);
    u_xlat1.xyz = u_xlat1.xyz * u_xlat2.xyz;
    u_xlat0.xyz = fma(u_xlat1.xyz, float3(VGlobals._HeightDisplacement), u_xlat0.xyz);
    u_xlat1 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], u_xlat0.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], u_xlat0.zzzz, u_xlat1);
    u_xlat3 = u_xlat1 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, u_xlat0.www, u_xlat1.xyz);
    u_xlat1 = u_xlat3.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat3.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat3.zzzz, u_xlat1);
    output.mtl_Position = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat3.wwww, u_xlat1);
    u_xlat1.y = dot(u_xlat2.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat1.z = dot(u_xlat2.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat1.x = dot(u_xlat2.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat12 = dot(u_xlat1.xyz, u_xlat1.xyz);
    u_xlat12 = rsqrt(u_xlat12);
    u_xlat1.xyz = float3(u_xlat12) * u_xlat1.xyz;
    output.TEXCOORD1.z = u_xlat1.y;
    u_xlat2 = mtl_TessCoord.yyyy * input.cp[1].TANGENT0;
    u_xlat2 = fma(input.cp[0].TANGENT0, mtl_TessCoord.xxxx, u_xlat2);
    u_xlat2 = fma(input.cp[2].TANGENT0, mtl_TessCoord.zzzz, u_xlat2);
    u_xlat3.xyz = u_xlat2.yyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].yzx;
    u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].yzx, u_xlat2.xxx, u_xlat3.xyz);
    u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].yzx, u_xlat2.zzz, u_xlat3.xyz);
    u_xlat12 = u_xlat2.w * VGlobals.unity_WorldTransformParams.w;
    u_xlat13 = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat13 = rsqrt(u_xlat13);
    u_xlat2.xyz = float3(u_xlat13) * u_xlat2.xyz;
    u_xlat3.xyz = u_xlat1.xyz * u_xlat2.xyz;
    u_xlat3.xyz = fma(u_xlat1.zxy, u_xlat2.yzx, (-u_xlat3.xyz));
    u_xlat3.xyz = float3(u_xlat12) * u_xlat3.xyz;
    output.TEXCOORD1.y = u_xlat3.x;
    output.TEXCOORD1.w = u_xlat0.x;
    output.TEXCOORD1.x = u_xlat2.z;
    output.TEXCOORD2.w = u_xlat0.y;
    output.TEXCOORD3.w = u_xlat0.z;
    output.TEXCOORD2.x = u_xlat2.x;
    output.TEXCOORD3.x = u_xlat2.y;
    output.TEXCOORD2.z = u_xlat1.z;
    output.TEXCOORD3.z = u_xlat1.x;
    output.TEXCOORD2.y = u_xlat3.y;
    output.TEXCOORD3.y = u_xlat3.z;
    output.TEXCOORD6 = float4(0.0, 0.0, 0.0, 0.0);
    output.TEXCOORD7 = float4(0.0, 0.0, 0.0, 0.0);
    return output;
}
// SHADER_STAGE_DOMAIN_end
Compilation succeeded with: 

program_source:301:53: warning: writable resources in non-void post-tessellation vertex function
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
                                                    ^
program_source:307:30: note: writable buffer defined here
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
                             ^
program_source:308:48: note: writable buffer defined here
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
                                               ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float4 TEXCOORD0 [[ attribute(3) ]] ;
    float4 TEXCOORD1 [[ attribute(4) ]] ;
    float4 TEXCOORD2 [[ attribute(5) ]] ;
    float4 TEXCOORD3 [[ attribute(6) ]] ;
    float4 COLOR0 [[ attribute(7) ]] ;
};
struct Mtl_VertexOut
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float4 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float4 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float4 TEXCOORD3 [[ user(TEXCOORD3) ]];
    float4 COLOR0 [[ user(COLOR0) ]];
};
static Mtl_VertexOut vertexFunction(
    Mtl_VertexIn input)
{
    Mtl_VertexOut output;
    output.INTERNALTESSPOS0 = input.POSITION0;
    output.TANGENT0 = input.TANGENT0;
    output.NORMAL0.xyz = input.NORMAL0.xyz;
    output.TEXCOORD0 = input.TEXCOORD0;
    output.TEXCOORD1 = input.TEXCOORD1;
    output.TEXCOORD2 = input.TEXCOORD2;
    output.TEXCOORD3 = input.TEXCOORD3;
    output.COLOR0 = input.COLOR0;
    return output;
}
// SHADER_STAGE_HULL_begin
struct Mtl_ControlPoint
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float4 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float4 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float4 TEXCOORD3 [[ user(TEXCOORD3) ]];
    float4 COLOR0 [[ user(COLOR0) ]];
};
struct Mtl_ControlPointIn
{
    float4 INTERNALTESSPOS0 [[ attribute(8) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float4 TEXCOORD0 [[ attribute(3) ]] ;
    float4 TEXCOORD1 [[ attribute(4) ]] ;
    float4 TEXCOORD2 [[ attribute(5) ]] ;
    float4 TEXCOORD3 [[ attribute(6) ]] ;
    float4 COLOR0 [[ attribute(7) ]] ;
};
struct Mtl_KernelPatchInfo
{
    uint numPatches;
    ushort numControlPointsPerPatch;
};
struct VGlobals_Type
{
    float4 _Time;
    float4 _SinTime;
    float4 _CosTime;
    float4 unity_DeltaTime;
    float3 _WorldSpaceCameraPos;
    float4 _ProjectionParams;
    float4 _ScreenParams;
    float4 _ZBufferParams;
    float4 unity_OrthoParams;
    float4 unity_CameraWorldClipPlanes[6];
    float4 hlslcc_mtx4x4unity_CameraProjection[4];
    float4 hlslcc_mtx4x4unity_CameraInvProjection[4];
    float4 hlslcc_mtx4x4unity_WorldToCamera[4];
    float4 hlslcc_mtx4x4unity_CameraToWorld[4];
    float4 _WorldSpaceLightPos0;
    float4 _LightPositionRange;
    float4 _LightProjectionParams;
    float4 unity_4LightPosX0;
    float4 unity_4LightPosY0;
    float4 unity_4LightPosZ0;
    float4 unity_4LightAtten0;
    float4 unity_LightColor[8];
    float4 unity_LightPosition[8];
    float4 unity_LightAtten[8];
    float4 unity_SpotDirection[8];
    float4 unity_SHAr;
    float4 unity_SHAg;
    float4 unity_SHAb;
    float4 unity_SHBr;
    float4 unity_SHBg;
    float4 unity_SHBb;
    float4 unity_SHC;
    float4 unity_OcclusionMaskSelector;
    float4 unity_ProbesOcclusion;
    float3 unity_LightColor0;
    float3 unity_LightColor1;
    float3 unity_LightColor2;
    float3 unity_LightColor3;
    float4 unity_ShadowSplitSpheres[4];
    float4 unity_ShadowSplitSqRadii;
    float4 unity_LightShadowBias;
    float4 _LightSplitsNear;
    float4 _LightSplitsFar;
    float4 hlslcc_mtx4x4unity_WorldToShadow[16];
    float4 _LightShadowData;
    float4 unity_ShadowFadeCenterAndType;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 unity_LODFade;
    float4 unity_WorldTransformParams;
    float4 unity_RenderingLayer;
    float4 hlslcc_mtx4x4glstate_matrix_transpose_modelview0[4];
    float4 glstate_lightmodel_ambient;
    float4 unity_AmbientSky;
    float4 unity_AmbientEquator;
    float4 unity_AmbientGround;
    float4 unity_IndirectSpecColor;
    float4 hlslcc_mtx4x4glstate_matrix_projection[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixInvV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    int unity_StereoEyeIndex;
    float4 unity_ShadowColor;
    float4 unity_FogColor;
    float4 unity_FogParams;
    float4 unity_LightmapST;
    float4 unity_DynamicLightmapST;
    float4 unity_SpecCube0_BoxMax;
    float4 unity_SpecCube0_BoxMin;
    float4 unity_SpecCube0_ProbePosition;
    float4 unity_SpecCube0_HDR;
    float4 unity_SpecCube1_BoxMax;
    float4 unity_SpecCube1_BoxMin;
    float4 unity_SpecCube1_ProbePosition;
    float4 unity_SpecCube1_HDR;
    float4 unity_ProbeVolumeParams;
    float4 hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[4];
    float3 unity_ProbeVolumeSizeInv;
    float3 unity_ProbeVolumeMin;
    float4 unity_Lightmap_HDR;
    float4 unity_DynamicLightmap_HDR;
    float4 _LightColor0;
    float4 _SpecColor;
    float4 hlslcc_mtx4x4unity_WorldToLight[4];
    float _Tile;
    float _HeightDisplacement;
    float _NormalScale;
    float4 _ColorTint;
    float _MetallicStrength;
    float _SmoothnessStrength;
    float _EdgeLength;
    float4 _texcoord_ST;
};
struct Mtl_HullIn
{
    Mtl_VertexOut cp[3];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
kernel void patchKernel(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn vertexInput [[ stage_in ]],
    uint2 tID [[ thread_position_in_grid ]],
    ushort2 groupID [[ threadgroup_position_in_grid ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    constant Mtl_KernelPatchInfo &patchInfo [[ buffer(3) ]])
{
#pragma clang diagnostic pop
    Mtl_ControlPoint output;
    const uint numPatchesInThreadGroup = 10;
    const uint patchID = (tID.x / patchInfo.numControlPointsPerPatch);
    const bool patchValid = (patchID < patchInfo.numPatches);
    const uint mtl_BaseInstance = 0;
    const uint mtl_InstanceID = groupID.y - mtl_BaseInstance;
    const uint internalPatchID = mtl_InstanceID * patchInfo.numPatches + patchID;
    const uint patchIDInThreadGroup = (patchID % numPatchesInThreadGroup);
    const uint controlPointID = (tID.x % patchInfo.numControlPointsPerPatch);
    const uint mtl_BaseVertex = 0;
    const uint mtl_VertexID = ((mtl_InstanceID * (patchInfo.numControlPointsPerPatch * patchInfo.numPatches)) + tID.x) - mtl_BaseVertex;
    threadgroup Mtl_HullIn inputGroup[numPatchesInThreadGroup];
    threadgroup Mtl_HullIn &input = inputGroup[patchIDInThreadGroup];
    MTLTriangleTessellationFactorsHalf tessFactor;
    if (patchValid) {
        input.cp[controlPointID] = vertexFunction(vertexInput);
        output.INTERNALTESSPOS0 = input.cp[controlPointID].INTERNALTESSPOS0;
        output.TANGENT0 = input.cp[controlPointID].TANGENT0;
        output.NORMAL0 = input.cp[controlPointID].NORMAL0;
        output.TEXCOORD0 = input.cp[controlPointID].TEXCOORD0;
        output.TEXCOORD1 = input.cp[controlPointID].TEXCOORD1;
        output.TEXCOORD2 = input.cp[controlPointID].TEXCOORD2;
        output.TEXCOORD3 = input.cp[controlPointID].TEXCOORD3;
        output.COLOR0 = input.cp[controlPointID].COLOR0;
    }
    threadgroup_barrier(mem_flags::mem_threadgroup);
    if (!patchValid) {
        return;
    }
    float3 u_xlat0;
    float3 u_xlat1;
    float3 u_xlat2;
    float3 u_xlat3;
    float3 u_xlat4;
    float u_xlat12;
    float u_xlat13;
    // fork_phase2
    {
        u_xlat0.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[1].INTERNALTESSPOS0.yyy;
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[1].INTERNALTESSPOS0.xxx, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[1].INTERNALTESSPOS0.zzz, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[1].INTERNALTESSPOS0.www, u_xlat0.xyz);
        u_xlat1.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[2].INTERNALTESSPOS0.yyy;
        u_xlat1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[2].INTERNALTESSPOS0.xxx, u_xlat1.xyz);
        u_xlat1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[2].INTERNALTESSPOS0.zzz, u_xlat1.xyz);
        u_xlat1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[2].INTERNALTESSPOS0.www, u_xlat1.xyz);
        u_xlat2.xyz = u_xlat0.xyz + u_xlat1.xyz;
        u_xlat2.xyz = fma(u_xlat2.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat12 = dot(u_xlat2.xyz, u_xlat2.xyz);
        u_xlat12 = sqrt(u_xlat12);
        u_xlat12 = u_xlat12 * VGlobals._EdgeLength;
        u_xlat2.xyz = u_xlat0.xyz + (-u_xlat1.xyz);
        u_xlat13 = dot(u_xlat2.xyz, u_xlat2.xyz);
        u_xlat13 = sqrt(u_xlat13);
        u_xlat13 = u_xlat13 * VGlobals._ScreenParams.y;
        u_xlat12 = u_xlat13 / u_xlat12;
        tessFactor.edgeTessellationFactor[0] = max(u_xlat12, 1.0);
        u_xlat2.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[0].INTERNALTESSPOS0.yyy;
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[0].INTERNALTESSPOS0.xxx, u_xlat2.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[0].INTERNALTESSPOS0.zzz, u_xlat2.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[0].INTERNALTESSPOS0.www, u_xlat2.xyz);
        u_xlat3.xyz = u_xlat1.xyz + u_xlat2.xyz;
        u_xlat1.xyz = u_xlat1.xyz + (-u_xlat2.xyz);
        u_xlat12 = dot(u_xlat1.xyz, u_xlat1.xyz);
        u_xlat12 = sqrt(u_xlat12);
        u_xlat12 = u_xlat12 * VGlobals._ScreenParams.y;
        u_xlat1.xyz = fma(u_xlat3.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat1.x = dot(u_xlat1.xyz, u_xlat1.xyz);
        u_xlat1.x = sqrt(u_xlat1.x);
        u_xlat1.x = u_xlat1.x * VGlobals._EdgeLength;
        u_xlat12 = u_xlat12 / u_xlat1.x;
        tessFactor.edgeTessellationFactor[1] = max(u_xlat12, 1.0);
        u_xlat1.xyz = u_xlat0.xyz + u_xlat2.xyz;
        u_xlat0.xyz = (-u_xlat0.xyz) + u_xlat2.xyz;
        u_xlat0.x = dot(u_xlat0.xyz, u_xlat0.xyz);
        u_xlat0.x = sqrt(u_xlat0.x);
        u_xlat0.x = u_xlat0.x * VGlobals._ScreenParams.y;
        u_xlat4.xyz = fma(u_xlat1.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat4.x = dot(u_xlat4.xyz, u_xlat4.xyz);
        u_xlat4.x = sqrt(u_xlat4.x);
        u_xlat4.x = u_xlat4.x * VGlobals._EdgeLength;
        u_xlat0.x = u_xlat0.x / u_xlat4.x;
        tessFactor.edgeTessellationFactor[2] = max(u_xlat0.x, 1.0);
    }
    // join_phase3
    {
        u_xlat0.x = tessFactor.edgeTessellationFactor[0] + tessFactor.edgeTessellationFactor[1];
        u_xlat0.x = u_xlat0.x + tessFactor.edgeTessellationFactor[2];
        tessFactor.insideTessellationFactor = u_xlat0.x * 0.333333343;
    }
    controlPoints[mtl_VertexID] = output;
    tessFactors[internalPatchID] = tessFactor;
}
// SHADER_STAGE_HULL_end
// SHADER_STAGE_DOMAIN_begin
struct Mtl_VertexInPostTess
{
    patch_control_point<Mtl_ControlPointIn> cp;
};
struct Mtl_VertexOutPostTess
{
    float4 mtl_Position [[ position ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float3 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float3 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float3 TEXCOORD3 [[ user(TEXCOORD3) ]];
    float3 TEXCOORD4 [[ user(TEXCOORD4) ]];
    float3 TEXCOORD5 [[ user(TEXCOORD5) ]];
    float4 TEXCOORD6 [[ user(TEXCOORD6) ]];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    sampler sampler_Height [[ sampler (0) ]],
    texture2d<float, access::sample > _Height [[ texture(0) ]] ,
    float3 mtl_TessCoord [[ position_in_patch ]],
    uint patchID [[ patch_id ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    Mtl_VertexInPostTess input [[ stage_in ]])
{
#pragma clang diagnostic pop
    Mtl_VertexOutPostTess output;
    MTLTriangleTessellationFactorsHalf tessFactor;
    tessFactor = tessFactors[patchID];
    float4 u_xlat0;
    float3 u_xlat1;
    float4 u_xlat2;
    float4 u_xlat3;
    float4 u_xlat4;
    float2 u_xlat10;
    float u_xlat16;
    u_xlat0.xy = mtl_TessCoord.yy * input.cp[1].TEXCOORD0.xy;
    u_xlat0.xy = fma(input.cp[0].TEXCOORD0.xy, mtl_TessCoord.xx, u_xlat0.xy);
    u_xlat0.xy = fma(input.cp[2].TEXCOORD0.xy, mtl_TessCoord.zz, u_xlat0.xy);
    u_xlat10.xy = u_xlat0.xy * float2(VGlobals._Tile);
    output.TEXCOORD0.xy = fma(u_xlat0.xy, VGlobals._texcoord_ST.xy, VGlobals._texcoord_ST.zw);
    u_xlat0.xyz = _Height.sample(sampler_Height, u_xlat10.xy, level(1.0)).xyz;
    u_xlat1.xyz = mtl_TessCoord.yyy * input.cp[1].NORMAL0.xyz;
    u_xlat1.xyz = fma(input.cp[0].NORMAL0.xyz, mtl_TessCoord.xxx, u_xlat1.xyz);
    u_xlat1.xyz = fma(input.cp[2].NORMAL0.xyz, mtl_TessCoord.zzz, u_xlat1.xyz);
    u_xlat0.xyz = u_xlat0.xyz * u_xlat1.xyz;
    u_xlat2 = mtl_TessCoord.yyyy * input.cp[1].INTERNALTESSPOS0;
    u_xlat2 = fma(input.cp[0].INTERNALTESSPOS0, mtl_TessCoord.xxxx, u_xlat2);
    u_xlat2 = fma(input.cp[2].INTERNALTESSPOS0, mtl_TessCoord.zzzz, u_xlat2);
    u_xlat0.xyz = fma(u_xlat0.xyz, float3(VGlobals._HeightDisplacement), u_xlat2.xyz);
    u_xlat3 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], u_xlat0.xxxx, u_xlat3);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], u_xlat0.zzzz, u_xlat3);
    u_xlat3 = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat4 = u_xlat3.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat4 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat3.xxxx, u_xlat4);
    u_xlat4 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat3.zzzz, u_xlat4);
    output.mtl_Position = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat3.wwww, u_xlat4);
    u_xlat2.y = dot(u_xlat1.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat2.z = dot(u_xlat1.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat2.x = dot(u_xlat1.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat1.x = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat1.x = rsqrt(u_xlat1.x);
    u_xlat1.xyz = u_xlat1.xxx * u_xlat2.xyz;
    output.TEXCOORD1.z = u_xlat1.y;
    u_xlat3 = mtl_TessCoord.yyyy * input.cp[1].TANGENT0;
    u_xlat3 = fma(input.cp[0].TANGENT0, mtl_TessCoord.xxxx, u_xlat3);
    u_xlat3 = fma(input.cp[2].TANGENT0, mtl_TessCoord.zzzz, u_xlat3);
    u_xlat2.xyz = u_xlat3.yyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].yzx;
    u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].yzx, u_xlat3.xxx, u_xlat2.xyz);
    u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].yzx, u_xlat3.zzz, u_xlat2.xyz);
    u_xlat16 = u_xlat3.w * VGlobals.unity_WorldTransformParams.w;
    u_xlat3.x = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat3.x = rsqrt(u_xlat3.x);
    u_xlat2.xyz = u_xlat2.xyz * u_xlat3.xxx;
    u_xlat3.xyz = u_xlat1.xyz * u_xlat2.xyz;
    u_xlat3.xyz = fma(u_xlat1.zxy, u_xlat2.yzx, (-u_xlat3.xyz));
    u_xlat3.xyz = float3(u_xlat16) * u_xlat3.xyz;
    output.TEXCOORD1.y = u_xlat3.x;
    output.TEXCOORD1.x = u_xlat2.z;
    output.TEXCOORD2.x = u_xlat2.x;
    output.TEXCOORD3.x = u_xlat2.y;
    output.TEXCOORD2.z = u_xlat1.z;
    output.TEXCOORD3.z = u_xlat1.x;
    output.TEXCOORD2.y = u_xlat3.y;
    output.TEXCOORD3.y = u_xlat3.z;
    output.TEXCOORD4.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, u_xlat2.www, u_xlat0.xyz);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3], u_xlat2.wwww, u_xlat0);
    u_xlat1.xyz = u_xlat0.yyy * VGlobals.hlslcc_mtx4x4unity_WorldToLight[1].xyz;
    u_xlat1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_WorldToLight[0].xyz, u_xlat0.xxx, u_xlat1.xyz);
    u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_WorldToLight[2].xyz, u_xlat0.zzz, u_xlat1.xyz);
    output.TEXCOORD5.xyz = fma(VGlobals.hlslcc_mtx4x4unity_WorldToLight[3].xyz, u_xlat0.www, u_xlat0.xyz);
    output.TEXCOORD6 = float4(0.0, 0.0, 0.0, 0.0);
    return output;
}
// SHADER_STAGE_DOMAIN_end
Compilation succeeded with: 

program_source:293:53: warning: writable resources in non-void post-tessellation vertex function
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
                                                    ^
program_source:299:30: note: writable buffer defined here
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
                             ^
program_source:300:48: note: writable buffer defined here
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
                                               ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float4 TEXCOORD0 [[ attribute(3) ]] ;
    float4 TEXCOORD1 [[ attribute(4) ]] ;
    float4 TEXCOORD2 [[ attribute(5) ]] ;
    float4 TEXCOORD3 [[ attribute(6) ]] ;
    float4 COLOR0 [[ attribute(7) ]] ;
};
struct Mtl_VertexOut
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float4 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float4 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float4 TEXCOORD3 [[ user(TEXCOORD3) ]];
    float4 COLOR0 [[ user(COLOR0) ]];
};
static Mtl_VertexOut vertexFunction(
    Mtl_VertexIn input)
{
    Mtl_VertexOut output;
    output.INTERNALTESSPOS0 = input.POSITION0;
    output.TANGENT0 = input.TANGENT0;
    output.NORMAL0.xyz = input.NORMAL0.xyz;
    output.TEXCOORD0 = input.TEXCOORD0;
    output.TEXCOORD1 = input.TEXCOORD1;
    output.TEXCOORD2 = input.TEXCOORD2;
    output.TEXCOORD3 = input.TEXCOORD3;
    output.COLOR0 = input.COLOR0;
    return output;
}
// SHADER_STAGE_HULL_begin
struct Mtl_ControlPoint
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float4 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float4 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float4 TEXCOORD3 [[ user(TEXCOORD3) ]];
    float4 COLOR0 [[ user(COLOR0) ]];
};
struct Mtl_ControlPointIn
{
    float4 INTERNALTESSPOS0 [[ attribute(8) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float4 TEXCOORD0 [[ attribute(3) ]] ;
    float4 TEXCOORD1 [[ attribute(4) ]] ;
    float4 TEXCOORD2 [[ attribute(5) ]] ;
    float4 TEXCOORD3 [[ attribute(6) ]] ;
    float4 COLOR0 [[ attribute(7) ]] ;
};
struct Mtl_KernelPatchInfo
{
    uint numPatches;
    ushort numControlPointsPerPatch;
};
struct VGlobals_Type
{
    float4 _Time;
    float4 _SinTime;
    float4 _CosTime;
    float4 unity_DeltaTime;
    float3 _WorldSpaceCameraPos;
    float4 _ProjectionParams;
    float4 _ScreenParams;
    float4 _ZBufferParams;
    float4 unity_OrthoParams;
    float4 unity_CameraWorldClipPlanes[6];
    float4 hlslcc_mtx4x4unity_CameraProjection[4];
    float4 hlslcc_mtx4x4unity_CameraInvProjection[4];
    float4 hlslcc_mtx4x4unity_WorldToCamera[4];
    float4 hlslcc_mtx4x4unity_CameraToWorld[4];
    float4 _WorldSpaceLightPos0;
    float4 _LightPositionRange;
    float4 _LightProjectionParams;
    float4 unity_4LightPosX0;
    float4 unity_4LightPosY0;
    float4 unity_4LightPosZ0;
    float4 unity_4LightAtten0;
    float4 unity_LightColor[8];
    float4 unity_LightPosition[8];
    float4 unity_LightAtten[8];
    float4 unity_SpotDirection[8];
    float4 unity_SHAr;
    float4 unity_SHAg;
    float4 unity_SHAb;
    float4 unity_SHBr;
    float4 unity_SHBg;
    float4 unity_SHBb;
    float4 unity_SHC;
    float4 unity_OcclusionMaskSelector;
    float4 unity_ProbesOcclusion;
    float3 unity_LightColor0;
    float3 unity_LightColor1;
    float3 unity_LightColor2;
    float3 unity_LightColor3;
    float4 unity_ShadowSplitSpheres[4];
    float4 unity_ShadowSplitSqRadii;
    float4 unity_LightShadowBias;
    float4 _LightSplitsNear;
    float4 _LightSplitsFar;
    float4 hlslcc_mtx4x4unity_WorldToShadow[16];
    float4 _LightShadowData;
    float4 unity_ShadowFadeCenterAndType;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 unity_LODFade;
    float4 unity_WorldTransformParams;
    float4 unity_RenderingLayer;
    float4 hlslcc_mtx4x4glstate_matrix_transpose_modelview0[4];
    float4 glstate_lightmodel_ambient;
    float4 unity_AmbientSky;
    float4 unity_AmbientEquator;
    float4 unity_AmbientGround;
    float4 unity_IndirectSpecColor;
    float4 hlslcc_mtx4x4glstate_matrix_projection[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixInvV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    int unity_StereoEyeIndex;
    float4 unity_ShadowColor;
    float4 unity_FogColor;
    float4 unity_FogParams;
    float4 unity_LightmapST;
    float4 unity_DynamicLightmapST;
    float4 unity_SpecCube0_BoxMax;
    float4 unity_SpecCube0_BoxMin;
    float4 unity_SpecCube0_ProbePosition;
    float4 unity_SpecCube0_HDR;
    float4 unity_SpecCube1_BoxMax;
    float4 unity_SpecCube1_BoxMin;
    float4 unity_SpecCube1_ProbePosition;
    float4 unity_SpecCube1_HDR;
    float4 unity_ProbeVolumeParams;
    float4 hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[4];
    float3 unity_ProbeVolumeSizeInv;
    float3 unity_ProbeVolumeMin;
    float4 unity_Lightmap_HDR;
    float4 unity_DynamicLightmap_HDR;
    float4 _LightColor0;
    float4 _SpecColor;
    float _Tile;
    float _HeightDisplacement;
    float _NormalScale;
    float4 _ColorTint;
    float _MetallicStrength;
    float _SmoothnessStrength;
    float _EdgeLength;
};
struct Mtl_HullIn
{
    Mtl_VertexOut cp[3];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
kernel void patchKernel(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn vertexInput [[ stage_in ]],
    uint2 tID [[ thread_position_in_grid ]],
    ushort2 groupID [[ threadgroup_position_in_grid ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    constant Mtl_KernelPatchInfo &patchInfo [[ buffer(3) ]])
{
#pragma clang diagnostic pop
    Mtl_ControlPoint output;
    const uint numPatchesInThreadGroup = 10;
    const uint patchID = (tID.x / patchInfo.numControlPointsPerPatch);
    const bool patchValid = (patchID < patchInfo.numPatches);
    const uint mtl_BaseInstance = 0;
    const uint mtl_InstanceID = groupID.y - mtl_BaseInstance;
    const uint internalPatchID = mtl_InstanceID * patchInfo.numPatches + patchID;
    const uint patchIDInThreadGroup = (patchID % numPatchesInThreadGroup);
    const uint controlPointID = (tID.x % patchInfo.numControlPointsPerPatch);
    const uint mtl_BaseVertex = 0;
    const uint mtl_VertexID = ((mtl_InstanceID * (patchInfo.numControlPointsPerPatch * patchInfo.numPatches)) + tID.x) - mtl_BaseVertex;
    threadgroup Mtl_HullIn inputGroup[numPatchesInThreadGroup];
    threadgroup Mtl_HullIn &input = inputGroup[patchIDInThreadGroup];
    MTLTriangleTessellationFactorsHalf tessFactor;
    if (patchValid) {
        input.cp[controlPointID] = vertexFunction(vertexInput);
        output.INTERNALTESSPOS0 = input.cp[controlPointID].INTERNALTESSPOS0;
        output.TANGENT0 = input.cp[controlPointID].TANGENT0;
        output.NORMAL0 = input.cp[controlPointID].NORMAL0;
        output.TEXCOORD0 = input.cp[controlPointID].TEXCOORD0;
        output.TEXCOORD1 = input.cp[controlPointID].TEXCOORD1;
        output.TEXCOORD2 = input.cp[controlPointID].TEXCOORD2;
        output.TEXCOORD3 = input.cp[controlPointID].TEXCOORD3;
        output.COLOR0 = input.cp[controlPointID].COLOR0;
    }
    threadgroup_barrier(mem_flags::mem_threadgroup);
    if (!patchValid) {
        return;
    }
    float3 u_xlat0;
    float3 u_xlat1;
    float3 u_xlat2;
    float3 u_xlat3;
    float3 u_xlat4;
    float u_xlat12;
    float u_xlat13;
    // fork_phase2
    {
        u_xlat0.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[1].INTERNALTESSPOS0.yyy;
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[1].INTERNALTESSPOS0.xxx, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[1].INTERNALTESSPOS0.zzz, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[1].INTERNALTESSPOS0.www, u_xlat0.xyz);
        u_xlat1.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[2].INTERNALTESSPOS0.yyy;
        u_xlat1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[2].INTERNALTESSPOS0.xxx, u_xlat1.xyz);
        u_xlat1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[2].INTERNALTESSPOS0.zzz, u_xlat1.xyz);
        u_xlat1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[2].INTERNALTESSPOS0.www, u_xlat1.xyz);
        u_xlat2.xyz = u_xlat0.xyz + u_xlat1.xyz;
        u_xlat2.xyz = fma(u_xlat2.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat12 = dot(u_xlat2.xyz, u_xlat2.xyz);
        u_xlat12 = sqrt(u_xlat12);
        u_xlat12 = u_xlat12 * VGlobals._EdgeLength;
        u_xlat2.xyz = u_xlat0.xyz + (-u_xlat1.xyz);
        u_xlat13 = dot(u_xlat2.xyz, u_xlat2.xyz);
        u_xlat13 = sqrt(u_xlat13);
        u_xlat13 = u_xlat13 * VGlobals._ScreenParams.y;
        u_xlat12 = u_xlat13 / u_xlat12;
        tessFactor.edgeTessellationFactor[0] = max(u_xlat12, 1.0);
        u_xlat2.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[0].INTERNALTESSPOS0.yyy;
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[0].INTERNALTESSPOS0.xxx, u_xlat2.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[0].INTERNALTESSPOS0.zzz, u_xlat2.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[0].INTERNALTESSPOS0.www, u_xlat2.xyz);
        u_xlat3.xyz = u_xlat1.xyz + u_xlat2.xyz;
        u_xlat1.xyz = u_xlat1.xyz + (-u_xlat2.xyz);
        u_xlat12 = dot(u_xlat1.xyz, u_xlat1.xyz);
        u_xlat12 = sqrt(u_xlat12);
        u_xlat12 = u_xlat12 * VGlobals._ScreenParams.y;
        u_xlat1.xyz = fma(u_xlat3.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat1.x = dot(u_xlat1.xyz, u_xlat1.xyz);
        u_xlat1.x = sqrt(u_xlat1.x);
        u_xlat1.x = u_xlat1.x * VGlobals._EdgeLength;
        u_xlat12 = u_xlat12 / u_xlat1.x;
        tessFactor.edgeTessellationFactor[1] = max(u_xlat12, 1.0);
        u_xlat1.xyz = u_xlat0.xyz + u_xlat2.xyz;
        u_xlat0.xyz = (-u_xlat0.xyz) + u_xlat2.xyz;
        u_xlat0.x = dot(u_xlat0.xyz, u_xlat0.xyz);
        u_xlat0.x = sqrt(u_xlat0.x);
        u_xlat0.x = u_xlat0.x * VGlobals._ScreenParams.y;
        u_xlat4.xyz = fma(u_xlat1.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat4.x = dot(u_xlat4.xyz, u_xlat4.xyz);
        u_xlat4.x = sqrt(u_xlat4.x);
        u_xlat4.x = u_xlat4.x * VGlobals._EdgeLength;
        u_xlat0.x = u_xlat0.x / u_xlat4.x;
        tessFactor.edgeTessellationFactor[2] = max(u_xlat0.x, 1.0);
    }
    // join_phase3
    {
        u_xlat0.x = tessFactor.edgeTessellationFactor[0] + tessFactor.edgeTessellationFactor[1];
        u_xlat0.x = u_xlat0.x + tessFactor.edgeTessellationFactor[2];
        tessFactor.insideTessellationFactor = u_xlat0.x * 0.333333343;
    }
    controlPoints[mtl_VertexID] = output;
    tessFactors[internalPatchID] = tessFactor;
}
// SHADER_STAGE_HULL_end
// SHADER_STAGE_DOMAIN_begin
struct Mtl_VertexInPostTess
{
    patch_control_point<Mtl_ControlPointIn> cp;
};
struct Mtl_VertexOutPostTess
{
    float4 mtl_Position [[ position ]];
    float3 TEXCOORD1 [[ user(TEXCOORD1) ]];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    sampler sampler_Height [[ sampler (0) ]],
    texture2d<float, access::sample > _Height [[ texture(0) ]] ,
    float3 mtl_TessCoord [[ position_in_patch ]],
    uint patchID [[ patch_id ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    Mtl_VertexInPostTess input [[ stage_in ]])
{
#pragma clang diagnostic pop
    Mtl_VertexOutPostTess output;
    MTLTriangleTessellationFactorsHalf tessFactor;
    tessFactor = tessFactors[patchID];
    float4 u_xlat0;
    float4 u_xlat1;
    float4 u_xlat2;
    float4 u_xlat3;
    float4 u_xlat4;
    float u_xlat11;
    float u_xlat15;
    bool u_xlatb15;
    u_xlat0.xyz = mtl_TessCoord.yyy * input.cp[1].NORMAL0.xyz;
    u_xlat0.xyz = fma(input.cp[0].NORMAL0.xyz, mtl_TessCoord.xxx, u_xlat0.xyz);
    u_xlat0.xyz = fma(input.cp[2].NORMAL0.xyz, mtl_TessCoord.zzz, u_xlat0.xyz);
    u_xlat1.x = dot(u_xlat0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat1.y = dot(u_xlat0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat1.z = dot(u_xlat0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat15 = dot(u_xlat1.xyz, u_xlat1.xyz);
    u_xlat15 = rsqrt(u_xlat15);
    u_xlat1.xyz = float3(u_xlat15) * u_xlat1.xyz;
    u_xlat2.xy = mtl_TessCoord.yy * input.cp[1].TEXCOORD0.xy;
    u_xlat2.xy = fma(input.cp[0].TEXCOORD0.xy, mtl_TessCoord.xx, u_xlat2.xy);
    u_xlat2.xy = fma(input.cp[2].TEXCOORD0.xy, mtl_TessCoord.zz, u_xlat2.xy);
    u_xlat2.xy = u_xlat2.xy * float2(VGlobals._Tile);
    u_xlat2.xyz = _Height.sample(sampler_Height, u_xlat2.xy, level(1.0)).xyz;
    u_xlat0.xyz = u_xlat0.xyz * u_xlat2.xyz;
    u_xlat2 = mtl_TessCoord.yyyy * input.cp[1].INTERNALTESSPOS0;
    u_xlat2 = fma(input.cp[0].INTERNALTESSPOS0, mtl_TessCoord.xxxx, u_xlat2);
    u_xlat2 = fma(input.cp[2].INTERNALTESSPOS0, mtl_TessCoord.zzzz, u_xlat2);
    u_xlat0.xyz = fma(u_xlat0.xyz, float3(VGlobals._HeightDisplacement), u_xlat2.xyz);
    u_xlat3 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], u_xlat0.xxxx, u_xlat3);
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], u_xlat0.zzzz, u_xlat3);
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3], u_xlat2.wwww, u_xlat3);
    u_xlat2.xyz = fma((-u_xlat3.xyz), VGlobals._WorldSpaceLightPos0.www, VGlobals._WorldSpaceLightPos0.xyz);
    u_xlat15 = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat15 = rsqrt(u_xlat15);
    u_xlat2.xyz = float3(u_xlat15) * u_xlat2.xyz;
    u_xlat15 = dot(u_xlat1.xyz, u_xlat2.xyz);
    u_xlat15 = fma((-u_xlat15), u_xlat15, 1.0);
    u_xlat15 = sqrt(u_xlat15);
    u_xlat15 = u_xlat15 * VGlobals.unity_LightShadowBias.z;
    u_xlat1.xyz = fma((-u_xlat1.xyz), float3(u_xlat15), u_xlat3.xyz);
    u_xlatb15 = VGlobals.unity_LightShadowBias.z!=0.0;
    u_xlat1.xyz = (bool(u_xlatb15)) ? u_xlat1.xyz : u_xlat3.xyz;
    u_xlat4 = u_xlat1.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat4 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat1.xxxx, u_xlat4);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat1.zzzz, u_xlat4);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat3.wwww, u_xlat1);
    u_xlat15 = VGlobals.unity_LightShadowBias.x / u_xlat1.w;
    u_xlat15 = min(u_xlat15, 0.0);
    u_xlat15 = max(u_xlat15, -1.0);
    u_xlat15 = u_xlat15 + u_xlat1.z;
    u_xlat11 = min(u_xlat1.w, u_xlat15);
    output.mtl_Position.xyw = u_xlat1.xyw;
    u_xlat1.x = (-u_xlat15) + u_xlat11;
    output.mtl_Position.z = fma(VGlobals.unity_LightShadowBias.y, u_xlat1.x, u_xlat15);
    u_xlat1.xyz = u_xlat0.yyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz;
    u_xlat0.xyw = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, u_xlat0.xxx, u_xlat1.xyz);
    u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, u_xlat0.zzz, u_xlat0.xyw);
    output.TEXCOORD1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, u_xlat2.www, u_xlat0.xyz);
    return output;
}
// SHADER_STAGE_DOMAIN_end
Compilation succeeded with: 

program_source:299:53: warning: writable resources in non-void post-tessellation vertex function
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
                                                    ^
program_source:305:30: note: writable buffer defined here
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
                             ^
program_source:306:48: note: writable buffer defined here
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
                                               ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float4 TEXCOORD0 [[ attribute(3) ]] ;
    float4 TEXCOORD1 [[ attribute(4) ]] ;
    float4 TEXCOORD2 [[ attribute(5) ]] ;
    float4 TEXCOORD3 [[ attribute(6) ]] ;
    float4 COLOR0 [[ attribute(7) ]] ;
};
struct Mtl_VertexOut
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float4 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float4 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float4 TEXCOORD3 [[ user(TEXCOORD3) ]];
    float4 COLOR0 [[ user(COLOR0) ]];
};
static Mtl_VertexOut vertexFunction(
    Mtl_VertexIn input)
{
    Mtl_VertexOut output;
    output.INTERNALTESSPOS0 = input.POSITION0;
    output.TANGENT0 = input.TANGENT0;
    output.NORMAL0.xyz = input.NORMAL0.xyz;
    output.TEXCOORD0 = input.TEXCOORD0;
    output.TEXCOORD1 = input.TEXCOORD1;
    output.TEXCOORD2 = input.TEXCOORD2;
    output.TEXCOORD3 = input.TEXCOORD3;
    output.COLOR0 = input.COLOR0;
    return output;
}
// SHADER_STAGE_HULL_begin
struct Mtl_ControlPoint
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float4 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float4 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float4 TEXCOORD3 [[ user(TEXCOORD3) ]];
    float4 COLOR0 [[ user(COLOR0) ]];
};
struct Mtl_ControlPointIn
{
    float4 INTERNALTESSPOS0 [[ attribute(8) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float4 TEXCOORD0 [[ attribute(3) ]] ;
    float4 TEXCOORD1 [[ attribute(4) ]] ;
    float4 TEXCOORD2 [[ attribute(5) ]] ;
    float4 TEXCOORD3 [[ attribute(6) ]] ;
    float4 COLOR0 [[ attribute(7) ]] ;
};
struct Mtl_KernelPatchInfo
{
    uint numPatches;
    ushort numControlPointsPerPatch;
};
struct VGlobals_Type
{
    float4 _Time;
    float4 _SinTime;
    float4 _CosTime;
    float4 unity_DeltaTime;
    float3 _WorldSpaceCameraPos;
    float4 _ProjectionParams;
    float4 _ScreenParams;
    float4 _ZBufferParams;
    float4 unity_OrthoParams;
    float4 unity_CameraWorldClipPlanes[6];
    float4 hlslcc_mtx4x4unity_CameraProjection[4];
    float4 hlslcc_mtx4x4unity_CameraInvProjection[4];
    float4 hlslcc_mtx4x4unity_WorldToCamera[4];
    float4 hlslcc_mtx4x4unity_CameraToWorld[4];
    float4 _WorldSpaceLightPos0;
    float4 _LightPositionRange;
    float4 _LightProjectionParams;
    float4 unity_4LightPosX0;
    float4 unity_4LightPosY0;
    float4 unity_4LightPosZ0;
    float4 unity_4LightAtten0;
    float4 unity_LightColor[8];
    float4 unity_LightPosition[8];
    float4 unity_LightAtten[8];
    float4 unity_SpotDirection[8];
    float4 unity_SHAr;
    float4 unity_SHAg;
    float4 unity_SHAb;
    float4 unity_SHBr;
    float4 unity_SHBg;
    float4 unity_SHBb;
    float4 unity_SHC;
    float4 unity_OcclusionMaskSelector;
    float4 unity_ProbesOcclusion;
    float3 unity_LightColor0;
    float3 unity_LightColor1;
    float3 unity_LightColor2;
    float3 unity_LightColor3;
    float4 unity_ShadowSplitSpheres[4];
    float4 unity_ShadowSplitSqRadii;
    float4 unity_LightShadowBias;
    float4 _LightSplitsNear;
    float4 _LightSplitsFar;
    float4 hlslcc_mtx4x4unity_WorldToShadow[16];
    float4 _LightShadowData;
    float4 unity_ShadowFadeCenterAndType;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 unity_LODFade;
    float4 unity_WorldTransformParams;
    float4 unity_RenderingLayer;
    float4 hlslcc_mtx4x4glstate_matrix_transpose_modelview0[4];
    float4 glstate_lightmodel_ambient;
    float4 unity_AmbientSky;
    float4 unity_AmbientEquator;
    float4 unity_AmbientGround;
    float4 unity_IndirectSpecColor;
    float4 hlslcc_mtx4x4glstate_matrix_projection[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixInvV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    int unity_StereoEyeIndex;
    float4 unity_ShadowColor;
    float4 unity_FogColor;
    float4 unity_FogParams;
    float4 unity_LightmapST;
    float4 unity_DynamicLightmapST;
    float4 unity_SpecCube0_BoxMax;
    float4 unity_SpecCube0_BoxMin;
    float4 unity_SpecCube0_ProbePosition;
    float4 unity_SpecCube0_HDR;
    float4 unity_SpecCube1_BoxMax;
    float4 unity_SpecCube1_BoxMin;
    float4 unity_SpecCube1_ProbePosition;
    float4 unity_SpecCube1_HDR;
    float4 unity_ProbeVolumeParams;
    float4 hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[4];
    float3 unity_ProbeVolumeSizeInv;
    float3 unity_ProbeVolumeMin;
    float4 unity_Lightmap_HDR;
    float4 unity_DynamicLightmap_HDR;
    float4 _LightColor0;
    float4 _SpecColor;
    float _Tile;
    float _HeightDisplacement;
    float _NormalScale;
    float4 _ColorTint;
    float _MetallicStrength;
    float _SmoothnessStrength;
    float _EdgeLength;
    float4 _texcoord_ST;
    float4 unity_Ambient;
};
struct Mtl_HullIn
{
    Mtl_VertexOut cp[3];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
kernel void patchKernel(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn vertexInput [[ stage_in ]],
    uint2 tID [[ thread_position_in_grid ]],
    ushort2 groupID [[ threadgroup_position_in_grid ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    constant Mtl_KernelPatchInfo &patchInfo [[ buffer(3) ]])
{
#pragma clang diagnostic pop
    Mtl_ControlPoint output;
    const uint numPatchesInThreadGroup = 10;
    const uint patchID = (tID.x / patchInfo.numControlPointsPerPatch);
    const bool patchValid = (patchID < patchInfo.numPatches);
    const uint mtl_BaseInstance = 0;
    const uint mtl_InstanceID = groupID.y - mtl_BaseInstance;
    const uint internalPatchID = mtl_InstanceID * patchInfo.numPatches + patchID;
    const uint patchIDInThreadGroup = (patchID % numPatchesInThreadGroup);
    const uint controlPointID = (tID.x % patchInfo.numControlPointsPerPatch);
    const uint mtl_BaseVertex = 0;
    const uint mtl_VertexID = ((mtl_InstanceID * (patchInfo.numControlPointsPerPatch * patchInfo.numPatches)) + tID.x) - mtl_BaseVertex;
    threadgroup Mtl_HullIn inputGroup[numPatchesInThreadGroup];
    threadgroup Mtl_HullIn &input = inputGroup[patchIDInThreadGroup];
    MTLTriangleTessellationFactorsHalf tessFactor;
    if (patchValid) {
        input.cp[controlPointID] = vertexFunction(vertexInput);
        output.INTERNALTESSPOS0 = input.cp[controlPointID].INTERNALTESSPOS0;
        output.TANGENT0 = input.cp[controlPointID].TANGENT0;
        output.NORMAL0 = input.cp[controlPointID].NORMAL0;
        output.TEXCOORD0 = input.cp[controlPointID].TEXCOORD0;
        output.TEXCOORD1 = input.cp[controlPointID].TEXCOORD1;
        output.TEXCOORD2 = input.cp[controlPointID].TEXCOORD2;
        output.TEXCOORD3 = input.cp[controlPointID].TEXCOORD3;
        output.COLOR0 = input.cp[controlPointID].COLOR0;
    }
    threadgroup_barrier(mem_flags::mem_threadgroup);
    if (!patchValid) {
        return;
    }
    float3 u_xlat0;
    float3 u_xlat1;
    float3 u_xlat2;
    float3 u_xlat3;
    float3 u_xlat4;
    float u_xlat12;
    float u_xlat13;
    // fork_phase2
    {
        u_xlat0.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[1].INTERNALTESSPOS0.yyy;
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[1].INTERNALTESSPOS0.xxx, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[1].INTERNALTESSPOS0.zzz, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[1].INTERNALTESSPOS0.www, u_xlat0.xyz);
        u_xlat1.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[2].INTERNALTESSPOS0.yyy;
        u_xlat1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[2].INTERNALTESSPOS0.xxx, u_xlat1.xyz);
        u_xlat1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[2].INTERNALTESSPOS0.zzz, u_xlat1.xyz);
        u_xlat1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[2].INTERNALTESSPOS0.www, u_xlat1.xyz);
        u_xlat2.xyz = u_xlat0.xyz + u_xlat1.xyz;
        u_xlat2.xyz = fma(u_xlat2.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat12 = dot(u_xlat2.xyz, u_xlat2.xyz);
        u_xlat12 = sqrt(u_xlat12);
        u_xlat12 = u_xlat12 * VGlobals._EdgeLength;
        u_xlat2.xyz = u_xlat0.xyz + (-u_xlat1.xyz);
        u_xlat13 = dot(u_xlat2.xyz, u_xlat2.xyz);
        u_xlat13 = sqrt(u_xlat13);
        u_xlat13 = u_xlat13 * VGlobals._ScreenParams.y;
        u_xlat12 = u_xlat13 / u_xlat12;
        tessFactor.edgeTessellationFactor[0] = max(u_xlat12, 1.0);
        u_xlat2.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[0].INTERNALTESSPOS0.yyy;
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[0].INTERNALTESSPOS0.xxx, u_xlat2.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[0].INTERNALTESSPOS0.zzz, u_xlat2.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[0].INTERNALTESSPOS0.www, u_xlat2.xyz);
        u_xlat3.xyz = u_xlat1.xyz + u_xlat2.xyz;
        u_xlat1.xyz = u_xlat1.xyz + (-u_xlat2.xyz);
        u_xlat12 = dot(u_xlat1.xyz, u_xlat1.xyz);
        u_xlat12 = sqrt(u_xlat12);
        u_xlat12 = u_xlat12 * VGlobals._ScreenParams.y;
        u_xlat1.xyz = fma(u_xlat3.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat1.x = dot(u_xlat1.xyz, u_xlat1.xyz);
        u_xlat1.x = sqrt(u_xlat1.x);
        u_xlat1.x = u_xlat1.x * VGlobals._EdgeLength;
        u_xlat12 = u_xlat12 / u_xlat1.x;
        tessFactor.edgeTessellationFactor[1] = max(u_xlat12, 1.0);
        u_xlat1.xyz = u_xlat0.xyz + u_xlat2.xyz;
        u_xlat0.xyz = (-u_xlat0.xyz) + u_xlat2.xyz;
        u_xlat0.x = dot(u_xlat0.xyz, u_xlat0.xyz);
        u_xlat0.x = sqrt(u_xlat0.x);
        u_xlat0.x = u_xlat0.x * VGlobals._ScreenParams.y;
        u_xlat4.xyz = fma(u_xlat1.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat4.x = dot(u_xlat4.xyz, u_xlat4.xyz);
        u_xlat4.x = sqrt(u_xlat4.x);
        u_xlat4.x = u_xlat4.x * VGlobals._EdgeLength;
        u_xlat0.x = u_xlat0.x / u_xlat4.x;
        tessFactor.edgeTessellationFactor[2] = max(u_xlat0.x, 1.0);
    }
    // join_phase3
    {
        u_xlat0.x = tessFactor.edgeTessellationFactor[0] + tessFactor.edgeTessellationFactor[1];
        u_xlat0.x = u_xlat0.x + tessFactor.edgeTessellationFactor[2];
        tessFactor.insideTessellationFactor = u_xlat0.x * 0.333333343;
    }
    controlPoints[mtl_VertexID] = output;
    tessFactors[internalPatchID] = tessFactor;
}
// SHADER_STAGE_HULL_end
// SHADER_STAGE_DOMAIN_begin
struct Mtl_VertexInPostTess
{
    patch_control_point<Mtl_ControlPointIn> cp;
};
struct Mtl_VertexOutPostTess
{
    float4 mtl_Position [[ position ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float4 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float4 TEXCOORD3 [[ user(TEXCOORD3) ]];
    float4 TEXCOORD5 [[ user(TEXCOORD5) ]];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    sampler sampler_Height [[ sampler (0) ]],
    texture2d<float, access::sample > _Height [[ texture(0) ]] ,
    float3 mtl_TessCoord [[ position_in_patch ]],
    uint patchID [[ patch_id ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    Mtl_VertexInPostTess input [[ stage_in ]])
{
#pragma clang diagnostic pop
    Mtl_VertexOutPostTess output;
    MTLTriangleTessellationFactorsHalf tessFactor;
    tessFactor = tessFactors[patchID];
    float4 u_xlat0;
    float4 u_xlat1;
    float4 u_xlat2;
    float4 u_xlat3;
    float2 u_xlat9;
    float u_xlat12;
    float u_xlat13;
    u_xlat0 = mtl_TessCoord.yyyy * input.cp[1].INTERNALTESSPOS0;
    u_xlat0 = fma(input.cp[0].INTERNALTESSPOS0, mtl_TessCoord.xxxx, u_xlat0);
    u_xlat0 = fma(input.cp[2].INTERNALTESSPOS0, mtl_TessCoord.zzzz, u_xlat0);
    u_xlat1.xy = mtl_TessCoord.yy * input.cp[1].TEXCOORD0.xy;
    u_xlat1.xy = fma(input.cp[0].TEXCOORD0.xy, mtl_TessCoord.xx, u_xlat1.xy);
    u_xlat1.xy = fma(input.cp[2].TEXCOORD0.xy, mtl_TessCoord.zz, u_xlat1.xy);
    u_xlat9.xy = u_xlat1.xy * float2(VGlobals._Tile);
    output.TEXCOORD0.xy = fma(u_xlat1.xy, VGlobals._texcoord_ST.xy, VGlobals._texcoord_ST.zw);
    u_xlat1.xyz = _Height.sample(sampler_Height, u_xlat9.xy, level(1.0)).xyz;
    u_xlat2.xyz = mtl_TessCoord.yyy * input.cp[1].NORMAL0.xyz;
    u_xlat2.xyz = fma(input.cp[0].NORMAL0.xyz, mtl_TessCoord.xxx, u_xlat2.xyz);
    u_xlat2.xyz = fma(input.cp[2].NORMAL0.xyz, mtl_TessCoord.zzz, u_xlat2.xyz);
    u_xlat1.xyz = u_xlat1.xyz * u_xlat2.xyz;
    u_xlat0.xyz = fma(u_xlat1.xyz, float3(VGlobals._HeightDisplacement), u_xlat0.xyz);
    u_xlat1 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], u_xlat0.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], u_xlat0.zzzz, u_xlat1);
    u_xlat3 = u_xlat1 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, u_xlat0.www, u_xlat1.xyz);
    u_xlat1 = u_xlat3.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat3.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat3.zzzz, u_xlat1);
    output.mtl_Position = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat3.wwww, u_xlat1);
    u_xlat1.y = dot(u_xlat2.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat1.z = dot(u_xlat2.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat1.x = dot(u_xlat2.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat12 = dot(u_xlat1.xyz, u_xlat1.xyz);
    u_xlat12 = rsqrt(u_xlat12);
    u_xlat1.xyz = float3(u_xlat12) * u_xlat1.xyz;
    output.TEXCOORD1.z = u_xlat1.y;
    u_xlat2 = mtl_TessCoord.yyyy * input.cp[1].TANGENT0;
    u_xlat2 = fma(input.cp[0].TANGENT0, mtl_TessCoord.xxxx, u_xlat2);
    u_xlat2 = fma(input.cp[2].TANGENT0, mtl_TessCoord.zzzz, u_xlat2);
    u_xlat3.xyz = u_xlat2.yyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].yzx;
    u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].yzx, u_xlat2.xxx, u_xlat3.xyz);
    u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].yzx, u_xlat2.zzz, u_xlat3.xyz);
    u_xlat12 = u_xlat2.w * VGlobals.unity_WorldTransformParams.w;
    u_xlat13 = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat13 = rsqrt(u_xlat13);
    u_xlat2.xyz = float3(u_xlat13) * u_xlat2.xyz;
    u_xlat3.xyz = u_xlat1.xyz * u_xlat2.xyz;
    u_xlat3.xyz = fma(u_xlat1.zxy, u_xlat2.yzx, (-u_xlat3.xyz));
    u_xlat3.xyz = float3(u_xlat12) * u_xlat3.xyz;
    output.TEXCOORD1.y = u_xlat3.x;
    output.TEXCOORD1.w = u_xlat0.x;
    output.TEXCOORD1.x = u_xlat2.z;
    output.TEXCOORD2.w = u_xlat0.y;
    output.TEXCOORD3.w = u_xlat0.z;
    output.TEXCOORD2.x = u_xlat2.x;
    output.TEXCOORD3.x = u_xlat2.y;
    output.TEXCOORD2.z = u_xlat1.z;
    output.TEXCOORD3.z = u_xlat1.x;
    output.TEXCOORD2.y = u_xlat3.y;
    output.TEXCOORD3.y = u_xlat3.z;
    output.TEXCOORD5 = float4(0.0, 0.0, 0.0, 0.0);
    return output;
}
// SHADER_STAGE_DOMAIN_end
Compilation succeeded with: 

program_source:303:53: warning: writable resources in non-void post-tessellation vertex function
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
                                                    ^
program_source:309:30: note: writable buffer defined here
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
                             ^
program_source:310:48: note: writable buffer defined here
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
                                               ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float4 TEXCOORD0 [[ attribute(3) ]] ;
    float4 TEXCOORD1 [[ attribute(4) ]] ;
    float4 TEXCOORD2 [[ attribute(5) ]] ;
    float4 TEXCOORD3 [[ attribute(6) ]] ;
    float4 COLOR0 [[ attribute(7) ]] ;
};
struct Mtl_VertexOut
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float4 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float4 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float4 TEXCOORD3 [[ user(TEXCOORD3) ]];
    float4 COLOR0 [[ user(COLOR0) ]];
};
static Mtl_VertexOut vertexFunction(
    Mtl_VertexIn input)
{
    Mtl_VertexOut output;
    output.INTERNALTESSPOS0 = input.POSITION0;
    output.TANGENT0 = input.TANGENT0;
    output.NORMAL0.xyz = input.NORMAL0.xyz;
    output.TEXCOORD0 = input.TEXCOORD0;
    output.TEXCOORD1 = input.TEXCOORD1;
    output.TEXCOORD2 = input.TEXCOORD2;
    output.TEXCOORD3 = input.TEXCOORD3;
    output.COLOR0 = input.COLOR0;
    return output;
}
// SHADER_STAGE_HULL_begin
struct Mtl_ControlPoint
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float4 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float4 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float4 TEXCOORD3 [[ user(TEXCOORD3) ]];
    float4 COLOR0 [[ user(COLOR0) ]];
};
struct Mtl_ControlPointIn
{
    float4 INTERNALTESSPOS0 [[ attribute(8) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float4 TEXCOORD0 [[ attribute(3) ]] ;
    float4 TEXCOORD1 [[ attribute(4) ]] ;
    float4 TEXCOORD2 [[ attribute(5) ]] ;
    float4 TEXCOORD3 [[ attribute(6) ]] ;
    float4 COLOR0 [[ attribute(7) ]] ;
};
struct Mtl_KernelPatchInfo
{
    uint numPatches;
    ushort numControlPointsPerPatch;
};
struct VGlobals_Type
{
    float4 _Time;
    float4 _SinTime;
    float4 _CosTime;
    float4 unity_DeltaTime;
    float3 _WorldSpaceCameraPos;
    float4 _ProjectionParams;
    float4 _ScreenParams;
    float4 _ZBufferParams;
    float4 unity_OrthoParams;
    float4 unity_CameraWorldClipPlanes[6];
    float4 hlslcc_mtx4x4unity_CameraProjection[4];
    float4 hlslcc_mtx4x4unity_CameraInvProjection[4];
    float4 hlslcc_mtx4x4unity_WorldToCamera[4];
    float4 hlslcc_mtx4x4unity_CameraToWorld[4];
    float4 _WorldSpaceLightPos0;
    float4 _LightPositionRange;
    float4 _LightProjectionParams;
    float4 unity_4LightPosX0;
    float4 unity_4LightPosY0;
    float4 unity_4LightPosZ0;
    float4 unity_4LightAtten0;
    float4 unity_LightColor[8];
    float4 unity_LightPosition[8];
    float4 unity_LightAtten[8];
    float4 unity_SpotDirection[8];
    float4 unity_SHAr;
    float4 unity_SHAg;
    float4 unity_SHAb;
    float4 unity_SHBr;
    float4 unity_SHBg;
    float4 unity_SHBb;
    float4 unity_SHC;
    float4 unity_OcclusionMaskSelector;
    float4 unity_ProbesOcclusion;
    float3 unity_LightColor0;
    float3 unity_LightColor1;
    float3 unity_LightColor2;
    float3 unity_LightColor3;
    float4 unity_ShadowSplitSpheres[4];
    float4 unity_ShadowSplitSqRadii;
    float4 unity_LightShadowBias;
    float4 _LightSplitsNear;
    float4 _LightSplitsFar;
    float4 hlslcc_mtx4x4unity_WorldToShadow[16];
    float4 _LightShadowData;
    float4 unity_ShadowFadeCenterAndType;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 unity_LODFade;
    float4 unity_WorldTransformParams;
    float4 unity_RenderingLayer;
    float4 hlslcc_mtx4x4glstate_matrix_transpose_modelview0[4];
    float4 glstate_lightmodel_ambient;
    float4 unity_AmbientSky;
    float4 unity_AmbientEquator;
    float4 unity_AmbientGround;
    float4 unity_IndirectSpecColor;
    float4 hlslcc_mtx4x4glstate_matrix_projection[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixInvV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    int unity_StereoEyeIndex;
    float4 unity_ShadowColor;
    float4 unity_FogColor;
    float4 unity_FogParams;
    float4 unity_LightmapST;
    float4 unity_DynamicLightmapST;
    float4 unity_SpecCube0_BoxMax;
    float4 unity_SpecCube0_BoxMin;
    float4 unity_SpecCube0_ProbePosition;
    float4 unity_SpecCube0_HDR;
    float4 unity_SpecCube1_BoxMax;
    float4 unity_SpecCube1_BoxMin;
    float4 unity_SpecCube1_ProbePosition;
    float4 unity_SpecCube1_HDR;
    float4 unity_ProbeVolumeParams;
    float4 hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[4];
    float3 unity_ProbeVolumeSizeInv;
    float3 unity_ProbeVolumeMin;
    float4 unity_Lightmap_HDR;
    float4 unity_DynamicLightmap_HDR;
    float4 _LightColor0;
    float4 _SpecColor;
    float _Tile;
    float _HeightDisplacement;
    float _NormalScale;
    float4 _ColorTint;
    float _MetallicStrength;
    float _SmoothnessStrength;
    float _EdgeLength;
    bool4 unity_MetaVertexControl;
    bool4 unity_MetaFragmentControl;
    int unity_VisualizationMode;
    float unity_OneOverOutputBoost;
    float unity_MaxOutputValue;
    float unity_UseLinearSpace;
    float4 _texcoord_ST;
};
struct Mtl_HullIn
{
    Mtl_VertexOut cp[3];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
kernel void patchKernel(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn vertexInput [[ stage_in ]],
    uint2 tID [[ thread_position_in_grid ]],
    ushort2 groupID [[ threadgroup_position_in_grid ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    constant Mtl_KernelPatchInfo &patchInfo [[ buffer(3) ]])
{
#pragma clang diagnostic pop
    Mtl_ControlPoint output;
    const uint numPatchesInThreadGroup = 10;
    const uint patchID = (tID.x / patchInfo.numControlPointsPerPatch);
    const bool patchValid = (patchID < patchInfo.numPatches);
    const uint mtl_BaseInstance = 0;
    const uint mtl_InstanceID = groupID.y - mtl_BaseInstance;
    const uint internalPatchID = mtl_InstanceID * patchInfo.numPatches + patchID;
    const uint patchIDInThreadGroup = (patchID % numPatchesInThreadGroup);
    const uint controlPointID = (tID.x % patchInfo.numControlPointsPerPatch);
    const uint mtl_BaseVertex = 0;
    const uint mtl_VertexID = ((mtl_InstanceID * (patchInfo.numControlPointsPerPatch * patchInfo.numPatches)) + tID.x) - mtl_BaseVertex;
    threadgroup Mtl_HullIn inputGroup[numPatchesInThreadGroup];
    threadgroup Mtl_HullIn &input = inputGroup[patchIDInThreadGroup];
    MTLTriangleTessellationFactorsHalf tessFactor;
    if (patchValid) {
        input.cp[controlPointID] = vertexFunction(vertexInput);
        output.INTERNALTESSPOS0 = input.cp[controlPointID].INTERNALTESSPOS0;
        output.TANGENT0 = input.cp[controlPointID].TANGENT0;
        output.NORMAL0 = input.cp[controlPointID].NORMAL0;
        output.TEXCOORD0 = input.cp[controlPointID].TEXCOORD0;
        output.TEXCOORD1 = input.cp[controlPointID].TEXCOORD1;
        output.TEXCOORD2 = input.cp[controlPointID].TEXCOORD2;
        output.TEXCOORD3 = input.cp[controlPointID].TEXCOORD3;
        output.COLOR0 = input.cp[controlPointID].COLOR0;
    }
    threadgroup_barrier(mem_flags::mem_threadgroup);
    if (!patchValid) {
        return;
    }
    float3 u_xlat0;
    float3 u_xlat1;
    float3 u_xlat2;
    float3 u_xlat3;
    float3 u_xlat4;
    float u_xlat12;
    float u_xlat13;
    // fork_phase2
    {
        u_xlat0.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[1].INTERNALTESSPOS0.yyy;
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[1].INTERNALTESSPOS0.xxx, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[1].INTERNALTESSPOS0.zzz, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[1].INTERNALTESSPOS0.www, u_xlat0.xyz);
        u_xlat1.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[2].INTERNALTESSPOS0.yyy;
        u_xlat1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[2].INTERNALTESSPOS0.xxx, u_xlat1.xyz);
        u_xlat1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[2].INTERNALTESSPOS0.zzz, u_xlat1.xyz);
        u_xlat1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[2].INTERNALTESSPOS0.www, u_xlat1.xyz);
        u_xlat2.xyz = u_xlat0.xyz + u_xlat1.xyz;
        u_xlat2.xyz = fma(u_xlat2.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat12 = dot(u_xlat2.xyz, u_xlat2.xyz);
        u_xlat12 = sqrt(u_xlat12);
        u_xlat12 = u_xlat12 * VGlobals._EdgeLength;
        u_xlat2.xyz = u_xlat0.xyz + (-u_xlat1.xyz);
        u_xlat13 = dot(u_xlat2.xyz, u_xlat2.xyz);
        u_xlat13 = sqrt(u_xlat13);
        u_xlat13 = u_xlat13 * VGlobals._ScreenParams.y;
        u_xlat12 = u_xlat13 / u_xlat12;
        tessFactor.edgeTessellationFactor[0] = max(u_xlat12, 1.0);
        u_xlat2.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[0].INTERNALTESSPOS0.yyy;
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[0].INTERNALTESSPOS0.xxx, u_xlat2.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[0].INTERNALTESSPOS0.zzz, u_xlat2.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[0].INTERNALTESSPOS0.www, u_xlat2.xyz);
        u_xlat3.xyz = u_xlat1.xyz + u_xlat2.xyz;
        u_xlat1.xyz = u_xlat1.xyz + (-u_xlat2.xyz);
        u_xlat12 = dot(u_xlat1.xyz, u_xlat1.xyz);
        u_xlat12 = sqrt(u_xlat12);
        u_xlat12 = u_xlat12 * VGlobals._ScreenParams.y;
        u_xlat1.xyz = fma(u_xlat3.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat1.x = dot(u_xlat1.xyz, u_xlat1.xyz);
        u_xlat1.x = sqrt(u_xlat1.x);
        u_xlat1.x = u_xlat1.x * VGlobals._EdgeLength;
        u_xlat12 = u_xlat12 / u_xlat1.x;
        tessFactor.edgeTessellationFactor[1] = max(u_xlat12, 1.0);
        u_xlat1.xyz = u_xlat0.xyz + u_xlat2.xyz;
        u_xlat0.xyz = (-u_xlat0.xyz) + u_xlat2.xyz;
        u_xlat0.x = dot(u_xlat0.xyz, u_xlat0.xyz);
        u_xlat0.x = sqrt(u_xlat0.x);
        u_xlat0.x = u_xlat0.x * VGlobals._ScreenParams.y;
        u_xlat4.xyz = fma(u_xlat1.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat4.x = dot(u_xlat4.xyz, u_xlat4.xyz);
        u_xlat4.x = sqrt(u_xlat4.x);
        u_xlat4.x = u_xlat4.x * VGlobals._EdgeLength;
        u_xlat0.x = u_xlat0.x / u_xlat4.x;
        tessFactor.edgeTessellationFactor[2] = max(u_xlat0.x, 1.0);
    }
    // join_phase3
    {
        u_xlat0.x = tessFactor.edgeTessellationFactor[0] + tessFactor.edgeTessellationFactor[1];
        u_xlat0.x = u_xlat0.x + tessFactor.edgeTessellationFactor[2];
        tessFactor.insideTessellationFactor = u_xlat0.x * 0.333333343;
    }
    controlPoints[mtl_VertexID] = output;
    tessFactors[internalPatchID] = tessFactor;
}
// SHADER_STAGE_HULL_end
// SHADER_STAGE_DOMAIN_begin
struct Mtl_VertexInPostTess
{
    patch_control_point<Mtl_ControlPointIn> cp;
};
struct Mtl_VertexOutPostTess
{
    float4 mtl_Position [[ position ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float4 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float4 TEXCOORD3 [[ user(TEXCOORD3) ]];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    sampler sampler_Height [[ sampler (0) ]],
    texture2d<float, access::sample > _Height [[ texture(0) ]] ,
    float3 mtl_TessCoord [[ position_in_patch ]],
    uint patchID [[ patch_id ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    Mtl_VertexInPostTess input [[ stage_in ]])
{
#pragma clang diagnostic pop
    Mtl_VertexOutPostTess output;
    MTLTriangleTessellationFactorsHalf tessFactor;
    tessFactor = tessFactors[patchID];
    float4 u_xlat0;
    float4 u_xlat1;
    float4 u_xlat2;
    float3 u_xlat3;
    float3 u_xlat4;
    float2 u_xlat13;
    float u_xlat15;
    bool u_xlatb15;
    u_xlat0.xy = mtl_TessCoord.yy * input.cp[1].TEXCOORD2.xy;
    u_xlat0.xy = fma(input.cp[0].TEXCOORD2.xy, mtl_TessCoord.xx, u_xlat0.xy);
    u_xlat0.xy = fma(input.cp[2].TEXCOORD2.xy, mtl_TessCoord.zz, u_xlat0.xy);
    u_xlat0.xy = fma(u_xlat0.xy, VGlobals.unity_DynamicLightmapST.xy, VGlobals.unity_DynamicLightmapST.zw);
    u_xlat1.xy = mtl_TessCoord.yy * input.cp[1].TEXCOORD1.xy;
    u_xlat1.xy = fma(input.cp[0].TEXCOORD1.xy, mtl_TessCoord.xx, u_xlat1.xy);
    u_xlat1.xy = fma(input.cp[2].TEXCOORD1.xy, mtl_TessCoord.zz, u_xlat1.xy);
    u_xlat1.xy = fma(u_xlat1.xy, VGlobals.unity_LightmapST.xy, VGlobals.unity_LightmapST.zw);
    u_xlat2 = mtl_TessCoord.yyyy * input.cp[1].INTERNALTESSPOS0;
    u_xlat2 = fma(input.cp[0].INTERNALTESSPOS0, mtl_TessCoord.xxxx, u_xlat2);
    u_xlat2 = fma(input.cp[2].INTERNALTESSPOS0, mtl_TessCoord.zzzz, u_xlat2);
    u_xlat3.xy = mtl_TessCoord.yy * input.cp[1].TEXCOORD0.xy;
    u_xlat3.xy = fma(input.cp[0].TEXCOORD0.xy, mtl_TessCoord.xx, u_xlat3.xy);
    u_xlat3.xy = fma(input.cp[2].TEXCOORD0.xy, mtl_TessCoord.zz, u_xlat3.xy);
    u_xlat13.xy = u_xlat3.xy * float2(VGlobals._Tile);
    output.TEXCOORD0.xy = fma(u_xlat3.xy, VGlobals._texcoord_ST.xy, VGlobals._texcoord_ST.zw);
    u_xlat3.xyz = _Height.sample(sampler_Height, u_xlat13.xy, level(1.0)).xyz;
    u_xlat4.xyz = mtl_TessCoord.yyy * input.cp[1].NORMAL0.xyz;
    u_xlat4.xyz = fma(input.cp[0].NORMAL0.xyz, mtl_TessCoord.xxx, u_xlat4.xyz);
    u_xlat4.xyz = fma(input.cp[2].NORMAL0.xyz, mtl_TessCoord.zzz, u_xlat4.xyz);
    u_xlat3.xyz = u_xlat3.xyz * u_xlat4.xyz;
    u_xlat2.xyz = fma(u_xlat3.xyz, float3(VGlobals._HeightDisplacement), u_xlat2.xyz);
    u_xlatb15 = 0.0<u_xlat2.z;
    u_xlat1.z = u_xlatb15 ? 9.99999975e-05 : float(0.0);
    u_xlat1.xyz = (VGlobals.unity_MetaVertexControl.x) ? u_xlat1.xyz : u_xlat2.xyz;
    u_xlatb15 = 0.0<u_xlat1.z;
    u_xlat0.z = u_xlatb15 ? 9.99999975e-05 : float(0.0);
    u_xlat0.xyz = (VGlobals.unity_MetaVertexControl.y) ? u_xlat0.xyz : u_xlat1.xyz;
    u_xlat1 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat0.xxxx, u_xlat1);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat0.zzzz, u_xlat1);
    output.mtl_Position = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_MatrixVP[3];
    u_xlat0.xyz = u_xlat2.yyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz;
    u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, u_xlat2.xxx, u_xlat0.xyz);
    u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, u_xlat2.zzz, u_xlat0.xyz);
    u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, u_xlat2.www, u_xlat0.xyz);
    output.TEXCOORD1.w = u_xlat0.x;
    u_xlat1.y = dot(u_xlat4.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat1.z = dot(u_xlat4.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat1.x = dot(u_xlat4.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat0.x = dot(u_xlat1.xyz, u_xlat1.xyz);
    u_xlat0.x = rsqrt(u_xlat0.x);
    u_xlat1.xyz = u_xlat0.xxx * u_xlat1.xyz;
    output.TEXCOORD1.z = u_xlat1.y;
    u_xlat2 = mtl_TessCoord.yyyy * input.cp[1].TANGENT0;
    u_xlat2 = fma(input.cp[0].TANGENT0, mtl_TessCoord.xxxx, u_xlat2);
    u_xlat2 = fma(input.cp[2].TANGENT0, mtl_TessCoord.zzzz, u_xlat2);
    u_xlat3.xyz = u_xlat2.yyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].yzx;
    u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].yzx, u_xlat2.xxx, u_xlat3.xyz);
    u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].yzx, u_xlat2.zzz, u_xlat3.xyz);
    u_xlat0.x = u_xlat2.w * VGlobals.unity_WorldTransformParams.w;
    u_xlat15 = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat15 = rsqrt(u_xlat15);
    u_xlat2.xyz = float3(u_xlat15) * u_xlat2.xyz;
    u_xlat3.xyz = u_xlat1.xyz * u_xlat2.xyz;
    u_xlat3.xyz = fma(u_xlat1.zxy, u_xlat2.yzx, (-u_xlat3.xyz));
    u_xlat3.xyz = u_xlat0.xxx * u_xlat3.xyz;
    output.TEXCOORD1.y = u_xlat3.x;
    output.TEXCOORD1.x = u_xlat2.z;
    output.TEXCOORD2.w = u_xlat0.y;
    output.TEXCOORD3.w = u_xlat0.z;
    output.TEXCOORD2.x = u_xlat2.x;
    output.TEXCOORD3.x = u_xlat2.y;
    output.TEXCOORD2.z = u_xlat1.z;
    output.TEXCOORD3.z = u_xlat1.x;
    output.TEXCOORD2.y = u_xlat3.y;
    output.TEXCOORD3.y = u_xlat3.z;
    return output;
}
// SHADER_STAGE_DOMAIN_end
Refreshing native plugins compatible for Editor in 2.58 ms, found 2 plugins.
Preloading 0 native plugins for Editor in 0.00 ms.
Unloading 3375 Unused Serialized files (Serialized files now loaded: 0)
Unloading 20 unused Assets / (0.6 MB). Loaded Objects now: 3913.
Memory consumption went from 136.4 MB to 135.8 MB.
Total: 5.070244 ms (FindLiveObjects: 0.365706 ms CreateObjectMapping: 0.351836 ms MarkObjects: 3.829030 ms  DeleteObjects: 0.522296 ms)

AssetImportParameters requested are different than current active one (requested -> active):
  custom:video-decoder-ogg-theora: a1e56fd34408186e4bbccfd4996cb3dc -> 
  custom:container-muxer-webm: aa71ff27fc2769a1b78a27578f13a17b -> 
  custom:container-demuxer-webm: 4f35f7cbe854078d1ac9338744f61a02 -> 
  custom:video-encoder-webm-vp8: eb34c28f22e8b96e1ab97ce403110664 -> 
  custom:framework-osx-AVFoundation: b23960f63f64bdc6ff669e2cdcee2391 -> 
  custom:audio-encoder-webm-vorbis: bf7c407c2cedff20999df2af8eb42d56 -> 
  custom:container-demuxer-ogg: 62fdf1f143b41e24485cea50d1cbac27 -> 
  custom:video-decoder-webm-vp8: 9c59270c3fd7afecdb556c50c9e8de78 -> 
  custom:audio-decoder-ogg-vorbis: bf7c407c2cedff20999df2af8eb42d56 -> 
========================================================================
Received Prepare
Registering precompiled user dll's ...
Registered in 0.003560 seconds.
Begin MonoManager ReloadAssembly
Symbol file LoadedFromMemory doesn't match image /Users/kamilaamendolagine/Desktop/Staugen Raug v2 - Prefab - Map 1.01/Library/PackageCache/com.unity.visualscripting@1.7.8/Editor/VisualScripting.Core/Dependencies/YamlDotNet/Unity.VisualScripting.YamlDotNet.dll
Symbol file LoadedFromMemory doesn't match image /Users/kamilaamendolagine/Desktop/Staugen Raug v2 - Prefab - Map 1.01/Library/PackageCache/com.unity.visualscripting@1.7.8/Editor/VisualScripting.Core/Dependencies/DotNetZip/Unity.VisualScripting.IonicZip.dll
Native extension for OSXStandalone target not found
Native extension for WebGL target not found
Refreshing native plugins compatible for Editor in 0.99 ms, found 2 plugins.
Preloading 0 native plugins for Editor in 0.00 ms.
Mono: successfully reloaded assembly
- Completed reload, in  1.854 seconds
Domain Reload Profiling:
	ReloadAssembly (1855ms)
		BeginReloadAssembly (200ms)
			ExecutionOrderSort (0ms)
			DisableScriptedObjects (10ms)
			BackupInstance (0ms)
			ReleaseScriptingObjects (0ms)
			CreateAndSetChildDomain (85ms)
		EndReloadAssembly (1486ms)
			LoadAssemblies (91ms)
			RebuildTransferFunctionScriptingTraits (0ms)
			SetupTypeCache (500ms)
			ReleaseScriptCaches (2ms)
			RebuildScriptCaches (85ms)
			SetupLoadedEditorAssemblies (695ms)
				LogAssemblyErrors (0ms)
				InitializePlatformSupportModulesInManaged (20ms)
				SetLoadedEditorAssemblies (1ms)
				RefreshPlugins (1ms)
				BeforeProcessingInitializeOnLoad (106ms)
				ProcessInitializeOnLoadAttributes (511ms)
				ProcessInitializeOnLoadMethodAttributes (50ms)
				AfterProcessingInitializeOnLoad (5ms)
				EditorAssembliesLoaded (0ms)
			ExecutionOrderSort2 (0ms)
			AwakeInstancesAfterBackupRestoration (9ms)
Platform modules already initialized, skipping
Compilation succeeded with: 

program_source:299:53: warning: writable resources in non-void post-tessellation vertex function
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
                                                    ^
program_source:305:30: note: writable buffer defined here
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
                             ^
program_source:306:48: note: writable buffer defined here
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
                                               ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float4 TEXCOORD0 [[ attribute(3) ]] ;
    float4 TEXCOORD1 [[ attribute(4) ]] ;
    float4 TEXCOORD2 [[ attribute(5) ]] ;
    float4 TEXCOORD3 [[ attribute(6) ]] ;
    float4 COLOR0 [[ attribute(7) ]] ;
};
struct Mtl_VertexOut
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float4 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float4 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float4 TEXCOORD3 [[ user(TEXCOORD3) ]];
    float4 COLOR0 [[ user(COLOR0) ]];
};
static Mtl_VertexOut vertexFunction(
    Mtl_VertexIn input)
{
    Mtl_VertexOut output;
    output.INTERNALTESSPOS0 = input.POSITION0;
    output.TANGENT0 = input.TANGENT0;
    output.NORMAL0.xyz = input.NORMAL0.xyz;
    output.TEXCOORD0 = input.TEXCOORD0;
    output.TEXCOORD1 = input.TEXCOORD1;
    output.TEXCOORD2 = input.TEXCOORD2;
    output.TEXCOORD3 = input.TEXCOORD3;
    output.COLOR0 = input.COLOR0;
    return output;
}
// SHADER_STAGE_HULL_begin
struct Mtl_ControlPoint
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float4 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float4 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float4 TEXCOORD3 [[ user(TEXCOORD3) ]];
    float4 COLOR0 [[ user(COLOR0) ]];
};
struct Mtl_ControlPointIn
{
    float4 INTERNALTESSPOS0 [[ attribute(8) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float4 TEXCOORD0 [[ attribute(3) ]] ;
    float4 TEXCOORD1 [[ attribute(4) ]] ;
    float4 TEXCOORD2 [[ attribute(5) ]] ;
    float4 TEXCOORD3 [[ attribute(6) ]] ;
    float4 COLOR0 [[ attribute(7) ]] ;
};
struct Mtl_KernelPatchInfo
{
    uint numPatches;
    ushort numControlPointsPerPatch;
};
struct VGlobals_Type
{
    float4 _Time;
    float4 _SinTime;
    float4 _CosTime;
    float4 unity_DeltaTime;
    float3 _WorldSpaceCameraPos;
    float4 _ProjectionParams;
    float4 _ScreenParams;
    float4 _ZBufferParams;
    float4 unity_OrthoParams;
    float4 unity_CameraWorldClipPlanes[6];
    float4 hlslcc_mtx4x4unity_CameraProjection[4];
    float4 hlslcc_mtx4x4unity_CameraInvProjection[4];
    float4 hlslcc_mtx4x4unity_WorldToCamera[4];
    float4 hlslcc_mtx4x4unity_CameraToWorld[4];
    float4 _WorldSpaceLightPos0;
    float4 _LightPositionRange;
    float4 _LightProjectionParams;
    float4 unity_4LightPosX0;
    float4 unity_4LightPosY0;
    float4 unity_4LightPosZ0;
    float4 unity_4LightAtten0;
    float4 unity_LightColor[8];
    float4 unity_LightPosition[8];
    float4 unity_LightAtten[8];
    float4 unity_SpotDirection[8];
    float4 unity_SHAr;
    float4 unity_SHAg;
    float4 unity_SHAb;
    float4 unity_SHBr;
    float4 unity_SHBg;
    float4 unity_SHBb;
    float4 unity_SHC;
    float4 unity_OcclusionMaskSelector;
    float4 unity_ProbesOcclusion;
    float3 unity_LightColor0;
    float3 unity_LightColor1;
    float3 unity_LightColor2;
    float3 unity_LightColor3;
    float4 unity_ShadowSplitSpheres[4];
    float4 unity_ShadowSplitSqRadii;
    float4 unity_LightShadowBias;
    float4 _LightSplitsNear;
    float4 _LightSplitsFar;
    float4 hlslcc_mtx4x4unity_WorldToShadow[16];
    float4 _LightShadowData;
    float4 unity_ShadowFadeCenterAndType;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 unity_LODFade;
    float4 unity_WorldTransformParams;
    float4 unity_RenderingLayer;
    float4 hlslcc_mtx4x4glstate_matrix_transpose_modelview0[4];
    float4 glstate_lightmodel_ambient;
    float4 unity_AmbientSky;
    float4 unity_AmbientEquator;
    float4 unity_AmbientGround;
    float4 unity_IndirectSpecColor;
    float4 hlslcc_mtx4x4glstate_matrix_projection[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixInvV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    int unity_StereoEyeIndex;
    float4 unity_ShadowColor;
    float4 unity_FogColor;
    float4 unity_FogParams;
    float4 unity_LightmapST;
    float4 unity_DynamicLightmapST;
    float4 unity_SpecCube0_BoxMax;
    float4 unity_SpecCube0_BoxMin;
    float4 unity_SpecCube0_ProbePosition;
    float4 unity_SpecCube0_HDR;
    float4 unity_SpecCube1_BoxMax;
    float4 unity_SpecCube1_BoxMin;
    float4 unity_SpecCube1_ProbePosition;
    float4 unity_SpecCube1_HDR;
    float4 unity_ProbeVolumeParams;
    float4 hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[4];
    float3 unity_ProbeVolumeSizeInv;
    float3 unity_ProbeVolumeMin;
    float4 unity_Lightmap_HDR;
    float4 unity_DynamicLightmap_HDR;
    float4 _LightColor0;
    float4 _SpecColor;
    float _Tile;
    float _HeightDisplacement;
    float _NormalScale;
    float4 _ColorTint;
    float _MetallicStrength;
    float _SmoothnessStrength;
    float _EdgeLength;
    float4 _texcoord_ST;
};
struct Mtl_HullIn
{
    Mtl_VertexOut cp[3];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
kernel void patchKernel(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn vertexInput [[ stage_in ]],
    uint2 tID [[ thread_position_in_grid ]],
    ushort2 groupID [[ threadgroup_position_in_grid ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    constant Mtl_KernelPatchInfo &patchInfo [[ buffer(3) ]])
{
#pragma clang diagnostic pop
    Mtl_ControlPoint output;
    const uint numPatchesInThreadGroup = 10;
    const uint patchID = (tID.x / patchInfo.numControlPointsPerPatch);
    const bool patchValid = (patchID < patchInfo.numPatches);
    const uint mtl_BaseInstance = 0;
    const uint mtl_InstanceID = groupID.y - mtl_BaseInstance;
    const uint internalPatchID = mtl_InstanceID * patchInfo.numPatches + patchID;
    const uint patchIDInThreadGroup = (patchID % numPatchesInThreadGroup);
    const uint controlPointID = (tID.x % patchInfo.numControlPointsPerPatch);
    const uint mtl_BaseVertex = 0;
    const uint mtl_VertexID = ((mtl_InstanceID * (patchInfo.numControlPointsPerPatch * patchInfo.numPatches)) + tID.x) - mtl_BaseVertex;
    threadgroup Mtl_HullIn inputGroup[numPatchesInThreadGroup];
    threadgroup Mtl_HullIn &input = inputGroup[patchIDInThreadGroup];
    MTLTriangleTessellationFactorsHalf tessFactor;
    if (patchValid) {
        input.cp[controlPointID] = vertexFunction(vertexInput);
        output.INTERNALTESSPOS0 = input.cp[controlPointID].INTERNALTESSPOS0;
        output.TANGENT0 = input.cp[controlPointID].TANGENT0;
        output.NORMAL0 = input.cp[controlPointID].NORMAL0;
        output.TEXCOORD0 = input.cp[controlPointID].TEXCOORD0;
        output.TEXCOORD1 = input.cp[controlPointID].TEXCOORD1;
        output.TEXCOORD2 = input.cp[controlPointID].TEXCOORD2;
        output.TEXCOORD3 = input.cp[controlPointID].TEXCOORD3;
        output.COLOR0 = input.cp[controlPointID].COLOR0;
    }
    threadgroup_barrier(mem_flags::mem_threadgroup);
    if (!patchValid) {
        return;
    }
    float3 u_xlat0;
    float3 u_xlat1;
    float3 u_xlat2;
    float3 u_xlat3;
    float3 u_xlat4;
    float u_xlat12;
    float u_xlat13;
    // fork_phase2
    {
        u_xlat0.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[1].INTERNALTESSPOS0.yyy;
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[1].INTERNALTESSPOS0.xxx, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[1].INTERNALTESSPOS0.zzz, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[1].INTERNALTESSPOS0.www, u_xlat0.xyz);
        u_xlat1.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[2].INTERNALTESSPOS0.yyy;
        u_xlat1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[2].INTERNALTESSPOS0.xxx, u_xlat1.xyz);
        u_xlat1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[2].INTERNALTESSPOS0.zzz, u_xlat1.xyz);
        u_xlat1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[2].INTERNALTESSPOS0.www, u_xlat1.xyz);
        u_xlat2.xyz = u_xlat0.xyz + u_xlat1.xyz;
        u_xlat2.xyz = fma(u_xlat2.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat12 = dot(u_xlat2.xyz, u_xlat2.xyz);
        u_xlat12 = sqrt(u_xlat12);
        u_xlat12 = u_xlat12 * VGlobals._EdgeLength;
        u_xlat2.xyz = u_xlat0.xyz + (-u_xlat1.xyz);
        u_xlat13 = dot(u_xlat2.xyz, u_xlat2.xyz);
        u_xlat13 = sqrt(u_xlat13);
        u_xlat13 = u_xlat13 * VGlobals._ScreenParams.y;
        u_xlat12 = u_xlat13 / u_xlat12;
        tessFactor.edgeTessellationFactor[0] = max(u_xlat12, 1.0);
        u_xlat2.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[0].INTERNALTESSPOS0.yyy;
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[0].INTERNALTESSPOS0.xxx, u_xlat2.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[0].INTERNALTESSPOS0.zzz, u_xlat2.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[0].INTERNALTESSPOS0.www, u_xlat2.xyz);
        u_xlat3.xyz = u_xlat1.xyz + u_xlat2.xyz;
        u_xlat1.xyz = u_xlat1.xyz + (-u_xlat2.xyz);
        u_xlat12 = dot(u_xlat1.xyz, u_xlat1.xyz);
        u_xlat12 = sqrt(u_xlat12);
        u_xlat12 = u_xlat12 * VGlobals._ScreenParams.y;
        u_xlat1.xyz = fma(u_xlat3.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat1.x = dot(u_xlat1.xyz, u_xlat1.xyz);
        u_xlat1.x = sqrt(u_xlat1.x);
        u_xlat1.x = u_xlat1.x * VGlobals._EdgeLength;
        u_xlat12 = u_xlat12 / u_xlat1.x;
        tessFactor.edgeTessellationFactor[1] = max(u_xlat12, 1.0);
        u_xlat1.xyz = u_xlat0.xyz + u_xlat2.xyz;
        u_xlat0.xyz = (-u_xlat0.xyz) + u_xlat2.xyz;
        u_xlat0.x = dot(u_xlat0.xyz, u_xlat0.xyz);
        u_xlat0.x = sqrt(u_xlat0.x);
        u_xlat0.x = u_xlat0.x * VGlobals._ScreenParams.y;
        u_xlat4.xyz = fma(u_xlat1.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat4.x = dot(u_xlat4.xyz, u_xlat4.xyz);
        u_xlat4.x = sqrt(u_xlat4.x);
        u_xlat4.x = u_xlat4.x * VGlobals._EdgeLength;
        u_xlat0.x = u_xlat0.x / u_xlat4.x;
        tessFactor.edgeTessellationFactor[2] = max(u_xlat0.x, 1.0);
    }
    // join_phase3
    {
        u_xlat0.x = tessFactor.edgeTessellationFactor[0] + tessFactor.edgeTessellationFactor[1];
        u_xlat0.x = u_xlat0.x + tessFactor.edgeTessellationFactor[2];
        tessFactor.insideTessellationFactor = u_xlat0.x * 0.333333343;
    }
    controlPoints[mtl_VertexID] = output;
    tessFactors[internalPatchID] = tessFactor;
}
// SHADER_STAGE_HULL_end
// SHADER_STAGE_DOMAIN_begin
struct Mtl_VertexInPostTess
{
    patch_control_point<Mtl_ControlPointIn> cp;
};
struct Mtl_VertexOutPostTess
{
    float4 mtl_Position [[ position ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float4 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float4 TEXCOORD3 [[ user(TEXCOORD3) ]];
    float4 TEXCOORD6 [[ user(TEXCOORD6) ]];
    float4 TEXCOORD7 [[ user(TEXCOORD7) ]];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    sampler sampler_Height [[ sampler (0) ]],
    texture2d<float, access::sample > _Height [[ texture(0) ]] ,
    float3 mtl_TessCoord [[ position_in_patch ]],
    uint patchID [[ patch_id ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    Mtl_VertexInPostTess input [[ stage_in ]])
{
#pragma clang diagnostic pop
    Mtl_VertexOutPostTess output;
    MTLTriangleTessellationFactorsHalf tessFactor;
    tessFactor = tessFactors[patchID];
    float4 u_xlat0;
    float4 u_xlat1;
    float4 u_xlat2;
    float4 u_xlat3;
    float2 u_xlat9;
    float u_xlat12;
    float u_xlat13;
    u_xlat0 = mtl_TessCoord.yyyy * input.cp[1].INTERNALTESSPOS0;
    u_xlat0 = fma(input.cp[0].INTERNALTESSPOS0, mtl_TessCoord.xxxx, u_xlat0);
    u_xlat0 = fma(input.cp[2].INTERNALTESSPOS0, mtl_TessCoord.zzzz, u_xlat0);
    u_xlat1.xy = mtl_TessCoord.yy * input.cp[1].TEXCOORD0.xy;
    u_xlat1.xy = fma(input.cp[0].TEXCOORD0.xy, mtl_TessCoord.xx, u_xlat1.xy);
    u_xlat1.xy = fma(input.cp[2].TEXCOORD0.xy, mtl_TessCoord.zz, u_xlat1.xy);
    u_xlat9.xy = u_xlat1.xy * float2(VGlobals._Tile);
    output.TEXCOORD0.xy = fma(u_xlat1.xy, VGlobals._texcoord_ST.xy, VGlobals._texcoord_ST.zw);
    u_xlat1.xyz = _Height.sample(sampler_Height, u_xlat9.xy, level(1.0)).xyz;
    u_xlat2.xyz = mtl_TessCoord.yyy * input.cp[1].NORMAL0.xyz;
    u_xlat2.xyz = fma(input.cp[0].NORMAL0.xyz, mtl_TessCoord.xxx, u_xlat2.xyz);
    u_xlat2.xyz = fma(input.cp[2].NORMAL0.xyz, mtl_TessCoord.zzz, u_xlat2.xyz);
    u_xlat1.xyz = u_xlat1.xyz * u_xlat2.xyz;
    u_xlat0.xyz = fma(u_xlat1.xyz, float3(VGlobals._HeightDisplacement), u_xlat0.xyz);
    u_xlat1 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], u_xlat0.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], u_xlat0.zzzz, u_xlat1);
    u_xlat3 = u_xlat1 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, u_xlat0.www, u_xlat1.xyz);
    u_xlat1 = u_xlat3.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat3.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat3.zzzz, u_xlat1);
    output.mtl_Position = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat3.wwww, u_xlat1);
    u_xlat1.y = dot(u_xlat2.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat1.z = dot(u_xlat2.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat1.x = dot(u_xlat2.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat12 = dot(u_xlat1.xyz, u_xlat1.xyz);
    u_xlat12 = rsqrt(u_xlat12);
    u_xlat1.xyz = float3(u_xlat12) * u_xlat1.xyz;
    output.TEXCOORD1.z = u_xlat1.y;
    u_xlat2 = mtl_TessCoord.yyyy * input.cp[1].TANGENT0;
    u_xlat2 = fma(input.cp[0].TANGENT0, mtl_TessCoord.xxxx, u_xlat2);
    u_xlat2 = fma(input.cp[2].TANGENT0, mtl_TessCoord.zzzz, u_xlat2);
    u_xlat3.xyz = u_xlat2.yyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].yzx;
    u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].yzx, u_xlat2.xxx, u_xlat3.xyz);
    u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].yzx, u_xlat2.zzz, u_xlat3.xyz);
    u_xlat12 = u_xlat2.w * VGlobals.unity_WorldTransformParams.w;
    u_xlat13 = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat13 = rsqrt(u_xlat13);
    u_xlat2.xyz = float3(u_xlat13) * u_xlat2.xyz;
    u_xlat3.xyz = u_xlat1.xyz * u_xlat2.xyz;
    u_xlat3.xyz = fma(u_xlat1.zxy, u_xlat2.yzx, (-u_xlat3.xyz));
    u_xlat3.xyz = float3(u_xlat12) * u_xlat3.xyz;
    output.TEXCOORD1.y = u_xlat3.x;
    output.TEXCOORD1.w = u_xlat0.x;
    output.TEXCOORD1.x = u_xlat2.z;
    output.TEXCOORD2.w = u_xlat0.y;
    output.TEXCOORD3.w = u_xlat0.z;
    output.TEXCOORD2.x = u_xlat2.x;
    output.TEXCOORD3.x = u_xlat2.y;
    output.TEXCOORD2.z = u_xlat1.z;
    output.TEXCOORD3.z = u_xlat1.x;
    output.TEXCOORD2.y = u_xlat3.y;
    output.TEXCOORD3.y = u_xlat3.z;
    output.TEXCOORD6 = float4(0.0, 0.0, 0.0, 0.0);
    output.TEXCOORD7 = float4(0.0, 0.0, 0.0, 0.0);
    return output;
}
// SHADER_STAGE_DOMAIN_end
Compilation succeeded with: 

program_source:301:53: warning: writable resources in non-void post-tessellation vertex function
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
                                                    ^
program_source:307:30: note: writable buffer defined here
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
                             ^
program_source:308:48: note: writable buffer defined here
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
                                               ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float4 TEXCOORD0 [[ attribute(3) ]] ;
    float4 TEXCOORD1 [[ attribute(4) ]] ;
    float4 TEXCOORD2 [[ attribute(5) ]] ;
    float4 TEXCOORD3 [[ attribute(6) ]] ;
    float4 COLOR0 [[ attribute(7) ]] ;
};
struct Mtl_VertexOut
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float4 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float4 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float4 TEXCOORD3 [[ user(TEXCOORD3) ]];
    float4 COLOR0 [[ user(COLOR0) ]];
};
static Mtl_VertexOut vertexFunction(
    Mtl_VertexIn input)
{
    Mtl_VertexOut output;
    output.INTERNALTESSPOS0 = input.POSITION0;
    output.TANGENT0 = input.TANGENT0;
    output.NORMAL0.xyz = input.NORMAL0.xyz;
    output.TEXCOORD0 = input.TEXCOORD0;
    output.TEXCOORD1 = input.TEXCOORD1;
    output.TEXCOORD2 = input.TEXCOORD2;
    output.TEXCOORD3 = input.TEXCOORD3;
    output.COLOR0 = input.COLOR0;
    return output;
}
// SHADER_STAGE_HULL_begin
struct Mtl_ControlPoint
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float4 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float4 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float4 TEXCOORD3 [[ user(TEXCOORD3) ]];
    float4 COLOR0 [[ user(COLOR0) ]];
};
struct Mtl_ControlPointIn
{
    float4 INTERNALTESSPOS0 [[ attribute(8) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float4 TEXCOORD0 [[ attribute(3) ]] ;
    float4 TEXCOORD1 [[ attribute(4) ]] ;
    float4 TEXCOORD2 [[ attribute(5) ]] ;
    float4 TEXCOORD3 [[ attribute(6) ]] ;
    float4 COLOR0 [[ attribute(7) ]] ;
};
struct Mtl_KernelPatchInfo
{
    uint numPatches;
    ushort numControlPointsPerPatch;
};
struct VGlobals_Type
{
    float4 _Time;
    float4 _SinTime;
    float4 _CosTime;
    float4 unity_DeltaTime;
    float3 _WorldSpaceCameraPos;
    float4 _ProjectionParams;
    float4 _ScreenParams;
    float4 _ZBufferParams;
    float4 unity_OrthoParams;
    float4 unity_CameraWorldClipPlanes[6];
    float4 hlslcc_mtx4x4unity_CameraProjection[4];
    float4 hlslcc_mtx4x4unity_CameraInvProjection[4];
    float4 hlslcc_mtx4x4unity_WorldToCamera[4];
    float4 hlslcc_mtx4x4unity_CameraToWorld[4];
    float4 _WorldSpaceLightPos0;
    float4 _LightPositionRange;
    float4 _LightProjectionParams;
    float4 unity_4LightPosX0;
    float4 unity_4LightPosY0;
    float4 unity_4LightPosZ0;
    float4 unity_4LightAtten0;
    float4 unity_LightColor[8];
    float4 unity_LightPosition[8];
    float4 unity_LightAtten[8];
    float4 unity_SpotDirection[8];
    float4 unity_SHAr;
    float4 unity_SHAg;
    float4 unity_SHAb;
    float4 unity_SHBr;
    float4 unity_SHBg;
    float4 unity_SHBb;
    float4 unity_SHC;
    float4 unity_OcclusionMaskSelector;
    float4 unity_ProbesOcclusion;
    float3 unity_LightColor0;
    float3 unity_LightColor1;
    float3 unity_LightColor2;
    float3 unity_LightColor3;
    float4 unity_ShadowSplitSpheres[4];
    float4 unity_ShadowSplitSqRadii;
    float4 unity_LightShadowBias;
    float4 _LightSplitsNear;
    float4 _LightSplitsFar;
    float4 hlslcc_mtx4x4unity_WorldToShadow[16];
    float4 _LightShadowData;
    float4 unity_ShadowFadeCenterAndType;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 unity_LODFade;
    float4 unity_WorldTransformParams;
    float4 unity_RenderingLayer;
    float4 hlslcc_mtx4x4glstate_matrix_transpose_modelview0[4];
    float4 glstate_lightmodel_ambient;
    float4 unity_AmbientSky;
    float4 unity_AmbientEquator;
    float4 unity_AmbientGround;
    float4 unity_IndirectSpecColor;
    float4 hlslcc_mtx4x4glstate_matrix_projection[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixInvV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    int unity_StereoEyeIndex;
    float4 unity_ShadowColor;
    float4 unity_FogColor;
    float4 unity_FogParams;
    float4 unity_LightmapST;
    float4 unity_DynamicLightmapST;
    float4 unity_SpecCube0_BoxMax;
    float4 unity_SpecCube0_BoxMin;
    float4 unity_SpecCube0_ProbePosition;
    float4 unity_SpecCube0_HDR;
    float4 unity_SpecCube1_BoxMax;
    float4 unity_SpecCube1_BoxMin;
    float4 unity_SpecCube1_ProbePosition;
    float4 unity_SpecCube1_HDR;
    float4 unity_ProbeVolumeParams;
    float4 hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[4];
    float3 unity_ProbeVolumeSizeInv;
    float3 unity_ProbeVolumeMin;
    float4 unity_Lightmap_HDR;
    float4 unity_DynamicLightmap_HDR;
    float4 _LightColor0;
    float4 _SpecColor;
    float4 hlslcc_mtx4x4unity_WorldToLight[4];
    float _Tile;
    float _HeightDisplacement;
    float _NormalScale;
    float4 _ColorTint;
    float _MetallicStrength;
    float _SmoothnessStrength;
    float _EdgeLength;
    float4 _texcoord_ST;
};
struct Mtl_HullIn
{
    Mtl_VertexOut cp[3];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
kernel void patchKernel(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn vertexInput [[ stage_in ]],
    uint2 tID [[ thread_position_in_grid ]],
    ushort2 groupID [[ threadgroup_position_in_grid ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    constant Mtl_KernelPatchInfo &patchInfo [[ buffer(3) ]])
{
#pragma clang diagnostic pop
    Mtl_ControlPoint output;
    const uint numPatchesInThreadGroup = 10;
    const uint patchID = (tID.x / patchInfo.numControlPointsPerPatch);
    const bool patchValid = (patchID < patchInfo.numPatches);
    const uint mtl_BaseInstance = 0;
    const uint mtl_InstanceID = groupID.y - mtl_BaseInstance;
    const uint internalPatchID = mtl_InstanceID * patchInfo.numPatches + patchID;
    const uint patchIDInThreadGroup = (patchID % numPatchesInThreadGroup);
    const uint controlPointID = (tID.x % patchInfo.numControlPointsPerPatch);
    const uint mtl_BaseVertex = 0;
    const uint mtl_VertexID = ((mtl_InstanceID * (patchInfo.numControlPointsPerPatch * patchInfo.numPatches)) + tID.x) - mtl_BaseVertex;
    threadgroup Mtl_HullIn inputGroup[numPatchesInThreadGroup];
    threadgroup Mtl_HullIn &input = inputGroup[patchIDInThreadGroup];
    MTLTriangleTessellationFactorsHalf tessFactor;
    if (patchValid) {
        input.cp[controlPointID] = vertexFunction(vertexInput);
        output.INTERNALTESSPOS0 = input.cp[controlPointID].INTERNALTESSPOS0;
        output.TANGENT0 = input.cp[controlPointID].TANGENT0;
        output.NORMAL0 = input.cp[controlPointID].NORMAL0;
        output.TEXCOORD0 = input.cp[controlPointID].TEXCOORD0;
        output.TEXCOORD1 = input.cp[controlPointID].TEXCOORD1;
        output.TEXCOORD2 = input.cp[controlPointID].TEXCOORD2;
        output.TEXCOORD3 = input.cp[controlPointID].TEXCOORD3;
        output.COLOR0 = input.cp[controlPointID].COLOR0;
    }
    threadgroup_barrier(mem_flags::mem_threadgroup);
    if (!patchValid) {
        return;
    }
    float3 u_xlat0;
    float3 u_xlat1;
    float3 u_xlat2;
    float3 u_xlat3;
    float3 u_xlat4;
    float u_xlat12;
    float u_xlat13;
    // fork_phase2
    {
        u_xlat0.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[1].INTERNALTESSPOS0.yyy;
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[1].INTERNALTESSPOS0.xxx, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[1].INTERNALTESSPOS0.zzz, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[1].INTERNALTESSPOS0.www, u_xlat0.xyz);
        u_xlat1.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[2].INTERNALTESSPOS0.yyy;
        u_xlat1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[2].INTERNALTESSPOS0.xxx, u_xlat1.xyz);
        u_xlat1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[2].INTERNALTESSPOS0.zzz, u_xlat1.xyz);
        u_xlat1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[2].INTERNALTESSPOS0.www, u_xlat1.xyz);
        u_xlat2.xyz = u_xlat0.xyz + u_xlat1.xyz;
        u_xlat2.xyz = fma(u_xlat2.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat12 = dot(u_xlat2.xyz, u_xlat2.xyz);
        u_xlat12 = sqrt(u_xlat12);
        u_xlat12 = u_xlat12 * VGlobals._EdgeLength;
        u_xlat2.xyz = u_xlat0.xyz + (-u_xlat1.xyz);
        u_xlat13 = dot(u_xlat2.xyz, u_xlat2.xyz);
        u_xlat13 = sqrt(u_xlat13);
        u_xlat13 = u_xlat13 * VGlobals._ScreenParams.y;
        u_xlat12 = u_xlat13 / u_xlat12;
        tessFactor.edgeTessellationFactor[0] = max(u_xlat12, 1.0);
        u_xlat2.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[0].INTERNALTESSPOS0.yyy;
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[0].INTERNALTESSPOS0.xxx, u_xlat2.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[0].INTERNALTESSPOS0.zzz, u_xlat2.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[0].INTERNALTESSPOS0.www, u_xlat2.xyz);
        u_xlat3.xyz = u_xlat1.xyz + u_xlat2.xyz;
        u_xlat1.xyz = u_xlat1.xyz + (-u_xlat2.xyz);
        u_xlat12 = dot(u_xlat1.xyz, u_xlat1.xyz);
        u_xlat12 = sqrt(u_xlat12);
        u_xlat12 = u_xlat12 * VGlobals._ScreenParams.y;
        u_xlat1.xyz = fma(u_xlat3.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat1.x = dot(u_xlat1.xyz, u_xlat1.xyz);
        u_xlat1.x = sqrt(u_xlat1.x);
        u_xlat1.x = u_xlat1.x * VGlobals._EdgeLength;
        u_xlat12 = u_xlat12 / u_xlat1.x;
        tessFactor.edgeTessellationFactor[1] = max(u_xlat12, 1.0);
        u_xlat1.xyz = u_xlat0.xyz + u_xlat2.xyz;
        u_xlat0.xyz = (-u_xlat0.xyz) + u_xlat2.xyz;
        u_xlat0.x = dot(u_xlat0.xyz, u_xlat0.xyz);
        u_xlat0.x = sqrt(u_xlat0.x);
        u_xlat0.x = u_xlat0.x * VGlobals._ScreenParams.y;
        u_xlat4.xyz = fma(u_xlat1.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat4.x = dot(u_xlat4.xyz, u_xlat4.xyz);
        u_xlat4.x = sqrt(u_xlat4.x);
        u_xlat4.x = u_xlat4.x * VGlobals._EdgeLength;
        u_xlat0.x = u_xlat0.x / u_xlat4.x;
        tessFactor.edgeTessellationFactor[2] = max(u_xlat0.x, 1.0);
    }
    // join_phase3
    {
        u_xlat0.x = tessFactor.edgeTessellationFactor[0] + tessFactor.edgeTessellationFactor[1];
        u_xlat0.x = u_xlat0.x + tessFactor.edgeTessellationFactor[2];
        tessFactor.insideTessellationFactor = u_xlat0.x * 0.333333343;
    }
    controlPoints[mtl_VertexID] = output;
    tessFactors[internalPatchID] = tessFactor;
}
// SHADER_STAGE_HULL_end
// SHADER_STAGE_DOMAIN_begin
struct Mtl_VertexInPostTess
{
    patch_control_point<Mtl_ControlPointIn> cp;
};
struct Mtl_VertexOutPostTess
{
    float4 mtl_Position [[ position ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float3 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float3 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float3 TEXCOORD3 [[ user(TEXCOORD3) ]];
    float3 TEXCOORD4 [[ user(TEXCOORD4) ]];
    float3 TEXCOORD5 [[ user(TEXCOORD5) ]];
    float4 TEXCOORD6 [[ user(TEXCOORD6) ]];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    sampler sampler_Height [[ sampler (0) ]],
    texture2d<float, access::sample > _Height [[ texture(0) ]] ,
    float3 mtl_TessCoord [[ position_in_patch ]],
    uint patchID [[ patch_id ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    Mtl_VertexInPostTess input [[ stage_in ]])
{
#pragma clang diagnostic pop
    Mtl_VertexOutPostTess output;
    MTLTriangleTessellationFactorsHalf tessFactor;
    tessFactor = tessFactors[patchID];
    float4 u_xlat0;
    float3 u_xlat1;
    float4 u_xlat2;
    float4 u_xlat3;
    float4 u_xlat4;
    float2 u_xlat10;
    float u_xlat16;
    u_xlat0.xy = mtl_TessCoord.yy * input.cp[1].TEXCOORD0.xy;
    u_xlat0.xy = fma(input.cp[0].TEXCOORD0.xy, mtl_TessCoord.xx, u_xlat0.xy);
    u_xlat0.xy = fma(input.cp[2].TEXCOORD0.xy, mtl_TessCoord.zz, u_xlat0.xy);
    u_xlat10.xy = u_xlat0.xy * float2(VGlobals._Tile);
    output.TEXCOORD0.xy = fma(u_xlat0.xy, VGlobals._texcoord_ST.xy, VGlobals._texcoord_ST.zw);
    u_xlat0.xyz = _Height.sample(sampler_Height, u_xlat10.xy, level(1.0)).xyz;
    u_xlat1.xyz = mtl_TessCoord.yyy * input.cp[1].NORMAL0.xyz;
    u_xlat1.xyz = fma(input.cp[0].NORMAL0.xyz, mtl_TessCoord.xxx, u_xlat1.xyz);
    u_xlat1.xyz = fma(input.cp[2].NORMAL0.xyz, mtl_TessCoord.zzz, u_xlat1.xyz);
    u_xlat0.xyz = u_xlat0.xyz * u_xlat1.xyz;
    u_xlat2 = mtl_TessCoord.yyyy * input.cp[1].INTERNALTESSPOS0;
    u_xlat2 = fma(input.cp[0].INTERNALTESSPOS0, mtl_TessCoord.xxxx, u_xlat2);
    u_xlat2 = fma(input.cp[2].INTERNALTESSPOS0, mtl_TessCoord.zzzz, u_xlat2);
    u_xlat0.xyz = fma(u_xlat0.xyz, float3(VGlobals._HeightDisplacement), u_xlat2.xyz);
    u_xlat3 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], u_xlat0.xxxx, u_xlat3);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], u_xlat0.zzzz, u_xlat3);
    u_xlat3 = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat4 = u_xlat3.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat4 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat3.xxxx, u_xlat4);
    u_xlat4 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat3.zzzz, u_xlat4);
    output.mtl_Position = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat3.wwww, u_xlat4);
    u_xlat2.y = dot(u_xlat1.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat2.z = dot(u_xlat1.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat2.x = dot(u_xlat1.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat1.x = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat1.x = rsqrt(u_xlat1.x);
    u_xlat1.xyz = u_xlat1.xxx * u_xlat2.xyz;
    output.TEXCOORD1.z = u_xlat1.y;
    u_xlat3 = mtl_TessCoord.yyyy * input.cp[1].TANGENT0;
    u_xlat3 = fma(input.cp[0].TANGENT0, mtl_TessCoord.xxxx, u_xlat3);
    u_xlat3 = fma(input.cp[2].TANGENT0, mtl_TessCoord.zzzz, u_xlat3);
    u_xlat2.xyz = u_xlat3.yyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].yzx;
    u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].yzx, u_xlat3.xxx, u_xlat2.xyz);
    u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].yzx, u_xlat3.zzz, u_xlat2.xyz);
    u_xlat16 = u_xlat3.w * VGlobals.unity_WorldTransformParams.w;
    u_xlat3.x = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat3.x = rsqrt(u_xlat3.x);
    u_xlat2.xyz = u_xlat2.xyz * u_xlat3.xxx;
    u_xlat3.xyz = u_xlat1.xyz * u_xlat2.xyz;
    u_xlat3.xyz = fma(u_xlat1.zxy, u_xlat2.yzx, (-u_xlat3.xyz));
    u_xlat3.xyz = float3(u_xlat16) * u_xlat3.xyz;
    output.TEXCOORD1.y = u_xlat3.x;
    output.TEXCOORD1.x = u_xlat2.z;
    output.TEXCOORD2.x = u_xlat2.x;
    output.TEXCOORD3.x = u_xlat2.y;
    output.TEXCOORD2.z = u_xlat1.z;
    output.TEXCOORD3.z = u_xlat1.x;
    output.TEXCOORD2.y = u_xlat3.y;
    output.TEXCOORD3.y = u_xlat3.z;
    output.TEXCOORD4.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, u_xlat2.www, u_xlat0.xyz);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3], u_xlat2.wwww, u_xlat0);
    u_xlat1.xyz = u_xlat0.yyy * VGlobals.hlslcc_mtx4x4unity_WorldToLight[1].xyz;
    u_xlat1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_WorldToLight[0].xyz, u_xlat0.xxx, u_xlat1.xyz);
    u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_WorldToLight[2].xyz, u_xlat0.zzz, u_xlat1.xyz);
    output.TEXCOORD5.xyz = fma(VGlobals.hlslcc_mtx4x4unity_WorldToLight[3].xyz, u_xlat0.www, u_xlat0.xyz);
    output.TEXCOORD6 = float4(0.0, 0.0, 0.0, 0.0);
    return output;
}
// SHADER_STAGE_DOMAIN_end
Compilation succeeded with: 

program_source:293:53: warning: writable resources in non-void post-tessellation vertex function
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
                                                    ^
program_source:299:30: note: writable buffer defined here
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
                             ^
program_source:300:48: note: writable buffer defined here
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
                                               ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float4 TEXCOORD0 [[ attribute(3) ]] ;
    float4 TEXCOORD1 [[ attribute(4) ]] ;
    float4 TEXCOORD2 [[ attribute(5) ]] ;
    float4 TEXCOORD3 [[ attribute(6) ]] ;
    float4 COLOR0 [[ attribute(7) ]] ;
};
struct Mtl_VertexOut
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float4 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float4 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float4 TEXCOORD3 [[ user(TEXCOORD3) ]];
    float4 COLOR0 [[ user(COLOR0) ]];
};
static Mtl_VertexOut vertexFunction(
    Mtl_VertexIn input)
{
    Mtl_VertexOut output;
    output.INTERNALTESSPOS0 = input.POSITION0;
    output.TANGENT0 = input.TANGENT0;
    output.NORMAL0.xyz = input.NORMAL0.xyz;
    output.TEXCOORD0 = input.TEXCOORD0;
    output.TEXCOORD1 = input.TEXCOORD1;
    output.TEXCOORD2 = input.TEXCOORD2;
    output.TEXCOORD3 = input.TEXCOORD3;
    output.COLOR0 = input.COLOR0;
    return output;
}
// SHADER_STAGE_HULL_begin
struct Mtl_ControlPoint
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float4 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float4 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float4 TEXCOORD3 [[ user(TEXCOORD3) ]];
    float4 COLOR0 [[ user(COLOR0) ]];
};
struct Mtl_ControlPointIn
{
    float4 INTERNALTESSPOS0 [[ attribute(8) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float4 TEXCOORD0 [[ attribute(3) ]] ;
    float4 TEXCOORD1 [[ attribute(4) ]] ;
    float4 TEXCOORD2 [[ attribute(5) ]] ;
    float4 TEXCOORD3 [[ attribute(6) ]] ;
    float4 COLOR0 [[ attribute(7) ]] ;
};
struct Mtl_KernelPatchInfo
{
    uint numPatches;
    ushort numControlPointsPerPatch;
};
struct VGlobals_Type
{
    float4 _Time;
    float4 _SinTime;
    float4 _CosTime;
    float4 unity_DeltaTime;
    float3 _WorldSpaceCameraPos;
    float4 _ProjectionParams;
    float4 _ScreenParams;
    float4 _ZBufferParams;
    float4 unity_OrthoParams;
    float4 unity_CameraWorldClipPlanes[6];
    float4 hlslcc_mtx4x4unity_CameraProjection[4];
    float4 hlslcc_mtx4x4unity_CameraInvProjection[4];
    float4 hlslcc_mtx4x4unity_WorldToCamera[4];
    float4 hlslcc_mtx4x4unity_CameraToWorld[4];
    float4 _WorldSpaceLightPos0;
    float4 _LightPositionRange;
    float4 _LightProjectionParams;
    float4 unity_4LightPosX0;
    float4 unity_4LightPosY0;
    float4 unity_4LightPosZ0;
    float4 unity_4LightAtten0;
    float4 unity_LightColor[8];
    float4 unity_LightPosition[8];
    float4 unity_LightAtten[8];
    float4 unity_SpotDirection[8];
    float4 unity_SHAr;
    float4 unity_SHAg;
    float4 unity_SHAb;
    float4 unity_SHBr;
    float4 unity_SHBg;
    float4 unity_SHBb;
    float4 unity_SHC;
    float4 unity_OcclusionMaskSelector;
    float4 unity_ProbesOcclusion;
    float3 unity_LightColor0;
    float3 unity_LightColor1;
    float3 unity_LightColor2;
    float3 unity_LightColor3;
    float4 unity_ShadowSplitSpheres[4];
    float4 unity_ShadowSplitSqRadii;
    float4 unity_LightShadowBias;
    float4 _LightSplitsNear;
    float4 _LightSplitsFar;
    float4 hlslcc_mtx4x4unity_WorldToShadow[16];
    float4 _LightShadowData;
    float4 unity_ShadowFadeCenterAndType;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 unity_LODFade;
    float4 unity_WorldTransformParams;
    float4 unity_RenderingLayer;
    float4 hlslcc_mtx4x4glstate_matrix_transpose_modelview0[4];
    float4 glstate_lightmodel_ambient;
    float4 unity_AmbientSky;
    float4 unity_AmbientEquator;
    float4 unity_AmbientGround;
    float4 unity_IndirectSpecColor;
    float4 hlslcc_mtx4x4glstate_matrix_projection[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixInvV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    int unity_StereoEyeIndex;
    float4 unity_ShadowColor;
    float4 unity_FogColor;
    float4 unity_FogParams;
    float4 unity_LightmapST;
    float4 unity_DynamicLightmapST;
    float4 unity_SpecCube0_BoxMax;
    float4 unity_SpecCube0_BoxMin;
    float4 unity_SpecCube0_ProbePosition;
    float4 unity_SpecCube0_HDR;
    float4 unity_SpecCube1_BoxMax;
    float4 unity_SpecCube1_BoxMin;
    float4 unity_SpecCube1_ProbePosition;
    float4 unity_SpecCube1_HDR;
    float4 unity_ProbeVolumeParams;
    float4 hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[4];
    float3 unity_ProbeVolumeSizeInv;
    float3 unity_ProbeVolumeMin;
    float4 unity_Lightmap_HDR;
    float4 unity_DynamicLightmap_HDR;
    float4 _LightColor0;
    float4 _SpecColor;
    float _Tile;
    float _HeightDisplacement;
    float _NormalScale;
    float4 _ColorTint;
    float _MetallicStrength;
    float _SmoothnessStrength;
    float _EdgeLength;
};
struct Mtl_HullIn
{
    Mtl_VertexOut cp[3];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
kernel void patchKernel(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn vertexInput [[ stage_in ]],
    uint2 tID [[ thread_position_in_grid ]],
    ushort2 groupID [[ threadgroup_position_in_grid ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    constant Mtl_KernelPatchInfo &patchInfo [[ buffer(3) ]])
{
#pragma clang diagnostic pop
    Mtl_ControlPoint output;
    const uint numPatchesInThreadGroup = 10;
    const uint patchID = (tID.x / patchInfo.numControlPointsPerPatch);
    const bool patchValid = (patchID < patchInfo.numPatches);
    const uint mtl_BaseInstance = 0;
    const uint mtl_InstanceID = groupID.y - mtl_BaseInstance;
    const uint internalPatchID = mtl_InstanceID * patchInfo.numPatches + patchID;
    const uint patchIDInThreadGroup = (patchID % numPatchesInThreadGroup);
    const uint controlPointID = (tID.x % patchInfo.numControlPointsPerPatch);
    const uint mtl_BaseVertex = 0;
    const uint mtl_VertexID = ((mtl_InstanceID * (patchInfo.numControlPointsPerPatch * patchInfo.numPatches)) + tID.x) - mtl_BaseVertex;
    threadgroup Mtl_HullIn inputGroup[numPatchesInThreadGroup];
    threadgroup Mtl_HullIn &input = inputGroup[patchIDInThreadGroup];
    MTLTriangleTessellationFactorsHalf tessFactor;
    if (patchValid) {
        input.cp[controlPointID] = vertexFunction(vertexInput);
        output.INTERNALTESSPOS0 = input.cp[controlPointID].INTERNALTESSPOS0;
        output.TANGENT0 = input.cp[controlPointID].TANGENT0;
        output.NORMAL0 = input.cp[controlPointID].NORMAL0;
        output.TEXCOORD0 = input.cp[controlPointID].TEXCOORD0;
        output.TEXCOORD1 = input.cp[controlPointID].TEXCOORD1;
        output.TEXCOORD2 = input.cp[controlPointID].TEXCOORD2;
        output.TEXCOORD3 = input.cp[controlPointID].TEXCOORD3;
        output.COLOR0 = input.cp[controlPointID].COLOR0;
    }
    threadgroup_barrier(mem_flags::mem_threadgroup);
    if (!patchValid) {
        return;
    }
    float3 u_xlat0;
    float3 u_xlat1;
    float3 u_xlat2;
    float3 u_xlat3;
    float3 u_xlat4;
    float u_xlat12;
    float u_xlat13;
    // fork_phase2
    {
        u_xlat0.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[1].INTERNALTESSPOS0.yyy;
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[1].INTERNALTESSPOS0.xxx, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[1].INTERNALTESSPOS0.zzz, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[1].INTERNALTESSPOS0.www, u_xlat0.xyz);
        u_xlat1.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[2].INTERNALTESSPOS0.yyy;
        u_xlat1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[2].INTERNALTESSPOS0.xxx, u_xlat1.xyz);
        u_xlat1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[2].INTERNALTESSPOS0.zzz, u_xlat1.xyz);
        u_xlat1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[2].INTERNALTESSPOS0.www, u_xlat1.xyz);
        u_xlat2.xyz = u_xlat0.xyz + u_xlat1.xyz;
        u_xlat2.xyz = fma(u_xlat2.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat12 = dot(u_xlat2.xyz, u_xlat2.xyz);
        u_xlat12 = sqrt(u_xlat12);
        u_xlat12 = u_xlat12 * VGlobals._EdgeLength;
        u_xlat2.xyz = u_xlat0.xyz + (-u_xlat1.xyz);
        u_xlat13 = dot(u_xlat2.xyz, u_xlat2.xyz);
        u_xlat13 = sqrt(u_xlat13);
        u_xlat13 = u_xlat13 * VGlobals._ScreenParams.y;
        u_xlat12 = u_xlat13 / u_xlat12;
        tessFactor.edgeTessellationFactor[0] = max(u_xlat12, 1.0);
        u_xlat2.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[0].INTERNALTESSPOS0.yyy;
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[0].INTERNALTESSPOS0.xxx, u_xlat2.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[0].INTERNALTESSPOS0.zzz, u_xlat2.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[0].INTERNALTESSPOS0.www, u_xlat2.xyz);
        u_xlat3.xyz = u_xlat1.xyz + u_xlat2.xyz;
        u_xlat1.xyz = u_xlat1.xyz + (-u_xlat2.xyz);
        u_xlat12 = dot(u_xlat1.xyz, u_xlat1.xyz);
        u_xlat12 = sqrt(u_xlat12);
        u_xlat12 = u_xlat12 * VGlobals._ScreenParams.y;
        u_xlat1.xyz = fma(u_xlat3.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat1.x = dot(u_xlat1.xyz, u_xlat1.xyz);
        u_xlat1.x = sqrt(u_xlat1.x);
        u_xlat1.x = u_xlat1.x * VGlobals._EdgeLength;
        u_xlat12 = u_xlat12 / u_xlat1.x;
        tessFactor.edgeTessellationFactor[1] = max(u_xlat12, 1.0);
        u_xlat1.xyz = u_xlat0.xyz + u_xlat2.xyz;
        u_xlat0.xyz = (-u_xlat0.xyz) + u_xlat2.xyz;
        u_xlat0.x = dot(u_xlat0.xyz, u_xlat0.xyz);
        u_xlat0.x = sqrt(u_xlat0.x);
        u_xlat0.x = u_xlat0.x * VGlobals._ScreenParams.y;
        u_xlat4.xyz = fma(u_xlat1.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat4.x = dot(u_xlat4.xyz, u_xlat4.xyz);
        u_xlat4.x = sqrt(u_xlat4.x);
        u_xlat4.x = u_xlat4.x * VGlobals._EdgeLength;
        u_xlat0.x = u_xlat0.x / u_xlat4.x;
        tessFactor.edgeTessellationFactor[2] = max(u_xlat0.x, 1.0);
    }
    // join_phase3
    {
        u_xlat0.x = tessFactor.edgeTessellationFactor[0] + tessFactor.edgeTessellationFactor[1];
        u_xlat0.x = u_xlat0.x + tessFactor.edgeTessellationFactor[2];
        tessFactor.insideTessellationFactor = u_xlat0.x * 0.333333343;
    }
    controlPoints[mtl_VertexID] = output;
    tessFactors[internalPatchID] = tessFactor;
}
// SHADER_STAGE_HULL_end
// SHADER_STAGE_DOMAIN_begin
struct Mtl_VertexInPostTess
{
    patch_control_point<Mtl_ControlPointIn> cp;
};
struct Mtl_VertexOutPostTess
{
    float4 mtl_Position [[ position ]];
    float3 TEXCOORD1 [[ user(TEXCOORD1) ]];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    sampler sampler_Height [[ sampler (0) ]],
    texture2d<float, access::sample > _Height [[ texture(0) ]] ,
    float3 mtl_TessCoord [[ position_in_patch ]],
    uint patchID [[ patch_id ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    Mtl_VertexInPostTess input [[ stage_in ]])
{
#pragma clang diagnostic pop
    Mtl_VertexOutPostTess output;
    MTLTriangleTessellationFactorsHalf tessFactor;
    tessFactor = tessFactors[patchID];
    float4 u_xlat0;
    float4 u_xlat1;
    float4 u_xlat2;
    float4 u_xlat3;
    float4 u_xlat4;
    float u_xlat11;
    float u_xlat15;
    bool u_xlatb15;
    u_xlat0.xyz = mtl_TessCoord.yyy * input.cp[1].NORMAL0.xyz;
    u_xlat0.xyz = fma(input.cp[0].NORMAL0.xyz, mtl_TessCoord.xxx, u_xlat0.xyz);
    u_xlat0.xyz = fma(input.cp[2].NORMAL0.xyz, mtl_TessCoord.zzz, u_xlat0.xyz);
    u_xlat1.x = dot(u_xlat0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat1.y = dot(u_xlat0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat1.z = dot(u_xlat0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat15 = dot(u_xlat1.xyz, u_xlat1.xyz);
    u_xlat15 = rsqrt(u_xlat15);
    u_xlat1.xyz = float3(u_xlat15) * u_xlat1.xyz;
    u_xlat2.xy = mtl_TessCoord.yy * input.cp[1].TEXCOORD0.xy;
    u_xlat2.xy = fma(input.cp[0].TEXCOORD0.xy, mtl_TessCoord.xx, u_xlat2.xy);
    u_xlat2.xy = fma(input.cp[2].TEXCOORD0.xy, mtl_TessCoord.zz, u_xlat2.xy);
    u_xlat2.xy = u_xlat2.xy * float2(VGlobals._Tile);
    u_xlat2.xyz = _Height.sample(sampler_Height, u_xlat2.xy, level(1.0)).xyz;
    u_xlat0.xyz = u_xlat0.xyz * u_xlat2.xyz;
    u_xlat2 = mtl_TessCoord.yyyy * input.cp[1].INTERNALTESSPOS0;
    u_xlat2 = fma(input.cp[0].INTERNALTESSPOS0, mtl_TessCoord.xxxx, u_xlat2);
    u_xlat2 = fma(input.cp[2].INTERNALTESSPOS0, mtl_TessCoord.zzzz, u_xlat2);
    u_xlat0.xyz = fma(u_xlat0.xyz, float3(VGlobals._HeightDisplacement), u_xlat2.xyz);
    u_xlat3 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], u_xlat0.xxxx, u_xlat3);
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], u_xlat0.zzzz, u_xlat3);
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3], u_xlat2.wwww, u_xlat3);
    u_xlat2.xyz = fma((-u_xlat3.xyz), VGlobals._WorldSpaceLightPos0.www, VGlobals._WorldSpaceLightPos0.xyz);
    u_xlat15 = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat15 = rsqrt(u_xlat15);
    u_xlat2.xyz = float3(u_xlat15) * u_xlat2.xyz;
    u_xlat15 = dot(u_xlat1.xyz, u_xlat2.xyz);
    u_xlat15 = fma((-u_xlat15), u_xlat15, 1.0);
    u_xlat15 = sqrt(u_xlat15);
    u_xlat15 = u_xlat15 * VGlobals.unity_LightShadowBias.z;
    u_xlat1.xyz = fma((-u_xlat1.xyz), float3(u_xlat15), u_xlat3.xyz);
    u_xlatb15 = VGlobals.unity_LightShadowBias.z!=0.0;
    u_xlat1.xyz = (bool(u_xlatb15)) ? u_xlat1.xyz : u_xlat3.xyz;
    u_xlat4 = u_xlat1.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat4 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat1.xxxx, u_xlat4);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat1.zzzz, u_xlat4);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat3.wwww, u_xlat1);
    u_xlat15 = VGlobals.unity_LightShadowBias.x / u_xlat1.w;
    u_xlat15 = min(u_xlat15, 0.0);
    u_xlat15 = max(u_xlat15, -1.0);
    u_xlat15 = u_xlat15 + u_xlat1.z;
    u_xlat11 = min(u_xlat1.w, u_xlat15);
    output.mtl_Position.xyw = u_xlat1.xyw;
    u_xlat1.x = (-u_xlat15) + u_xlat11;
    output.mtl_Position.z = fma(VGlobals.unity_LightShadowBias.y, u_xlat1.x, u_xlat15);
    u_xlat1.xyz = u_xlat0.yyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz;
    u_xlat0.xyw = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, u_xlat0.xxx, u_xlat1.xyz);
    u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, u_xlat0.zzz, u_xlat0.xyw);
    output.TEXCOORD1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, u_xlat2.www, u_xlat0.xyz);
    return output;
}
// SHADER_STAGE_DOMAIN_end
Compilation succeeded with: 

program_source:299:53: warning: writable resources in non-void post-tessellation vertex function
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
                                                    ^
program_source:305:30: note: writable buffer defined here
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
                             ^
program_source:306:48: note: writable buffer defined here
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
                                               ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float4 TEXCOORD0 [[ attribute(3) ]] ;
    float4 TEXCOORD1 [[ attribute(4) ]] ;
    float4 TEXCOORD2 [[ attribute(5) ]] ;
    float4 TEXCOORD3 [[ attribute(6) ]] ;
    float4 COLOR0 [[ attribute(7) ]] ;
};
struct Mtl_VertexOut
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float4 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float4 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float4 TEXCOORD3 [[ user(TEXCOORD3) ]];
    float4 COLOR0 [[ user(COLOR0) ]];
};
static Mtl_VertexOut vertexFunction(
    Mtl_VertexIn input)
{
    Mtl_VertexOut output;
    output.INTERNALTESSPOS0 = input.POSITION0;
    output.TANGENT0 = input.TANGENT0;
    output.NORMAL0.xyz = input.NORMAL0.xyz;
    output.TEXCOORD0 = input.TEXCOORD0;
    output.TEXCOORD1 = input.TEXCOORD1;
    output.TEXCOORD2 = input.TEXCOORD2;
    output.TEXCOORD3 = input.TEXCOORD3;
    output.COLOR0 = input.COLOR0;
    return output;
}
// SHADER_STAGE_HULL_begin
struct Mtl_ControlPoint
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float4 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float4 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float4 TEXCOORD3 [[ user(TEXCOORD3) ]];
    float4 COLOR0 [[ user(COLOR0) ]];
};
struct Mtl_ControlPointIn
{
    float4 INTERNALTESSPOS0 [[ attribute(8) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float4 TEXCOORD0 [[ attribute(3) ]] ;
    float4 TEXCOORD1 [[ attribute(4) ]] ;
    float4 TEXCOORD2 [[ attribute(5) ]] ;
    float4 TEXCOORD3 [[ attribute(6) ]] ;
    float4 COLOR0 [[ attribute(7) ]] ;
};
struct Mtl_KernelPatchInfo
{
    uint numPatches;
    ushort numControlPointsPerPatch;
};
struct VGlobals_Type
{
    float4 _Time;
    float4 _SinTime;
    float4 _CosTime;
    float4 unity_DeltaTime;
    float3 _WorldSpaceCameraPos;
    float4 _ProjectionParams;
    float4 _ScreenParams;
    float4 _ZBufferParams;
    float4 unity_OrthoParams;
    float4 unity_CameraWorldClipPlanes[6];
    float4 hlslcc_mtx4x4unity_CameraProjection[4];
    float4 hlslcc_mtx4x4unity_CameraInvProjection[4];
    float4 hlslcc_mtx4x4unity_WorldToCamera[4];
    float4 hlslcc_mtx4x4unity_CameraToWorld[4];
    float4 _WorldSpaceLightPos0;
    float4 _LightPositionRange;
    float4 _LightProjectionParams;
    float4 unity_4LightPosX0;
    float4 unity_4LightPosY0;
    float4 unity_4LightPosZ0;
    float4 unity_4LightAtten0;
    float4 unity_LightColor[8];
    float4 unity_LightPosition[8];
    float4 unity_LightAtten[8];
    float4 unity_SpotDirection[8];
    float4 unity_SHAr;
    float4 unity_SHAg;
    float4 unity_SHAb;
    float4 unity_SHBr;
    float4 unity_SHBg;
    float4 unity_SHBb;
    float4 unity_SHC;
    float4 unity_OcclusionMaskSelector;
    float4 unity_ProbesOcclusion;
    float3 unity_LightColor0;
    float3 unity_LightColor1;
    float3 unity_LightColor2;
    float3 unity_LightColor3;
    float4 unity_ShadowSplitSpheres[4];
    float4 unity_ShadowSplitSqRadii;
    float4 unity_LightShadowBias;
    float4 _LightSplitsNear;
    float4 _LightSplitsFar;
    float4 hlslcc_mtx4x4unity_WorldToShadow[16];
    float4 _LightShadowData;
    float4 unity_ShadowFadeCenterAndType;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 unity_LODFade;
    float4 unity_WorldTransformParams;
    float4 unity_RenderingLayer;
    float4 hlslcc_mtx4x4glstate_matrix_transpose_modelview0[4];
    float4 glstate_lightmodel_ambient;
    float4 unity_AmbientSky;
    float4 unity_AmbientEquator;
    float4 unity_AmbientGround;
    float4 unity_IndirectSpecColor;
    float4 hlslcc_mtx4x4glstate_matrix_projection[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixInvV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    int unity_StereoEyeIndex;
    float4 unity_ShadowColor;
    float4 unity_FogColor;
    float4 unity_FogParams;
    float4 unity_LightmapST;
    float4 unity_DynamicLightmapST;
    float4 unity_SpecCube0_BoxMax;
    float4 unity_SpecCube0_BoxMin;
    float4 unity_SpecCube0_ProbePosition;
    float4 unity_SpecCube0_HDR;
    float4 unity_SpecCube1_BoxMax;
    float4 unity_SpecCube1_BoxMin;
    float4 unity_SpecCube1_ProbePosition;
    float4 unity_SpecCube1_HDR;
    float4 unity_ProbeVolumeParams;
    float4 hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[4];
    float3 unity_ProbeVolumeSizeInv;
    float3 unity_ProbeVolumeMin;
    float4 unity_Lightmap_HDR;
    float4 unity_DynamicLightmap_HDR;
    float4 _LightColor0;
    float4 _SpecColor;
    float _Tile;
    float _HeightDisplacement;
    float _NormalScale;
    float4 _ColorTint;
    float _MetallicStrength;
    float _SmoothnessStrength;
    float _EdgeLength;
    float4 _texcoord_ST;
    float4 unity_Ambient;
};
struct Mtl_HullIn
{
    Mtl_VertexOut cp[3];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
kernel void patchKernel(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn vertexInput [[ stage_in ]],
    uint2 tID [[ thread_position_in_grid ]],
    ushort2 groupID [[ threadgroup_position_in_grid ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    constant Mtl_KernelPatchInfo &patchInfo [[ buffer(3) ]])
{
#pragma clang diagnostic pop
    Mtl_ControlPoint output;
    const uint numPatchesInThreadGroup = 10;
    const uint patchID = (tID.x / patchInfo.numControlPointsPerPatch);
    const bool patchValid = (patchID < patchInfo.numPatches);
    const uint mtl_BaseInstance = 0;
    const uint mtl_InstanceID = groupID.y - mtl_BaseInstance;
    const uint internalPatchID = mtl_InstanceID * patchInfo.numPatches + patchID;
    const uint patchIDInThreadGroup = (patchID % numPatchesInThreadGroup);
    const uint controlPointID = (tID.x % patchInfo.numControlPointsPerPatch);
    const uint mtl_BaseVertex = 0;
    const uint mtl_VertexID = ((mtl_InstanceID * (patchInfo.numControlPointsPerPatch * patchInfo.numPatches)) + tID.x) - mtl_BaseVertex;
    threadgroup Mtl_HullIn inputGroup[numPatchesInThreadGroup];
    threadgroup Mtl_HullIn &input = inputGroup[patchIDInThreadGroup];
    MTLTriangleTessellationFactorsHalf tessFactor;
    if (patchValid) {
        input.cp[controlPointID] = vertexFunction(vertexInput);
        output.INTERNALTESSPOS0 = input.cp[controlPointID].INTERNALTESSPOS0;
        output.TANGENT0 = input.cp[controlPointID].TANGENT0;
        output.NORMAL0 = input.cp[controlPointID].NORMAL0;
        output.TEXCOORD0 = input.cp[controlPointID].TEXCOORD0;
        output.TEXCOORD1 = input.cp[controlPointID].TEXCOORD1;
        output.TEXCOORD2 = input.cp[controlPointID].TEXCOORD2;
        output.TEXCOORD3 = input.cp[controlPointID].TEXCOORD3;
        output.COLOR0 = input.cp[controlPointID].COLOR0;
    }
    threadgroup_barrier(mem_flags::mem_threadgroup);
    if (!patchValid) {
        return;
    }
    float3 u_xlat0;
    float3 u_xlat1;
    float3 u_xlat2;
    float3 u_xlat3;
    float3 u_xlat4;
    float u_xlat12;
    float u_xlat13;
    // fork_phase2
    {
        u_xlat0.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[1].INTERNALTESSPOS0.yyy;
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[1].INTERNALTESSPOS0.xxx, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[1].INTERNALTESSPOS0.zzz, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[1].INTERNALTESSPOS0.www, u_xlat0.xyz);
        u_xlat1.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[2].INTERNALTESSPOS0.yyy;
        u_xlat1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[2].INTERNALTESSPOS0.xxx, u_xlat1.xyz);
        u_xlat1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[2].INTERNALTESSPOS0.zzz, u_xlat1.xyz);
        u_xlat1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[2].INTERNALTESSPOS0.www, u_xlat1.xyz);
        u_xlat2.xyz = u_xlat0.xyz + u_xlat1.xyz;
        u_xlat2.xyz = fma(u_xlat2.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat12 = dot(u_xlat2.xyz, u_xlat2.xyz);
        u_xlat12 = sqrt(u_xlat12);
        u_xlat12 = u_xlat12 * VGlobals._EdgeLength;
        u_xlat2.xyz = u_xlat0.xyz + (-u_xlat1.xyz);
        u_xlat13 = dot(u_xlat2.xyz, u_xlat2.xyz);
        u_xlat13 = sqrt(u_xlat13);
        u_xlat13 = u_xlat13 * VGlobals._ScreenParams.y;
        u_xlat12 = u_xlat13 / u_xlat12;
        tessFactor.edgeTessellationFactor[0] = max(u_xlat12, 1.0);
        u_xlat2.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[0].INTERNALTESSPOS0.yyy;
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[0].INTERNALTESSPOS0.xxx, u_xlat2.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[0].INTERNALTESSPOS0.zzz, u_xlat2.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[0].INTERNALTESSPOS0.www, u_xlat2.xyz);
        u_xlat3.xyz = u_xlat1.xyz + u_xlat2.xyz;
        u_xlat1.xyz = u_xlat1.xyz + (-u_xlat2.xyz);
        u_xlat12 = dot(u_xlat1.xyz, u_xlat1.xyz);
        u_xlat12 = sqrt(u_xlat12);
        u_xlat12 = u_xlat12 * VGlobals._ScreenParams.y;
        u_xlat1.xyz = fma(u_xlat3.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat1.x = dot(u_xlat1.xyz, u_xlat1.xyz);
        u_xlat1.x = sqrt(u_xlat1.x);
        u_xlat1.x = u_xlat1.x * VGlobals._EdgeLength;
        u_xlat12 = u_xlat12 / u_xlat1.x;
        tessFactor.edgeTessellationFactor[1] = max(u_xlat12, 1.0);
        u_xlat1.xyz = u_xlat0.xyz + u_xlat2.xyz;
        u_xlat0.xyz = (-u_xlat0.xyz) + u_xlat2.xyz;
        u_xlat0.x = dot(u_xlat0.xyz, u_xlat0.xyz);
        u_xlat0.x = sqrt(u_xlat0.x);
        u_xlat0.x = u_xlat0.x * VGlobals._ScreenParams.y;
        u_xlat4.xyz = fma(u_xlat1.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat4.x = dot(u_xlat4.xyz, u_xlat4.xyz);
        u_xlat4.x = sqrt(u_xlat4.x);
        u_xlat4.x = u_xlat4.x * VGlobals._EdgeLength;
        u_xlat0.x = u_xlat0.x / u_xlat4.x;
        tessFactor.edgeTessellationFactor[2] = max(u_xlat0.x, 1.0);
    }
    // join_phase3
    {
        u_xlat0.x = tessFactor.edgeTessellationFactor[0] + tessFactor.edgeTessellationFactor[1];
        u_xlat0.x = u_xlat0.x + tessFactor.edgeTessellationFactor[2];
        tessFactor.insideTessellationFactor = u_xlat0.x * 0.333333343;
    }
    controlPoints[mtl_VertexID] = output;
    tessFactors[internalPatchID] = tessFactor;
}
// SHADER_STAGE_HULL_end
// SHADER_STAGE_DOMAIN_begin
struct Mtl_VertexInPostTess
{
    patch_control_point<Mtl_ControlPointIn> cp;
};
struct Mtl_VertexOutPostTess
{
    float4 mtl_Position [[ position ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float4 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float4 TEXCOORD3 [[ user(TEXCOORD3) ]];
    float4 TEXCOORD5 [[ user(TEXCOORD5) ]];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    sampler sampler_Height [[ sampler (0) ]],
    texture2d<float, access::sample > _Height [[ texture(0) ]] ,
    float3 mtl_TessCoord [[ position_in_patch ]],
    uint patchID [[ patch_id ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    Mtl_VertexInPostTess input [[ stage_in ]])
{
#pragma clang diagnostic pop
    Mtl_VertexOutPostTess output;
    MTLTriangleTessellationFactorsHalf tessFactor;
    tessFactor = tessFactors[patchID];
    float4 u_xlat0;
    float4 u_xlat1;
    float4 u_xlat2;
    float4 u_xlat3;
    float2 u_xlat9;
    float u_xlat12;
    float u_xlat13;
    u_xlat0 = mtl_TessCoord.yyyy * input.cp[1].INTERNALTESSPOS0;
    u_xlat0 = fma(input.cp[0].INTERNALTESSPOS0, mtl_TessCoord.xxxx, u_xlat0);
    u_xlat0 = fma(input.cp[2].INTERNALTESSPOS0, mtl_TessCoord.zzzz, u_xlat0);
    u_xlat1.xy = mtl_TessCoord.yy * input.cp[1].TEXCOORD0.xy;
    u_xlat1.xy = fma(input.cp[0].TEXCOORD0.xy, mtl_TessCoord.xx, u_xlat1.xy);
    u_xlat1.xy = fma(input.cp[2].TEXCOORD0.xy, mtl_TessCoord.zz, u_xlat1.xy);
    u_xlat9.xy = u_xlat1.xy * float2(VGlobals._Tile);
    output.TEXCOORD0.xy = fma(u_xlat1.xy, VGlobals._texcoord_ST.xy, VGlobals._texcoord_ST.zw);
    u_xlat1.xyz = _Height.sample(sampler_Height, u_xlat9.xy, level(1.0)).xyz;
    u_xlat2.xyz = mtl_TessCoord.yyy * input.cp[1].NORMAL0.xyz;
    u_xlat2.xyz = fma(input.cp[0].NORMAL0.xyz, mtl_TessCoord.xxx, u_xlat2.xyz);
    u_xlat2.xyz = fma(input.cp[2].NORMAL0.xyz, mtl_TessCoord.zzz, u_xlat2.xyz);
    u_xlat1.xyz = u_xlat1.xyz * u_xlat2.xyz;
    u_xlat0.xyz = fma(u_xlat1.xyz, float3(VGlobals._HeightDisplacement), u_xlat0.xyz);
    u_xlat1 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], u_xlat0.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], u_xlat0.zzzz, u_xlat1);
    u_xlat3 = u_xlat1 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, u_xlat0.www, u_xlat1.xyz);
    u_xlat1 = u_xlat3.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat3.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat3.zzzz, u_xlat1);
    output.mtl_Position = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat3.wwww, u_xlat1);
    u_xlat1.y = dot(u_xlat2.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat1.z = dot(u_xlat2.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat1.x = dot(u_xlat2.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat12 = dot(u_xlat1.xyz, u_xlat1.xyz);
    u_xlat12 = rsqrt(u_xlat12);
    u_xlat1.xyz = float3(u_xlat12) * u_xlat1.xyz;
    output.TEXCOORD1.z = u_xlat1.y;
    u_xlat2 = mtl_TessCoord.yyyy * input.cp[1].TANGENT0;
    u_xlat2 = fma(input.cp[0].TANGENT0, mtl_TessCoord.xxxx, u_xlat2);
    u_xlat2 = fma(input.cp[2].TANGENT0, mtl_TessCoord.zzzz, u_xlat2);
    u_xlat3.xyz = u_xlat2.yyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].yzx;
    u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].yzx, u_xlat2.xxx, u_xlat3.xyz);
    u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].yzx, u_xlat2.zzz, u_xlat3.xyz);
    u_xlat12 = u_xlat2.w * VGlobals.unity_WorldTransformParams.w;
    u_xlat13 = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat13 = rsqrt(u_xlat13);
    u_xlat2.xyz = float3(u_xlat13) * u_xlat2.xyz;
    u_xlat3.xyz = u_xlat1.xyz * u_xlat2.xyz;
    u_xlat3.xyz = fma(u_xlat1.zxy, u_xlat2.yzx, (-u_xlat3.xyz));
    u_xlat3.xyz = float3(u_xlat12) * u_xlat3.xyz;
    output.TEXCOORD1.y = u_xlat3.x;
    output.TEXCOORD1.w = u_xlat0.x;
    output.TEXCOORD1.x = u_xlat2.z;
    output.TEXCOORD2.w = u_xlat0.y;
    output.TEXCOORD3.w = u_xlat0.z;
    output.TEXCOORD2.x = u_xlat2.x;
    output.TEXCOORD3.x = u_xlat2.y;
    output.TEXCOORD2.z = u_xlat1.z;
    output.TEXCOORD3.z = u_xlat1.x;
    output.TEXCOORD2.y = u_xlat3.y;
    output.TEXCOORD3.y = u_xlat3.z;
    output.TEXCOORD5 = float4(0.0, 0.0, 0.0, 0.0);
    return output;
}
// SHADER_STAGE_DOMAIN_end
Compilation succeeded with: 

program_source:303:53: warning: writable resources in non-void post-tessellation vertex function
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
                                                    ^
program_source:309:30: note: writable buffer defined here
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
                             ^
program_source:310:48: note: writable buffer defined here
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
                                               ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float4 TEXCOORD0 [[ attribute(3) ]] ;
    float4 TEXCOORD1 [[ attribute(4) ]] ;
    float4 TEXCOORD2 [[ attribute(5) ]] ;
    float4 TEXCOORD3 [[ attribute(6) ]] ;
    float4 COLOR0 [[ attribute(7) ]] ;
};
struct Mtl_VertexOut
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float4 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float4 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float4 TEXCOORD3 [[ user(TEXCOORD3) ]];
    float4 COLOR0 [[ user(COLOR0) ]];
};
static Mtl_VertexOut vertexFunction(
    Mtl_VertexIn input)
{
    Mtl_VertexOut output;
    output.INTERNALTESSPOS0 = input.POSITION0;
    output.TANGENT0 = input.TANGENT0;
    output.NORMAL0.xyz = input.NORMAL0.xyz;
    output.TEXCOORD0 = input.TEXCOORD0;
    output.TEXCOORD1 = input.TEXCOORD1;
    output.TEXCOORD2 = input.TEXCOORD2;
    output.TEXCOORD3 = input.TEXCOORD3;
    output.COLOR0 = input.COLOR0;
    return output;
}
// SHADER_STAGE_HULL_begin
struct Mtl_ControlPoint
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float4 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float4 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float4 TEXCOORD3 [[ user(TEXCOORD3) ]];
    float4 COLOR0 [[ user(COLOR0) ]];
};
struct Mtl_ControlPointIn
{
    float4 INTERNALTESSPOS0 [[ attribute(8) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float4 TEXCOORD0 [[ attribute(3) ]] ;
    float4 TEXCOORD1 [[ attribute(4) ]] ;
    float4 TEXCOORD2 [[ attribute(5) ]] ;
    float4 TEXCOORD3 [[ attribute(6) ]] ;
    float4 COLOR0 [[ attribute(7) ]] ;
};
struct Mtl_KernelPatchInfo
{
    uint numPatches;
    ushort numControlPointsPerPatch;
};
struct VGlobals_Type
{
    float4 _Time;
    float4 _SinTime;
    float4 _CosTime;
    float4 unity_DeltaTime;
    float3 _WorldSpaceCameraPos;
    float4 _ProjectionParams;
    float4 _ScreenParams;
    float4 _ZBufferParams;
    float4 unity_OrthoParams;
    float4 unity_CameraWorldClipPlanes[6];
    float4 hlslcc_mtx4x4unity_CameraProjection[4];
    float4 hlslcc_mtx4x4unity_CameraInvProjection[4];
    float4 hlslcc_mtx4x4unity_WorldToCamera[4];
    float4 hlslcc_mtx4x4unity_CameraToWorld[4];
    float4 _WorldSpaceLightPos0;
    float4 _LightPositionRange;
    float4 _LightProjectionParams;
    float4 unity_4LightPosX0;
    float4 unity_4LightPosY0;
    float4 unity_4LightPosZ0;
    float4 unity_4LightAtten0;
    float4 unity_LightColor[8];
    float4 unity_LightPosition[8];
    float4 unity_LightAtten[8];
    float4 unity_SpotDirection[8];
    float4 unity_SHAr;
    float4 unity_SHAg;
    float4 unity_SHAb;
    float4 unity_SHBr;
    float4 unity_SHBg;
    float4 unity_SHBb;
    float4 unity_SHC;
    float4 unity_OcclusionMaskSelector;
    float4 unity_ProbesOcclusion;
    float3 unity_LightColor0;
    float3 unity_LightColor1;
    float3 unity_LightColor2;
    float3 unity_LightColor3;
    float4 unity_ShadowSplitSpheres[4];
    float4 unity_ShadowSplitSqRadii;
    float4 unity_LightShadowBias;
    float4 _LightSplitsNear;
    float4 _LightSplitsFar;
    float4 hlslcc_mtx4x4unity_WorldToShadow[16];
    float4 _LightShadowData;
    float4 unity_ShadowFadeCenterAndType;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 unity_LODFade;
    float4 unity_WorldTransformParams;
    float4 unity_RenderingLayer;
    float4 hlslcc_mtx4x4glstate_matrix_transpose_modelview0[4];
    float4 glstate_lightmodel_ambient;
    float4 unity_AmbientSky;
    float4 unity_AmbientEquator;
    float4 unity_AmbientGround;
    float4 unity_IndirectSpecColor;
    float4 hlslcc_mtx4x4glstate_matrix_projection[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixInvV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    int unity_StereoEyeIndex;
    float4 unity_ShadowColor;
    float4 unity_FogColor;
    float4 unity_FogParams;
    float4 unity_LightmapST;
    float4 unity_DynamicLightmapST;
    float4 unity_SpecCube0_BoxMax;
    float4 unity_SpecCube0_BoxMin;
    float4 unity_SpecCube0_ProbePosition;
    float4 unity_SpecCube0_HDR;
    float4 unity_SpecCube1_BoxMax;
    float4 unity_SpecCube1_BoxMin;
    float4 unity_SpecCube1_ProbePosition;
    float4 unity_SpecCube1_HDR;
    float4 unity_ProbeVolumeParams;
    float4 hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[4];
    float3 unity_ProbeVolumeSizeInv;
    float3 unity_ProbeVolumeMin;
    float4 unity_Lightmap_HDR;
    float4 unity_DynamicLightmap_HDR;
    float4 _LightColor0;
    float4 _SpecColor;
    float _Tile;
    float _HeightDisplacement;
    float _NormalScale;
    float4 _ColorTint;
    float _MetallicStrength;
    float _SmoothnessStrength;
    float _EdgeLength;
    bool4 unity_MetaVertexControl;
    bool4 unity_MetaFragmentControl;
    int unity_VisualizationMode;
    float unity_OneOverOutputBoost;
    float unity_MaxOutputValue;
    float unity_UseLinearSpace;
    float4 _texcoord_ST;
};
struct Mtl_HullIn
{
    Mtl_VertexOut cp[3];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
kernel void patchKernel(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn vertexInput [[ stage_in ]],
    uint2 tID [[ thread_position_in_grid ]],
    ushort2 groupID [[ threadgroup_position_in_grid ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    constant Mtl_KernelPatchInfo &patchInfo [[ buffer(3) ]])
{
#pragma clang diagnostic pop
    Mtl_ControlPoint output;
    const uint numPatchesInThreadGroup = 10;
    const uint patchID = (tID.x / patchInfo.numControlPointsPerPatch);
    const bool patchValid = (patchID < patchInfo.numPatches);
    const uint mtl_BaseInstance = 0;
    const uint mtl_InstanceID = groupID.y - mtl_BaseInstance;
    const uint internalPatchID = mtl_InstanceID * patchInfo.numPatches + patchID;
    const uint patchIDInThreadGroup = (patchID % numPatchesInThreadGroup);
    const uint controlPointID = (tID.x % patchInfo.numControlPointsPerPatch);
    const uint mtl_BaseVertex = 0;
    const uint mtl_VertexID = ((mtl_InstanceID * (patchInfo.numControlPointsPerPatch * patchInfo.numPatches)) + tID.x) - mtl_BaseVertex;
    threadgroup Mtl_HullIn inputGroup[numPatchesInThreadGroup];
    threadgroup Mtl_HullIn &input = inputGroup[patchIDInThreadGroup];
    MTLTriangleTessellationFactorsHalf tessFactor;
    if (patchValid) {
        input.cp[controlPointID] = vertexFunction(vertexInput);
        output.INTERNALTESSPOS0 = input.cp[controlPointID].INTERNALTESSPOS0;
        output.TANGENT0 = input.cp[controlPointID].TANGENT0;
        output.NORMAL0 = input.cp[controlPointID].NORMAL0;
        output.TEXCOORD0 = input.cp[controlPointID].TEXCOORD0;
        output.TEXCOORD1 = input.cp[controlPointID].TEXCOORD1;
        output.TEXCOORD2 = input.cp[controlPointID].TEXCOORD2;
        output.TEXCOORD3 = input.cp[controlPointID].TEXCOORD3;
        output.COLOR0 = input.cp[controlPointID].COLOR0;
    }
    threadgroup_barrier(mem_flags::mem_threadgroup);
    if (!patchValid) {
        return;
    }
    float3 u_xlat0;
    float3 u_xlat1;
    float3 u_xlat2;
    float3 u_xlat3;
    float3 u_xlat4;
    float u_xlat12;
    float u_xlat13;
    // fork_phase2
    {
        u_xlat0.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[1].INTERNALTESSPOS0.yyy;
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[1].INTERNALTESSPOS0.xxx, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[1].INTERNALTESSPOS0.zzz, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[1].INTERNALTESSPOS0.www, u_xlat0.xyz);
        u_xlat1.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[2].INTERNALTESSPOS0.yyy;
        u_xlat1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[2].INTERNALTESSPOS0.xxx, u_xlat1.xyz);
        u_xlat1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[2].INTERNALTESSPOS0.zzz, u_xlat1.xyz);
        u_xlat1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[2].INTERNALTESSPOS0.www, u_xlat1.xyz);
        u_xlat2.xyz = u_xlat0.xyz + u_xlat1.xyz;
        u_xlat2.xyz = fma(u_xlat2.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat12 = dot(u_xlat2.xyz, u_xlat2.xyz);
        u_xlat12 = sqrt(u_xlat12);
        u_xlat12 = u_xlat12 * VGlobals._EdgeLength;
        u_xlat2.xyz = u_xlat0.xyz + (-u_xlat1.xyz);
        u_xlat13 = dot(u_xlat2.xyz, u_xlat2.xyz);
        u_xlat13 = sqrt(u_xlat13);
        u_xlat13 = u_xlat13 * VGlobals._ScreenParams.y;
        u_xlat12 = u_xlat13 / u_xlat12;
        tessFactor.edgeTessellationFactor[0] = max(u_xlat12, 1.0);
        u_xlat2.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[0].INTERNALTESSPOS0.yyy;
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[0].INTERNALTESSPOS0.xxx, u_xlat2.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[0].INTERNALTESSPOS0.zzz, u_xlat2.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[0].INTERNALTESSPOS0.www, u_xlat2.xyz);
        u_xlat3.xyz = u_xlat1.xyz + u_xlat2.xyz;
        u_xlat1.xyz = u_xlat1.xyz + (-u_xlat2.xyz);
        u_xlat12 = dot(u_xlat1.xyz, u_xlat1.xyz);
        u_xlat12 = sqrt(u_xlat12);
        u_xlat12 = u_xlat12 * VGlobals._ScreenParams.y;
        u_xlat1.xyz = fma(u_xlat3.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat1.x = dot(u_xlat1.xyz, u_xlat1.xyz);
        u_xlat1.x = sqrt(u_xlat1.x);
        u_xlat1.x = u_xlat1.x * VGlobals._EdgeLength;
        u_xlat12 = u_xlat12 / u_xlat1.x;
        tessFactor.edgeTessellationFactor[1] = max(u_xlat12, 1.0);
        u_xlat1.xyz = u_xlat0.xyz + u_xlat2.xyz;
        u_xlat0.xyz = (-u_xlat0.xyz) + u_xlat2.xyz;
        u_xlat0.x = dot(u_xlat0.xyz, u_xlat0.xyz);
        u_xlat0.x = sqrt(u_xlat0.x);
        u_xlat0.x = u_xlat0.x * VGlobals._ScreenParams.y;
        u_xlat4.xyz = fma(u_xlat1.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat4.x = dot(u_xlat4.xyz, u_xlat4.xyz);
        u_xlat4.x = sqrt(u_xlat4.x);
        u_xlat4.x = u_xlat4.x * VGlobals._EdgeLength;
        u_xlat0.x = u_xlat0.x / u_xlat4.x;
        tessFactor.edgeTessellationFactor[2] = max(u_xlat0.x, 1.0);
    }
    // join_phase3
    {
        u_xlat0.x = tessFactor.edgeTessellationFactor[0] + tessFactor.edgeTessellationFactor[1];
        u_xlat0.x = u_xlat0.x + tessFactor.edgeTessellationFactor[2];
        tessFactor.insideTessellationFactor = u_xlat0.x * 0.333333343;
    }
    controlPoints[mtl_VertexID] = output;
    tessFactors[internalPatchID] = tessFactor;
}
// SHADER_STAGE_HULL_end
// SHADER_STAGE_DOMAIN_begin
struct Mtl_VertexInPostTess
{
    patch_control_point<Mtl_ControlPointIn> cp;
};
struct Mtl_VertexOutPostTess
{
    float4 mtl_Position [[ position ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float4 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float4 TEXCOORD3 [[ user(TEXCOORD3) ]];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    sampler sampler_Height [[ sampler (0) ]],
    texture2d<float, access::sample > _Height [[ texture(0) ]] ,
    float3 mtl_TessCoord [[ position_in_patch ]],
    uint patchID [[ patch_id ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    Mtl_VertexInPostTess input [[ stage_in ]])
{
#pragma clang diagnostic pop
    Mtl_VertexOutPostTess output;
    MTLTriangleTessellationFactorsHalf tessFactor;
    tessFactor = tessFactors[patchID];
    float4 u_xlat0;
    float4 u_xlat1;
    float4 u_xlat2;
    float3 u_xlat3;
    float3 u_xlat4;
    float2 u_xlat13;
    float u_xlat15;
    bool u_xlatb15;
    u_xlat0.xy = mtl_TessCoord.yy * input.cp[1].TEXCOORD2.xy;
    u_xlat0.xy = fma(input.cp[0].TEXCOORD2.xy, mtl_TessCoord.xx, u_xlat0.xy);
    u_xlat0.xy = fma(input.cp[2].TEXCOORD2.xy, mtl_TessCoord.zz, u_xlat0.xy);
    u_xlat0.xy = fma(u_xlat0.xy, VGlobals.unity_DynamicLightmapST.xy, VGlobals.unity_DynamicLightmapST.zw);
    u_xlat1.xy = mtl_TessCoord.yy * input.cp[1].TEXCOORD1.xy;
    u_xlat1.xy = fma(input.cp[0].TEXCOORD1.xy, mtl_TessCoord.xx, u_xlat1.xy);
    u_xlat1.xy = fma(input.cp[2].TEXCOORD1.xy, mtl_TessCoord.zz, u_xlat1.xy);
    u_xlat1.xy = fma(u_xlat1.xy, VGlobals.unity_LightmapST.xy, VGlobals.unity_LightmapST.zw);
    u_xlat2 = mtl_TessCoord.yyyy * input.cp[1].INTERNALTESSPOS0;
    u_xlat2 = fma(input.cp[0].INTERNALTESSPOS0, mtl_TessCoord.xxxx, u_xlat2);
    u_xlat2 = fma(input.cp[2].INTERNALTESSPOS0, mtl_TessCoord.zzzz, u_xlat2);
    u_xlat3.xy = mtl_TessCoord.yy * input.cp[1].TEXCOORD0.xy;
    u_xlat3.xy = fma(input.cp[0].TEXCOORD0.xy, mtl_TessCoord.xx, u_xlat3.xy);
    u_xlat3.xy = fma(input.cp[2].TEXCOORD0.xy, mtl_TessCoord.zz, u_xlat3.xy);
    u_xlat13.xy = u_xlat3.xy * float2(VGlobals._Tile);
    output.TEXCOORD0.xy = fma(u_xlat3.xy, VGlobals._texcoord_ST.xy, VGlobals._texcoord_ST.zw);
    u_xlat3.xyz = _Height.sample(sampler_Height, u_xlat13.xy, level(1.0)).xyz;
    u_xlat4.xyz = mtl_TessCoord.yyy * input.cp[1].NORMAL0.xyz;
    u_xlat4.xyz = fma(input.cp[0].NORMAL0.xyz, mtl_TessCoord.xxx, u_xlat4.xyz);
    u_xlat4.xyz = fma(input.cp[2].NORMAL0.xyz, mtl_TessCoord.zzz, u_xlat4.xyz);
    u_xlat3.xyz = u_xlat3.xyz * u_xlat4.xyz;
    u_xlat2.xyz = fma(u_xlat3.xyz, float3(VGlobals._HeightDisplacement), u_xlat2.xyz);
    u_xlatb15 = 0.0<u_xlat2.z;
    u_xlat1.z = u_xlatb15 ? 9.99999975e-05 : float(0.0);
    u_xlat1.xyz = (VGlobals.unity_MetaVertexControl.x) ? u_xlat1.xyz : u_xlat2.xyz;
    u_xlatb15 = 0.0<u_xlat1.z;
    u_xlat0.z = u_xlatb15 ? 9.99999975e-05 : float(0.0);
    u_xlat0.xyz = (VGlobals.unity_MetaVertexControl.y) ? u_xlat0.xyz : u_xlat1.xyz;
    u_xlat1 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat0.xxxx, u_xlat1);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat0.zzzz, u_xlat1);
    output.mtl_Position = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_MatrixVP[3];
    u_xlat0.xyz = u_xlat2.yyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz;
    u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, u_xlat2.xxx, u_xlat0.xyz);
    u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, u_xlat2.zzz, u_xlat0.xyz);
    u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, u_xlat2.www, u_xlat0.xyz);
    output.TEXCOORD1.w = u_xlat0.x;
    u_xlat1.y = dot(u_xlat4.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat1.z = dot(u_xlat4.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat1.x = dot(u_xlat4.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat0.x = dot(u_xlat1.xyz, u_xlat1.xyz);
    u_xlat0.x = rsqrt(u_xlat0.x);
    u_xlat1.xyz = u_xlat0.xxx * u_xlat1.xyz;
    output.TEXCOORD1.z = u_xlat1.y;
    u_xlat2 = mtl_TessCoord.yyyy * input.cp[1].TANGENT0;
    u_xlat2 = fma(input.cp[0].TANGENT0, mtl_TessCoord.xxxx, u_xlat2);
    u_xlat2 = fma(input.cp[2].TANGENT0, mtl_TessCoord.zzzz, u_xlat2);
    u_xlat3.xyz = u_xlat2.yyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].yzx;
    u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].yzx, u_xlat2.xxx, u_xlat3.xyz);
    u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].yzx, u_xlat2.zzz, u_xlat3.xyz);
    u_xlat0.x = u_xlat2.w * VGlobals.unity_WorldTransformParams.w;
    u_xlat15 = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat15 = rsqrt(u_xlat15);
    u_xlat2.xyz = float3(u_xlat15) * u_xlat2.xyz;
    u_xlat3.xyz = u_xlat1.xyz * u_xlat2.xyz;
    u_xlat3.xyz = fma(u_xlat1.zxy, u_xlat2.yzx, (-u_xlat3.xyz));
    u_xlat3.xyz = u_xlat0.xxx * u_xlat3.xyz;
    output.TEXCOORD1.y = u_xlat3.x;
    output.TEXCOORD1.x = u_xlat2.z;
    output.TEXCOORD2.w = u_xlat0.y;
    output.TEXCOORD3.w = u_xlat0.z;
    output.TEXCOORD2.x = u_xlat2.x;
    output.TEXCOORD3.x = u_xlat2.y;
    output.TEXCOORD2.z = u_xlat1.z;
    output.TEXCOORD3.z = u_xlat1.x;
    output.TEXCOORD2.y = u_xlat3.y;
    output.TEXCOORD3.y = u_xlat3.z;
    return output;
}
// SHADER_STAGE_DOMAIN_end
Refreshing native plugins compatible for Editor in 2.34 ms, found 2 plugins.
Preloading 0 native plugins for Editor in 0.00 ms.
Unloading 3375 Unused Serialized files (Serialized files now loaded: 0)
Unloading 20 unused Assets / (0.6 MB). Loaded Objects now: 3916.
Memory consumption went from 136.5 MB to 135.9 MB.
Total: 5.683753 ms (FindLiveObjects: 0.396462 ms CreateObjectMapping: 0.405223 ms MarkObjects: 4.379152 ms  DeleteObjects: 0.501558 ms)

AssetImportParameters requested are different than current active one (requested -> active):
  custom:video-decoder-ogg-theora: a1e56fd34408186e4bbccfd4996cb3dc -> 
  custom:container-muxer-webm: aa71ff27fc2769a1b78a27578f13a17b -> 
  custom:container-demuxer-webm: 4f35f7cbe854078d1ac9338744f61a02 -> 
  custom:video-encoder-webm-vp8: eb34c28f22e8b96e1ab97ce403110664 -> 
  custom:framework-osx-AVFoundation: b23960f63f64bdc6ff669e2cdcee2391 -> 
  custom:audio-encoder-webm-vorbis: bf7c407c2cedff20999df2af8eb42d56 -> 
  custom:container-demuxer-ogg: 62fdf1f143b41e24485cea50d1cbac27 -> 
  custom:video-decoder-webm-vp8: 9c59270c3fd7afecdb556c50c9e8de78 -> 
  custom:audio-decoder-ogg-vorbis: bf7c407c2cedff20999df2af8eb42d56 -> 
========================================================================
Received Prepare
Registering precompiled user dll's ...
Registered in 0.003452 seconds.
Begin MonoManager ReloadAssembly
Symbol file LoadedFromMemory doesn't match image /Users/kamilaamendolagine/Desktop/Staugen Raug v2 - Prefab - Map 1.01/Library/PackageCache/com.unity.visualscripting@1.7.8/Editor/VisualScripting.Core/Dependencies/YamlDotNet/Unity.VisualScripting.YamlDotNet.dll
Symbol file LoadedFromMemory doesn't match image /Users/kamilaamendolagine/Desktop/Staugen Raug v2 - Prefab - Map 1.01/Library/PackageCache/com.unity.visualscripting@1.7.8/Editor/VisualScripting.Core/Dependencies/DotNetZip/Unity.VisualScripting.IonicZip.dll
Native extension for OSXStandalone target not found
Native extension for WebGL target not found
Refreshing native plugins compatible for Editor in 1.02 ms, found 2 plugins.
Preloading 0 native plugins for Editor in 0.00 ms.
Mono: successfully reloaded assembly
- Completed reload, in  1.867 seconds
Domain Reload Profiling:
	ReloadAssembly (1868ms)
		BeginReloadAssembly (204ms)
			ExecutionOrderSort (0ms)
			DisableScriptedObjects (10ms)
			BackupInstance (0ms)
			ReleaseScriptingObjects (0ms)
			CreateAndSetChildDomain (90ms)
		EndReloadAssembly (1493ms)
			LoadAssemblies (91ms)
			RebuildTransferFunctionScriptingTraits (0ms)
			SetupTypeCache (503ms)
			ReleaseScriptCaches (2ms)
			RebuildScriptCaches (85ms)
			SetupLoadedEditorAssemblies (697ms)
				LogAssemblyErrors (0ms)
				InitializePlatformSupportModulesInManaged (20ms)
				SetLoadedEditorAssemblies (1ms)
				RefreshPlugins (1ms)
				BeforeProcessingInitializeOnLoad (99ms)
				ProcessInitializeOnLoadAttributes (520ms)
				ProcessInitializeOnLoadMethodAttributes (51ms)
				AfterProcessingInitializeOnLoad (4ms)
				EditorAssembliesLoaded (0ms)
			ExecutionOrderSort2 (0ms)
			AwakeInstancesAfterBackupRestoration (9ms)
Platform modules already initialized, skipping
Compilation succeeded with: 

program_source:299:53: warning: writable resources in non-void post-tessellation vertex function
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
                                                    ^
program_source:305:30: note: writable buffer defined here
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
                             ^
program_source:306:48: note: writable buffer defined here
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
                                               ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float4 TEXCOORD0 [[ attribute(3) ]] ;
    float4 TEXCOORD1 [[ attribute(4) ]] ;
    float4 TEXCOORD2 [[ attribute(5) ]] ;
    float4 TEXCOORD3 [[ attribute(6) ]] ;
    float4 COLOR0 [[ attribute(7) ]] ;
};
struct Mtl_VertexOut
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float4 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float4 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float4 TEXCOORD3 [[ user(TEXCOORD3) ]];
    float4 COLOR0 [[ user(COLOR0) ]];
};
static Mtl_VertexOut vertexFunction(
    Mtl_VertexIn input)
{
    Mtl_VertexOut output;
    output.INTERNALTESSPOS0 = input.POSITION0;
    output.TANGENT0 = input.TANGENT0;
    output.NORMAL0.xyz = input.NORMAL0.xyz;
    output.TEXCOORD0 = input.TEXCOORD0;
    output.TEXCOORD1 = input.TEXCOORD1;
    output.TEXCOORD2 = input.TEXCOORD2;
    output.TEXCOORD3 = input.TEXCOORD3;
    output.COLOR0 = input.COLOR0;
    return output;
}
// SHADER_STAGE_HULL_begin
struct Mtl_ControlPoint
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float4 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float4 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float4 TEXCOORD3 [[ user(TEXCOORD3) ]];
    float4 COLOR0 [[ user(COLOR0) ]];
};
struct Mtl_ControlPointIn
{
    float4 INTERNALTESSPOS0 [[ attribute(8) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float4 TEXCOORD0 [[ attribute(3) ]] ;
    float4 TEXCOORD1 [[ attribute(4) ]] ;
    float4 TEXCOORD2 [[ attribute(5) ]] ;
    float4 TEXCOORD3 [[ attribute(6) ]] ;
    float4 COLOR0 [[ attribute(7) ]] ;
};
struct Mtl_KernelPatchInfo
{
    uint numPatches;
    ushort numControlPointsPerPatch;
};
struct VGlobals_Type
{
    float4 _Time;
    float4 _SinTime;
    float4 _CosTime;
    float4 unity_DeltaTime;
    float3 _WorldSpaceCameraPos;
    float4 _ProjectionParams;
    float4 _ScreenParams;
    float4 _ZBufferParams;
    float4 unity_OrthoParams;
    float4 unity_CameraWorldClipPlanes[6];
    float4 hlslcc_mtx4x4unity_CameraProjection[4];
    float4 hlslcc_mtx4x4unity_CameraInvProjection[4];
    float4 hlslcc_mtx4x4unity_WorldToCamera[4];
    float4 hlslcc_mtx4x4unity_CameraToWorld[4];
    float4 _WorldSpaceLightPos0;
    float4 _LightPositionRange;
    float4 _LightProjectionParams;
    float4 unity_4LightPosX0;
    float4 unity_4LightPosY0;
    float4 unity_4LightPosZ0;
    float4 unity_4LightAtten0;
    float4 unity_LightColor[8];
    float4 unity_LightPosition[8];
    float4 unity_LightAtten[8];
    float4 unity_SpotDirection[8];
    float4 unity_SHAr;
    float4 unity_SHAg;
    float4 unity_SHAb;
    float4 unity_SHBr;
    float4 unity_SHBg;
    float4 unity_SHBb;
    float4 unity_SHC;
    float4 unity_OcclusionMaskSelector;
    float4 unity_ProbesOcclusion;
    float3 unity_LightColor0;
    float3 unity_LightColor1;
    float3 unity_LightColor2;
    float3 unity_LightColor3;
    float4 unity_ShadowSplitSpheres[4];
    float4 unity_ShadowSplitSqRadii;
    float4 unity_LightShadowBias;
    float4 _LightSplitsNear;
    float4 _LightSplitsFar;
    float4 hlslcc_mtx4x4unity_WorldToShadow[16];
    float4 _LightShadowData;
    float4 unity_ShadowFadeCenterAndType;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 unity_LODFade;
    float4 unity_WorldTransformParams;
    float4 unity_RenderingLayer;
    float4 hlslcc_mtx4x4glstate_matrix_transpose_modelview0[4];
    float4 glstate_lightmodel_ambient;
    float4 unity_AmbientSky;
    float4 unity_AmbientEquator;
    float4 unity_AmbientGround;
    float4 unity_IndirectSpecColor;
    float4 hlslcc_mtx4x4glstate_matrix_projection[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixInvV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    int unity_StereoEyeIndex;
    float4 unity_ShadowColor;
    float4 unity_FogColor;
    float4 unity_FogParams;
    float4 unity_LightmapST;
    float4 unity_DynamicLightmapST;
    float4 unity_SpecCube0_BoxMax;
    float4 unity_SpecCube0_BoxMin;
    float4 unity_SpecCube0_ProbePosition;
    float4 unity_SpecCube0_HDR;
    float4 unity_SpecCube1_BoxMax;
    float4 unity_SpecCube1_BoxMin;
    float4 unity_SpecCube1_ProbePosition;
    float4 unity_SpecCube1_HDR;
    float4 unity_ProbeVolumeParams;
    float4 hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[4];
    float3 unity_ProbeVolumeSizeInv;
    float3 unity_ProbeVolumeMin;
    float4 unity_Lightmap_HDR;
    float4 unity_DynamicLightmap_HDR;
    float4 _LightColor0;
    float4 _SpecColor;
    float _Tile;
    float _HeightDisplacement;
    float _NormalScale;
    float4 _ColorTint;
    float _MetallicStrength;
    float _SmoothnessStrength;
    float _EdgeLength;
    float4 _texcoord_ST;
};
struct Mtl_HullIn
{
    Mtl_VertexOut cp[3];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
kernel void patchKernel(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn vertexInput [[ stage_in ]],
    uint2 tID [[ thread_position_in_grid ]],
    ushort2 groupID [[ threadgroup_position_in_grid ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    constant Mtl_KernelPatchInfo &patchInfo [[ buffer(3) ]])
{
#pragma clang diagnostic pop
    Mtl_ControlPoint output;
    const uint numPatchesInThreadGroup = 10;
    const uint patchID = (tID.x / patchInfo.numControlPointsPerPatch);
    const bool patchValid = (patchID < patchInfo.numPatches);
    const uint mtl_BaseInstance = 0;
    const uint mtl_InstanceID = groupID.y - mtl_BaseInstance;
    const uint internalPatchID = mtl_InstanceID * patchInfo.numPatches + patchID;
    const uint patchIDInThreadGroup = (patchID % numPatchesInThreadGroup);
    const uint controlPointID = (tID.x % patchInfo.numControlPointsPerPatch);
    const uint mtl_BaseVertex = 0;
    const uint mtl_VertexID = ((mtl_InstanceID * (patchInfo.numControlPointsPerPatch * patchInfo.numPatches)) + tID.x) - mtl_BaseVertex;
    threadgroup Mtl_HullIn inputGroup[numPatchesInThreadGroup];
    threadgroup Mtl_HullIn &input = inputGroup[patchIDInThreadGroup];
    MTLTriangleTessellationFactorsHalf tessFactor;
    if (patchValid) {
        input.cp[controlPointID] = vertexFunction(vertexInput);
        output.INTERNALTESSPOS0 = input.cp[controlPointID].INTERNALTESSPOS0;
        output.TANGENT0 = input.cp[controlPointID].TANGENT0;
        output.NORMAL0 = input.cp[controlPointID].NORMAL0;
        output.TEXCOORD0 = input.cp[controlPointID].TEXCOORD0;
        output.TEXCOORD1 = input.cp[controlPointID].TEXCOORD1;
        output.TEXCOORD2 = input.cp[controlPointID].TEXCOORD2;
        output.TEXCOORD3 = input.cp[controlPointID].TEXCOORD3;
        output.COLOR0 = input.cp[controlPointID].COLOR0;
    }
    threadgroup_barrier(mem_flags::mem_threadgroup);
    if (!patchValid) {
        return;
    }
    float3 u_xlat0;
    float3 u_xlat1;
    float3 u_xlat2;
    float3 u_xlat3;
    float3 u_xlat4;
    float u_xlat12;
    float u_xlat13;
    // fork_phase2
    {
        u_xlat0.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[1].INTERNALTESSPOS0.yyy;
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[1].INTERNALTESSPOS0.xxx, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[1].INTERNALTESSPOS0.zzz, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[1].INTERNALTESSPOS0.www, u_xlat0.xyz);
        u_xlat1.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[2].INTERNALTESSPOS0.yyy;
        u_xlat1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[2].INTERNALTESSPOS0.xxx, u_xlat1.xyz);
        u_xlat1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[2].INTERNALTESSPOS0.zzz, u_xlat1.xyz);
        u_xlat1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[2].INTERNALTESSPOS0.www, u_xlat1.xyz);
        u_xlat2.xyz = u_xlat0.xyz + u_xlat1.xyz;
        u_xlat2.xyz = fma(u_xlat2.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat12 = dot(u_xlat2.xyz, u_xlat2.xyz);
        u_xlat12 = sqrt(u_xlat12);
        u_xlat12 = u_xlat12 * VGlobals._EdgeLength;
        u_xlat2.xyz = u_xlat0.xyz + (-u_xlat1.xyz);
        u_xlat13 = dot(u_xlat2.xyz, u_xlat2.xyz);
        u_xlat13 = sqrt(u_xlat13);
        u_xlat13 = u_xlat13 * VGlobals._ScreenParams.y;
        u_xlat12 = u_xlat13 / u_xlat12;
        tessFactor.edgeTessellationFactor[0] = max(u_xlat12, 1.0);
        u_xlat2.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[0].INTERNALTESSPOS0.yyy;
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[0].INTERNALTESSPOS0.xxx, u_xlat2.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[0].INTERNALTESSPOS0.zzz, u_xlat2.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[0].INTERNALTESSPOS0.www, u_xlat2.xyz);
        u_xlat3.xyz = u_xlat1.xyz + u_xlat2.xyz;
        u_xlat1.xyz = u_xlat1.xyz + (-u_xlat2.xyz);
        u_xlat12 = dot(u_xlat1.xyz, u_xlat1.xyz);
        u_xlat12 = sqrt(u_xlat12);
        u_xlat12 = u_xlat12 * VGlobals._ScreenParams.y;
        u_xlat1.xyz = fma(u_xlat3.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat1.x = dot(u_xlat1.xyz, u_xlat1.xyz);
        u_xlat1.x = sqrt(u_xlat1.x);
        u_xlat1.x = u_xlat1.x * VGlobals._EdgeLength;
        u_xlat12 = u_xlat12 / u_xlat1.x;
        tessFactor.edgeTessellationFactor[1] = max(u_xlat12, 1.0);
        u_xlat1.xyz = u_xlat0.xyz + u_xlat2.xyz;
        u_xlat0.xyz = (-u_xlat0.xyz) + u_xlat2.xyz;
        u_xlat0.x = dot(u_xlat0.xyz, u_xlat0.xyz);
        u_xlat0.x = sqrt(u_xlat0.x);
        u_xlat0.x = u_xlat0.x * VGlobals._ScreenParams.y;
        u_xlat4.xyz = fma(u_xlat1.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat4.x = dot(u_xlat4.xyz, u_xlat4.xyz);
        u_xlat4.x = sqrt(u_xlat4.x);
        u_xlat4.x = u_xlat4.x * VGlobals._EdgeLength;
        u_xlat0.x = u_xlat0.x / u_xlat4.x;
        tessFactor.edgeTessellationFactor[2] = max(u_xlat0.x, 1.0);
    }
    // join_phase3
    {
        u_xlat0.x = tessFactor.edgeTessellationFactor[0] + tessFactor.edgeTessellationFactor[1];
        u_xlat0.x = u_xlat0.x + tessFactor.edgeTessellationFactor[2];
        tessFactor.insideTessellationFactor = u_xlat0.x * 0.333333343;
    }
    controlPoints[mtl_VertexID] = output;
    tessFactors[internalPatchID] = tessFactor;
}
// SHADER_STAGE_HULL_end
// SHADER_STAGE_DOMAIN_begin
struct Mtl_VertexInPostTess
{
    patch_control_point<Mtl_ControlPointIn> cp;
};
struct Mtl_VertexOutPostTess
{
    float4 mtl_Position [[ position ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float4 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float4 TEXCOORD3 [[ user(TEXCOORD3) ]];
    float4 TEXCOORD6 [[ user(TEXCOORD6) ]];
    float4 TEXCOORD7 [[ user(TEXCOORD7) ]];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    sampler sampler_Height [[ sampler (0) ]],
    texture2d<float, access::sample > _Height [[ texture(0) ]] ,
    float3 mtl_TessCoord [[ position_in_patch ]],
    uint patchID [[ patch_id ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    Mtl_VertexInPostTess input [[ stage_in ]])
{
#pragma clang diagnostic pop
    Mtl_VertexOutPostTess output;
    MTLTriangleTessellationFactorsHalf tessFactor;
    tessFactor = tessFactors[patchID];
    float4 u_xlat0;
    float4 u_xlat1;
    float4 u_xlat2;
    float4 u_xlat3;
    float2 u_xlat9;
    float u_xlat12;
    float u_xlat13;
    u_xlat0 = mtl_TessCoord.yyyy * input.cp[1].INTERNALTESSPOS0;
    u_xlat0 = fma(input.cp[0].INTERNALTESSPOS0, mtl_TessCoord.xxxx, u_xlat0);
    u_xlat0 = fma(input.cp[2].INTERNALTESSPOS0, mtl_TessCoord.zzzz, u_xlat0);
    u_xlat1.xy = mtl_TessCoord.yy * input.cp[1].TEXCOORD0.xy;
    u_xlat1.xy = fma(input.cp[0].TEXCOORD0.xy, mtl_TessCoord.xx, u_xlat1.xy);
    u_xlat1.xy = fma(input.cp[2].TEXCOORD0.xy, mtl_TessCoord.zz, u_xlat1.xy);
    u_xlat9.xy = u_xlat1.xy * float2(VGlobals._Tile);
    output.TEXCOORD0.xy = fma(u_xlat1.xy, VGlobals._texcoord_ST.xy, VGlobals._texcoord_ST.zw);
    u_xlat1.xyz = _Height.sample(sampler_Height, u_xlat9.xy, level(1.0)).xyz;
    u_xlat2.xyz = mtl_TessCoord.yyy * input.cp[1].NORMAL0.xyz;
    u_xlat2.xyz = fma(input.cp[0].NORMAL0.xyz, mtl_TessCoord.xxx, u_xlat2.xyz);
    u_xlat2.xyz = fma(input.cp[2].NORMAL0.xyz, mtl_TessCoord.zzz, u_xlat2.xyz);
    u_xlat1.xyz = u_xlat1.xyz * u_xlat2.xyz;
    u_xlat0.xyz = fma(u_xlat1.xyz, float3(VGlobals._HeightDisplacement), u_xlat0.xyz);
    u_xlat1 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], u_xlat0.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], u_xlat0.zzzz, u_xlat1);
    u_xlat3 = u_xlat1 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, u_xlat0.www, u_xlat1.xyz);
    u_xlat1 = u_xlat3.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat3.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat3.zzzz, u_xlat1);
    output.mtl_Position = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat3.wwww, u_xlat1);
    u_xlat1.y = dot(u_xlat2.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat1.z = dot(u_xlat2.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat1.x = dot(u_xlat2.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat12 = dot(u_xlat1.xyz, u_xlat1.xyz);
    u_xlat12 = rsqrt(u_xlat12);
    u_xlat1.xyz = float3(u_xlat12) * u_xlat1.xyz;
    output.TEXCOORD1.z = u_xlat1.y;
    u_xlat2 = mtl_TessCoord.yyyy * input.cp[1].TANGENT0;
    u_xlat2 = fma(input.cp[0].TANGENT0, mtl_TessCoord.xxxx, u_xlat2);
    u_xlat2 = fma(input.cp[2].TANGENT0, mtl_TessCoord.zzzz, u_xlat2);
    u_xlat3.xyz = u_xlat2.yyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].yzx;
    u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].yzx, u_xlat2.xxx, u_xlat3.xyz);
    u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].yzx, u_xlat2.zzz, u_xlat3.xyz);
    u_xlat12 = u_xlat2.w * VGlobals.unity_WorldTransformParams.w;
    u_xlat13 = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat13 = rsqrt(u_xlat13);
    u_xlat2.xyz = float3(u_xlat13) * u_xlat2.xyz;
    u_xlat3.xyz = u_xlat1.xyz * u_xlat2.xyz;
    u_xlat3.xyz = fma(u_xlat1.zxy, u_xlat2.yzx, (-u_xlat3.xyz));
    u_xlat3.xyz = float3(u_xlat12) * u_xlat3.xyz;
    output.TEXCOORD1.y = u_xlat3.x;
    output.TEXCOORD1.w = u_xlat0.x;
    output.TEXCOORD1.x = u_xlat2.z;
    output.TEXCOORD2.w = u_xlat0.y;
    output.TEXCOORD3.w = u_xlat0.z;
    output.TEXCOORD2.x = u_xlat2.x;
    output.TEXCOORD3.x = u_xlat2.y;
    output.TEXCOORD2.z = u_xlat1.z;
    output.TEXCOORD3.z = u_xlat1.x;
    output.TEXCOORD2.y = u_xlat3.y;
    output.TEXCOORD3.y = u_xlat3.z;
    output.TEXCOORD6 = float4(0.0, 0.0, 0.0, 0.0);
    output.TEXCOORD7 = float4(0.0, 0.0, 0.0, 0.0);
    return output;
}
// SHADER_STAGE_DOMAIN_end
Compilation succeeded with: 

program_source:301:53: warning: writable resources in non-void post-tessellation vertex function
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
                                                    ^
program_source:307:30: note: writable buffer defined here
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
                             ^
program_source:308:48: note: writable buffer defined here
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
                                               ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float4 TEXCOORD0 [[ attribute(3) ]] ;
    float4 TEXCOORD1 [[ attribute(4) ]] ;
    float4 TEXCOORD2 [[ attribute(5) ]] ;
    float4 TEXCOORD3 [[ attribute(6) ]] ;
    float4 COLOR0 [[ attribute(7) ]] ;
};
struct Mtl_VertexOut
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float4 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float4 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float4 TEXCOORD3 [[ user(TEXCOORD3) ]];
    float4 COLOR0 [[ user(COLOR0) ]];
};
static Mtl_VertexOut vertexFunction(
    Mtl_VertexIn input)
{
    Mtl_VertexOut output;
    output.INTERNALTESSPOS0 = input.POSITION0;
    output.TANGENT0 = input.TANGENT0;
    output.NORMAL0.xyz = input.NORMAL0.xyz;
    output.TEXCOORD0 = input.TEXCOORD0;
    output.TEXCOORD1 = input.TEXCOORD1;
    output.TEXCOORD2 = input.TEXCOORD2;
    output.TEXCOORD3 = input.TEXCOORD3;
    output.COLOR0 = input.COLOR0;
    return output;
}
// SHADER_STAGE_HULL_begin
struct Mtl_ControlPoint
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float4 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float4 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float4 TEXCOORD3 [[ user(TEXCOORD3) ]];
    float4 COLOR0 [[ user(COLOR0) ]];
};
struct Mtl_ControlPointIn
{
    float4 INTERNALTESSPOS0 [[ attribute(8) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float4 TEXCOORD0 [[ attribute(3) ]] ;
    float4 TEXCOORD1 [[ attribute(4) ]] ;
    float4 TEXCOORD2 [[ attribute(5) ]] ;
    float4 TEXCOORD3 [[ attribute(6) ]] ;
    float4 COLOR0 [[ attribute(7) ]] ;
};
struct Mtl_KernelPatchInfo
{
    uint numPatches;
    ushort numControlPointsPerPatch;
};
struct VGlobals_Type
{
    float4 _Time;
    float4 _SinTime;
    float4 _CosTime;
    float4 unity_DeltaTime;
    float3 _WorldSpaceCameraPos;
    float4 _ProjectionParams;
    float4 _ScreenParams;
    float4 _ZBufferParams;
    float4 unity_OrthoParams;
    float4 unity_CameraWorldClipPlanes[6];
    float4 hlslcc_mtx4x4unity_CameraProjection[4];
    float4 hlslcc_mtx4x4unity_CameraInvProjection[4];
    float4 hlslcc_mtx4x4unity_WorldToCamera[4];
    float4 hlslcc_mtx4x4unity_CameraToWorld[4];
    float4 _WorldSpaceLightPos0;
    float4 _LightPositionRange;
    float4 _LightProjectionParams;
    float4 unity_4LightPosX0;
    float4 unity_4LightPosY0;
    float4 unity_4LightPosZ0;
    float4 unity_4LightAtten0;
    float4 unity_LightColor[8];
    float4 unity_LightPosition[8];
    float4 unity_LightAtten[8];
    float4 unity_SpotDirection[8];
    float4 unity_SHAr;
    float4 unity_SHAg;
    float4 unity_SHAb;
    float4 unity_SHBr;
    float4 unity_SHBg;
    float4 unity_SHBb;
    float4 unity_SHC;
    float4 unity_OcclusionMaskSelector;
    float4 unity_ProbesOcclusion;
    float3 unity_LightColor0;
    float3 unity_LightColor1;
    float3 unity_LightColor2;
    float3 unity_LightColor3;
    float4 unity_ShadowSplitSpheres[4];
    float4 unity_ShadowSplitSqRadii;
    float4 unity_LightShadowBias;
    float4 _LightSplitsNear;
    float4 _LightSplitsFar;
    float4 hlslcc_mtx4x4unity_WorldToShadow[16];
    float4 _LightShadowData;
    float4 unity_ShadowFadeCenterAndType;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 unity_LODFade;
    float4 unity_WorldTransformParams;
    float4 unity_RenderingLayer;
    float4 hlslcc_mtx4x4glstate_matrix_transpose_modelview0[4];
    float4 glstate_lightmodel_ambient;
    float4 unity_AmbientSky;
    float4 unity_AmbientEquator;
    float4 unity_AmbientGround;
    float4 unity_IndirectSpecColor;
    float4 hlslcc_mtx4x4glstate_matrix_projection[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixInvV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    int unity_StereoEyeIndex;
    float4 unity_ShadowColor;
    float4 unity_FogColor;
    float4 unity_FogParams;
    float4 unity_LightmapST;
    float4 unity_DynamicLightmapST;
    float4 unity_SpecCube0_BoxMax;
    float4 unity_SpecCube0_BoxMin;
    float4 unity_SpecCube0_ProbePosition;
    float4 unity_SpecCube0_HDR;
    float4 unity_SpecCube1_BoxMax;
    float4 unity_SpecCube1_BoxMin;
    float4 unity_SpecCube1_ProbePosition;
    float4 unity_SpecCube1_HDR;
    float4 unity_ProbeVolumeParams;
    float4 hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[4];
    float3 unity_ProbeVolumeSizeInv;
    float3 unity_ProbeVolumeMin;
    float4 unity_Lightmap_HDR;
    float4 unity_DynamicLightmap_HDR;
    float4 _LightColor0;
    float4 _SpecColor;
    float4 hlslcc_mtx4x4unity_WorldToLight[4];
    float _Tile;
    float _HeightDisplacement;
    float _NormalScale;
    float4 _ColorTint;
    float _MetallicStrength;
    float _SmoothnessStrength;
    float _EdgeLength;
    float4 _texcoord_ST;
};
struct Mtl_HullIn
{
    Mtl_VertexOut cp[3];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
kernel void patchKernel(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn vertexInput [[ stage_in ]],
    uint2 tID [[ thread_position_in_grid ]],
    ushort2 groupID [[ threadgroup_position_in_grid ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    constant Mtl_KernelPatchInfo &patchInfo [[ buffer(3) ]])
{
#pragma clang diagnostic pop
    Mtl_ControlPoint output;
    const uint numPatchesInThreadGroup = 10;
    const uint patchID = (tID.x / patchInfo.numControlPointsPerPatch);
    const bool patchValid = (patchID < patchInfo.numPatches);
    const uint mtl_BaseInstance = 0;
    const uint mtl_InstanceID = groupID.y - mtl_BaseInstance;
    const uint internalPatchID = mtl_InstanceID * patchInfo.numPatches + patchID;
    const uint patchIDInThreadGroup = (patchID % numPatchesInThreadGroup);
    const uint controlPointID = (tID.x % patchInfo.numControlPointsPerPatch);
    const uint mtl_BaseVertex = 0;
    const uint mtl_VertexID = ((mtl_InstanceID * (patchInfo.numControlPointsPerPatch * patchInfo.numPatches)) + tID.x) - mtl_BaseVertex;
    threadgroup Mtl_HullIn inputGroup[numPatchesInThreadGroup];
    threadgroup Mtl_HullIn &input = inputGroup[patchIDInThreadGroup];
    MTLTriangleTessellationFactorsHalf tessFactor;
    if (patchValid) {
        input.cp[controlPointID] = vertexFunction(vertexInput);
        output.INTERNALTESSPOS0 = input.cp[controlPointID].INTERNALTESSPOS0;
        output.TANGENT0 = input.cp[controlPointID].TANGENT0;
        output.NORMAL0 = input.cp[controlPointID].NORMAL0;
        output.TEXCOORD0 = input.cp[controlPointID].TEXCOORD0;
        output.TEXCOORD1 = input.cp[controlPointID].TEXCOORD1;
        output.TEXCOORD2 = input.cp[controlPointID].TEXCOORD2;
        output.TEXCOORD3 = input.cp[controlPointID].TEXCOORD3;
        output.COLOR0 = input.cp[controlPointID].COLOR0;
    }
    threadgroup_barrier(mem_flags::mem_threadgroup);
    if (!patchValid) {
        return;
    }
    float3 u_xlat0;
    float3 u_xlat1;
    float3 u_xlat2;
    float3 u_xlat3;
    float3 u_xlat4;
    float u_xlat12;
    float u_xlat13;
    // fork_phase2
    {
        u_xlat0.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[1].INTERNALTESSPOS0.yyy;
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[1].INTERNALTESSPOS0.xxx, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[1].INTERNALTESSPOS0.zzz, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[1].INTERNALTESSPOS0.www, u_xlat0.xyz);
        u_xlat1.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[2].INTERNALTESSPOS0.yyy;
        u_xlat1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[2].INTERNALTESSPOS0.xxx, u_xlat1.xyz);
        u_xlat1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[2].INTERNALTESSPOS0.zzz, u_xlat1.xyz);
        u_xlat1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[2].INTERNALTESSPOS0.www, u_xlat1.xyz);
        u_xlat2.xyz = u_xlat0.xyz + u_xlat1.xyz;
        u_xlat2.xyz = fma(u_xlat2.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat12 = dot(u_xlat2.xyz, u_xlat2.xyz);
        u_xlat12 = sqrt(u_xlat12);
        u_xlat12 = u_xlat12 * VGlobals._EdgeLength;
        u_xlat2.xyz = u_xlat0.xyz + (-u_xlat1.xyz);
        u_xlat13 = dot(u_xlat2.xyz, u_xlat2.xyz);
        u_xlat13 = sqrt(u_xlat13);
        u_xlat13 = u_xlat13 * VGlobals._ScreenParams.y;
        u_xlat12 = u_xlat13 / u_xlat12;
        tessFactor.edgeTessellationFactor[0] = max(u_xlat12, 1.0);
        u_xlat2.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[0].INTERNALTESSPOS0.yyy;
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[0].INTERNALTESSPOS0.xxx, u_xlat2.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[0].INTERNALTESSPOS0.zzz, u_xlat2.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[0].INTERNALTESSPOS0.www, u_xlat2.xyz);
        u_xlat3.xyz = u_xlat1.xyz + u_xlat2.xyz;
        u_xlat1.xyz = u_xlat1.xyz + (-u_xlat2.xyz);
        u_xlat12 = dot(u_xlat1.xyz, u_xlat1.xyz);
        u_xlat12 = sqrt(u_xlat12);
        u_xlat12 = u_xlat12 * VGlobals._ScreenParams.y;
        u_xlat1.xyz = fma(u_xlat3.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat1.x = dot(u_xlat1.xyz, u_xlat1.xyz);
        u_xlat1.x = sqrt(u_xlat1.x);
        u_xlat1.x = u_xlat1.x * VGlobals._EdgeLength;
        u_xlat12 = u_xlat12 / u_xlat1.x;
        tessFactor.edgeTessellationFactor[1] = max(u_xlat12, 1.0);
        u_xlat1.xyz = u_xlat0.xyz + u_xlat2.xyz;
        u_xlat0.xyz = (-u_xlat0.xyz) + u_xlat2.xyz;
        u_xlat0.x = dot(u_xlat0.xyz, u_xlat0.xyz);
        u_xlat0.x = sqrt(u_xlat0.x);
        u_xlat0.x = u_xlat0.x * VGlobals._ScreenParams.y;
        u_xlat4.xyz = fma(u_xlat1.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat4.x = dot(u_xlat4.xyz, u_xlat4.xyz);
        u_xlat4.x = sqrt(u_xlat4.x);
        u_xlat4.x = u_xlat4.x * VGlobals._EdgeLength;
        u_xlat0.x = u_xlat0.x / u_xlat4.x;
        tessFactor.edgeTessellationFactor[2] = max(u_xlat0.x, 1.0);
    }
    // join_phase3
    {
        u_xlat0.x = tessFactor.edgeTessellationFactor[0] + tessFactor.edgeTessellationFactor[1];
        u_xlat0.x = u_xlat0.x + tessFactor.edgeTessellationFactor[2];
        tessFactor.insideTessellationFactor = u_xlat0.x * 0.333333343;
    }
    controlPoints[mtl_VertexID] = output;
    tessFactors[internalPatchID] = tessFactor;
}
// SHADER_STAGE_HULL_end
// SHADER_STAGE_DOMAIN_begin
struct Mtl_VertexInPostTess
{
    patch_control_point<Mtl_ControlPointIn> cp;
};
struct Mtl_VertexOutPostTess
{
    float4 mtl_Position [[ position ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float3 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float3 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float3 TEXCOORD3 [[ user(TEXCOORD3) ]];
    float3 TEXCOORD4 [[ user(TEXCOORD4) ]];
    float3 TEXCOORD5 [[ user(TEXCOORD5) ]];
    float4 TEXCOORD6 [[ user(TEXCOORD6) ]];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    sampler sampler_Height [[ sampler (0) ]],
    texture2d<float, access::sample > _Height [[ texture(0) ]] ,
    float3 mtl_TessCoord [[ position_in_patch ]],
    uint patchID [[ patch_id ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    Mtl_VertexInPostTess input [[ stage_in ]])
{
#pragma clang diagnostic pop
    Mtl_VertexOutPostTess output;
    MTLTriangleTessellationFactorsHalf tessFactor;
    tessFactor = tessFactors[patchID];
    float4 u_xlat0;
    float3 u_xlat1;
    float4 u_xlat2;
    float4 u_xlat3;
    float4 u_xlat4;
    float2 u_xlat10;
    float u_xlat16;
    u_xlat0.xy = mtl_TessCoord.yy * input.cp[1].TEXCOORD0.xy;
    u_xlat0.xy = fma(input.cp[0].TEXCOORD0.xy, mtl_TessCoord.xx, u_xlat0.xy);
    u_xlat0.xy = fma(input.cp[2].TEXCOORD0.xy, mtl_TessCoord.zz, u_xlat0.xy);
    u_xlat10.xy = u_xlat0.xy * float2(VGlobals._Tile);
    output.TEXCOORD0.xy = fma(u_xlat0.xy, VGlobals._texcoord_ST.xy, VGlobals._texcoord_ST.zw);
    u_xlat0.xyz = _Height.sample(sampler_Height, u_xlat10.xy, level(1.0)).xyz;
    u_xlat1.xyz = mtl_TessCoord.yyy * input.cp[1].NORMAL0.xyz;
    u_xlat1.xyz = fma(input.cp[0].NORMAL0.xyz, mtl_TessCoord.xxx, u_xlat1.xyz);
    u_xlat1.xyz = fma(input.cp[2].NORMAL0.xyz, mtl_TessCoord.zzz, u_xlat1.xyz);
    u_xlat0.xyz = u_xlat0.xyz * u_xlat1.xyz;
    u_xlat2 = mtl_TessCoord.yyyy * input.cp[1].INTERNALTESSPOS0;
    u_xlat2 = fma(input.cp[0].INTERNALTESSPOS0, mtl_TessCoord.xxxx, u_xlat2);
    u_xlat2 = fma(input.cp[2].INTERNALTESSPOS0, mtl_TessCoord.zzzz, u_xlat2);
    u_xlat0.xyz = fma(u_xlat0.xyz, float3(VGlobals._HeightDisplacement), u_xlat2.xyz);
    u_xlat3 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], u_xlat0.xxxx, u_xlat3);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], u_xlat0.zzzz, u_xlat3);
    u_xlat3 = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat4 = u_xlat3.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat4 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat3.xxxx, u_xlat4);
    u_xlat4 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat3.zzzz, u_xlat4);
    output.mtl_Position = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat3.wwww, u_xlat4);
    u_xlat2.y = dot(u_xlat1.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat2.z = dot(u_xlat1.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat2.x = dot(u_xlat1.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat1.x = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat1.x = rsqrt(u_xlat1.x);
    u_xlat1.xyz = u_xlat1.xxx * u_xlat2.xyz;
    output.TEXCOORD1.z = u_xlat1.y;
    u_xlat3 = mtl_TessCoord.yyyy * input.cp[1].TANGENT0;
    u_xlat3 = fma(input.cp[0].TANGENT0, mtl_TessCoord.xxxx, u_xlat3);
    u_xlat3 = fma(input.cp[2].TANGENT0, mtl_TessCoord.zzzz, u_xlat3);
    u_xlat2.xyz = u_xlat3.yyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].yzx;
    u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].yzx, u_xlat3.xxx, u_xlat2.xyz);
    u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].yzx, u_xlat3.zzz, u_xlat2.xyz);
    u_xlat16 = u_xlat3.w * VGlobals.unity_WorldTransformParams.w;
    u_xlat3.x = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat3.x = rsqrt(u_xlat3.x);
    u_xlat2.xyz = u_xlat2.xyz * u_xlat3.xxx;
    u_xlat3.xyz = u_xlat1.xyz * u_xlat2.xyz;
    u_xlat3.xyz = fma(u_xlat1.zxy, u_xlat2.yzx, (-u_xlat3.xyz));
    u_xlat3.xyz = float3(u_xlat16) * u_xlat3.xyz;
    output.TEXCOORD1.y = u_xlat3.x;
    output.TEXCOORD1.x = u_xlat2.z;
    output.TEXCOORD2.x = u_xlat2.x;
    output.TEXCOORD3.x = u_xlat2.y;
    output.TEXCOORD2.z = u_xlat1.z;
    output.TEXCOORD3.z = u_xlat1.x;
    output.TEXCOORD2.y = u_xlat3.y;
    output.TEXCOORD3.y = u_xlat3.z;
    output.TEXCOORD4.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, u_xlat2.www, u_xlat0.xyz);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3], u_xlat2.wwww, u_xlat0);
    u_xlat1.xyz = u_xlat0.yyy * VGlobals.hlslcc_mtx4x4unity_WorldToLight[1].xyz;
    u_xlat1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_WorldToLight[0].xyz, u_xlat0.xxx, u_xlat1.xyz);
    u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_WorldToLight[2].xyz, u_xlat0.zzz, u_xlat1.xyz);
    output.TEXCOORD5.xyz = fma(VGlobals.hlslcc_mtx4x4unity_WorldToLight[3].xyz, u_xlat0.www, u_xlat0.xyz);
    output.TEXCOORD6 = float4(0.0, 0.0, 0.0, 0.0);
    return output;
}
// SHADER_STAGE_DOMAIN_end
Compilation succeeded with: 

program_source:293:53: warning: writable resources in non-void post-tessellation vertex function
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
                                                    ^
program_source:299:30: note: writable buffer defined here
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
                             ^
program_source:300:48: note: writable buffer defined here
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
                                               ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float4 TEXCOORD0 [[ attribute(3) ]] ;
    float4 TEXCOORD1 [[ attribute(4) ]] ;
    float4 TEXCOORD2 [[ attribute(5) ]] ;
    float4 TEXCOORD3 [[ attribute(6) ]] ;
    float4 COLOR0 [[ attribute(7) ]] ;
};
struct Mtl_VertexOut
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float4 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float4 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float4 TEXCOORD3 [[ user(TEXCOORD3) ]];
    float4 COLOR0 [[ user(COLOR0) ]];
};
static Mtl_VertexOut vertexFunction(
    Mtl_VertexIn input)
{
    Mtl_VertexOut output;
    output.INTERNALTESSPOS0 = input.POSITION0;
    output.TANGENT0 = input.TANGENT0;
    output.NORMAL0.xyz = input.NORMAL0.xyz;
    output.TEXCOORD0 = input.TEXCOORD0;
    output.TEXCOORD1 = input.TEXCOORD1;
    output.TEXCOORD2 = input.TEXCOORD2;
    output.TEXCOORD3 = input.TEXCOORD3;
    output.COLOR0 = input.COLOR0;
    return output;
}
// SHADER_STAGE_HULL_begin
struct Mtl_ControlPoint
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float4 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float4 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float4 TEXCOORD3 [[ user(TEXCOORD3) ]];
    float4 COLOR0 [[ user(COLOR0) ]];
};
struct Mtl_ControlPointIn
{
    float4 INTERNALTESSPOS0 [[ attribute(8) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float4 TEXCOORD0 [[ attribute(3) ]] ;
    float4 TEXCOORD1 [[ attribute(4) ]] ;
    float4 TEXCOORD2 [[ attribute(5) ]] ;
    float4 TEXCOORD3 [[ attribute(6) ]] ;
    float4 COLOR0 [[ attribute(7) ]] ;
};
struct Mtl_KernelPatchInfo
{
    uint numPatches;
    ushort numControlPointsPerPatch;
};
struct VGlobals_Type
{
    float4 _Time;
    float4 _SinTime;
    float4 _CosTime;
    float4 unity_DeltaTime;
    float3 _WorldSpaceCameraPos;
    float4 _ProjectionParams;
    float4 _ScreenParams;
    float4 _ZBufferParams;
    float4 unity_OrthoParams;
    float4 unity_CameraWorldClipPlanes[6];
    float4 hlslcc_mtx4x4unity_CameraProjection[4];
    float4 hlslcc_mtx4x4unity_CameraInvProjection[4];
    float4 hlslcc_mtx4x4unity_WorldToCamera[4];
    float4 hlslcc_mtx4x4unity_CameraToWorld[4];
    float4 _WorldSpaceLightPos0;
    float4 _LightPositionRange;
    float4 _LightProjectionParams;
    float4 unity_4LightPosX0;
    float4 unity_4LightPosY0;
    float4 unity_4LightPosZ0;
    float4 unity_4LightAtten0;
    float4 unity_LightColor[8];
    float4 unity_LightPosition[8];
    float4 unity_LightAtten[8];
    float4 unity_SpotDirection[8];
    float4 unity_SHAr;
    float4 unity_SHAg;
    float4 unity_SHAb;
    float4 unity_SHBr;
    float4 unity_SHBg;
    float4 unity_SHBb;
    float4 unity_SHC;
    float4 unity_OcclusionMaskSelector;
    float4 unity_ProbesOcclusion;
    float3 unity_LightColor0;
    float3 unity_LightColor1;
    float3 unity_LightColor2;
    float3 unity_LightColor3;
    float4 unity_ShadowSplitSpheres[4];
    float4 unity_ShadowSplitSqRadii;
    float4 unity_LightShadowBias;
    float4 _LightSplitsNear;
    float4 _LightSplitsFar;
    float4 hlslcc_mtx4x4unity_WorldToShadow[16];
    float4 _LightShadowData;
    float4 unity_ShadowFadeCenterAndType;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 unity_LODFade;
    float4 unity_WorldTransformParams;
    float4 unity_RenderingLayer;
    float4 hlslcc_mtx4x4glstate_matrix_transpose_modelview0[4];
    float4 glstate_lightmodel_ambient;
    float4 unity_AmbientSky;
    float4 unity_AmbientEquator;
    float4 unity_AmbientGround;
    float4 unity_IndirectSpecColor;
    float4 hlslcc_mtx4x4glstate_matrix_projection[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixInvV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    int unity_StereoEyeIndex;
    float4 unity_ShadowColor;
    float4 unity_FogColor;
    float4 unity_FogParams;
    float4 unity_LightmapST;
    float4 unity_DynamicLightmapST;
    float4 unity_SpecCube0_BoxMax;
    float4 unity_SpecCube0_BoxMin;
    float4 unity_SpecCube0_ProbePosition;
    float4 unity_SpecCube0_HDR;
    float4 unity_SpecCube1_BoxMax;
    float4 unity_SpecCube1_BoxMin;
    float4 unity_SpecCube1_ProbePosition;
    float4 unity_SpecCube1_HDR;
    float4 unity_ProbeVolumeParams;
    float4 hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[4];
    float3 unity_ProbeVolumeSizeInv;
    float3 unity_ProbeVolumeMin;
    float4 unity_Lightmap_HDR;
    float4 unity_DynamicLightmap_HDR;
    float4 _LightColor0;
    float4 _SpecColor;
    float _Tile;
    float _HeightDisplacement;
    float _NormalScale;
    float4 _ColorTint;
    float _MetallicStrength;
    float _SmoothnessStrength;
    float _EdgeLength;
};
struct Mtl_HullIn
{
    Mtl_VertexOut cp[3];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
kernel void patchKernel(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn vertexInput [[ stage_in ]],
    uint2 tID [[ thread_position_in_grid ]],
    ushort2 groupID [[ threadgroup_position_in_grid ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    constant Mtl_KernelPatchInfo &patchInfo [[ buffer(3) ]])
{
#pragma clang diagnostic pop
    Mtl_ControlPoint output;
    const uint numPatchesInThreadGroup = 10;
    const uint patchID = (tID.x / patchInfo.numControlPointsPerPatch);
    const bool patchValid = (patchID < patchInfo.numPatches);
    const uint mtl_BaseInstance = 0;
    const uint mtl_InstanceID = groupID.y - mtl_BaseInstance;
    const uint internalPatchID = mtl_InstanceID * patchInfo.numPatches + patchID;
    const uint patchIDInThreadGroup = (patchID % numPatchesInThreadGroup);
    const uint controlPointID = (tID.x % patchInfo.numControlPointsPerPatch);
    const uint mtl_BaseVertex = 0;
    const uint mtl_VertexID = ((mtl_InstanceID * (patchInfo.numControlPointsPerPatch * patchInfo.numPatches)) + tID.x) - mtl_BaseVertex;
    threadgroup Mtl_HullIn inputGroup[numPatchesInThreadGroup];
    threadgroup Mtl_HullIn &input = inputGroup[patchIDInThreadGroup];
    MTLTriangleTessellationFactorsHalf tessFactor;
    if (patchValid) {
        input.cp[controlPointID] = vertexFunction(vertexInput);
        output.INTERNALTESSPOS0 = input.cp[controlPointID].INTERNALTESSPOS0;
        output.TANGENT0 = input.cp[controlPointID].TANGENT0;
        output.NORMAL0 = input.cp[controlPointID].NORMAL0;
        output.TEXCOORD0 = input.cp[controlPointID].TEXCOORD0;
        output.TEXCOORD1 = input.cp[controlPointID].TEXCOORD1;
        output.TEXCOORD2 = input.cp[controlPointID].TEXCOORD2;
        output.TEXCOORD3 = input.cp[controlPointID].TEXCOORD3;
        output.COLOR0 = input.cp[controlPointID].COLOR0;
    }
    threadgroup_barrier(mem_flags::mem_threadgroup);
    if (!patchValid) {
        return;
    }
    float3 u_xlat0;
    float3 u_xlat1;
    float3 u_xlat2;
    float3 u_xlat3;
    float3 u_xlat4;
    float u_xlat12;
    float u_xlat13;
    // fork_phase2
    {
        u_xlat0.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[1].INTERNALTESSPOS0.yyy;
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[1].INTERNALTESSPOS0.xxx, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[1].INTERNALTESSPOS0.zzz, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[1].INTERNALTESSPOS0.www, u_xlat0.xyz);
        u_xlat1.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[2].INTERNALTESSPOS0.yyy;
        u_xlat1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[2].INTERNALTESSPOS0.xxx, u_xlat1.xyz);
        u_xlat1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[2].INTERNALTESSPOS0.zzz, u_xlat1.xyz);
        u_xlat1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[2].INTERNALTESSPOS0.www, u_xlat1.xyz);
        u_xlat2.xyz = u_xlat0.xyz + u_xlat1.xyz;
        u_xlat2.xyz = fma(u_xlat2.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat12 = dot(u_xlat2.xyz, u_xlat2.xyz);
        u_xlat12 = sqrt(u_xlat12);
        u_xlat12 = u_xlat12 * VGlobals._EdgeLength;
        u_xlat2.xyz = u_xlat0.xyz + (-u_xlat1.xyz);
        u_xlat13 = dot(u_xlat2.xyz, u_xlat2.xyz);
        u_xlat13 = sqrt(u_xlat13);
        u_xlat13 = u_xlat13 * VGlobals._ScreenParams.y;
        u_xlat12 = u_xlat13 / u_xlat12;
        tessFactor.edgeTessellationFactor[0] = max(u_xlat12, 1.0);
        u_xlat2.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[0].INTERNALTESSPOS0.yyy;
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[0].INTERNALTESSPOS0.xxx, u_xlat2.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[0].INTERNALTESSPOS0.zzz, u_xlat2.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[0].INTERNALTESSPOS0.www, u_xlat2.xyz);
        u_xlat3.xyz = u_xlat1.xyz + u_xlat2.xyz;
        u_xlat1.xyz = u_xlat1.xyz + (-u_xlat2.xyz);
        u_xlat12 = dot(u_xlat1.xyz, u_xlat1.xyz);
        u_xlat12 = sqrt(u_xlat12);
        u_xlat12 = u_xlat12 * VGlobals._ScreenParams.y;
        u_xlat1.xyz = fma(u_xlat3.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat1.x = dot(u_xlat1.xyz, u_xlat1.xyz);
        u_xlat1.x = sqrt(u_xlat1.x);
        u_xlat1.x = u_xlat1.x * VGlobals._EdgeLength;
        u_xlat12 = u_xlat12 / u_xlat1.x;
        tessFactor.edgeTessellationFactor[1] = max(u_xlat12, 1.0);
        u_xlat1.xyz = u_xlat0.xyz + u_xlat2.xyz;
        u_xlat0.xyz = (-u_xlat0.xyz) + u_xlat2.xyz;
        u_xlat0.x = dot(u_xlat0.xyz, u_xlat0.xyz);
        u_xlat0.x = sqrt(u_xlat0.x);
        u_xlat0.x = u_xlat0.x * VGlobals._ScreenParams.y;
        u_xlat4.xyz = fma(u_xlat1.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat4.x = dot(u_xlat4.xyz, u_xlat4.xyz);
        u_xlat4.x = sqrt(u_xlat4.x);
        u_xlat4.x = u_xlat4.x * VGlobals._EdgeLength;
        u_xlat0.x = u_xlat0.x / u_xlat4.x;
        tessFactor.edgeTessellationFactor[2] = max(u_xlat0.x, 1.0);
    }
    // join_phase3
    {
        u_xlat0.x = tessFactor.edgeTessellationFactor[0] + tessFactor.edgeTessellationFactor[1];
        u_xlat0.x = u_xlat0.x + tessFactor.edgeTessellationFactor[2];
        tessFactor.insideTessellationFactor = u_xlat0.x * 0.333333343;
    }
    controlPoints[mtl_VertexID] = output;
    tessFactors[internalPatchID] = tessFactor;
}
// SHADER_STAGE_HULL_end
// SHADER_STAGE_DOMAIN_begin
struct Mtl_VertexInPostTess
{
    patch_control_point<Mtl_ControlPointIn> cp;
};
struct Mtl_VertexOutPostTess
{
    float4 mtl_Position [[ position ]];
    float3 TEXCOORD1 [[ user(TEXCOORD1) ]];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    sampler sampler_Height [[ sampler (0) ]],
    texture2d<float, access::sample > _Height [[ texture(0) ]] ,
    float3 mtl_TessCoord [[ position_in_patch ]],
    uint patchID [[ patch_id ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    Mtl_VertexInPostTess input [[ stage_in ]])
{
#pragma clang diagnostic pop
    Mtl_VertexOutPostTess output;
    MTLTriangleTessellationFactorsHalf tessFactor;
    tessFactor = tessFactors[patchID];
    float4 u_xlat0;
    float4 u_xlat1;
    float4 u_xlat2;
    float4 u_xlat3;
    float4 u_xlat4;
    float u_xlat11;
    float u_xlat15;
    bool u_xlatb15;
    u_xlat0.xyz = mtl_TessCoord.yyy * input.cp[1].NORMAL0.xyz;
    u_xlat0.xyz = fma(input.cp[0].NORMAL0.xyz, mtl_TessCoord.xxx, u_xlat0.xyz);
    u_xlat0.xyz = fma(input.cp[2].NORMAL0.xyz, mtl_TessCoord.zzz, u_xlat0.xyz);
    u_xlat1.x = dot(u_xlat0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat1.y = dot(u_xlat0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat1.z = dot(u_xlat0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat15 = dot(u_xlat1.xyz, u_xlat1.xyz);
    u_xlat15 = rsqrt(u_xlat15);
    u_xlat1.xyz = float3(u_xlat15) * u_xlat1.xyz;
    u_xlat2.xy = mtl_TessCoord.yy * input.cp[1].TEXCOORD0.xy;
    u_xlat2.xy = fma(input.cp[0].TEXCOORD0.xy, mtl_TessCoord.xx, u_xlat2.xy);
    u_xlat2.xy = fma(input.cp[2].TEXCOORD0.xy, mtl_TessCoord.zz, u_xlat2.xy);
    u_xlat2.xy = u_xlat2.xy * float2(VGlobals._Tile);
    u_xlat2.xyz = _Height.sample(sampler_Height, u_xlat2.xy, level(1.0)).xyz;
    u_xlat0.xyz = u_xlat0.xyz * u_xlat2.xyz;
    u_xlat2 = mtl_TessCoord.yyyy * input.cp[1].INTERNALTESSPOS0;
    u_xlat2 = fma(input.cp[0].INTERNALTESSPOS0, mtl_TessCoord.xxxx, u_xlat2);
    u_xlat2 = fma(input.cp[2].INTERNALTESSPOS0, mtl_TessCoord.zzzz, u_xlat2);
    u_xlat0.xyz = fma(u_xlat0.xyz, float3(VGlobals._HeightDisplacement), u_xlat2.xyz);
    u_xlat3 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], u_xlat0.xxxx, u_xlat3);
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], u_xlat0.zzzz, u_xlat3);
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3], u_xlat2.wwww, u_xlat3);
    u_xlat2.xyz = fma((-u_xlat3.xyz), VGlobals._WorldSpaceLightPos0.www, VGlobals._WorldSpaceLightPos0.xyz);
    u_xlat15 = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat15 = rsqrt(u_xlat15);
    u_xlat2.xyz = float3(u_xlat15) * u_xlat2.xyz;
    u_xlat15 = dot(u_xlat1.xyz, u_xlat2.xyz);
    u_xlat15 = fma((-u_xlat15), u_xlat15, 1.0);
    u_xlat15 = sqrt(u_xlat15);
    u_xlat15 = u_xlat15 * VGlobals.unity_LightShadowBias.z;
    u_xlat1.xyz = fma((-u_xlat1.xyz), float3(u_xlat15), u_xlat3.xyz);
    u_xlatb15 = VGlobals.unity_LightShadowBias.z!=0.0;
    u_xlat1.xyz = (bool(u_xlatb15)) ? u_xlat1.xyz : u_xlat3.xyz;
    u_xlat4 = u_xlat1.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat4 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat1.xxxx, u_xlat4);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat1.zzzz, u_xlat4);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat3.wwww, u_xlat1);
    u_xlat15 = VGlobals.unity_LightShadowBias.x / u_xlat1.w;
    u_xlat15 = min(u_xlat15, 0.0);
    u_xlat15 = max(u_xlat15, -1.0);
    u_xlat15 = u_xlat15 + u_xlat1.z;
    u_xlat11 = min(u_xlat1.w, u_xlat15);
    output.mtl_Position.xyw = u_xlat1.xyw;
    u_xlat1.x = (-u_xlat15) + u_xlat11;
    output.mtl_Position.z = fma(VGlobals.unity_LightShadowBias.y, u_xlat1.x, u_xlat15);
    u_xlat1.xyz = u_xlat0.yyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz;
    u_xlat0.xyw = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, u_xlat0.xxx, u_xlat1.xyz);
    u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, u_xlat0.zzz, u_xlat0.xyw);
    output.TEXCOORD1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, u_xlat2.www, u_xlat0.xyz);
    return output;
}
// SHADER_STAGE_DOMAIN_end
Compilation succeeded with: 

program_source:299:53: warning: writable resources in non-void post-tessellation vertex function
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
                                                    ^
program_source:305:30: note: writable buffer defined here
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
                             ^
program_source:306:48: note: writable buffer defined here
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
                                               ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float4 TEXCOORD0 [[ attribute(3) ]] ;
    float4 TEXCOORD1 [[ attribute(4) ]] ;
    float4 TEXCOORD2 [[ attribute(5) ]] ;
    float4 TEXCOORD3 [[ attribute(6) ]] ;
    float4 COLOR0 [[ attribute(7) ]] ;
};
struct Mtl_VertexOut
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float4 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float4 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float4 TEXCOORD3 [[ user(TEXCOORD3) ]];
    float4 COLOR0 [[ user(COLOR0) ]];
};
static Mtl_VertexOut vertexFunction(
    Mtl_VertexIn input)
{
    Mtl_VertexOut output;
    output.INTERNALTESSPOS0 = input.POSITION0;
    output.TANGENT0 = input.TANGENT0;
    output.NORMAL0.xyz = input.NORMAL0.xyz;
    output.TEXCOORD0 = input.TEXCOORD0;
    output.TEXCOORD1 = input.TEXCOORD1;
    output.TEXCOORD2 = input.TEXCOORD2;
    output.TEXCOORD3 = input.TEXCOORD3;
    output.COLOR0 = input.COLOR0;
    return output;
}
// SHADER_STAGE_HULL_begin
struct Mtl_ControlPoint
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float4 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float4 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float4 TEXCOORD3 [[ user(TEXCOORD3) ]];
    float4 COLOR0 [[ user(COLOR0) ]];
};
struct Mtl_ControlPointIn
{
    float4 INTERNALTESSPOS0 [[ attribute(8) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float4 TEXCOORD0 [[ attribute(3) ]] ;
    float4 TEXCOORD1 [[ attribute(4) ]] ;
    float4 TEXCOORD2 [[ attribute(5) ]] ;
    float4 TEXCOORD3 [[ attribute(6) ]] ;
    float4 COLOR0 [[ attribute(7) ]] ;
};
struct Mtl_KernelPatchInfo
{
    uint numPatches;
    ushort numControlPointsPerPatch;
};
struct VGlobals_Type
{
    float4 _Time;
    float4 _SinTime;
    float4 _CosTime;
    float4 unity_DeltaTime;
    float3 _WorldSpaceCameraPos;
    float4 _ProjectionParams;
    float4 _ScreenParams;
    float4 _ZBufferParams;
    float4 unity_OrthoParams;
    float4 unity_CameraWorldClipPlanes[6];
    float4 hlslcc_mtx4x4unity_CameraProjection[4];
    float4 hlslcc_mtx4x4unity_CameraInvProjection[4];
    float4 hlslcc_mtx4x4unity_WorldToCamera[4];
    float4 hlslcc_mtx4x4unity_CameraToWorld[4];
    float4 _WorldSpaceLightPos0;
    float4 _LightPositionRange;
    float4 _LightProjectionParams;
    float4 unity_4LightPosX0;
    float4 unity_4LightPosY0;
    float4 unity_4LightPosZ0;
    float4 unity_4LightAtten0;
    float4 unity_LightColor[8];
    float4 unity_LightPosition[8];
    float4 unity_LightAtten[8];
    float4 unity_SpotDirection[8];
    float4 unity_SHAr;
    float4 unity_SHAg;
    float4 unity_SHAb;
    float4 unity_SHBr;
    float4 unity_SHBg;
    float4 unity_SHBb;
    float4 unity_SHC;
    float4 unity_OcclusionMaskSelector;
    float4 unity_ProbesOcclusion;
    float3 unity_LightColor0;
    float3 unity_LightColor1;
    float3 unity_LightColor2;
    float3 unity_LightColor3;
    float4 unity_ShadowSplitSpheres[4];
    float4 unity_ShadowSplitSqRadii;
    float4 unity_LightShadowBias;
    float4 _LightSplitsNear;
    float4 _LightSplitsFar;
    float4 hlslcc_mtx4x4unity_WorldToShadow[16];
    float4 _LightShadowData;
    float4 unity_ShadowFadeCenterAndType;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 unity_LODFade;
    float4 unity_WorldTransformParams;
    float4 unity_RenderingLayer;
    float4 hlslcc_mtx4x4glstate_matrix_transpose_modelview0[4];
    float4 glstate_lightmodel_ambient;
    float4 unity_AmbientSky;
    float4 unity_AmbientEquator;
    float4 unity_AmbientGround;
    float4 unity_IndirectSpecColor;
    float4 hlslcc_mtx4x4glstate_matrix_projection[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixInvV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    int unity_StereoEyeIndex;
    float4 unity_ShadowColor;
    float4 unity_FogColor;
    float4 unity_FogParams;
    float4 unity_LightmapST;
    float4 unity_DynamicLightmapST;
    float4 unity_SpecCube0_BoxMax;
    float4 unity_SpecCube0_BoxMin;
    float4 unity_SpecCube0_ProbePosition;
    float4 unity_SpecCube0_HDR;
    float4 unity_SpecCube1_BoxMax;
    float4 unity_SpecCube1_BoxMin;
    float4 unity_SpecCube1_ProbePosition;
    float4 unity_SpecCube1_HDR;
    float4 unity_ProbeVolumeParams;
    float4 hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[4];
    float3 unity_ProbeVolumeSizeInv;
    float3 unity_ProbeVolumeMin;
    float4 unity_Lightmap_HDR;
    float4 unity_DynamicLightmap_HDR;
    float4 _LightColor0;
    float4 _SpecColor;
    float _Tile;
    float _HeightDisplacement;
    float _NormalScale;
    float4 _ColorTint;
    float _MetallicStrength;
    float _SmoothnessStrength;
    float _EdgeLength;
    float4 _texcoord_ST;
    float4 unity_Ambient;
};
struct Mtl_HullIn
{
    Mtl_VertexOut cp[3];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
kernel void patchKernel(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn vertexInput [[ stage_in ]],
    uint2 tID [[ thread_position_in_grid ]],
    ushort2 groupID [[ threadgroup_position_in_grid ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    constant Mtl_KernelPatchInfo &patchInfo [[ buffer(3) ]])
{
#pragma clang diagnostic pop
    Mtl_ControlPoint output;
    const uint numPatchesInThreadGroup = 10;
    const uint patchID = (tID.x / patchInfo.numControlPointsPerPatch);
    const bool patchValid = (patchID < patchInfo.numPatches);
    const uint mtl_BaseInstance = 0;
    const uint mtl_InstanceID = groupID.y - mtl_BaseInstance;
    const uint internalPatchID = mtl_InstanceID * patchInfo.numPatches + patchID;
    const uint patchIDInThreadGroup = (patchID % numPatchesInThreadGroup);
    const uint controlPointID = (tID.x % patchInfo.numControlPointsPerPatch);
    const uint mtl_BaseVertex = 0;
    const uint mtl_VertexID = ((mtl_InstanceID * (patchInfo.numControlPointsPerPatch * patchInfo.numPatches)) + tID.x) - mtl_BaseVertex;
    threadgroup Mtl_HullIn inputGroup[numPatchesInThreadGroup];
    threadgroup Mtl_HullIn &input = inputGroup[patchIDInThreadGroup];
    MTLTriangleTessellationFactorsHalf tessFactor;
    if (patchValid) {
        input.cp[controlPointID] = vertexFunction(vertexInput);
        output.INTERNALTESSPOS0 = input.cp[controlPointID].INTERNALTESSPOS0;
        output.TANGENT0 = input.cp[controlPointID].TANGENT0;
        output.NORMAL0 = input.cp[controlPointID].NORMAL0;
        output.TEXCOORD0 = input.cp[controlPointID].TEXCOORD0;
        output.TEXCOORD1 = input.cp[controlPointID].TEXCOORD1;
        output.TEXCOORD2 = input.cp[controlPointID].TEXCOORD2;
        output.TEXCOORD3 = input.cp[controlPointID].TEXCOORD3;
        output.COLOR0 = input.cp[controlPointID].COLOR0;
    }
    threadgroup_barrier(mem_flags::mem_threadgroup);
    if (!patchValid) {
        return;
    }
    float3 u_xlat0;
    float3 u_xlat1;
    float3 u_xlat2;
    float3 u_xlat3;
    float3 u_xlat4;
    float u_xlat12;
    float u_xlat13;
    // fork_phase2
    {
        u_xlat0.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[1].INTERNALTESSPOS0.yyy;
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[1].INTERNALTESSPOS0.xxx, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[1].INTERNALTESSPOS0.zzz, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[1].INTERNALTESSPOS0.www, u_xlat0.xyz);
        u_xlat1.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[2].INTERNALTESSPOS0.yyy;
        u_xlat1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[2].INTERNALTESSPOS0.xxx, u_xlat1.xyz);
        u_xlat1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[2].INTERNALTESSPOS0.zzz, u_xlat1.xyz);
        u_xlat1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[2].INTERNALTESSPOS0.www, u_xlat1.xyz);
        u_xlat2.xyz = u_xlat0.xyz + u_xlat1.xyz;
        u_xlat2.xyz = fma(u_xlat2.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat12 = dot(u_xlat2.xyz, u_xlat2.xyz);
        u_xlat12 = sqrt(u_xlat12);
        u_xlat12 = u_xlat12 * VGlobals._EdgeLength;
        u_xlat2.xyz = u_xlat0.xyz + (-u_xlat1.xyz);
        u_xlat13 = dot(u_xlat2.xyz, u_xlat2.xyz);
        u_xlat13 = sqrt(u_xlat13);
        u_xlat13 = u_xlat13 * VGlobals._ScreenParams.y;
        u_xlat12 = u_xlat13 / u_xlat12;
        tessFactor.edgeTessellationFactor[0] = max(u_xlat12, 1.0);
        u_xlat2.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[0].INTERNALTESSPOS0.yyy;
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[0].INTERNALTESSPOS0.xxx, u_xlat2.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[0].INTERNALTESSPOS0.zzz, u_xlat2.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[0].INTERNALTESSPOS0.www, u_xlat2.xyz);
        u_xlat3.xyz = u_xlat1.xyz + u_xlat2.xyz;
        u_xlat1.xyz = u_xlat1.xyz + (-u_xlat2.xyz);
        u_xlat12 = dot(u_xlat1.xyz, u_xlat1.xyz);
        u_xlat12 = sqrt(u_xlat12);
        u_xlat12 = u_xlat12 * VGlobals._ScreenParams.y;
        u_xlat1.xyz = fma(u_xlat3.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat1.x = dot(u_xlat1.xyz, u_xlat1.xyz);
        u_xlat1.x = sqrt(u_xlat1.x);
        u_xlat1.x = u_xlat1.x * VGlobals._EdgeLength;
        u_xlat12 = u_xlat12 / u_xlat1.x;
        tessFactor.edgeTessellationFactor[1] = max(u_xlat12, 1.0);
        u_xlat1.xyz = u_xlat0.xyz + u_xlat2.xyz;
        u_xlat0.xyz = (-u_xlat0.xyz) + u_xlat2.xyz;
        u_xlat0.x = dot(u_xlat0.xyz, u_xlat0.xyz);
        u_xlat0.x = sqrt(u_xlat0.x);
        u_xlat0.x = u_xlat0.x * VGlobals._ScreenParams.y;
        u_xlat4.xyz = fma(u_xlat1.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat4.x = dot(u_xlat4.xyz, u_xlat4.xyz);
        u_xlat4.x = sqrt(u_xlat4.x);
        u_xlat4.x = u_xlat4.x * VGlobals._EdgeLength;
        u_xlat0.x = u_xlat0.x / u_xlat4.x;
        tessFactor.edgeTessellationFactor[2] = max(u_xlat0.x, 1.0);
    }
    // join_phase3
    {
        u_xlat0.x = tessFactor.edgeTessellationFactor[0] + tessFactor.edgeTessellationFactor[1];
        u_xlat0.x = u_xlat0.x + tessFactor.edgeTessellationFactor[2];
        tessFactor.insideTessellationFactor = u_xlat0.x * 0.333333343;
    }
    controlPoints[mtl_VertexID] = output;
    tessFactors[internalPatchID] = tessFactor;
}
// SHADER_STAGE_HULL_end
// SHADER_STAGE_DOMAIN_begin
struct Mtl_VertexInPostTess
{
    patch_control_point<Mtl_ControlPointIn> cp;
};
struct Mtl_VertexOutPostTess
{
    float4 mtl_Position [[ position ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float4 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float4 TEXCOORD3 [[ user(TEXCOORD3) ]];
    float4 TEXCOORD5 [[ user(TEXCOORD5) ]];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    sampler sampler_Height [[ sampler (0) ]],
    texture2d<float, access::sample > _Height [[ texture(0) ]] ,
    float3 mtl_TessCoord [[ position_in_patch ]],
    uint patchID [[ patch_id ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    Mtl_VertexInPostTess input [[ stage_in ]])
{
#pragma clang diagnostic pop
    Mtl_VertexOutPostTess output;
    MTLTriangleTessellationFactorsHalf tessFactor;
    tessFactor = tessFactors[patchID];
    float4 u_xlat0;
    float4 u_xlat1;
    float4 u_xlat2;
    float4 u_xlat3;
    float2 u_xlat9;
    float u_xlat12;
    float u_xlat13;
    u_xlat0 = mtl_TessCoord.yyyy * input.cp[1].INTERNALTESSPOS0;
    u_xlat0 = fma(input.cp[0].INTERNALTESSPOS0, mtl_TessCoord.xxxx, u_xlat0);
    u_xlat0 = fma(input.cp[2].INTERNALTESSPOS0, mtl_TessCoord.zzzz, u_xlat0);
    u_xlat1.xy = mtl_TessCoord.yy * input.cp[1].TEXCOORD0.xy;
    u_xlat1.xy = fma(input.cp[0].TEXCOORD0.xy, mtl_TessCoord.xx, u_xlat1.xy);
    u_xlat1.xy = fma(input.cp[2].TEXCOORD0.xy, mtl_TessCoord.zz, u_xlat1.xy);
    u_xlat9.xy = u_xlat1.xy * float2(VGlobals._Tile);
    output.TEXCOORD0.xy = fma(u_xlat1.xy, VGlobals._texcoord_ST.xy, VGlobals._texcoord_ST.zw);
    u_xlat1.xyz = _Height.sample(sampler_Height, u_xlat9.xy, level(1.0)).xyz;
    u_xlat2.xyz = mtl_TessCoord.yyy * input.cp[1].NORMAL0.xyz;
    u_xlat2.xyz = fma(input.cp[0].NORMAL0.xyz, mtl_TessCoord.xxx, u_xlat2.xyz);
    u_xlat2.xyz = fma(input.cp[2].NORMAL0.xyz, mtl_TessCoord.zzz, u_xlat2.xyz);
    u_xlat1.xyz = u_xlat1.xyz * u_xlat2.xyz;
    u_xlat0.xyz = fma(u_xlat1.xyz, float3(VGlobals._HeightDisplacement), u_xlat0.xyz);
    u_xlat1 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], u_xlat0.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], u_xlat0.zzzz, u_xlat1);
    u_xlat3 = u_xlat1 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, u_xlat0.www, u_xlat1.xyz);
    u_xlat1 = u_xlat3.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat3.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat3.zzzz, u_xlat1);
    output.mtl_Position = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat3.wwww, u_xlat1);
    u_xlat1.y = dot(u_xlat2.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat1.z = dot(u_xlat2.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat1.x = dot(u_xlat2.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat12 = dot(u_xlat1.xyz, u_xlat1.xyz);
    u_xlat12 = rsqrt(u_xlat12);
    u_xlat1.xyz = float3(u_xlat12) * u_xlat1.xyz;
    output.TEXCOORD1.z = u_xlat1.y;
    u_xlat2 = mtl_TessCoord.yyyy * input.cp[1].TANGENT0;
    u_xlat2 = fma(input.cp[0].TANGENT0, mtl_TessCoord.xxxx, u_xlat2);
    u_xlat2 = fma(input.cp[2].TANGENT0, mtl_TessCoord.zzzz, u_xlat2);
    u_xlat3.xyz = u_xlat2.yyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].yzx;
    u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].yzx, u_xlat2.xxx, u_xlat3.xyz);
    u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].yzx, u_xlat2.zzz, u_xlat3.xyz);
    u_xlat12 = u_xlat2.w * VGlobals.unity_WorldTransformParams.w;
    u_xlat13 = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat13 = rsqrt(u_xlat13);
    u_xlat2.xyz = float3(u_xlat13) * u_xlat2.xyz;
    u_xlat3.xyz = u_xlat1.xyz * u_xlat2.xyz;
    u_xlat3.xyz = fma(u_xlat1.zxy, u_xlat2.yzx, (-u_xlat3.xyz));
    u_xlat3.xyz = float3(u_xlat12) * u_xlat3.xyz;
    output.TEXCOORD1.y = u_xlat3.x;
    output.TEXCOORD1.w = u_xlat0.x;
    output.TEXCOORD1.x = u_xlat2.z;
    output.TEXCOORD2.w = u_xlat0.y;
    output.TEXCOORD3.w = u_xlat0.z;
    output.TEXCOORD2.x = u_xlat2.x;
    output.TEXCOORD3.x = u_xlat2.y;
    output.TEXCOORD2.z = u_xlat1.z;
    output.TEXCOORD3.z = u_xlat1.x;
    output.TEXCOORD2.y = u_xlat3.y;
    output.TEXCOORD3.y = u_xlat3.z;
    output.TEXCOORD5 = float4(0.0, 0.0, 0.0, 0.0);
    return output;
}
// SHADER_STAGE_DOMAIN_end
Compilation succeeded with: 

program_source:303:53: warning: writable resources in non-void post-tessellation vertex function
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
                                                    ^
program_source:309:30: note: writable buffer defined here
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
                             ^
program_source:310:48: note: writable buffer defined here
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
                                               ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float4 TEXCOORD0 [[ attribute(3) ]] ;
    float4 TEXCOORD1 [[ attribute(4) ]] ;
    float4 TEXCOORD2 [[ attribute(5) ]] ;
    float4 TEXCOORD3 [[ attribute(6) ]] ;
    float4 COLOR0 [[ attribute(7) ]] ;
};
struct Mtl_VertexOut
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float4 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float4 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float4 TEXCOORD3 [[ user(TEXCOORD3) ]];
    float4 COLOR0 [[ user(COLOR0) ]];
};
static Mtl_VertexOut vertexFunction(
    Mtl_VertexIn input)
{
    Mtl_VertexOut output;
    output.INTERNALTESSPOS0 = input.POSITION0;
    output.TANGENT0 = input.TANGENT0;
    output.NORMAL0.xyz = input.NORMAL0.xyz;
    output.TEXCOORD0 = input.TEXCOORD0;
    output.TEXCOORD1 = input.TEXCOORD1;
    output.TEXCOORD2 = input.TEXCOORD2;
    output.TEXCOORD3 = input.TEXCOORD3;
    output.COLOR0 = input.COLOR0;
    return output;
}
// SHADER_STAGE_HULL_begin
struct Mtl_ControlPoint
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float4 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float4 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float4 TEXCOORD3 [[ user(TEXCOORD3) ]];
    float4 COLOR0 [[ user(COLOR0) ]];
};
struct Mtl_ControlPointIn
{
    float4 INTERNALTESSPOS0 [[ attribute(8) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float4 TEXCOORD0 [[ attribute(3) ]] ;
    float4 TEXCOORD1 [[ attribute(4) ]] ;
    float4 TEXCOORD2 [[ attribute(5) ]] ;
    float4 TEXCOORD3 [[ attribute(6) ]] ;
    float4 COLOR0 [[ attribute(7) ]] ;
};
struct Mtl_KernelPatchInfo
{
    uint numPatches;
    ushort numControlPointsPerPatch;
};
struct VGlobals_Type
{
    float4 _Time;
    float4 _SinTime;
    float4 _CosTime;
    float4 unity_DeltaTime;
    float3 _WorldSpaceCameraPos;
    float4 _ProjectionParams;
    float4 _ScreenParams;
    float4 _ZBufferParams;
    float4 unity_OrthoParams;
    float4 unity_CameraWorldClipPlanes[6];
    float4 hlslcc_mtx4x4unity_CameraProjection[4];
    float4 hlslcc_mtx4x4unity_CameraInvProjection[4];
    float4 hlslcc_mtx4x4unity_WorldToCamera[4];
    float4 hlslcc_mtx4x4unity_CameraToWorld[4];
    float4 _WorldSpaceLightPos0;
    float4 _LightPositionRange;
    float4 _LightProjectionParams;
    float4 unity_4LightPosX0;
    float4 unity_4LightPosY0;
    float4 unity_4LightPosZ0;
    float4 unity_4LightAtten0;
    float4 unity_LightColor[8];
    float4 unity_LightPosition[8];
    float4 unity_LightAtten[8];
    float4 unity_SpotDirection[8];
    float4 unity_SHAr;
    float4 unity_SHAg;
    float4 unity_SHAb;
    float4 unity_SHBr;
    float4 unity_SHBg;
    float4 unity_SHBb;
    float4 unity_SHC;
    float4 unity_OcclusionMaskSelector;
    float4 unity_ProbesOcclusion;
    float3 unity_LightColor0;
    float3 unity_LightColor1;
    float3 unity_LightColor2;
    float3 unity_LightColor3;
    float4 unity_ShadowSplitSpheres[4];
    float4 unity_ShadowSplitSqRadii;
    float4 unity_LightShadowBias;
    float4 _LightSplitsNear;
    float4 _LightSplitsFar;
    float4 hlslcc_mtx4x4unity_WorldToShadow[16];
    float4 _LightShadowData;
    float4 unity_ShadowFadeCenterAndType;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 unity_LODFade;
    float4 unity_WorldTransformParams;
    float4 unity_RenderingLayer;
    float4 hlslcc_mtx4x4glstate_matrix_transpose_modelview0[4];
    float4 glstate_lightmodel_ambient;
    float4 unity_AmbientSky;
    float4 unity_AmbientEquator;
    float4 unity_AmbientGround;
    float4 unity_IndirectSpecColor;
    float4 hlslcc_mtx4x4glstate_matrix_projection[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixInvV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    int unity_StereoEyeIndex;
    float4 unity_ShadowColor;
    float4 unity_FogColor;
    float4 unity_FogParams;
    float4 unity_LightmapST;
    float4 unity_DynamicLightmapST;
    float4 unity_SpecCube0_BoxMax;
    float4 unity_SpecCube0_BoxMin;
    float4 unity_SpecCube0_ProbePosition;
    float4 unity_SpecCube0_HDR;
    float4 unity_SpecCube1_BoxMax;
    float4 unity_SpecCube1_BoxMin;
    float4 unity_SpecCube1_ProbePosition;
    float4 unity_SpecCube1_HDR;
    float4 unity_ProbeVolumeParams;
    float4 hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[4];
    float3 unity_ProbeVolumeSizeInv;
    float3 unity_ProbeVolumeMin;
    float4 unity_Lightmap_HDR;
    float4 unity_DynamicLightmap_HDR;
    float4 _LightColor0;
    float4 _SpecColor;
    float _Tile;
    float _HeightDisplacement;
    float _NormalScale;
    float4 _ColorTint;
    float _MetallicStrength;
    float _SmoothnessStrength;
    float _EdgeLength;
    bool4 unity_MetaVertexControl;
    bool4 unity_MetaFragmentControl;
    int unity_VisualizationMode;
    float unity_OneOverOutputBoost;
    float unity_MaxOutputValue;
    float unity_UseLinearSpace;
    float4 _texcoord_ST;
};
struct Mtl_HullIn
{
    Mtl_VertexOut cp[3];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
kernel void patchKernel(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn vertexInput [[ stage_in ]],
    uint2 tID [[ thread_position_in_grid ]],
    ushort2 groupID [[ threadgroup_position_in_grid ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    constant Mtl_KernelPatchInfo &patchInfo [[ buffer(3) ]])
{
#pragma clang diagnostic pop
    Mtl_ControlPoint output;
    const uint numPatchesInThreadGroup = 10;
    const uint patchID = (tID.x / patchInfo.numControlPointsPerPatch);
    const bool patchValid = (patchID < patchInfo.numPatches);
    const uint mtl_BaseInstance = 0;
    const uint mtl_InstanceID = groupID.y - mtl_BaseInstance;
    const uint internalPatchID = mtl_InstanceID * patchInfo.numPatches + patchID;
    const uint patchIDInThreadGroup = (patchID % numPatchesInThreadGroup);
    const uint controlPointID = (tID.x % patchInfo.numControlPointsPerPatch);
    const uint mtl_BaseVertex = 0;
    const uint mtl_VertexID = ((mtl_InstanceID * (patchInfo.numControlPointsPerPatch * patchInfo.numPatches)) + tID.x) - mtl_BaseVertex;
    threadgroup Mtl_HullIn inputGroup[numPatchesInThreadGroup];
    threadgroup Mtl_HullIn &input = inputGroup[patchIDInThreadGroup];
    MTLTriangleTessellationFactorsHalf tessFactor;
    if (patchValid) {
        input.cp[controlPointID] = vertexFunction(vertexInput);
        output.INTERNALTESSPOS0 = input.cp[controlPointID].INTERNALTESSPOS0;
        output.TANGENT0 = input.cp[controlPointID].TANGENT0;
        output.NORMAL0 = input.cp[controlPointID].NORMAL0;
        output.TEXCOORD0 = input.cp[controlPointID].TEXCOORD0;
        output.TEXCOORD1 = input.cp[controlPointID].TEXCOORD1;
        output.TEXCOORD2 = input.cp[controlPointID].TEXCOORD2;
        output.TEXCOORD3 = input.cp[controlPointID].TEXCOORD3;
        output.COLOR0 = input.cp[controlPointID].COLOR0;
    }
    threadgroup_barrier(mem_flags::mem_threadgroup);
    if (!patchValid) {
        return;
    }
    float3 u_xlat0;
    float3 u_xlat1;
    float3 u_xlat2;
    float3 u_xlat3;
    float3 u_xlat4;
    float u_xlat12;
    float u_xlat13;
    // fork_phase2
    {
        u_xlat0.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[1].INTERNALTESSPOS0.yyy;
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[1].INTERNALTESSPOS0.xxx, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[1].INTERNALTESSPOS0.zzz, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[1].INTERNALTESSPOS0.www, u_xlat0.xyz);
        u_xlat1.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[2].INTERNALTESSPOS0.yyy;
        u_xlat1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[2].INTERNALTESSPOS0.xxx, u_xlat1.xyz);
        u_xlat1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[2].INTERNALTESSPOS0.zzz, u_xlat1.xyz);
        u_xlat1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[2].INTERNALTESSPOS0.www, u_xlat1.xyz);
        u_xlat2.xyz = u_xlat0.xyz + u_xlat1.xyz;
        u_xlat2.xyz = fma(u_xlat2.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat12 = dot(u_xlat2.xyz, u_xlat2.xyz);
        u_xlat12 = sqrt(u_xlat12);
        u_xlat12 = u_xlat12 * VGlobals._EdgeLength;
        u_xlat2.xyz = u_xlat0.xyz + (-u_xlat1.xyz);
        u_xlat13 = dot(u_xlat2.xyz, u_xlat2.xyz);
        u_xlat13 = sqrt(u_xlat13);
        u_xlat13 = u_xlat13 * VGlobals._ScreenParams.y;
        u_xlat12 = u_xlat13 / u_xlat12;
        tessFactor.edgeTessellationFactor[0] = max(u_xlat12, 1.0);
        u_xlat2.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[0].INTERNALTESSPOS0.yyy;
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[0].INTERNALTESSPOS0.xxx, u_xlat2.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[0].INTERNALTESSPOS0.zzz, u_xlat2.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[0].INTERNALTESSPOS0.www, u_xlat2.xyz);
        u_xlat3.xyz = u_xlat1.xyz + u_xlat2.xyz;
        u_xlat1.xyz = u_xlat1.xyz + (-u_xlat2.xyz);
        u_xlat12 = dot(u_xlat1.xyz, u_xlat1.xyz);
        u_xlat12 = sqrt(u_xlat12);
        u_xlat12 = u_xlat12 * VGlobals._ScreenParams.y;
        u_xlat1.xyz = fma(u_xlat3.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat1.x = dot(u_xlat1.xyz, u_xlat1.xyz);
        u_xlat1.x = sqrt(u_xlat1.x);
        u_xlat1.x = u_xlat1.x * VGlobals._EdgeLength;
        u_xlat12 = u_xlat12 / u_xlat1.x;
        tessFactor.edgeTessellationFactor[1] = max(u_xlat12, 1.0);
        u_xlat1.xyz = u_xlat0.xyz + u_xlat2.xyz;
        u_xlat0.xyz = (-u_xlat0.xyz) + u_xlat2.xyz;
        u_xlat0.x = dot(u_xlat0.xyz, u_xlat0.xyz);
        u_xlat0.x = sqrt(u_xlat0.x);
        u_xlat0.x = u_xlat0.x * VGlobals._ScreenParams.y;
        u_xlat4.xyz = fma(u_xlat1.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat4.x = dot(u_xlat4.xyz, u_xlat4.xyz);
        u_xlat4.x = sqrt(u_xlat4.x);
        u_xlat4.x = u_xlat4.x * VGlobals._EdgeLength;
        u_xlat0.x = u_xlat0.x / u_xlat4.x;
        tessFactor.edgeTessellationFactor[2] = max(u_xlat0.x, 1.0);
    }
    // join_phase3
    {
        u_xlat0.x = tessFactor.edgeTessellationFactor[0] + tessFactor.edgeTessellationFactor[1];
        u_xlat0.x = u_xlat0.x + tessFactor.edgeTessellationFactor[2];
        tessFactor.insideTessellationFactor = u_xlat0.x * 0.333333343;
    }
    controlPoints[mtl_VertexID] = output;
    tessFactors[internalPatchID] = tessFactor;
}
// SHADER_STAGE_HULL_end
// SHADER_STAGE_DOMAIN_begin
struct Mtl_VertexInPostTess
{
    patch_control_point<Mtl_ControlPointIn> cp;
};
struct Mtl_VertexOutPostTess
{
    float4 mtl_Position [[ position ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float4 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float4 TEXCOORD3 [[ user(TEXCOORD3) ]];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    sampler sampler_Height [[ sampler (0) ]],
    texture2d<float, access::sample > _Height [[ texture(0) ]] ,
    float3 mtl_TessCoord [[ position_in_patch ]],
    uint patchID [[ patch_id ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    Mtl_VertexInPostTess input [[ stage_in ]])
{
#pragma clang diagnostic pop
    Mtl_VertexOutPostTess output;
    MTLTriangleTessellationFactorsHalf tessFactor;
    tessFactor = tessFactors[patchID];
    float4 u_xlat0;
    float4 u_xlat1;
    float4 u_xlat2;
    float3 u_xlat3;
    float3 u_xlat4;
    float2 u_xlat13;
    float u_xlat15;
    bool u_xlatb15;
    u_xlat0.xy = mtl_TessCoord.yy * input.cp[1].TEXCOORD2.xy;
    u_xlat0.xy = fma(input.cp[0].TEXCOORD2.xy, mtl_TessCoord.xx, u_xlat0.xy);
    u_xlat0.xy = fma(input.cp[2].TEXCOORD2.xy, mtl_TessCoord.zz, u_xlat0.xy);
    u_xlat0.xy = fma(u_xlat0.xy, VGlobals.unity_DynamicLightmapST.xy, VGlobals.unity_DynamicLightmapST.zw);
    u_xlat1.xy = mtl_TessCoord.yy * input.cp[1].TEXCOORD1.xy;
    u_xlat1.xy = fma(input.cp[0].TEXCOORD1.xy, mtl_TessCoord.xx, u_xlat1.xy);
    u_xlat1.xy = fma(input.cp[2].TEXCOORD1.xy, mtl_TessCoord.zz, u_xlat1.xy);
    u_xlat1.xy = fma(u_xlat1.xy, VGlobals.unity_LightmapST.xy, VGlobals.unity_LightmapST.zw);
    u_xlat2 = mtl_TessCoord.yyyy * input.cp[1].INTERNALTESSPOS0;
    u_xlat2 = fma(input.cp[0].INTERNALTESSPOS0, mtl_TessCoord.xxxx, u_xlat2);
    u_xlat2 = fma(input.cp[2].INTERNALTESSPOS0, mtl_TessCoord.zzzz, u_xlat2);
    u_xlat3.xy = mtl_TessCoord.yy * input.cp[1].TEXCOORD0.xy;
    u_xlat3.xy = fma(input.cp[0].TEXCOORD0.xy, mtl_TessCoord.xx, u_xlat3.xy);
    u_xlat3.xy = fma(input.cp[2].TEXCOORD0.xy, mtl_TessCoord.zz, u_xlat3.xy);
    u_xlat13.xy = u_xlat3.xy * float2(VGlobals._Tile);
    output.TEXCOORD0.xy = fma(u_xlat3.xy, VGlobals._texcoord_ST.xy, VGlobals._texcoord_ST.zw);
    u_xlat3.xyz = _Height.sample(sampler_Height, u_xlat13.xy, level(1.0)).xyz;
    u_xlat4.xyz = mtl_TessCoord.yyy * input.cp[1].NORMAL0.xyz;
    u_xlat4.xyz = fma(input.cp[0].NORMAL0.xyz, mtl_TessCoord.xxx, u_xlat4.xyz);
    u_xlat4.xyz = fma(input.cp[2].NORMAL0.xyz, mtl_TessCoord.zzz, u_xlat4.xyz);
    u_xlat3.xyz = u_xlat3.xyz * u_xlat4.xyz;
    u_xlat2.xyz = fma(u_xlat3.xyz, float3(VGlobals._HeightDisplacement), u_xlat2.xyz);
    u_xlatb15 = 0.0<u_xlat2.z;
    u_xlat1.z = u_xlatb15 ? 9.99999975e-05 : float(0.0);
    u_xlat1.xyz = (VGlobals.unity_MetaVertexControl.x) ? u_xlat1.xyz : u_xlat2.xyz;
    u_xlatb15 = 0.0<u_xlat1.z;
    u_xlat0.z = u_xlatb15 ? 9.99999975e-05 : float(0.0);
    u_xlat0.xyz = (VGlobals.unity_MetaVertexControl.y) ? u_xlat0.xyz : u_xlat1.xyz;
    u_xlat1 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat0.xxxx, u_xlat1);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat0.zzzz, u_xlat1);
    output.mtl_Position = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_MatrixVP[3];
    u_xlat0.xyz = u_xlat2.yyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz;
    u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, u_xlat2.xxx, u_xlat0.xyz);
    u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, u_xlat2.zzz, u_xlat0.xyz);
    u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, u_xlat2.www, u_xlat0.xyz);
    output.TEXCOORD1.w = u_xlat0.x;
    u_xlat1.y = dot(u_xlat4.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat1.z = dot(u_xlat4.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat1.x = dot(u_xlat4.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat0.x = dot(u_xlat1.xyz, u_xlat1.xyz);
    u_xlat0.x = rsqrt(u_xlat0.x);
    u_xlat1.xyz = u_xlat0.xxx * u_xlat1.xyz;
    output.TEXCOORD1.z = u_xlat1.y;
    u_xlat2 = mtl_TessCoord.yyyy * input.cp[1].TANGENT0;
    u_xlat2 = fma(input.cp[0].TANGENT0, mtl_TessCoord.xxxx, u_xlat2);
    u_xlat2 = fma(input.cp[2].TANGENT0, mtl_TessCoord.zzzz, u_xlat2);
    u_xlat3.xyz = u_xlat2.yyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].yzx;
    u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].yzx, u_xlat2.xxx, u_xlat3.xyz);
    u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].yzx, u_xlat2.zzz, u_xlat3.xyz);
    u_xlat0.x = u_xlat2.w * VGlobals.unity_WorldTransformParams.w;
    u_xlat15 = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat15 = rsqrt(u_xlat15);
    u_xlat2.xyz = float3(u_xlat15) * u_xlat2.xyz;
    u_xlat3.xyz = u_xlat1.xyz * u_xlat2.xyz;
    u_xlat3.xyz = fma(u_xlat1.zxy, u_xlat2.yzx, (-u_xlat3.xyz));
    u_xlat3.xyz = u_xlat0.xxx * u_xlat3.xyz;
    output.TEXCOORD1.y = u_xlat3.x;
    output.TEXCOORD1.x = u_xlat2.z;
    output.TEXCOORD2.w = u_xlat0.y;
    output.TEXCOORD3.w = u_xlat0.z;
    output.TEXCOORD2.x = u_xlat2.x;
    output.TEXCOORD3.x = u_xlat2.y;
    output.TEXCOORD2.z = u_xlat1.z;
    output.TEXCOORD3.z = u_xlat1.x;
    output.TEXCOORD2.y = u_xlat3.y;
    output.TEXCOORD3.y = u_xlat3.z;
    return output;
}
// SHADER_STAGE_DOMAIN_end
Refreshing native plugins compatible for Editor in 2.18 ms, found 2 plugins.
Preloading 0 native plugins for Editor in 0.00 ms.
Unloading 3375 Unused Serialized files (Serialized files now loaded: 0)
Unloading 20 unused Assets / (0.6 MB). Loaded Objects now: 3919.
Memory consumption went from 136.5 MB to 135.9 MB.
Total: 5.805093 ms (FindLiveObjects: 0.344780 ms CreateObjectMapping: 0.354062 ms MarkObjects: 4.611081 ms  DeleteObjects: 0.493938 ms)

AssetImportParameters requested are different than current active one (requested -> active):
  custom:video-decoder-ogg-theora: a1e56fd34408186e4bbccfd4996cb3dc -> 
  custom:container-muxer-webm: aa71ff27fc2769a1b78a27578f13a17b -> 
  custom:container-demuxer-webm: 4f35f7cbe854078d1ac9338744f61a02 -> 
  custom:video-encoder-webm-vp8: eb34c28f22e8b96e1ab97ce403110664 -> 
  custom:framework-osx-AVFoundation: b23960f63f64bdc6ff669e2cdcee2391 -> 
  custom:audio-encoder-webm-vorbis: bf7c407c2cedff20999df2af8eb42d56 -> 
  custom:container-demuxer-ogg: 62fdf1f143b41e24485cea50d1cbac27 -> 
  custom:video-decoder-webm-vp8: 9c59270c3fd7afecdb556c50c9e8de78 -> 
  custom:audio-decoder-ogg-vorbis: bf7c407c2cedff20999df2af8eb42d56 -> 
========================================================================
Received Prepare
Registering precompiled user dll's ...
Registered in 0.003584 seconds.
Begin MonoManager ReloadAssembly
Symbol file LoadedFromMemory doesn't match image /Users/kamilaamendolagine/Desktop/Staugen Raug v2 - Prefab - Map 1.01/Library/PackageCache/com.unity.visualscripting@1.7.8/Editor/VisualScripting.Core/Dependencies/YamlDotNet/Unity.VisualScripting.YamlDotNet.dll
Symbol file LoadedFromMemory doesn't match image /Users/kamilaamendolagine/Desktop/Staugen Raug v2 - Prefab - Map 1.01/Library/PackageCache/com.unity.visualscripting@1.7.8/Editor/VisualScripting.Core/Dependencies/DotNetZip/Unity.VisualScripting.IonicZip.dll
Native extension for OSXStandalone target not found
Native extension for WebGL target not found
Refreshing native plugins compatible for Editor in 1.13 ms, found 2 plugins.
Preloading 0 native plugins for Editor in 0.00 ms.
Mono: successfully reloaded assembly
- Completed reload, in  1.901 seconds
Domain Reload Profiling:
	ReloadAssembly (1903ms)
		BeginReloadAssembly (202ms)
			ExecutionOrderSort (0ms)
			DisableScriptedObjects (11ms)
			BackupInstance (0ms)
			ReleaseScriptingObjects (0ms)
			CreateAndSetChildDomain (87ms)
		EndReloadAssembly (1530ms)
			LoadAssemblies (90ms)
			RebuildTransferFunctionScriptingTraits (0ms)
			SetupTypeCache (508ms)
			ReleaseScriptCaches (2ms)
			RebuildScriptCaches (85ms)
			SetupLoadedEditorAssemblies (724ms)
				LogAssemblyErrors (0ms)
				InitializePlatformSupportModulesInManaged (22ms)
				SetLoadedEditorAssemblies (1ms)
				RefreshPlugins (1ms)
				BeforeProcessingInitializeOnLoad (110ms)
				ProcessInitializeOnLoadAttributes (530ms)
				ProcessInitializeOnLoadMethodAttributes (54ms)
				AfterProcessingInitializeOnLoad (5ms)
				EditorAssembliesLoaded (0ms)
			ExecutionOrderSort2 (0ms)
			AwakeInstancesAfterBackupRestoration (10ms)
Platform modules already initialized, skipping
Compilation succeeded with: 

program_source:299:53: warning: writable resources in non-void post-tessellation vertex function
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
                                                    ^
program_source:305:30: note: writable buffer defined here
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
                             ^
program_source:306:48: note: writable buffer defined here
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
                                               ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float4 TEXCOORD0 [[ attribute(3) ]] ;
    float4 TEXCOORD1 [[ attribute(4) ]] ;
    float4 TEXCOORD2 [[ attribute(5) ]] ;
    float4 TEXCOORD3 [[ attribute(6) ]] ;
    float4 COLOR0 [[ attribute(7) ]] ;
};
struct Mtl_VertexOut
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float4 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float4 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float4 TEXCOORD3 [[ user(TEXCOORD3) ]];
    float4 COLOR0 [[ user(COLOR0) ]];
};
static Mtl_VertexOut vertexFunction(
    Mtl_VertexIn input)
{
    Mtl_VertexOut output;
    output.INTERNALTESSPOS0 = input.POSITION0;
    output.TANGENT0 = input.TANGENT0;
    output.NORMAL0.xyz = input.NORMAL0.xyz;
    output.TEXCOORD0 = input.TEXCOORD0;
    output.TEXCOORD1 = input.TEXCOORD1;
    output.TEXCOORD2 = input.TEXCOORD2;
    output.TEXCOORD3 = input.TEXCOORD3;
    output.COLOR0 = input.COLOR0;
    return output;
}
// SHADER_STAGE_HULL_begin
struct Mtl_ControlPoint
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float4 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float4 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float4 TEXCOORD3 [[ user(TEXCOORD3) ]];
    float4 COLOR0 [[ user(COLOR0) ]];
};
struct Mtl_ControlPointIn
{
    float4 INTERNALTESSPOS0 [[ attribute(8) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float4 TEXCOORD0 [[ attribute(3) ]] ;
    float4 TEXCOORD1 [[ attribute(4) ]] ;
    float4 TEXCOORD2 [[ attribute(5) ]] ;
    float4 TEXCOORD3 [[ attribute(6) ]] ;
    float4 COLOR0 [[ attribute(7) ]] ;
};
struct Mtl_KernelPatchInfo
{
    uint numPatches;
    ushort numControlPointsPerPatch;
};
struct VGlobals_Type
{
    float4 _Time;
    float4 _SinTime;
    float4 _CosTime;
    float4 unity_DeltaTime;
    float3 _WorldSpaceCameraPos;
    float4 _ProjectionParams;
    float4 _ScreenParams;
    float4 _ZBufferParams;
    float4 unity_OrthoParams;
    float4 unity_CameraWorldClipPlanes[6];
    float4 hlslcc_mtx4x4unity_CameraProjection[4];
    float4 hlslcc_mtx4x4unity_CameraInvProjection[4];
    float4 hlslcc_mtx4x4unity_WorldToCamera[4];
    float4 hlslcc_mtx4x4unity_CameraToWorld[4];
    float4 _WorldSpaceLightPos0;
    float4 _LightPositionRange;
    float4 _LightProjectionParams;
    float4 unity_4LightPosX0;
    float4 unity_4LightPosY0;
    float4 unity_4LightPosZ0;
    float4 unity_4LightAtten0;
    float4 unity_LightColor[8];
    float4 unity_LightPosition[8];
    float4 unity_LightAtten[8];
    float4 unity_SpotDirection[8];
    float4 unity_SHAr;
    float4 unity_SHAg;
    float4 unity_SHAb;
    float4 unity_SHBr;
    float4 unity_SHBg;
    float4 unity_SHBb;
    float4 unity_SHC;
    float4 unity_OcclusionMaskSelector;
    float4 unity_ProbesOcclusion;
    float3 unity_LightColor0;
    float3 unity_LightColor1;
    float3 unity_LightColor2;
    float3 unity_LightColor3;
    float4 unity_ShadowSplitSpheres[4];
    float4 unity_ShadowSplitSqRadii;
    float4 unity_LightShadowBias;
    float4 _LightSplitsNear;
    float4 _LightSplitsFar;
    float4 hlslcc_mtx4x4unity_WorldToShadow[16];
    float4 _LightShadowData;
    float4 unity_ShadowFadeCenterAndType;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 unity_LODFade;
    float4 unity_WorldTransformParams;
    float4 unity_RenderingLayer;
    float4 hlslcc_mtx4x4glstate_matrix_transpose_modelview0[4];
    float4 glstate_lightmodel_ambient;
    float4 unity_AmbientSky;
    float4 unity_AmbientEquator;
    float4 unity_AmbientGround;
    float4 unity_IndirectSpecColor;
    float4 hlslcc_mtx4x4glstate_matrix_projection[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixInvV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    int unity_StereoEyeIndex;
    float4 unity_ShadowColor;
    float4 unity_FogColor;
    float4 unity_FogParams;
    float4 unity_LightmapST;
    float4 unity_DynamicLightmapST;
    float4 unity_SpecCube0_BoxMax;
    float4 unity_SpecCube0_BoxMin;
    float4 unity_SpecCube0_ProbePosition;
    float4 unity_SpecCube0_HDR;
    float4 unity_SpecCube1_BoxMax;
    float4 unity_SpecCube1_BoxMin;
    float4 unity_SpecCube1_ProbePosition;
    float4 unity_SpecCube1_HDR;
    float4 unity_ProbeVolumeParams;
    float4 hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[4];
    float3 unity_ProbeVolumeSizeInv;
    float3 unity_ProbeVolumeMin;
    float4 unity_Lightmap_HDR;
    float4 unity_DynamicLightmap_HDR;
    float4 _LightColor0;
    float4 _SpecColor;
    float _Tile;
    float _HeightDisplacement;
    float _NormalScale;
    float4 _ColorTint;
    float _MetallicStrength;
    float _SmoothnessStrength;
    float _EdgeLength;
    float4 _texcoord_ST;
};
struct Mtl_HullIn
{
    Mtl_VertexOut cp[3];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
kernel void patchKernel(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn vertexInput [[ stage_in ]],
    uint2 tID [[ thread_position_in_grid ]],
    ushort2 groupID [[ threadgroup_position_in_grid ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    constant Mtl_KernelPatchInfo &patchInfo [[ buffer(3) ]])
{
#pragma clang diagnostic pop
    Mtl_ControlPoint output;
    const uint numPatchesInThreadGroup = 10;
    const uint patchID = (tID.x / patchInfo.numControlPointsPerPatch);
    const bool patchValid = (patchID < patchInfo.numPatches);
    const uint mtl_BaseInstance = 0;
    const uint mtl_InstanceID = groupID.y - mtl_BaseInstance;
    const uint internalPatchID = mtl_InstanceID * patchInfo.numPatches + patchID;
    const uint patchIDInThreadGroup = (patchID % numPatchesInThreadGroup);
    const uint controlPointID = (tID.x % patchInfo.numControlPointsPerPatch);
    const uint mtl_BaseVertex = 0;
    const uint mtl_VertexID = ((mtl_InstanceID * (patchInfo.numControlPointsPerPatch * patchInfo.numPatches)) + tID.x) - mtl_BaseVertex;
    threadgroup Mtl_HullIn inputGroup[numPatchesInThreadGroup];
    threadgroup Mtl_HullIn &input = inputGroup[patchIDInThreadGroup];
    MTLTriangleTessellationFactorsHalf tessFactor;
    if (patchValid) {
        input.cp[controlPointID] = vertexFunction(vertexInput);
        output.INTERNALTESSPOS0 = input.cp[controlPointID].INTERNALTESSPOS0;
        output.TANGENT0 = input.cp[controlPointID].TANGENT0;
        output.NORMAL0 = input.cp[controlPointID].NORMAL0;
        output.TEXCOORD0 = input.cp[controlPointID].TEXCOORD0;
        output.TEXCOORD1 = input.cp[controlPointID].TEXCOORD1;
        output.TEXCOORD2 = input.cp[controlPointID].TEXCOORD2;
        output.TEXCOORD3 = input.cp[controlPointID].TEXCOORD3;
        output.COLOR0 = input.cp[controlPointID].COLOR0;
    }
    threadgroup_barrier(mem_flags::mem_threadgroup);
    if (!patchValid) {
        return;
    }
    float3 u_xlat0;
    float3 u_xlat1;
    float3 u_xlat2;
    float3 u_xlat3;
    float3 u_xlat4;
    float u_xlat12;
    float u_xlat13;
    // fork_phase2
    {
        u_xlat0.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[1].INTERNALTESSPOS0.yyy;
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[1].INTERNALTESSPOS0.xxx, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[1].INTERNALTESSPOS0.zzz, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[1].INTERNALTESSPOS0.www, u_xlat0.xyz);
        u_xlat1.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[2].INTERNALTESSPOS0.yyy;
        u_xlat1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[2].INTERNALTESSPOS0.xxx, u_xlat1.xyz);
        u_xlat1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[2].INTERNALTESSPOS0.zzz, u_xlat1.xyz);
        u_xlat1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[2].INTERNALTESSPOS0.www, u_xlat1.xyz);
        u_xlat2.xyz = u_xlat0.xyz + u_xlat1.xyz;
        u_xlat2.xyz = fma(u_xlat2.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat12 = dot(u_xlat2.xyz, u_xlat2.xyz);
        u_xlat12 = sqrt(u_xlat12);
        u_xlat12 = u_xlat12 * VGlobals._EdgeLength;
        u_xlat2.xyz = u_xlat0.xyz + (-u_xlat1.xyz);
        u_xlat13 = dot(u_xlat2.xyz, u_xlat2.xyz);
        u_xlat13 = sqrt(u_xlat13);
        u_xlat13 = u_xlat13 * VGlobals._ScreenParams.y;
        u_xlat12 = u_xlat13 / u_xlat12;
        tessFactor.edgeTessellationFactor[0] = max(u_xlat12, 1.0);
        u_xlat2.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[0].INTERNALTESSPOS0.yyy;
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[0].INTERNALTESSPOS0.xxx, u_xlat2.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[0].INTERNALTESSPOS0.zzz, u_xlat2.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[0].INTERNALTESSPOS0.www, u_xlat2.xyz);
        u_xlat3.xyz = u_xlat1.xyz + u_xlat2.xyz;
        u_xlat1.xyz = u_xlat1.xyz + (-u_xlat2.xyz);
        u_xlat12 = dot(u_xlat1.xyz, u_xlat1.xyz);
        u_xlat12 = sqrt(u_xlat12);
        u_xlat12 = u_xlat12 * VGlobals._ScreenParams.y;
        u_xlat1.xyz = fma(u_xlat3.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat1.x = dot(u_xlat1.xyz, u_xlat1.xyz);
        u_xlat1.x = sqrt(u_xlat1.x);
        u_xlat1.x = u_xlat1.x * VGlobals._EdgeLength;
        u_xlat12 = u_xlat12 / u_xlat1.x;
        tessFactor.edgeTessellationFactor[1] = max(u_xlat12, 1.0);
        u_xlat1.xyz = u_xlat0.xyz + u_xlat2.xyz;
        u_xlat0.xyz = (-u_xlat0.xyz) + u_xlat2.xyz;
        u_xlat0.x = dot(u_xlat0.xyz, u_xlat0.xyz);
        u_xlat0.x = sqrt(u_xlat0.x);
        u_xlat0.x = u_xlat0.x * VGlobals._ScreenParams.y;
        u_xlat4.xyz = fma(u_xlat1.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat4.x = dot(u_xlat4.xyz, u_xlat4.xyz);
        u_xlat4.x = sqrt(u_xlat4.x);
        u_xlat4.x = u_xlat4.x * VGlobals._EdgeLength;
        u_xlat0.x = u_xlat0.x / u_xlat4.x;
        tessFactor.edgeTessellationFactor[2] = max(u_xlat0.x, 1.0);
    }
    // join_phase3
    {
        u_xlat0.x = tessFactor.edgeTessellationFactor[0] + tessFactor.edgeTessellationFactor[1];
        u_xlat0.x = u_xlat0.x + tessFactor.edgeTessellationFactor[2];
        tessFactor.insideTessellationFactor = u_xlat0.x * 0.333333343;
    }
    controlPoints[mtl_VertexID] = output;
    tessFactors[internalPatchID] = tessFactor;
}
// SHADER_STAGE_HULL_end
// SHADER_STAGE_DOMAIN_begin
struct Mtl_VertexInPostTess
{
    patch_control_point<Mtl_ControlPointIn> cp;
};
struct Mtl_VertexOutPostTess
{
    float4 mtl_Position [[ position ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float4 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float4 TEXCOORD3 [[ user(TEXCOORD3) ]];
    float4 TEXCOORD6 [[ user(TEXCOORD6) ]];
    float4 TEXCOORD7 [[ user(TEXCOORD7) ]];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    sampler sampler_Height [[ sampler (0) ]],
    texture2d<float, access::sample > _Height [[ texture(0) ]] ,
    float3 mtl_TessCoord [[ position_in_patch ]],
    uint patchID [[ patch_id ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    Mtl_VertexInPostTess input [[ stage_in ]])
{
#pragma clang diagnostic pop
    Mtl_VertexOutPostTess output;
    MTLTriangleTessellationFactorsHalf tessFactor;
    tessFactor = tessFactors[patchID];
    float4 u_xlat0;
    float4 u_xlat1;
    float4 u_xlat2;
    float4 u_xlat3;
    float2 u_xlat9;
    float u_xlat12;
    float u_xlat13;
    u_xlat0 = mtl_TessCoord.yyyy * input.cp[1].INTERNALTESSPOS0;
    u_xlat0 = fma(input.cp[0].INTERNALTESSPOS0, mtl_TessCoord.xxxx, u_xlat0);
    u_xlat0 = fma(input.cp[2].INTERNALTESSPOS0, mtl_TessCoord.zzzz, u_xlat0);
    u_xlat1.xy = mtl_TessCoord.yy * input.cp[1].TEXCOORD0.xy;
    u_xlat1.xy = fma(input.cp[0].TEXCOORD0.xy, mtl_TessCoord.xx, u_xlat1.xy);
    u_xlat1.xy = fma(input.cp[2].TEXCOORD0.xy, mtl_TessCoord.zz, u_xlat1.xy);
    u_xlat9.xy = u_xlat1.xy * float2(VGlobals._Tile);
    output.TEXCOORD0.xy = fma(u_xlat1.xy, VGlobals._texcoord_ST.xy, VGlobals._texcoord_ST.zw);
    u_xlat1.xyz = _Height.sample(sampler_Height, u_xlat9.xy, level(1.0)).xyz;
    u_xlat2.xyz = mtl_TessCoord.yyy * input.cp[1].NORMAL0.xyz;
    u_xlat2.xyz = fma(input.cp[0].NORMAL0.xyz, mtl_TessCoord.xxx, u_xlat2.xyz);
    u_xlat2.xyz = fma(input.cp[2].NORMAL0.xyz, mtl_TessCoord.zzz, u_xlat2.xyz);
    u_xlat1.xyz = u_xlat1.xyz * u_xlat2.xyz;
    u_xlat0.xyz = fma(u_xlat1.xyz, float3(VGlobals._HeightDisplacement), u_xlat0.xyz);
    u_xlat1 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], u_xlat0.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], u_xlat0.zzzz, u_xlat1);
    u_xlat3 = u_xlat1 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, u_xlat0.www, u_xlat1.xyz);
    u_xlat1 = u_xlat3.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat3.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat3.zzzz, u_xlat1);
    output.mtl_Position = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat3.wwww, u_xlat1);
    u_xlat1.y = dot(u_xlat2.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat1.z = dot(u_xlat2.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat1.x = dot(u_xlat2.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat12 = dot(u_xlat1.xyz, u_xlat1.xyz);
    u_xlat12 = rsqrt(u_xlat12);
    u_xlat1.xyz = float3(u_xlat12) * u_xlat1.xyz;
    output.TEXCOORD1.z = u_xlat1.y;
    u_xlat2 = mtl_TessCoord.yyyy * input.cp[1].TANGENT0;
    u_xlat2 = fma(input.cp[0].TANGENT0, mtl_TessCoord.xxxx, u_xlat2);
    u_xlat2 = fma(input.cp[2].TANGENT0, mtl_TessCoord.zzzz, u_xlat2);
    u_xlat3.xyz = u_xlat2.yyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].yzx;
    u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].yzx, u_xlat2.xxx, u_xlat3.xyz);
    u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].yzx, u_xlat2.zzz, u_xlat3.xyz);
    u_xlat12 = u_xlat2.w * VGlobals.unity_WorldTransformParams.w;
    u_xlat13 = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat13 = rsqrt(u_xlat13);
    u_xlat2.xyz = float3(u_xlat13) * u_xlat2.xyz;
    u_xlat3.xyz = u_xlat1.xyz * u_xlat2.xyz;
    u_xlat3.xyz = fma(u_xlat1.zxy, u_xlat2.yzx, (-u_xlat3.xyz));
    u_xlat3.xyz = float3(u_xlat12) * u_xlat3.xyz;
    output.TEXCOORD1.y = u_xlat3.x;
    output.TEXCOORD1.w = u_xlat0.x;
    output.TEXCOORD1.x = u_xlat2.z;
    output.TEXCOORD2.w = u_xlat0.y;
    output.TEXCOORD3.w = u_xlat0.z;
    output.TEXCOORD2.x = u_xlat2.x;
    output.TEXCOORD3.x = u_xlat2.y;
    output.TEXCOORD2.z = u_xlat1.z;
    output.TEXCOORD3.z = u_xlat1.x;
    output.TEXCOORD2.y = u_xlat3.y;
    output.TEXCOORD3.y = u_xlat3.z;
    output.TEXCOORD6 = float4(0.0, 0.0, 0.0, 0.0);
    output.TEXCOORD7 = float4(0.0, 0.0, 0.0, 0.0);
    return output;
}
// SHADER_STAGE_DOMAIN_end
Compilation succeeded with: 

program_source:301:53: warning: writable resources in non-void post-tessellation vertex function
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
                                                    ^
program_source:307:30: note: writable buffer defined here
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
                             ^
program_source:308:48: note: writable buffer defined here
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
                                               ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float4 TEXCOORD0 [[ attribute(3) ]] ;
    float4 TEXCOORD1 [[ attribute(4) ]] ;
    float4 TEXCOORD2 [[ attribute(5) ]] ;
    float4 TEXCOORD3 [[ attribute(6) ]] ;
    float4 COLOR0 [[ attribute(7) ]] ;
};
struct Mtl_VertexOut
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float4 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float4 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float4 TEXCOORD3 [[ user(TEXCOORD3) ]];
    float4 COLOR0 [[ user(COLOR0) ]];
};
static Mtl_VertexOut vertexFunction(
    Mtl_VertexIn input)
{
    Mtl_VertexOut output;
    output.INTERNALTESSPOS0 = input.POSITION0;
    output.TANGENT0 = input.TANGENT0;
    output.NORMAL0.xyz = input.NORMAL0.xyz;
    output.TEXCOORD0 = input.TEXCOORD0;
    output.TEXCOORD1 = input.TEXCOORD1;
    output.TEXCOORD2 = input.TEXCOORD2;
    output.TEXCOORD3 = input.TEXCOORD3;
    output.COLOR0 = input.COLOR0;
    return output;
}
// SHADER_STAGE_HULL_begin
struct Mtl_ControlPoint
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float4 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float4 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float4 TEXCOORD3 [[ user(TEXCOORD3) ]];
    float4 COLOR0 [[ user(COLOR0) ]];
};
struct Mtl_ControlPointIn
{
    float4 INTERNALTESSPOS0 [[ attribute(8) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float4 TEXCOORD0 [[ attribute(3) ]] ;
    float4 TEXCOORD1 [[ attribute(4) ]] ;
    float4 TEXCOORD2 [[ attribute(5) ]] ;
    float4 TEXCOORD3 [[ attribute(6) ]] ;
    float4 COLOR0 [[ attribute(7) ]] ;
};
struct Mtl_KernelPatchInfo
{
    uint numPatches;
    ushort numControlPointsPerPatch;
};
struct VGlobals_Type
{
    float4 _Time;
    float4 _SinTime;
    float4 _CosTime;
    float4 unity_DeltaTime;
    float3 _WorldSpaceCameraPos;
    float4 _ProjectionParams;
    float4 _ScreenParams;
    float4 _ZBufferParams;
    float4 unity_OrthoParams;
    float4 unity_CameraWorldClipPlanes[6];
    float4 hlslcc_mtx4x4unity_CameraProjection[4];
    float4 hlslcc_mtx4x4unity_CameraInvProjection[4];
    float4 hlslcc_mtx4x4unity_WorldToCamera[4];
    float4 hlslcc_mtx4x4unity_CameraToWorld[4];
    float4 _WorldSpaceLightPos0;
    float4 _LightPositionRange;
    float4 _LightProjectionParams;
    float4 unity_4LightPosX0;
    float4 unity_4LightPosY0;
    float4 unity_4LightPosZ0;
    float4 unity_4LightAtten0;
    float4 unity_LightColor[8];
    float4 unity_LightPosition[8];
    float4 unity_LightAtten[8];
    float4 unity_SpotDirection[8];
    float4 unity_SHAr;
    float4 unity_SHAg;
    float4 unity_SHAb;
    float4 unity_SHBr;
    float4 unity_SHBg;
    float4 unity_SHBb;
    float4 unity_SHC;
    float4 unity_OcclusionMaskSelector;
    float4 unity_ProbesOcclusion;
    float3 unity_LightColor0;
    float3 unity_LightColor1;
    float3 unity_LightColor2;
    float3 unity_LightColor3;
    float4 unity_ShadowSplitSpheres[4];
    float4 unity_ShadowSplitSqRadii;
    float4 unity_LightShadowBias;
    float4 _LightSplitsNear;
    float4 _LightSplitsFar;
    float4 hlslcc_mtx4x4unity_WorldToShadow[16];
    float4 _LightShadowData;
    float4 unity_ShadowFadeCenterAndType;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 unity_LODFade;
    float4 unity_WorldTransformParams;
    float4 unity_RenderingLayer;
    float4 hlslcc_mtx4x4glstate_matrix_transpose_modelview0[4];
    float4 glstate_lightmodel_ambient;
    float4 unity_AmbientSky;
    float4 unity_AmbientEquator;
    float4 unity_AmbientGround;
    float4 unity_IndirectSpecColor;
    float4 hlslcc_mtx4x4glstate_matrix_projection[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixInvV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    int unity_StereoEyeIndex;
    float4 unity_ShadowColor;
    float4 unity_FogColor;
    float4 unity_FogParams;
    float4 unity_LightmapST;
    float4 unity_DynamicLightmapST;
    float4 unity_SpecCube0_BoxMax;
    float4 unity_SpecCube0_BoxMin;
    float4 unity_SpecCube0_ProbePosition;
    float4 unity_SpecCube0_HDR;
    float4 unity_SpecCube1_BoxMax;
    float4 unity_SpecCube1_BoxMin;
    float4 unity_SpecCube1_ProbePosition;
    float4 unity_SpecCube1_HDR;
    float4 unity_ProbeVolumeParams;
    float4 hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[4];
    float3 unity_ProbeVolumeSizeInv;
    float3 unity_ProbeVolumeMin;
    float4 unity_Lightmap_HDR;
    float4 unity_DynamicLightmap_HDR;
    float4 _LightColor0;
    float4 _SpecColor;
    float4 hlslcc_mtx4x4unity_WorldToLight[4];
    float _Tile;
    float _HeightDisplacement;
    float _NormalScale;
    float4 _ColorTint;
    float _MetallicStrength;
    float _SmoothnessStrength;
    float _EdgeLength;
    float4 _texcoord_ST;
};
struct Mtl_HullIn
{
    Mtl_VertexOut cp[3];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
kernel void patchKernel(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn vertexInput [[ stage_in ]],
    uint2 tID [[ thread_position_in_grid ]],
    ushort2 groupID [[ threadgroup_position_in_grid ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    constant Mtl_KernelPatchInfo &patchInfo [[ buffer(3) ]])
{
#pragma clang diagnostic pop
    Mtl_ControlPoint output;
    const uint numPatchesInThreadGroup = 10;
    const uint patchID = (tID.x / patchInfo.numControlPointsPerPatch);
    const bool patchValid = (patchID < patchInfo.numPatches);
    const uint mtl_BaseInstance = 0;
    const uint mtl_InstanceID = groupID.y - mtl_BaseInstance;
    const uint internalPatchID = mtl_InstanceID * patchInfo.numPatches + patchID;
    const uint patchIDInThreadGroup = (patchID % numPatchesInThreadGroup);
    const uint controlPointID = (tID.x % patchInfo.numControlPointsPerPatch);
    const uint mtl_BaseVertex = 0;
    const uint mtl_VertexID = ((mtl_InstanceID * (patchInfo.numControlPointsPerPatch * patchInfo.numPatches)) + tID.x) - mtl_BaseVertex;
    threadgroup Mtl_HullIn inputGroup[numPatchesInThreadGroup];
    threadgroup Mtl_HullIn &input = inputGroup[patchIDInThreadGroup];
    MTLTriangleTessellationFactorsHalf tessFactor;
    if (patchValid) {
        input.cp[controlPointID] = vertexFunction(vertexInput);
        output.INTERNALTESSPOS0 = input.cp[controlPointID].INTERNALTESSPOS0;
        output.TANGENT0 = input.cp[controlPointID].TANGENT0;
        output.NORMAL0 = input.cp[controlPointID].NORMAL0;
        output.TEXCOORD0 = input.cp[controlPointID].TEXCOORD0;
        output.TEXCOORD1 = input.cp[controlPointID].TEXCOORD1;
        output.TEXCOORD2 = input.cp[controlPointID].TEXCOORD2;
        output.TEXCOORD3 = input.cp[controlPointID].TEXCOORD3;
        output.COLOR0 = input.cp[controlPointID].COLOR0;
    }
    threadgroup_barrier(mem_flags::mem_threadgroup);
    if (!patchValid) {
        return;
    }
    float3 u_xlat0;
    float3 u_xlat1;
    float3 u_xlat2;
    float3 u_xlat3;
    float3 u_xlat4;
    float u_xlat12;
    float u_xlat13;
    // fork_phase2
    {
        u_xlat0.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[1].INTERNALTESSPOS0.yyy;
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[1].INTERNALTESSPOS0.xxx, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[1].INTERNALTESSPOS0.zzz, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[1].INTERNALTESSPOS0.www, u_xlat0.xyz);
        u_xlat1.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[2].INTERNALTESSPOS0.yyy;
        u_xlat1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[2].INTERNALTESSPOS0.xxx, u_xlat1.xyz);
        u_xlat1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[2].INTERNALTESSPOS0.zzz, u_xlat1.xyz);
        u_xlat1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[2].INTERNALTESSPOS0.www, u_xlat1.xyz);
        u_xlat2.xyz = u_xlat0.xyz + u_xlat1.xyz;
        u_xlat2.xyz = fma(u_xlat2.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat12 = dot(u_xlat2.xyz, u_xlat2.xyz);
        u_xlat12 = sqrt(u_xlat12);
        u_xlat12 = u_xlat12 * VGlobals._EdgeLength;
        u_xlat2.xyz = u_xlat0.xyz + (-u_xlat1.xyz);
        u_xlat13 = dot(u_xlat2.xyz, u_xlat2.xyz);
        u_xlat13 = sqrt(u_xlat13);
        u_xlat13 = u_xlat13 * VGlobals._ScreenParams.y;
        u_xlat12 = u_xlat13 / u_xlat12;
        tessFactor.edgeTessellationFactor[0] = max(u_xlat12, 1.0);
        u_xlat2.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[0].INTERNALTESSPOS0.yyy;
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[0].INTERNALTESSPOS0.xxx, u_xlat2.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[0].INTERNALTESSPOS0.zzz, u_xlat2.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[0].INTERNALTESSPOS0.www, u_xlat2.xyz);
        u_xlat3.xyz = u_xlat1.xyz + u_xlat2.xyz;
        u_xlat1.xyz = u_xlat1.xyz + (-u_xlat2.xyz);
        u_xlat12 = dot(u_xlat1.xyz, u_xlat1.xyz);
        u_xlat12 = sqrt(u_xlat12);
        u_xlat12 = u_xlat12 * VGlobals._ScreenParams.y;
        u_xlat1.xyz = fma(u_xlat3.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat1.x = dot(u_xlat1.xyz, u_xlat1.xyz);
        u_xlat1.x = sqrt(u_xlat1.x);
        u_xlat1.x = u_xlat1.x * VGlobals._EdgeLength;
        u_xlat12 = u_xlat12 / u_xlat1.x;
        tessFactor.edgeTessellationFactor[1] = max(u_xlat12, 1.0);
        u_xlat1.xyz = u_xlat0.xyz + u_xlat2.xyz;
        u_xlat0.xyz = (-u_xlat0.xyz) + u_xlat2.xyz;
        u_xlat0.x = dot(u_xlat0.xyz, u_xlat0.xyz);
        u_xlat0.x = sqrt(u_xlat0.x);
        u_xlat0.x = u_xlat0.x * VGlobals._ScreenParams.y;
        u_xlat4.xyz = fma(u_xlat1.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat4.x = dot(u_xlat4.xyz, u_xlat4.xyz);
        u_xlat4.x = sqrt(u_xlat4.x);
        u_xlat4.x = u_xlat4.x * VGlobals._EdgeLength;
        u_xlat0.x = u_xlat0.x / u_xlat4.x;
        tessFactor.edgeTessellationFactor[2] = max(u_xlat0.x, 1.0);
    }
    // join_phase3
    {
        u_xlat0.x = tessFactor.edgeTessellationFactor[0] + tessFactor.edgeTessellationFactor[1];
        u_xlat0.x = u_xlat0.x + tessFactor.edgeTessellationFactor[2];
        tessFactor.insideTessellationFactor = u_xlat0.x * 0.333333343;
    }
    controlPoints[mtl_VertexID] = output;
    tessFactors[internalPatchID] = tessFactor;
}
// SHADER_STAGE_HULL_end
// SHADER_STAGE_DOMAIN_begin
struct Mtl_VertexInPostTess
{
    patch_control_point<Mtl_ControlPointIn> cp;
};
struct Mtl_VertexOutPostTess
{
    float4 mtl_Position [[ position ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float3 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float3 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float3 TEXCOORD3 [[ user(TEXCOORD3) ]];
    float3 TEXCOORD4 [[ user(TEXCOORD4) ]];
    float3 TEXCOORD5 [[ user(TEXCOORD5) ]];
    float4 TEXCOORD6 [[ user(TEXCOORD6) ]];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    sampler sampler_Height [[ sampler (0) ]],
    texture2d<float, access::sample > _Height [[ texture(0) ]] ,
    float3 mtl_TessCoord [[ position_in_patch ]],
    uint patchID [[ patch_id ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    Mtl_VertexInPostTess input [[ stage_in ]])
{
#pragma clang diagnostic pop
    Mtl_VertexOutPostTess output;
    MTLTriangleTessellationFactorsHalf tessFactor;
    tessFactor = tessFactors[patchID];
    float4 u_xlat0;
    float3 u_xlat1;
    float4 u_xlat2;
    float4 u_xlat3;
    float4 u_xlat4;
    float2 u_xlat10;
    float u_xlat16;
    u_xlat0.xy = mtl_TessCoord.yy * input.cp[1].TEXCOORD0.xy;
    u_xlat0.xy = fma(input.cp[0].TEXCOORD0.xy, mtl_TessCoord.xx, u_xlat0.xy);
    u_xlat0.xy = fma(input.cp[2].TEXCOORD0.xy, mtl_TessCoord.zz, u_xlat0.xy);
    u_xlat10.xy = u_xlat0.xy * float2(VGlobals._Tile);
    output.TEXCOORD0.xy = fma(u_xlat0.xy, VGlobals._texcoord_ST.xy, VGlobals._texcoord_ST.zw);
    u_xlat0.xyz = _Height.sample(sampler_Height, u_xlat10.xy, level(1.0)).xyz;
    u_xlat1.xyz = mtl_TessCoord.yyy * input.cp[1].NORMAL0.xyz;
    u_xlat1.xyz = fma(input.cp[0].NORMAL0.xyz, mtl_TessCoord.xxx, u_xlat1.xyz);
    u_xlat1.xyz = fma(input.cp[2].NORMAL0.xyz, mtl_TessCoord.zzz, u_xlat1.xyz);
    u_xlat0.xyz = u_xlat0.xyz * u_xlat1.xyz;
    u_xlat2 = mtl_TessCoord.yyyy * input.cp[1].INTERNALTESSPOS0;
    u_xlat2 = fma(input.cp[0].INTERNALTESSPOS0, mtl_TessCoord.xxxx, u_xlat2);
    u_xlat2 = fma(input.cp[2].INTERNALTESSPOS0, mtl_TessCoord.zzzz, u_xlat2);
    u_xlat0.xyz = fma(u_xlat0.xyz, float3(VGlobals._HeightDisplacement), u_xlat2.xyz);
    u_xlat3 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], u_xlat0.xxxx, u_xlat3);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], u_xlat0.zzzz, u_xlat3);
    u_xlat3 = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat4 = u_xlat3.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat4 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat3.xxxx, u_xlat4);
    u_xlat4 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat3.zzzz, u_xlat4);
    output.mtl_Position = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat3.wwww, u_xlat4);
    u_xlat2.y = dot(u_xlat1.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat2.z = dot(u_xlat1.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat2.x = dot(u_xlat1.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat1.x = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat1.x = rsqrt(u_xlat1.x);
    u_xlat1.xyz = u_xlat1.xxx * u_xlat2.xyz;
    output.TEXCOORD1.z = u_xlat1.y;
    u_xlat3 = mtl_TessCoord.yyyy * input.cp[1].TANGENT0;
    u_xlat3 = fma(input.cp[0].TANGENT0, mtl_TessCoord.xxxx, u_xlat3);
    u_xlat3 = fma(input.cp[2].TANGENT0, mtl_TessCoord.zzzz, u_xlat3);
    u_xlat2.xyz = u_xlat3.yyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].yzx;
    u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].yzx, u_xlat3.xxx, u_xlat2.xyz);
    u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].yzx, u_xlat3.zzz, u_xlat2.xyz);
    u_xlat16 = u_xlat3.w * VGlobals.unity_WorldTransformParams.w;
    u_xlat3.x = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat3.x = rsqrt(u_xlat3.x);
    u_xlat2.xyz = u_xlat2.xyz * u_xlat3.xxx;
    u_xlat3.xyz = u_xlat1.xyz * u_xlat2.xyz;
    u_xlat3.xyz = fma(u_xlat1.zxy, u_xlat2.yzx, (-u_xlat3.xyz));
    u_xlat3.xyz = float3(u_xlat16) * u_xlat3.xyz;
    output.TEXCOORD1.y = u_xlat3.x;
    output.TEXCOORD1.x = u_xlat2.z;
    output.TEXCOORD2.x = u_xlat2.x;
    output.TEXCOORD3.x = u_xlat2.y;
    output.TEXCOORD2.z = u_xlat1.z;
    output.TEXCOORD3.z = u_xlat1.x;
    output.TEXCOORD2.y = u_xlat3.y;
    output.TEXCOORD3.y = u_xlat3.z;
    output.TEXCOORD4.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, u_xlat2.www, u_xlat0.xyz);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3], u_xlat2.wwww, u_xlat0);
    u_xlat1.xyz = u_xlat0.yyy * VGlobals.hlslcc_mtx4x4unity_WorldToLight[1].xyz;
    u_xlat1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_WorldToLight[0].xyz, u_xlat0.xxx, u_xlat1.xyz);
    u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_WorldToLight[2].xyz, u_xlat0.zzz, u_xlat1.xyz);
    output.TEXCOORD5.xyz = fma(VGlobals.hlslcc_mtx4x4unity_WorldToLight[3].xyz, u_xlat0.www, u_xlat0.xyz);
    output.TEXCOORD6 = float4(0.0, 0.0, 0.0, 0.0);
    return output;
}
// SHADER_STAGE_DOMAIN_end
Compilation succeeded with: 

program_source:293:53: warning: writable resources in non-void post-tessellation vertex function
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
                                                    ^
program_source:299:30: note: writable buffer defined here
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
                             ^
program_source:300:48: note: writable buffer defined here
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
                                               ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float4 TEXCOORD0 [[ attribute(3) ]] ;
    float4 TEXCOORD1 [[ attribute(4) ]] ;
    float4 TEXCOORD2 [[ attribute(5) ]] ;
    float4 TEXCOORD3 [[ attribute(6) ]] ;
    float4 COLOR0 [[ attribute(7) ]] ;
};
struct Mtl_VertexOut
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float4 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float4 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float4 TEXCOORD3 [[ user(TEXCOORD3) ]];
    float4 COLOR0 [[ user(COLOR0) ]];
};
static Mtl_VertexOut vertexFunction(
    Mtl_VertexIn input)
{
    Mtl_VertexOut output;
    output.INTERNALTESSPOS0 = input.POSITION0;
    output.TANGENT0 = input.TANGENT0;
    output.NORMAL0.xyz = input.NORMAL0.xyz;
    output.TEXCOORD0 = input.TEXCOORD0;
    output.TEXCOORD1 = input.TEXCOORD1;
    output.TEXCOORD2 = input.TEXCOORD2;
    output.TEXCOORD3 = input.TEXCOORD3;
    output.COLOR0 = input.COLOR0;
    return output;
}
// SHADER_STAGE_HULL_begin
struct Mtl_ControlPoint
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float4 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float4 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float4 TEXCOORD3 [[ user(TEXCOORD3) ]];
    float4 COLOR0 [[ user(COLOR0) ]];
};
struct Mtl_ControlPointIn
{
    float4 INTERNALTESSPOS0 [[ attribute(8) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float4 TEXCOORD0 [[ attribute(3) ]] ;
    float4 TEXCOORD1 [[ attribute(4) ]] ;
    float4 TEXCOORD2 [[ attribute(5) ]] ;
    float4 TEXCOORD3 [[ attribute(6) ]] ;
    float4 COLOR0 [[ attribute(7) ]] ;
};
struct Mtl_KernelPatchInfo
{
    uint numPatches;
    ushort numControlPointsPerPatch;
};
struct VGlobals_Type
{
    float4 _Time;
    float4 _SinTime;
    float4 _CosTime;
    float4 unity_DeltaTime;
    float3 _WorldSpaceCameraPos;
    float4 _ProjectionParams;
    float4 _ScreenParams;
    float4 _ZBufferParams;
    float4 unity_OrthoParams;
    float4 unity_CameraWorldClipPlanes[6];
    float4 hlslcc_mtx4x4unity_CameraProjection[4];
    float4 hlslcc_mtx4x4unity_CameraInvProjection[4];
    float4 hlslcc_mtx4x4unity_WorldToCamera[4];
    float4 hlslcc_mtx4x4unity_CameraToWorld[4];
    float4 _WorldSpaceLightPos0;
    float4 _LightPositionRange;
    float4 _LightProjectionParams;
    float4 unity_4LightPosX0;
    float4 unity_4LightPosY0;
    float4 unity_4LightPosZ0;
    float4 unity_4LightAtten0;
    float4 unity_LightColor[8];
    float4 unity_LightPosition[8];
    float4 unity_LightAtten[8];
    float4 unity_SpotDirection[8];
    float4 unity_SHAr;
    float4 unity_SHAg;
    float4 unity_SHAb;
    float4 unity_SHBr;
    float4 unity_SHBg;
    float4 unity_SHBb;
    float4 unity_SHC;
    float4 unity_OcclusionMaskSelector;
    float4 unity_ProbesOcclusion;
    float3 unity_LightColor0;
    float3 unity_LightColor1;
    float3 unity_LightColor2;
    float3 unity_LightColor3;
    float4 unity_ShadowSplitSpheres[4];
    float4 unity_ShadowSplitSqRadii;
    float4 unity_LightShadowBias;
    float4 _LightSplitsNear;
    float4 _LightSplitsFar;
    float4 hlslcc_mtx4x4unity_WorldToShadow[16];
    float4 _LightShadowData;
    float4 unity_ShadowFadeCenterAndType;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 unity_LODFade;
    float4 unity_WorldTransformParams;
    float4 unity_RenderingLayer;
    float4 hlslcc_mtx4x4glstate_matrix_transpose_modelview0[4];
    float4 glstate_lightmodel_ambient;
    float4 unity_AmbientSky;
    float4 unity_AmbientEquator;
    float4 unity_AmbientGround;
    float4 unity_IndirectSpecColor;
    float4 hlslcc_mtx4x4glstate_matrix_projection[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixInvV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    int unity_StereoEyeIndex;
    float4 unity_ShadowColor;
    float4 unity_FogColor;
    float4 unity_FogParams;
    float4 unity_LightmapST;
    float4 unity_DynamicLightmapST;
    float4 unity_SpecCube0_BoxMax;
    float4 unity_SpecCube0_BoxMin;
    float4 unity_SpecCube0_ProbePosition;
    float4 unity_SpecCube0_HDR;
    float4 unity_SpecCube1_BoxMax;
    float4 unity_SpecCube1_BoxMin;
    float4 unity_SpecCube1_ProbePosition;
    float4 unity_SpecCube1_HDR;
    float4 unity_ProbeVolumeParams;
    float4 hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[4];
    float3 unity_ProbeVolumeSizeInv;
    float3 unity_ProbeVolumeMin;
    float4 unity_Lightmap_HDR;
    float4 unity_DynamicLightmap_HDR;
    float4 _LightColor0;
    float4 _SpecColor;
    float _Tile;
    float _HeightDisplacement;
    float _NormalScale;
    float4 _ColorTint;
    float _MetallicStrength;
    float _SmoothnessStrength;
    float _EdgeLength;
};
struct Mtl_HullIn
{
    Mtl_VertexOut cp[3];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
kernel void patchKernel(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn vertexInput [[ stage_in ]],
    uint2 tID [[ thread_position_in_grid ]],
    ushort2 groupID [[ threadgroup_position_in_grid ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    constant Mtl_KernelPatchInfo &patchInfo [[ buffer(3) ]])
{
#pragma clang diagnostic pop
    Mtl_ControlPoint output;
    const uint numPatchesInThreadGroup = 10;
    const uint patchID = (tID.x / patchInfo.numControlPointsPerPatch);
    const bool patchValid = (patchID < patchInfo.numPatches);
    const uint mtl_BaseInstance = 0;
    const uint mtl_InstanceID = groupID.y - mtl_BaseInstance;
    const uint internalPatchID = mtl_InstanceID * patchInfo.numPatches + patchID;
    const uint patchIDInThreadGroup = (patchID % numPatchesInThreadGroup);
    const uint controlPointID = (tID.x % patchInfo.numControlPointsPerPatch);
    const uint mtl_BaseVertex = 0;
    const uint mtl_VertexID = ((mtl_InstanceID * (patchInfo.numControlPointsPerPatch * patchInfo.numPatches)) + tID.x) - mtl_BaseVertex;
    threadgroup Mtl_HullIn inputGroup[numPatchesInThreadGroup];
    threadgroup Mtl_HullIn &input = inputGroup[patchIDInThreadGroup];
    MTLTriangleTessellationFactorsHalf tessFactor;
    if (patchValid) {
        input.cp[controlPointID] = vertexFunction(vertexInput);
        output.INTERNALTESSPOS0 = input.cp[controlPointID].INTERNALTESSPOS0;
        output.TANGENT0 = input.cp[controlPointID].TANGENT0;
        output.NORMAL0 = input.cp[controlPointID].NORMAL0;
        output.TEXCOORD0 = input.cp[controlPointID].TEXCOORD0;
        output.TEXCOORD1 = input.cp[controlPointID].TEXCOORD1;
        output.TEXCOORD2 = input.cp[controlPointID].TEXCOORD2;
        output.TEXCOORD3 = input.cp[controlPointID].TEXCOORD3;
        output.COLOR0 = input.cp[controlPointID].COLOR0;
    }
    threadgroup_barrier(mem_flags::mem_threadgroup);
    if (!patchValid) {
        return;
    }
    float3 u_xlat0;
    float3 u_xlat1;
    float3 u_xlat2;
    float3 u_xlat3;
    float3 u_xlat4;
    float u_xlat12;
    float u_xlat13;
    // fork_phase2
    {
        u_xlat0.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[1].INTERNALTESSPOS0.yyy;
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[1].INTERNALTESSPOS0.xxx, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[1].INTERNALTESSPOS0.zzz, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[1].INTERNALTESSPOS0.www, u_xlat0.xyz);
        u_xlat1.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[2].INTERNALTESSPOS0.yyy;
        u_xlat1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[2].INTERNALTESSPOS0.xxx, u_xlat1.xyz);
        u_xlat1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[2].INTERNALTESSPOS0.zzz, u_xlat1.xyz);
        u_xlat1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[2].INTERNALTESSPOS0.www, u_xlat1.xyz);
        u_xlat2.xyz = u_xlat0.xyz + u_xlat1.xyz;
        u_xlat2.xyz = fma(u_xlat2.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat12 = dot(u_xlat2.xyz, u_xlat2.xyz);
        u_xlat12 = sqrt(u_xlat12);
        u_xlat12 = u_xlat12 * VGlobals._EdgeLength;
        u_xlat2.xyz = u_xlat0.xyz + (-u_xlat1.xyz);
        u_xlat13 = dot(u_xlat2.xyz, u_xlat2.xyz);
        u_xlat13 = sqrt(u_xlat13);
        u_xlat13 = u_xlat13 * VGlobals._ScreenParams.y;
        u_xlat12 = u_xlat13 / u_xlat12;
        tessFactor.edgeTessellationFactor[0] = max(u_xlat12, 1.0);
        u_xlat2.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[0].INTERNALTESSPOS0.yyy;
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[0].INTERNALTESSPOS0.xxx, u_xlat2.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[0].INTERNALTESSPOS0.zzz, u_xlat2.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[0].INTERNALTESSPOS0.www, u_xlat2.xyz);
        u_xlat3.xyz = u_xlat1.xyz + u_xlat2.xyz;
        u_xlat1.xyz = u_xlat1.xyz + (-u_xlat2.xyz);
        u_xlat12 = dot(u_xlat1.xyz, u_xlat1.xyz);
        u_xlat12 = sqrt(u_xlat12);
        u_xlat12 = u_xlat12 * VGlobals._ScreenParams.y;
        u_xlat1.xyz = fma(u_xlat3.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat1.x = dot(u_xlat1.xyz, u_xlat1.xyz);
        u_xlat1.x = sqrt(u_xlat1.x);
        u_xlat1.x = u_xlat1.x * VGlobals._EdgeLength;
        u_xlat12 = u_xlat12 / u_xlat1.x;
        tessFactor.edgeTessellationFactor[1] = max(u_xlat12, 1.0);
        u_xlat1.xyz = u_xlat0.xyz + u_xlat2.xyz;
        u_xlat0.xyz = (-u_xlat0.xyz) + u_xlat2.xyz;
        u_xlat0.x = dot(u_xlat0.xyz, u_xlat0.xyz);
        u_xlat0.x = sqrt(u_xlat0.x);
        u_xlat0.x = u_xlat0.x * VGlobals._ScreenParams.y;
        u_xlat4.xyz = fma(u_xlat1.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat4.x = dot(u_xlat4.xyz, u_xlat4.xyz);
        u_xlat4.x = sqrt(u_xlat4.x);
        u_xlat4.x = u_xlat4.x * VGlobals._EdgeLength;
        u_xlat0.x = u_xlat0.x / u_xlat4.x;
        tessFactor.edgeTessellationFactor[2] = max(u_xlat0.x, 1.0);
    }
    // join_phase3
    {
        u_xlat0.x = tessFactor.edgeTessellationFactor[0] + tessFactor.edgeTessellationFactor[1];
        u_xlat0.x = u_xlat0.x + tessFactor.edgeTessellationFactor[2];
        tessFactor.insideTessellationFactor = u_xlat0.x * 0.333333343;
    }
    controlPoints[mtl_VertexID] = output;
    tessFactors[internalPatchID] = tessFactor;
}
// SHADER_STAGE_HULL_end
// SHADER_STAGE_DOMAIN_begin
struct Mtl_VertexInPostTess
{
    patch_control_point<Mtl_ControlPointIn> cp;
};
struct Mtl_VertexOutPostTess
{
    float4 mtl_Position [[ position ]];
    float3 TEXCOORD1 [[ user(TEXCOORD1) ]];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    sampler sampler_Height [[ sampler (0) ]],
    texture2d<float, access::sample > _Height [[ texture(0) ]] ,
    float3 mtl_TessCoord [[ position_in_patch ]],
    uint patchID [[ patch_id ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    Mtl_VertexInPostTess input [[ stage_in ]])
{
#pragma clang diagnostic pop
    Mtl_VertexOutPostTess output;
    MTLTriangleTessellationFactorsHalf tessFactor;
    tessFactor = tessFactors[patchID];
    float4 u_xlat0;
    float4 u_xlat1;
    float4 u_xlat2;
    float4 u_xlat3;
    float4 u_xlat4;
    float u_xlat11;
    float u_xlat15;
    bool u_xlatb15;
    u_xlat0.xyz = mtl_TessCoord.yyy * input.cp[1].NORMAL0.xyz;
    u_xlat0.xyz = fma(input.cp[0].NORMAL0.xyz, mtl_TessCoord.xxx, u_xlat0.xyz);
    u_xlat0.xyz = fma(input.cp[2].NORMAL0.xyz, mtl_TessCoord.zzz, u_xlat0.xyz);
    u_xlat1.x = dot(u_xlat0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat1.y = dot(u_xlat0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat1.z = dot(u_xlat0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat15 = dot(u_xlat1.xyz, u_xlat1.xyz);
    u_xlat15 = rsqrt(u_xlat15);
    u_xlat1.xyz = float3(u_xlat15) * u_xlat1.xyz;
    u_xlat2.xy = mtl_TessCoord.yy * input.cp[1].TEXCOORD0.xy;
    u_xlat2.xy = fma(input.cp[0].TEXCOORD0.xy, mtl_TessCoord.xx, u_xlat2.xy);
    u_xlat2.xy = fma(input.cp[2].TEXCOORD0.xy, mtl_TessCoord.zz, u_xlat2.xy);
    u_xlat2.xy = u_xlat2.xy * float2(VGlobals._Tile);
    u_xlat2.xyz = _Height.sample(sampler_Height, u_xlat2.xy, level(1.0)).xyz;
    u_xlat0.xyz = u_xlat0.xyz * u_xlat2.xyz;
    u_xlat2 = mtl_TessCoord.yyyy * input.cp[1].INTERNALTESSPOS0;
    u_xlat2 = fma(input.cp[0].INTERNALTESSPOS0, mtl_TessCoord.xxxx, u_xlat2);
    u_xlat2 = fma(input.cp[2].INTERNALTESSPOS0, mtl_TessCoord.zzzz, u_xlat2);
    u_xlat0.xyz = fma(u_xlat0.xyz, float3(VGlobals._HeightDisplacement), u_xlat2.xyz);
    u_xlat3 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], u_xlat0.xxxx, u_xlat3);
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], u_xlat0.zzzz, u_xlat3);
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3], u_xlat2.wwww, u_xlat3);
    u_xlat2.xyz = fma((-u_xlat3.xyz), VGlobals._WorldSpaceLightPos0.www, VGlobals._WorldSpaceLightPos0.xyz);
    u_xlat15 = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat15 = rsqrt(u_xlat15);
    u_xlat2.xyz = float3(u_xlat15) * u_xlat2.xyz;
    u_xlat15 = dot(u_xlat1.xyz, u_xlat2.xyz);
    u_xlat15 = fma((-u_xlat15), u_xlat15, 1.0);
    u_xlat15 = sqrt(u_xlat15);
    u_xlat15 = u_xlat15 * VGlobals.unity_LightShadowBias.z;
    u_xlat1.xyz = fma((-u_xlat1.xyz), float3(u_xlat15), u_xlat3.xyz);
    u_xlatb15 = VGlobals.unity_LightShadowBias.z!=0.0;
    u_xlat1.xyz = (bool(u_xlatb15)) ? u_xlat1.xyz : u_xlat3.xyz;
    u_xlat4 = u_xlat1.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat4 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat1.xxxx, u_xlat4);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat1.zzzz, u_xlat4);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat3.wwww, u_xlat1);
    u_xlat15 = VGlobals.unity_LightShadowBias.x / u_xlat1.w;
    u_xlat15 = min(u_xlat15, 0.0);
    u_xlat15 = max(u_xlat15, -1.0);
    u_xlat15 = u_xlat15 + u_xlat1.z;
    u_xlat11 = min(u_xlat1.w, u_xlat15);
    output.mtl_Position.xyw = u_xlat1.xyw;
    u_xlat1.x = (-u_xlat15) + u_xlat11;
    output.mtl_Position.z = fma(VGlobals.unity_LightShadowBias.y, u_xlat1.x, u_xlat15);
    u_xlat1.xyz = u_xlat0.yyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz;
    u_xlat0.xyw = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, u_xlat0.xxx, u_xlat1.xyz);
    u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, u_xlat0.zzz, u_xlat0.xyw);
    output.TEXCOORD1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, u_xlat2.www, u_xlat0.xyz);
    return output;
}
// SHADER_STAGE_DOMAIN_end
Compilation succeeded with: 

program_source:299:53: warning: writable resources in non-void post-tessellation vertex function
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
                                                    ^
program_source:305:30: note: writable buffer defined here
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
                             ^
program_source:306:48: note: writable buffer defined here
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
                                               ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float4 TEXCOORD0 [[ attribute(3) ]] ;
    float4 TEXCOORD1 [[ attribute(4) ]] ;
    float4 TEXCOORD2 [[ attribute(5) ]] ;
    float4 TEXCOORD3 [[ attribute(6) ]] ;
    float4 COLOR0 [[ attribute(7) ]] ;
};
struct Mtl_VertexOut
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float4 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float4 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float4 TEXCOORD3 [[ user(TEXCOORD3) ]];
    float4 COLOR0 [[ user(COLOR0) ]];
};
static Mtl_VertexOut vertexFunction(
    Mtl_VertexIn input)
{
    Mtl_VertexOut output;
    output.INTERNALTESSPOS0 = input.POSITION0;
    output.TANGENT0 = input.TANGENT0;
    output.NORMAL0.xyz = input.NORMAL0.xyz;
    output.TEXCOORD0 = input.TEXCOORD0;
    output.TEXCOORD1 = input.TEXCOORD1;
    output.TEXCOORD2 = input.TEXCOORD2;
    output.TEXCOORD3 = input.TEXCOORD3;
    output.COLOR0 = input.COLOR0;
    return output;
}
// SHADER_STAGE_HULL_begin
struct Mtl_ControlPoint
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float4 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float4 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float4 TEXCOORD3 [[ user(TEXCOORD3) ]];
    float4 COLOR0 [[ user(COLOR0) ]];
};
struct Mtl_ControlPointIn
{
    float4 INTERNALTESSPOS0 [[ attribute(8) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float4 TEXCOORD0 [[ attribute(3) ]] ;
    float4 TEXCOORD1 [[ attribute(4) ]] ;
    float4 TEXCOORD2 [[ attribute(5) ]] ;
    float4 TEXCOORD3 [[ attribute(6) ]] ;
    float4 COLOR0 [[ attribute(7) ]] ;
};
struct Mtl_KernelPatchInfo
{
    uint numPatches;
    ushort numControlPointsPerPatch;
};
struct VGlobals_Type
{
    float4 _Time;
    float4 _SinTime;
    float4 _CosTime;
    float4 unity_DeltaTime;
    float3 _WorldSpaceCameraPos;
    float4 _ProjectionParams;
    float4 _ScreenParams;
    float4 _ZBufferParams;
    float4 unity_OrthoParams;
    float4 unity_CameraWorldClipPlanes[6];
    float4 hlslcc_mtx4x4unity_CameraProjection[4];
    float4 hlslcc_mtx4x4unity_CameraInvProjection[4];
    float4 hlslcc_mtx4x4unity_WorldToCamera[4];
    float4 hlslcc_mtx4x4unity_CameraToWorld[4];
    float4 _WorldSpaceLightPos0;
    float4 _LightPositionRange;
    float4 _LightProjectionParams;
    float4 unity_4LightPosX0;
    float4 unity_4LightPosY0;
    float4 unity_4LightPosZ0;
    float4 unity_4LightAtten0;
    float4 unity_LightColor[8];
    float4 unity_LightPosition[8];
    float4 unity_LightAtten[8];
    float4 unity_SpotDirection[8];
    float4 unity_SHAr;
    float4 unity_SHAg;
    float4 unity_SHAb;
    float4 unity_SHBr;
    float4 unity_SHBg;
    float4 unity_SHBb;
    float4 unity_SHC;
    float4 unity_OcclusionMaskSelector;
    float4 unity_ProbesOcclusion;
    float3 unity_LightColor0;
    float3 unity_LightColor1;
    float3 unity_LightColor2;
    float3 unity_LightColor3;
    float4 unity_ShadowSplitSpheres[4];
    float4 unity_ShadowSplitSqRadii;
    float4 unity_LightShadowBias;
    float4 _LightSplitsNear;
    float4 _LightSplitsFar;
    float4 hlslcc_mtx4x4unity_WorldToShadow[16];
    float4 _LightShadowData;
    float4 unity_ShadowFadeCenterAndType;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 unity_LODFade;
    float4 unity_WorldTransformParams;
    float4 unity_RenderingLayer;
    float4 hlslcc_mtx4x4glstate_matrix_transpose_modelview0[4];
    float4 glstate_lightmodel_ambient;
    float4 unity_AmbientSky;
    float4 unity_AmbientEquator;
    float4 unity_AmbientGround;
    float4 unity_IndirectSpecColor;
    float4 hlslcc_mtx4x4glstate_matrix_projection[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixInvV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    int unity_StereoEyeIndex;
    float4 unity_ShadowColor;
    float4 unity_FogColor;
    float4 unity_FogParams;
    float4 unity_LightmapST;
    float4 unity_DynamicLightmapST;
    float4 unity_SpecCube0_BoxMax;
    float4 unity_SpecCube0_BoxMin;
    float4 unity_SpecCube0_ProbePosition;
    float4 unity_SpecCube0_HDR;
    float4 unity_SpecCube1_BoxMax;
    float4 unity_SpecCube1_BoxMin;
    float4 unity_SpecCube1_ProbePosition;
    float4 unity_SpecCube1_HDR;
    float4 unity_ProbeVolumeParams;
    float4 hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[4];
    float3 unity_ProbeVolumeSizeInv;
    float3 unity_ProbeVolumeMin;
    float4 unity_Lightmap_HDR;
    float4 unity_DynamicLightmap_HDR;
    float4 _LightColor0;
    float4 _SpecColor;
    float _Tile;
    float _HeightDisplacement;
    float _NormalScale;
    float4 _ColorTint;
    float _MetallicStrength;
    float _SmoothnessStrength;
    float _EdgeLength;
    float4 _texcoord_ST;
    float4 unity_Ambient;
};
struct Mtl_HullIn
{
    Mtl_VertexOut cp[3];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
kernel void patchKernel(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn vertexInput [[ stage_in ]],
    uint2 tID [[ thread_position_in_grid ]],
    ushort2 groupID [[ threadgroup_position_in_grid ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    constant Mtl_KernelPatchInfo &patchInfo [[ buffer(3) ]])
{
#pragma clang diagnostic pop
    Mtl_ControlPoint output;
    const uint numPatchesInThreadGroup = 10;
    const uint patchID = (tID.x / patchInfo.numControlPointsPerPatch);
    const bool patchValid = (patchID < patchInfo.numPatches);
    const uint mtl_BaseInstance = 0;
    const uint mtl_InstanceID = groupID.y - mtl_BaseInstance;
    const uint internalPatchID = mtl_InstanceID * patchInfo.numPatches + patchID;
    const uint patchIDInThreadGroup = (patchID % numPatchesInThreadGroup);
    const uint controlPointID = (tID.x % patchInfo.numControlPointsPerPatch);
    const uint mtl_BaseVertex = 0;
    const uint mtl_VertexID = ((mtl_InstanceID * (patchInfo.numControlPointsPerPatch * patchInfo.numPatches)) + tID.x) - mtl_BaseVertex;
    threadgroup Mtl_HullIn inputGroup[numPatchesInThreadGroup];
    threadgroup Mtl_HullIn &input = inputGroup[patchIDInThreadGroup];
    MTLTriangleTessellationFactorsHalf tessFactor;
    if (patchValid) {
        input.cp[controlPointID] = vertexFunction(vertexInput);
        output.INTERNALTESSPOS0 = input.cp[controlPointID].INTERNALTESSPOS0;
        output.TANGENT0 = input.cp[controlPointID].TANGENT0;
        output.NORMAL0 = input.cp[controlPointID].NORMAL0;
        output.TEXCOORD0 = input.cp[controlPointID].TEXCOORD0;
        output.TEXCOORD1 = input.cp[controlPointID].TEXCOORD1;
        output.TEXCOORD2 = input.cp[controlPointID].TEXCOORD2;
        output.TEXCOORD3 = input.cp[controlPointID].TEXCOORD3;
        output.COLOR0 = input.cp[controlPointID].COLOR0;
    }
    threadgroup_barrier(mem_flags::mem_threadgroup);
    if (!patchValid) {
        return;
    }
    float3 u_xlat0;
    float3 u_xlat1;
    float3 u_xlat2;
    float3 u_xlat3;
    float3 u_xlat4;
    float u_xlat12;
    float u_xlat13;
    // fork_phase2
    {
        u_xlat0.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[1].INTERNALTESSPOS0.yyy;
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[1].INTERNALTESSPOS0.xxx, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[1].INTERNALTESSPOS0.zzz, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[1].INTERNALTESSPOS0.www, u_xlat0.xyz);
        u_xlat1.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[2].INTERNALTESSPOS0.yyy;
        u_xlat1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[2].INTERNALTESSPOS0.xxx, u_xlat1.xyz);
        u_xlat1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[2].INTERNALTESSPOS0.zzz, u_xlat1.xyz);
        u_xlat1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[2].INTERNALTESSPOS0.www, u_xlat1.xyz);
        u_xlat2.xyz = u_xlat0.xyz + u_xlat1.xyz;
        u_xlat2.xyz = fma(u_xlat2.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat12 = dot(u_xlat2.xyz, u_xlat2.xyz);
        u_xlat12 = sqrt(u_xlat12);
        u_xlat12 = u_xlat12 * VGlobals._EdgeLength;
        u_xlat2.xyz = u_xlat0.xyz + (-u_xlat1.xyz);
        u_xlat13 = dot(u_xlat2.xyz, u_xlat2.xyz);
        u_xlat13 = sqrt(u_xlat13);
        u_xlat13 = u_xlat13 * VGlobals._ScreenParams.y;
        u_xlat12 = u_xlat13 / u_xlat12;
        tessFactor.edgeTessellationFactor[0] = max(u_xlat12, 1.0);
        u_xlat2.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[0].INTERNALTESSPOS0.yyy;
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[0].INTERNALTESSPOS0.xxx, u_xlat2.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[0].INTERNALTESSPOS0.zzz, u_xlat2.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[0].INTERNALTESSPOS0.www, u_xlat2.xyz);
        u_xlat3.xyz = u_xlat1.xyz + u_xlat2.xyz;
        u_xlat1.xyz = u_xlat1.xyz + (-u_xlat2.xyz);
        u_xlat12 = dot(u_xlat1.xyz, u_xlat1.xyz);
        u_xlat12 = sqrt(u_xlat12);
        u_xlat12 = u_xlat12 * VGlobals._ScreenParams.y;
        u_xlat1.xyz = fma(u_xlat3.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat1.x = dot(u_xlat1.xyz, u_xlat1.xyz);
        u_xlat1.x = sqrt(u_xlat1.x);
        u_xlat1.x = u_xlat1.x * VGlobals._EdgeLength;
        u_xlat12 = u_xlat12 / u_xlat1.x;
        tessFactor.edgeTessellationFactor[1] = max(u_xlat12, 1.0);
        u_xlat1.xyz = u_xlat0.xyz + u_xlat2.xyz;
        u_xlat0.xyz = (-u_xlat0.xyz) + u_xlat2.xyz;
        u_xlat0.x = dot(u_xlat0.xyz, u_xlat0.xyz);
        u_xlat0.x = sqrt(u_xlat0.x);
        u_xlat0.x = u_xlat0.x * VGlobals._ScreenParams.y;
        u_xlat4.xyz = fma(u_xlat1.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat4.x = dot(u_xlat4.xyz, u_xlat4.xyz);
        u_xlat4.x = sqrt(u_xlat4.x);
        u_xlat4.x = u_xlat4.x * VGlobals._EdgeLength;
        u_xlat0.x = u_xlat0.x / u_xlat4.x;
        tessFactor.edgeTessellationFactor[2] = max(u_xlat0.x, 1.0);
    }
    // join_phase3
    {
        u_xlat0.x = tessFactor.edgeTessellationFactor[0] + tessFactor.edgeTessellationFactor[1];
        u_xlat0.x = u_xlat0.x + tessFactor.edgeTessellationFactor[2];
        tessFactor.insideTessellationFactor = u_xlat0.x * 0.333333343;
    }
    controlPoints[mtl_VertexID] = output;
    tessFactors[internalPatchID] = tessFactor;
}
// SHADER_STAGE_HULL_end
// SHADER_STAGE_DOMAIN_begin
struct Mtl_VertexInPostTess
{
    patch_control_point<Mtl_ControlPointIn> cp;
};
struct Mtl_VertexOutPostTess
{
    float4 mtl_Position [[ position ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float4 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float4 TEXCOORD3 [[ user(TEXCOORD3) ]];
    float4 TEXCOORD5 [[ user(TEXCOORD5) ]];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    sampler sampler_Height [[ sampler (0) ]],
    texture2d<float, access::sample > _Height [[ texture(0) ]] ,
    float3 mtl_TessCoord [[ position_in_patch ]],
    uint patchID [[ patch_id ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    Mtl_VertexInPostTess input [[ stage_in ]])
{
#pragma clang diagnostic pop
    Mtl_VertexOutPostTess output;
    MTLTriangleTessellationFactorsHalf tessFactor;
    tessFactor = tessFactors[patchID];
    float4 u_xlat0;
    float4 u_xlat1;
    float4 u_xlat2;
    float4 u_xlat3;
    float2 u_xlat9;
    float u_xlat12;
    float u_xlat13;
    u_xlat0 = mtl_TessCoord.yyyy * input.cp[1].INTERNALTESSPOS0;
    u_xlat0 = fma(input.cp[0].INTERNALTESSPOS0, mtl_TessCoord.xxxx, u_xlat0);
    u_xlat0 = fma(input.cp[2].INTERNALTESSPOS0, mtl_TessCoord.zzzz, u_xlat0);
    u_xlat1.xy = mtl_TessCoord.yy * input.cp[1].TEXCOORD0.xy;
    u_xlat1.xy = fma(input.cp[0].TEXCOORD0.xy, mtl_TessCoord.xx, u_xlat1.xy);
    u_xlat1.xy = fma(input.cp[2].TEXCOORD0.xy, mtl_TessCoord.zz, u_xlat1.xy);
    u_xlat9.xy = u_xlat1.xy * float2(VGlobals._Tile);
    output.TEXCOORD0.xy = fma(u_xlat1.xy, VGlobals._texcoord_ST.xy, VGlobals._texcoord_ST.zw);
    u_xlat1.xyz = _Height.sample(sampler_Height, u_xlat9.xy, level(1.0)).xyz;
    u_xlat2.xyz = mtl_TessCoord.yyy * input.cp[1].NORMAL0.xyz;
    u_xlat2.xyz = fma(input.cp[0].NORMAL0.xyz, mtl_TessCoord.xxx, u_xlat2.xyz);
    u_xlat2.xyz = fma(input.cp[2].NORMAL0.xyz, mtl_TessCoord.zzz, u_xlat2.xyz);
    u_xlat1.xyz = u_xlat1.xyz * u_xlat2.xyz;
    u_xlat0.xyz = fma(u_xlat1.xyz, float3(VGlobals._HeightDisplacement), u_xlat0.xyz);
    u_xlat1 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], u_xlat0.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], u_xlat0.zzzz, u_xlat1);
    u_xlat3 = u_xlat1 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, u_xlat0.www, u_xlat1.xyz);
    u_xlat1 = u_xlat3.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat3.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat3.zzzz, u_xlat1);
    output.mtl_Position = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat3.wwww, u_xlat1);
    u_xlat1.y = dot(u_xlat2.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat1.z = dot(u_xlat2.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat1.x = dot(u_xlat2.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat12 = dot(u_xlat1.xyz, u_xlat1.xyz);
    u_xlat12 = rsqrt(u_xlat12);
    u_xlat1.xyz = float3(u_xlat12) * u_xlat1.xyz;
    output.TEXCOORD1.z = u_xlat1.y;
    u_xlat2 = mtl_TessCoord.yyyy * input.cp[1].TANGENT0;
    u_xlat2 = fma(input.cp[0].TANGENT0, mtl_TessCoord.xxxx, u_xlat2);
    u_xlat2 = fma(input.cp[2].TANGENT0, mtl_TessCoord.zzzz, u_xlat2);
    u_xlat3.xyz = u_xlat2.yyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].yzx;
    u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].yzx, u_xlat2.xxx, u_xlat3.xyz);
    u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].yzx, u_xlat2.zzz, u_xlat3.xyz);
    u_xlat12 = u_xlat2.w * VGlobals.unity_WorldTransformParams.w;
    u_xlat13 = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat13 = rsqrt(u_xlat13);
    u_xlat2.xyz = float3(u_xlat13) * u_xlat2.xyz;
    u_xlat3.xyz = u_xlat1.xyz * u_xlat2.xyz;
    u_xlat3.xyz = fma(u_xlat1.zxy, u_xlat2.yzx, (-u_xlat3.xyz));
    u_xlat3.xyz = float3(u_xlat12) * u_xlat3.xyz;
    output.TEXCOORD1.y = u_xlat3.x;
    output.TEXCOORD1.w = u_xlat0.x;
    output.TEXCOORD1.x = u_xlat2.z;
    output.TEXCOORD2.w = u_xlat0.y;
    output.TEXCOORD3.w = u_xlat0.z;
    output.TEXCOORD2.x = u_xlat2.x;
    output.TEXCOORD3.x = u_xlat2.y;
    output.TEXCOORD2.z = u_xlat1.z;
    output.TEXCOORD3.z = u_xlat1.x;
    output.TEXCOORD2.y = u_xlat3.y;
    output.TEXCOORD3.y = u_xlat3.z;
    output.TEXCOORD5 = float4(0.0, 0.0, 0.0, 0.0);
    return output;
}
// SHADER_STAGE_DOMAIN_end
Compilation succeeded with: 

program_source:303:53: warning: writable resources in non-void post-tessellation vertex function
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
                                                    ^
program_source:309:30: note: writable buffer defined here
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
                             ^
program_source:310:48: note: writable buffer defined here
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
                                               ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float4 TEXCOORD0 [[ attribute(3) ]] ;
    float4 TEXCOORD1 [[ attribute(4) ]] ;
    float4 TEXCOORD2 [[ attribute(5) ]] ;
    float4 TEXCOORD3 [[ attribute(6) ]] ;
    float4 COLOR0 [[ attribute(7) ]] ;
};
struct Mtl_VertexOut
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float4 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float4 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float4 TEXCOORD3 [[ user(TEXCOORD3) ]];
    float4 COLOR0 [[ user(COLOR0) ]];
};
static Mtl_VertexOut vertexFunction(
    Mtl_VertexIn input)
{
    Mtl_VertexOut output;
    output.INTERNALTESSPOS0 = input.POSITION0;
    output.TANGENT0 = input.TANGENT0;
    output.NORMAL0.xyz = input.NORMAL0.xyz;
    output.TEXCOORD0 = input.TEXCOORD0;
    output.TEXCOORD1 = input.TEXCOORD1;
    output.TEXCOORD2 = input.TEXCOORD2;
    output.TEXCOORD3 = input.TEXCOORD3;
    output.COLOR0 = input.COLOR0;
    return output;
}
// SHADER_STAGE_HULL_begin
struct Mtl_ControlPoint
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float4 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float4 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float4 TEXCOORD3 [[ user(TEXCOORD3) ]];
    float4 COLOR0 [[ user(COLOR0) ]];
};
struct Mtl_ControlPointIn
{
    float4 INTERNALTESSPOS0 [[ attribute(8) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float4 TEXCOORD0 [[ attribute(3) ]] ;
    float4 TEXCOORD1 [[ attribute(4) ]] ;
    float4 TEXCOORD2 [[ attribute(5) ]] ;
    float4 TEXCOORD3 [[ attribute(6) ]] ;
    float4 COLOR0 [[ attribute(7) ]] ;
};
struct Mtl_KernelPatchInfo
{
    uint numPatches;
    ushort numControlPointsPerPatch;
};
struct VGlobals_Type
{
    float4 _Time;
    float4 _SinTime;
    float4 _CosTime;
    float4 unity_DeltaTime;
    float3 _WorldSpaceCameraPos;
    float4 _ProjectionParams;
    float4 _ScreenParams;
    float4 _ZBufferParams;
    float4 unity_OrthoParams;
    float4 unity_CameraWorldClipPlanes[6];
    float4 hlslcc_mtx4x4unity_CameraProjection[4];
    float4 hlslcc_mtx4x4unity_CameraInvProjection[4];
    float4 hlslcc_mtx4x4unity_WorldToCamera[4];
    float4 hlslcc_mtx4x4unity_CameraToWorld[4];
    float4 _WorldSpaceLightPos0;
    float4 _LightPositionRange;
    float4 _LightProjectionParams;
    float4 unity_4LightPosX0;
    float4 unity_4LightPosY0;
    float4 unity_4LightPosZ0;
    float4 unity_4LightAtten0;
    float4 unity_LightColor[8];
    float4 unity_LightPosition[8];
    float4 unity_LightAtten[8];
    float4 unity_SpotDirection[8];
    float4 unity_SHAr;
    float4 unity_SHAg;
    float4 unity_SHAb;
    float4 unity_SHBr;
    float4 unity_SHBg;
    float4 unity_SHBb;
    float4 unity_SHC;
    float4 unity_OcclusionMaskSelector;
    float4 unity_ProbesOcclusion;
    float3 unity_LightColor0;
    float3 unity_LightColor1;
    float3 unity_LightColor2;
    float3 unity_LightColor3;
    float4 unity_ShadowSplitSpheres[4];
    float4 unity_ShadowSplitSqRadii;
    float4 unity_LightShadowBias;
    float4 _LightSplitsNear;
    float4 _LightSplitsFar;
    float4 hlslcc_mtx4x4unity_WorldToShadow[16];
    float4 _LightShadowData;
    float4 unity_ShadowFadeCenterAndType;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 unity_LODFade;
    float4 unity_WorldTransformParams;
    float4 unity_RenderingLayer;
    float4 hlslcc_mtx4x4glstate_matrix_transpose_modelview0[4];
    float4 glstate_lightmodel_ambient;
    float4 unity_AmbientSky;
    float4 unity_AmbientEquator;
    float4 unity_AmbientGround;
    float4 unity_IndirectSpecColor;
    float4 hlslcc_mtx4x4glstate_matrix_projection[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixInvV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    int unity_StereoEyeIndex;
    float4 unity_ShadowColor;
    float4 unity_FogColor;
    float4 unity_FogParams;
    float4 unity_LightmapST;
    float4 unity_DynamicLightmapST;
    float4 unity_SpecCube0_BoxMax;
    float4 unity_SpecCube0_BoxMin;
    float4 unity_SpecCube0_ProbePosition;
    float4 unity_SpecCube0_HDR;
    float4 unity_SpecCube1_BoxMax;
    float4 unity_SpecCube1_BoxMin;
    float4 unity_SpecCube1_ProbePosition;
    float4 unity_SpecCube1_HDR;
    float4 unity_ProbeVolumeParams;
    float4 hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[4];
    float3 unity_ProbeVolumeSizeInv;
    float3 unity_ProbeVolumeMin;
    float4 unity_Lightmap_HDR;
    float4 unity_DynamicLightmap_HDR;
    float4 _LightColor0;
    float4 _SpecColor;
    float _Tile;
    float _HeightDisplacement;
    float _NormalScale;
    float4 _ColorTint;
    float _MetallicStrength;
    float _SmoothnessStrength;
    float _EdgeLength;
    bool4 unity_MetaVertexControl;
    bool4 unity_MetaFragmentControl;
    int unity_VisualizationMode;
    float unity_OneOverOutputBoost;
    float unity_MaxOutputValue;
    float unity_UseLinearSpace;
    float4 _texcoord_ST;
};
struct Mtl_HullIn
{
    Mtl_VertexOut cp[3];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
kernel void patchKernel(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn vertexInput [[ stage_in ]],
    uint2 tID [[ thread_position_in_grid ]],
    ushort2 groupID [[ threadgroup_position_in_grid ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    constant Mtl_KernelPatchInfo &patchInfo [[ buffer(3) ]])
{
#pragma clang diagnostic pop
    Mtl_ControlPoint output;
    const uint numPatchesInThreadGroup = 10;
    const uint patchID = (tID.x / patchInfo.numControlPointsPerPatch);
    const bool patchValid = (patchID < patchInfo.numPatches);
    const uint mtl_BaseInstance = 0;
    const uint mtl_InstanceID = groupID.y - mtl_BaseInstance;
    const uint internalPatchID = mtl_InstanceID * patchInfo.numPatches + patchID;
    const uint patchIDInThreadGroup = (patchID % numPatchesInThreadGroup);
    const uint controlPointID = (tID.x % patchInfo.numControlPointsPerPatch);
    const uint mtl_BaseVertex = 0;
    const uint mtl_VertexID = ((mtl_InstanceID * (patchInfo.numControlPointsPerPatch * patchInfo.numPatches)) + tID.x) - mtl_BaseVertex;
    threadgroup Mtl_HullIn inputGroup[numPatchesInThreadGroup];
    threadgroup Mtl_HullIn &input = inputGroup[patchIDInThreadGroup];
    MTLTriangleTessellationFactorsHalf tessFactor;
    if (patchValid) {
        input.cp[controlPointID] = vertexFunction(vertexInput);
        output.INTERNALTESSPOS0 = input.cp[controlPointID].INTERNALTESSPOS0;
        output.TANGENT0 = input.cp[controlPointID].TANGENT0;
        output.NORMAL0 = input.cp[controlPointID].NORMAL0;
        output.TEXCOORD0 = input.cp[controlPointID].TEXCOORD0;
        output.TEXCOORD1 = input.cp[controlPointID].TEXCOORD1;
        output.TEXCOORD2 = input.cp[controlPointID].TEXCOORD2;
        output.TEXCOORD3 = input.cp[controlPointID].TEXCOORD3;
        output.COLOR0 = input.cp[controlPointID].COLOR0;
    }
    threadgroup_barrier(mem_flags::mem_threadgroup);
    if (!patchValid) {
        return;
    }
    float3 u_xlat0;
    float3 u_xlat1;
    float3 u_xlat2;
    float3 u_xlat3;
    float3 u_xlat4;
    float u_xlat12;
    float u_xlat13;
    // fork_phase2
    {
        u_xlat0.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[1].INTERNALTESSPOS0.yyy;
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[1].INTERNALTESSPOS0.xxx, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[1].INTERNALTESSPOS0.zzz, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[1].INTERNALTESSPOS0.www, u_xlat0.xyz);
        u_xlat1.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[2].INTERNALTESSPOS0.yyy;
        u_xlat1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[2].INTERNALTESSPOS0.xxx, u_xlat1.xyz);
        u_xlat1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[2].INTERNALTESSPOS0.zzz, u_xlat1.xyz);
        u_xlat1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[2].INTERNALTESSPOS0.www, u_xlat1.xyz);
        u_xlat2.xyz = u_xlat0.xyz + u_xlat1.xyz;
        u_xlat2.xyz = fma(u_xlat2.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat12 = dot(u_xlat2.xyz, u_xlat2.xyz);
        u_xlat12 = sqrt(u_xlat12);
        u_xlat12 = u_xlat12 * VGlobals._EdgeLength;
        u_xlat2.xyz = u_xlat0.xyz + (-u_xlat1.xyz);
        u_xlat13 = dot(u_xlat2.xyz, u_xlat2.xyz);
        u_xlat13 = sqrt(u_xlat13);
        u_xlat13 = u_xlat13 * VGlobals._ScreenParams.y;
        u_xlat12 = u_xlat13 / u_xlat12;
        tessFactor.edgeTessellationFactor[0] = max(u_xlat12, 1.0);
        u_xlat2.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[0].INTERNALTESSPOS0.yyy;
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[0].INTERNALTESSPOS0.xxx, u_xlat2.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[0].INTERNALTESSPOS0.zzz, u_xlat2.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[0].INTERNALTESSPOS0.www, u_xlat2.xyz);
        u_xlat3.xyz = u_xlat1.xyz + u_xlat2.xyz;
        u_xlat1.xyz = u_xlat1.xyz + (-u_xlat2.xyz);
        u_xlat12 = dot(u_xlat1.xyz, u_xlat1.xyz);
        u_xlat12 = sqrt(u_xlat12);
        u_xlat12 = u_xlat12 * VGlobals._ScreenParams.y;
        u_xlat1.xyz = fma(u_xlat3.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat1.x = dot(u_xlat1.xyz, u_xlat1.xyz);
        u_xlat1.x = sqrt(u_xlat1.x);
        u_xlat1.x = u_xlat1.x * VGlobals._EdgeLength;
        u_xlat12 = u_xlat12 / u_xlat1.x;
        tessFactor.edgeTessellationFactor[1] = max(u_xlat12, 1.0);
        u_xlat1.xyz = u_xlat0.xyz + u_xlat2.xyz;
        u_xlat0.xyz = (-u_xlat0.xyz) + u_xlat2.xyz;
        u_xlat0.x = dot(u_xlat0.xyz, u_xlat0.xyz);
        u_xlat0.x = sqrt(u_xlat0.x);
        u_xlat0.x = u_xlat0.x * VGlobals._ScreenParams.y;
        u_xlat4.xyz = fma(u_xlat1.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat4.x = dot(u_xlat4.xyz, u_xlat4.xyz);
        u_xlat4.x = sqrt(u_xlat4.x);
        u_xlat4.x = u_xlat4.x * VGlobals._EdgeLength;
        u_xlat0.x = u_xlat0.x / u_xlat4.x;
        tessFactor.edgeTessellationFactor[2] = max(u_xlat0.x, 1.0);
    }
    // join_phase3
    {
        u_xlat0.x = tessFactor.edgeTessellationFactor[0] + tessFactor.edgeTessellationFactor[1];
        u_xlat0.x = u_xlat0.x + tessFactor.edgeTessellationFactor[2];
        tessFactor.insideTessellationFactor = u_xlat0.x * 0.333333343;
    }
    controlPoints[mtl_VertexID] = output;
    tessFactors[internalPatchID] = tessFactor;
}
// SHADER_STAGE_HULL_end
// SHADER_STAGE_DOMAIN_begin
struct Mtl_VertexInPostTess
{
    patch_control_point<Mtl_ControlPointIn> cp;
};
struct Mtl_VertexOutPostTess
{
    float4 mtl_Position [[ position ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float4 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float4 TEXCOORD3 [[ user(TEXCOORD3) ]];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    sampler sampler_Height [[ sampler (0) ]],
    texture2d<float, access::sample > _Height [[ texture(0) ]] ,
    float3 mtl_TessCoord [[ position_in_patch ]],
    uint patchID [[ patch_id ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    Mtl_VertexInPostTess input [[ stage_in ]])
{
#pragma clang diagnostic pop
    Mtl_VertexOutPostTess output;
    MTLTriangleTessellationFactorsHalf tessFactor;
    tessFactor = tessFactors[patchID];
    float4 u_xlat0;
    float4 u_xlat1;
    float4 u_xlat2;
    float3 u_xlat3;
    float3 u_xlat4;
    float2 u_xlat13;
    float u_xlat15;
    bool u_xlatb15;
    u_xlat0.xy = mtl_TessCoord.yy * input.cp[1].TEXCOORD2.xy;
    u_xlat0.xy = fma(input.cp[0].TEXCOORD2.xy, mtl_TessCoord.xx, u_xlat0.xy);
    u_xlat0.xy = fma(input.cp[2].TEXCOORD2.xy, mtl_TessCoord.zz, u_xlat0.xy);
    u_xlat0.xy = fma(u_xlat0.xy, VGlobals.unity_DynamicLightmapST.xy, VGlobals.unity_DynamicLightmapST.zw);
    u_xlat1.xy = mtl_TessCoord.yy * input.cp[1].TEXCOORD1.xy;
    u_xlat1.xy = fma(input.cp[0].TEXCOORD1.xy, mtl_TessCoord.xx, u_xlat1.xy);
    u_xlat1.xy = fma(input.cp[2].TEXCOORD1.xy, mtl_TessCoord.zz, u_xlat1.xy);
    u_xlat1.xy = fma(u_xlat1.xy, VGlobals.unity_LightmapST.xy, VGlobals.unity_LightmapST.zw);
    u_xlat2 = mtl_TessCoord.yyyy * input.cp[1].INTERNALTESSPOS0;
    u_xlat2 = fma(input.cp[0].INTERNALTESSPOS0, mtl_TessCoord.xxxx, u_xlat2);
    u_xlat2 = fma(input.cp[2].INTERNALTESSPOS0, mtl_TessCoord.zzzz, u_xlat2);
    u_xlat3.xy = mtl_TessCoord.yy * input.cp[1].TEXCOORD0.xy;
    u_xlat3.xy = fma(input.cp[0].TEXCOORD0.xy, mtl_TessCoord.xx, u_xlat3.xy);
    u_xlat3.xy = fma(input.cp[2].TEXCOORD0.xy, mtl_TessCoord.zz, u_xlat3.xy);
    u_xlat13.xy = u_xlat3.xy * float2(VGlobals._Tile);
    output.TEXCOORD0.xy = fma(u_xlat3.xy, VGlobals._texcoord_ST.xy, VGlobals._texcoord_ST.zw);
    u_xlat3.xyz = _Height.sample(sampler_Height, u_xlat13.xy, level(1.0)).xyz;
    u_xlat4.xyz = mtl_TessCoord.yyy * input.cp[1].NORMAL0.xyz;
    u_xlat4.xyz = fma(input.cp[0].NORMAL0.xyz, mtl_TessCoord.xxx, u_xlat4.xyz);
    u_xlat4.xyz = fma(input.cp[2].NORMAL0.xyz, mtl_TessCoord.zzz, u_xlat4.xyz);
    u_xlat3.xyz = u_xlat3.xyz * u_xlat4.xyz;
    u_xlat2.xyz = fma(u_xlat3.xyz, float3(VGlobals._HeightDisplacement), u_xlat2.xyz);
    u_xlatb15 = 0.0<u_xlat2.z;
    u_xlat1.z = u_xlatb15 ? 9.99999975e-05 : float(0.0);
    u_xlat1.xyz = (VGlobals.unity_MetaVertexControl.x) ? u_xlat1.xyz : u_xlat2.xyz;
    u_xlatb15 = 0.0<u_xlat1.z;
    u_xlat0.z = u_xlatb15 ? 9.99999975e-05 : float(0.0);
    u_xlat0.xyz = (VGlobals.unity_MetaVertexControl.y) ? u_xlat0.xyz : u_xlat1.xyz;
    u_xlat1 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat0.xxxx, u_xlat1);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat0.zzzz, u_xlat1);
    output.mtl_Position = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_MatrixVP[3];
    u_xlat0.xyz = u_xlat2.yyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz;
    u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, u_xlat2.xxx, u_xlat0.xyz);
    u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, u_xlat2.zzz, u_xlat0.xyz);
    u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, u_xlat2.www, u_xlat0.xyz);
    output.TEXCOORD1.w = u_xlat0.x;
    u_xlat1.y = dot(u_xlat4.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat1.z = dot(u_xlat4.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat1.x = dot(u_xlat4.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat0.x = dot(u_xlat1.xyz, u_xlat1.xyz);
    u_xlat0.x = rsqrt(u_xlat0.x);
    u_xlat1.xyz = u_xlat0.xxx * u_xlat1.xyz;
    output.TEXCOORD1.z = u_xlat1.y;
    u_xlat2 = mtl_TessCoord.yyyy * input.cp[1].TANGENT0;
    u_xlat2 = fma(input.cp[0].TANGENT0, mtl_TessCoord.xxxx, u_xlat2);
    u_xlat2 = fma(input.cp[2].TANGENT0, mtl_TessCoord.zzzz, u_xlat2);
    u_xlat3.xyz = u_xlat2.yyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].yzx;
    u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].yzx, u_xlat2.xxx, u_xlat3.xyz);
    u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].yzx, u_xlat2.zzz, u_xlat3.xyz);
    u_xlat0.x = u_xlat2.w * VGlobals.unity_WorldTransformParams.w;
    u_xlat15 = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat15 = rsqrt(u_xlat15);
    u_xlat2.xyz = float3(u_xlat15) * u_xlat2.xyz;
    u_xlat3.xyz = u_xlat1.xyz * u_xlat2.xyz;
    u_xlat3.xyz = fma(u_xlat1.zxy, u_xlat2.yzx, (-u_xlat3.xyz));
    u_xlat3.xyz = u_xlat0.xxx * u_xlat3.xyz;
    output.TEXCOORD1.y = u_xlat3.x;
    output.TEXCOORD1.x = u_xlat2.z;
    output.TEXCOORD2.w = u_xlat0.y;
    output.TEXCOORD3.w = u_xlat0.z;
    output.TEXCOORD2.x = u_xlat2.x;
    output.TEXCOORD3.x = u_xlat2.y;
    output.TEXCOORD2.z = u_xlat1.z;
    output.TEXCOORD3.z = u_xlat1.x;
    output.TEXCOORD2.y = u_xlat3.y;
    output.TEXCOORD3.y = u_xlat3.z;
    return output;
}
// SHADER_STAGE_DOMAIN_end
Refreshing native plugins compatible for Editor in 2.00 ms, found 2 plugins.
Preloading 0 native plugins for Editor in 0.00 ms.
Unloading 3375 Unused Serialized files (Serialized files now loaded: 0)
Unloading 20 unused Assets / (0.6 MB). Loaded Objects now: 3922.
Memory consumption went from 136.4 MB to 135.8 MB.
Total: 4.713136 ms (FindLiveObjects: 0.314417 ms CreateObjectMapping: 0.145767 ms MarkObjects: 3.724939 ms  DeleteObjects: 0.526473 ms)

AssetImportParameters requested are different than current active one (requested -> active):
  custom:video-decoder-ogg-theora: a1e56fd34408186e4bbccfd4996cb3dc -> 
  custom:container-muxer-webm: aa71ff27fc2769a1b78a27578f13a17b -> 
  custom:container-demuxer-webm: 4f35f7cbe854078d1ac9338744f61a02 -> 
  custom:video-encoder-webm-vp8: eb34c28f22e8b96e1ab97ce403110664 -> 
  custom:framework-osx-AVFoundation: b23960f63f64bdc6ff669e2cdcee2391 -> 
  custom:audio-encoder-webm-vorbis: bf7c407c2cedff20999df2af8eb42d56 -> 
  custom:container-demuxer-ogg: 62fdf1f143b41e24485cea50d1cbac27 -> 
  custom:video-decoder-webm-vp8: 9c59270c3fd7afecdb556c50c9e8de78 -> 
  custom:audio-decoder-ogg-vorbis: bf7c407c2cedff20999df2af8eb42d56 -> 
========================================================================
Received Prepare
Registering precompiled user dll's ...
Registered in 0.004243 seconds.
Begin MonoManager ReloadAssembly
Symbol file LoadedFromMemory doesn't match image /Users/kamilaamendolagine/Desktop/Staugen Raug v2 - Prefab - Map 1.01/Library/PackageCache/com.unity.visualscripting@1.7.8/Editor/VisualScripting.Core/Dependencies/YamlDotNet/Unity.VisualScripting.YamlDotNet.dll
Symbol file LoadedFromMemory doesn't match image /Users/kamilaamendolagine/Desktop/Staugen Raug v2 - Prefab - Map 1.01/Library/PackageCache/com.unity.visualscripting@1.7.8/Editor/VisualScripting.Core/Dependencies/DotNetZip/Unity.VisualScripting.IonicZip.dll
Native extension for OSXStandalone target not found
Native extension for WebGL target not found
Refreshing native plugins compatible for Editor in 0.87 ms, found 2 plugins.
Preloading 0 native plugins for Editor in 0.00 ms.
Mono: successfully reloaded assembly
- Completed reload, in  8.961 seconds
Domain Reload Profiling:
	ReloadAssembly (9005ms)
		BeginReloadAssembly (3223ms)
			ExecutionOrderSort (0ms)
			DisableScriptedObjects (15ms)
			BackupInstance (0ms)
			ReleaseScriptingObjects (0ms)
			CreateAndSetChildDomain (141ms)
		EndReloadAssembly (4981ms)
			LoadAssemblies (5856ms)
			RebuildTransferFunctionScriptingTraits (0ms)
			SetupTypeCache (701ms)
			ReleaseScriptCaches (2ms)
			RebuildScriptCaches (92ms)
			SetupLoadedEditorAssemblies (1101ms)
				LogAssemblyErrors (0ms)
				InitializePlatformSupportModulesInManaged (179ms)
				SetLoadedEditorAssemblies (1ms)
				RefreshPlugins (1ms)
				BeforeProcessingInitializeOnLoad (105ms)
				ProcessInitializeOnLoadAttributes (761ms)
				ProcessInitializeOnLoadMethodAttributes (51ms)
				AfterProcessingInitializeOnLoad (3ms)
				EditorAssembliesLoaded (0ms)
			ExecutionOrderSort2 (0ms)
			AwakeInstancesAfterBackupRestoration (8ms)
Platform modules already initialized, skipping
Compilation succeeded with: 

program_source:299:53: warning: writable resources in non-void post-tessellation vertex function
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
                                                    ^
program_source:305:30: note: writable buffer defined here
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
                             ^
program_source:306:48: note: writable buffer defined here
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
                                               ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float4 TEXCOORD0 [[ attribute(3) ]] ;
    float4 TEXCOORD1 [[ attribute(4) ]] ;
    float4 TEXCOORD2 [[ attribute(5) ]] ;
    float4 TEXCOORD3 [[ attribute(6) ]] ;
    float4 COLOR0 [[ attribute(7) ]] ;
};
struct Mtl_VertexOut
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float4 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float4 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float4 TEXCOORD3 [[ user(TEXCOORD3) ]];
    float4 COLOR0 [[ user(COLOR0) ]];
};
static Mtl_VertexOut vertexFunction(
    Mtl_VertexIn input)
{
    Mtl_VertexOut output;
    output.INTERNALTESSPOS0 = input.POSITION0;
    output.TANGENT0 = input.TANGENT0;
    output.NORMAL0.xyz = input.NORMAL0.xyz;
    output.TEXCOORD0 = input.TEXCOORD0;
    output.TEXCOORD1 = input.TEXCOORD1;
    output.TEXCOORD2 = input.TEXCOORD2;
    output.TEXCOORD3 = input.TEXCOORD3;
    output.COLOR0 = input.COLOR0;
    return output;
}
// SHADER_STAGE_HULL_begin
struct Mtl_ControlPoint
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float4 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float4 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float4 TEXCOORD3 [[ user(TEXCOORD3) ]];
    float4 COLOR0 [[ user(COLOR0) ]];
};
struct Mtl_ControlPointIn
{
    float4 INTERNALTESSPOS0 [[ attribute(8) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float4 TEXCOORD0 [[ attribute(3) ]] ;
    float4 TEXCOORD1 [[ attribute(4) ]] ;
    float4 TEXCOORD2 [[ attribute(5) ]] ;
    float4 TEXCOORD3 [[ attribute(6) ]] ;
    float4 COLOR0 [[ attribute(7) ]] ;
};
struct Mtl_KernelPatchInfo
{
    uint numPatches;
    ushort numControlPointsPerPatch;
};
struct VGlobals_Type
{
    float4 _Time;
    float4 _SinTime;
    float4 _CosTime;
    float4 unity_DeltaTime;
    float3 _WorldSpaceCameraPos;
    float4 _ProjectionParams;
    float4 _ScreenParams;
    float4 _ZBufferParams;
    float4 unity_OrthoParams;
    float4 unity_CameraWorldClipPlanes[6];
    float4 hlslcc_mtx4x4unity_CameraProjection[4];
    float4 hlslcc_mtx4x4unity_CameraInvProjection[4];
    float4 hlslcc_mtx4x4unity_WorldToCamera[4];
    float4 hlslcc_mtx4x4unity_CameraToWorld[4];
    float4 _WorldSpaceLightPos0;
    float4 _LightPositionRange;
    float4 _LightProjectionParams;
    float4 unity_4LightPosX0;
    float4 unity_4LightPosY0;
    float4 unity_4LightPosZ0;
    float4 unity_4LightAtten0;
    float4 unity_LightColor[8];
    float4 unity_LightPosition[8];
    float4 unity_LightAtten[8];
    float4 unity_SpotDirection[8];
    float4 unity_SHAr;
    float4 unity_SHAg;
    float4 unity_SHAb;
    float4 unity_SHBr;
    float4 unity_SHBg;
    float4 unity_SHBb;
    float4 unity_SHC;
    float4 unity_OcclusionMaskSelector;
    float4 unity_ProbesOcclusion;
    float3 unity_LightColor0;
    float3 unity_LightColor1;
    float3 unity_LightColor2;
    float3 unity_LightColor3;
    float4 unity_ShadowSplitSpheres[4];
    float4 unity_ShadowSplitSqRadii;
    float4 unity_LightShadowBias;
    float4 _LightSplitsNear;
    float4 _LightSplitsFar;
    float4 hlslcc_mtx4x4unity_WorldToShadow[16];
    float4 _LightShadowData;
    float4 unity_ShadowFadeCenterAndType;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 unity_LODFade;
    float4 unity_WorldTransformParams;
    float4 unity_RenderingLayer;
    float4 hlslcc_mtx4x4glstate_matrix_transpose_modelview0[4];
    float4 glstate_lightmodel_ambient;
    float4 unity_AmbientSky;
    float4 unity_AmbientEquator;
    float4 unity_AmbientGround;
    float4 unity_IndirectSpecColor;
    float4 hlslcc_mtx4x4glstate_matrix_projection[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixInvV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    int unity_StereoEyeIndex;
    float4 unity_ShadowColor;
    float4 unity_FogColor;
    float4 unity_FogParams;
    float4 unity_LightmapST;
    float4 unity_DynamicLightmapST;
    float4 unity_SpecCube0_BoxMax;
    float4 unity_SpecCube0_BoxMin;
    float4 unity_SpecCube0_ProbePosition;
    float4 unity_SpecCube0_HDR;
    float4 unity_SpecCube1_BoxMax;
    float4 unity_SpecCube1_BoxMin;
    float4 unity_SpecCube1_ProbePosition;
    float4 unity_SpecCube1_HDR;
    float4 unity_ProbeVolumeParams;
    float4 hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[4];
    float3 unity_ProbeVolumeSizeInv;
    float3 unity_ProbeVolumeMin;
    float4 unity_Lightmap_HDR;
    float4 unity_DynamicLightmap_HDR;
    float4 _LightColor0;
    float4 _SpecColor;
    float _Tile;
    float _HeightDisplacement;
    float _NormalScale;
    float4 _ColorTint;
    float _MetallicStrength;
    float _SmoothnessStrength;
    float _EdgeLength;
    float4 _texcoord_ST;
};
struct Mtl_HullIn
{
    Mtl_VertexOut cp[3];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
kernel void patchKernel(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn vertexInput [[ stage_in ]],
    uint2 tID [[ thread_position_in_grid ]],
    ushort2 groupID [[ threadgroup_position_in_grid ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    constant Mtl_KernelPatchInfo &patchInfo [[ buffer(3) ]])
{
#pragma clang diagnostic pop
    Mtl_ControlPoint output;
    const uint numPatchesInThreadGroup = 10;
    const uint patchID = (tID.x / patchInfo.numControlPointsPerPatch);
    const bool patchValid = (patchID < patchInfo.numPatches);
    const uint mtl_BaseInstance = 0;
    const uint mtl_InstanceID = groupID.y - mtl_BaseInstance;
    const uint internalPatchID = mtl_InstanceID * patchInfo.numPatches + patchID;
    const uint patchIDInThreadGroup = (patchID % numPatchesInThreadGroup);
    const uint controlPointID = (tID.x % patchInfo.numControlPointsPerPatch);
    const uint mtl_BaseVertex = 0;
    const uint mtl_VertexID = ((mtl_InstanceID * (patchInfo.numControlPointsPerPatch * patchInfo.numPatches)) + tID.x) - mtl_BaseVertex;
    threadgroup Mtl_HullIn inputGroup[numPatchesInThreadGroup];
    threadgroup Mtl_HullIn &input = inputGroup[patchIDInThreadGroup];
    MTLTriangleTessellationFactorsHalf tessFactor;
    if (patchValid) {
        input.cp[controlPointID] = vertexFunction(vertexInput);
        output.INTERNALTESSPOS0 = input.cp[controlPointID].INTERNALTESSPOS0;
        output.TANGENT0 = input.cp[controlPointID].TANGENT0;
        output.NORMAL0 = input.cp[controlPointID].NORMAL0;
        output.TEXCOORD0 = input.cp[controlPointID].TEXCOORD0;
        output.TEXCOORD1 = input.cp[controlPointID].TEXCOORD1;
        output.TEXCOORD2 = input.cp[controlPointID].TEXCOORD2;
        output.TEXCOORD3 = input.cp[controlPointID].TEXCOORD3;
        output.COLOR0 = input.cp[controlPointID].COLOR0;
    }
    threadgroup_barrier(mem_flags::mem_threadgroup);
    if (!patchValid) {
        return;
    }
    float3 u_xlat0;
    float3 u_xlat1;
    float3 u_xlat2;
    float3 u_xlat3;
    float3 u_xlat4;
    float u_xlat12;
    float u_xlat13;
    // fork_phase2
    {
        u_xlat0.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[1].INTERNALTESSPOS0.yyy;
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[1].INTERNALTESSPOS0.xxx, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[1].INTERNALTESSPOS0.zzz, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[1].INTERNALTESSPOS0.www, u_xlat0.xyz);
        u_xlat1.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[2].INTERNALTESSPOS0.yyy;
        u_xlat1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[2].INTERNALTESSPOS0.xxx, u_xlat1.xyz);
        u_xlat1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[2].INTERNALTESSPOS0.zzz, u_xlat1.xyz);
        u_xlat1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[2].INTERNALTESSPOS0.www, u_xlat1.xyz);
        u_xlat2.xyz = u_xlat0.xyz + u_xlat1.xyz;
        u_xlat2.xyz = fma(u_xlat2.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat12 = dot(u_xlat2.xyz, u_xlat2.xyz);
        u_xlat12 = sqrt(u_xlat12);
        u_xlat12 = u_xlat12 * VGlobals._EdgeLength;
        u_xlat2.xyz = u_xlat0.xyz + (-u_xlat1.xyz);
        u_xlat13 = dot(u_xlat2.xyz, u_xlat2.xyz);
        u_xlat13 = sqrt(u_xlat13);
        u_xlat13 = u_xlat13 * VGlobals._ScreenParams.y;
        u_xlat12 = u_xlat13 / u_xlat12;
        tessFactor.edgeTessellationFactor[0] = max(u_xlat12, 1.0);
        u_xlat2.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[0].INTERNALTESSPOS0.yyy;
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[0].INTERNALTESSPOS0.xxx, u_xlat2.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[0].INTERNALTESSPOS0.zzz, u_xlat2.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[0].INTERNALTESSPOS0.www, u_xlat2.xyz);
        u_xlat3.xyz = u_xlat1.xyz + u_xlat2.xyz;
        u_xlat1.xyz = u_xlat1.xyz + (-u_xlat2.xyz);
        u_xlat12 = dot(u_xlat1.xyz, u_xlat1.xyz);
        u_xlat12 = sqrt(u_xlat12);
        u_xlat12 = u_xlat12 * VGlobals._ScreenParams.y;
        u_xlat1.xyz = fma(u_xlat3.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat1.x = dot(u_xlat1.xyz, u_xlat1.xyz);
        u_xlat1.x = sqrt(u_xlat1.x);
        u_xlat1.x = u_xlat1.x * VGlobals._EdgeLength;
        u_xlat12 = u_xlat12 / u_xlat1.x;
        tessFactor.edgeTessellationFactor[1] = max(u_xlat12, 1.0);
        u_xlat1.xyz = u_xlat0.xyz + u_xlat2.xyz;
        u_xlat0.xyz = (-u_xlat0.xyz) + u_xlat2.xyz;
        u_xlat0.x = dot(u_xlat0.xyz, u_xlat0.xyz);
        u_xlat0.x = sqrt(u_xlat0.x);
        u_xlat0.x = u_xlat0.x * VGlobals._ScreenParams.y;
        u_xlat4.xyz = fma(u_xlat1.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat4.x = dot(u_xlat4.xyz, u_xlat4.xyz);
        u_xlat4.x = sqrt(u_xlat4.x);
        u_xlat4.x = u_xlat4.x * VGlobals._EdgeLength;
        u_xlat0.x = u_xlat0.x / u_xlat4.x;
        tessFactor.edgeTessellationFactor[2] = max(u_xlat0.x, 1.0);
    }
    // join_phase3
    {
        u_xlat0.x = tessFactor.edgeTessellationFactor[0] + tessFactor.edgeTessellationFactor[1];
        u_xlat0.x = u_xlat0.x + tessFactor.edgeTessellationFactor[2];
        tessFactor.insideTessellationFactor = u_xlat0.x * 0.333333343;
    }
    controlPoints[mtl_VertexID] = output;
    tessFactors[internalPatchID] = tessFactor;
}
// SHADER_STAGE_HULL_end
// SHADER_STAGE_DOMAIN_begin
struct Mtl_VertexInPostTess
{
    patch_control_point<Mtl_ControlPointIn> cp;
};
struct Mtl_VertexOutPostTess
{
    float4 mtl_Position [[ position ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float4 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float4 TEXCOORD3 [[ user(TEXCOORD3) ]];
    float4 TEXCOORD6 [[ user(TEXCOORD6) ]];
    float4 TEXCOORD7 [[ user(TEXCOORD7) ]];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    sampler sampler_Height [[ sampler (0) ]],
    texture2d<float, access::sample > _Height [[ texture(0) ]] ,
    float3 mtl_TessCoord [[ position_in_patch ]],
    uint patchID [[ patch_id ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    Mtl_VertexInPostTess input [[ stage_in ]])
{
#pragma clang diagnostic pop
    Mtl_VertexOutPostTess output;
    MTLTriangleTessellationFactorsHalf tessFactor;
    tessFactor = tessFactors[patchID];
    float4 u_xlat0;
    float4 u_xlat1;
    float4 u_xlat2;
    float4 u_xlat3;
    float2 u_xlat9;
    float u_xlat12;
    float u_xlat13;
    u_xlat0 = mtl_TessCoord.yyyy * input.cp[1].INTERNALTESSPOS0;
    u_xlat0 = fma(input.cp[0].INTERNALTESSPOS0, mtl_TessCoord.xxxx, u_xlat0);
    u_xlat0 = fma(input.cp[2].INTERNALTESSPOS0, mtl_TessCoord.zzzz, u_xlat0);
    u_xlat1.xy = mtl_TessCoord.yy * input.cp[1].TEXCOORD0.xy;
    u_xlat1.xy = fma(input.cp[0].TEXCOORD0.xy, mtl_TessCoord.xx, u_xlat1.xy);
    u_xlat1.xy = fma(input.cp[2].TEXCOORD0.xy, mtl_TessCoord.zz, u_xlat1.xy);
    u_xlat9.xy = u_xlat1.xy * float2(VGlobals._Tile);
    output.TEXCOORD0.xy = fma(u_xlat1.xy, VGlobals._texcoord_ST.xy, VGlobals._texcoord_ST.zw);
    u_xlat1.xyz = _Height.sample(sampler_Height, u_xlat9.xy, level(1.0)).xyz;
    u_xlat2.xyz = mtl_TessCoord.yyy * input.cp[1].NORMAL0.xyz;
    u_xlat2.xyz = fma(input.cp[0].NORMAL0.xyz, mtl_TessCoord.xxx, u_xlat2.xyz);
    u_xlat2.xyz = fma(input.cp[2].NORMAL0.xyz, mtl_TessCoord.zzz, u_xlat2.xyz);
    u_xlat1.xyz = u_xlat1.xyz * u_xlat2.xyz;
    u_xlat0.xyz = fma(u_xlat1.xyz, float3(VGlobals._HeightDisplacement), u_xlat0.xyz);
    u_xlat1 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], u_xlat0.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], u_xlat0.zzzz, u_xlat1);
    u_xlat3 = u_xlat1 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, u_xlat0.www, u_xlat1.xyz);
    u_xlat1 = u_xlat3.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat3.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat3.zzzz, u_xlat1);
    output.mtl_Position = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat3.wwww, u_xlat1);
    u_xlat1.y = dot(u_xlat2.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat1.z = dot(u_xlat2.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat1.x = dot(u_xlat2.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat12 = dot(u_xlat1.xyz, u_xlat1.xyz);
    u_xlat12 = rsqrt(u_xlat12);
    u_xlat1.xyz = float3(u_xlat12) * u_xlat1.xyz;
    output.TEXCOORD1.z = u_xlat1.y;
    u_xlat2 = mtl_TessCoord.yyyy * input.cp[1].TANGENT0;
    u_xlat2 = fma(input.cp[0].TANGENT0, mtl_TessCoord.xxxx, u_xlat2);
    u_xlat2 = fma(input.cp[2].TANGENT0, mtl_TessCoord.zzzz, u_xlat2);
    u_xlat3.xyz = u_xlat2.yyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].yzx;
    u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].yzx, u_xlat2.xxx, u_xlat3.xyz);
    u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].yzx, u_xlat2.zzz, u_xlat3.xyz);
    u_xlat12 = u_xlat2.w * VGlobals.unity_WorldTransformParams.w;
    u_xlat13 = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat13 = rsqrt(u_xlat13);
    u_xlat2.xyz = float3(u_xlat13) * u_xlat2.xyz;
    u_xlat3.xyz = u_xlat1.xyz * u_xlat2.xyz;
    u_xlat3.xyz = fma(u_xlat1.zxy, u_xlat2.yzx, (-u_xlat3.xyz));
    u_xlat3.xyz = float3(u_xlat12) * u_xlat3.xyz;
    output.TEXCOORD1.y = u_xlat3.x;
    output.TEXCOORD1.w = u_xlat0.x;
    output.TEXCOORD1.x = u_xlat2.z;
    output.TEXCOORD2.w = u_xlat0.y;
    output.TEXCOORD3.w = u_xlat0.z;
    output.TEXCOORD2.x = u_xlat2.x;
    output.TEXCOORD3.x = u_xlat2.y;
    output.TEXCOORD2.z = u_xlat1.z;
    output.TEXCOORD3.z = u_xlat1.x;
    output.TEXCOORD2.y = u_xlat3.y;
    output.TEXCOORD3.y = u_xlat3.z;
    output.TEXCOORD6 = float4(0.0, 0.0, 0.0, 0.0);
    output.TEXCOORD7 = float4(0.0, 0.0, 0.0, 0.0);
    return output;
}
// SHADER_STAGE_DOMAIN_end
Compilation succeeded with: 

program_source:301:53: warning: writable resources in non-void post-tessellation vertex function
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
                                                    ^
program_source:307:30: note: writable buffer defined here
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
                             ^
program_source:308:48: note: writable buffer defined here
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
                                               ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float4 TEXCOORD0 [[ attribute(3) ]] ;
    float4 TEXCOORD1 [[ attribute(4) ]] ;
    float4 TEXCOORD2 [[ attribute(5) ]] ;
    float4 TEXCOORD3 [[ attribute(6) ]] ;
    float4 COLOR0 [[ attribute(7) ]] ;
};
struct Mtl_VertexOut
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float4 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float4 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float4 TEXCOORD3 [[ user(TEXCOORD3) ]];
    float4 COLOR0 [[ user(COLOR0) ]];
};
static Mtl_VertexOut vertexFunction(
    Mtl_VertexIn input)
{
    Mtl_VertexOut output;
    output.INTERNALTESSPOS0 = input.POSITION0;
    output.TANGENT0 = input.TANGENT0;
    output.NORMAL0.xyz = input.NORMAL0.xyz;
    output.TEXCOORD0 = input.TEXCOORD0;
    output.TEXCOORD1 = input.TEXCOORD1;
    output.TEXCOORD2 = input.TEXCOORD2;
    output.TEXCOORD3 = input.TEXCOORD3;
    output.COLOR0 = input.COLOR0;
    return output;
}
// SHADER_STAGE_HULL_begin
struct Mtl_ControlPoint
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float4 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float4 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float4 TEXCOORD3 [[ user(TEXCOORD3) ]];
    float4 COLOR0 [[ user(COLOR0) ]];
};
struct Mtl_ControlPointIn
{
    float4 INTERNALTESSPOS0 [[ attribute(8) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float4 TEXCOORD0 [[ attribute(3) ]] ;
    float4 TEXCOORD1 [[ attribute(4) ]] ;
    float4 TEXCOORD2 [[ attribute(5) ]] ;
    float4 TEXCOORD3 [[ attribute(6) ]] ;
    float4 COLOR0 [[ attribute(7) ]] ;
};
struct Mtl_KernelPatchInfo
{
    uint numPatches;
    ushort numControlPointsPerPatch;
};
struct VGlobals_Type
{
    float4 _Time;
    float4 _SinTime;
    float4 _CosTime;
    float4 unity_DeltaTime;
    float3 _WorldSpaceCameraPos;
    float4 _ProjectionParams;
    float4 _ScreenParams;
    float4 _ZBufferParams;
    float4 unity_OrthoParams;
    float4 unity_CameraWorldClipPlanes[6];
    float4 hlslcc_mtx4x4unity_CameraProjection[4];
    float4 hlslcc_mtx4x4unity_CameraInvProjection[4];
    float4 hlslcc_mtx4x4unity_WorldToCamera[4];
    float4 hlslcc_mtx4x4unity_CameraToWorld[4];
    float4 _WorldSpaceLightPos0;
    float4 _LightPositionRange;
    float4 _LightProjectionParams;
    float4 unity_4LightPosX0;
    float4 unity_4LightPosY0;
    float4 unity_4LightPosZ0;
    float4 unity_4LightAtten0;
    float4 unity_LightColor[8];
    float4 unity_LightPosition[8];
    float4 unity_LightAtten[8];
    float4 unity_SpotDirection[8];
    float4 unity_SHAr;
    float4 unity_SHAg;
    float4 unity_SHAb;
    float4 unity_SHBr;
    float4 unity_SHBg;
    float4 unity_SHBb;
    float4 unity_SHC;
    float4 unity_OcclusionMaskSelector;
    float4 unity_ProbesOcclusion;
    float3 unity_LightColor0;
    float3 unity_LightColor1;
    float3 unity_LightColor2;
    float3 unity_LightColor3;
    float4 unity_ShadowSplitSpheres[4];
    float4 unity_ShadowSplitSqRadii;
    float4 unity_LightShadowBias;
    float4 _LightSplitsNear;
    float4 _LightSplitsFar;
    float4 hlslcc_mtx4x4unity_WorldToShadow[16];
    float4 _LightShadowData;
    float4 unity_ShadowFadeCenterAndType;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 unity_LODFade;
    float4 unity_WorldTransformParams;
    float4 unity_RenderingLayer;
    float4 hlslcc_mtx4x4glstate_matrix_transpose_modelview0[4];
    float4 glstate_lightmodel_ambient;
    float4 unity_AmbientSky;
    float4 unity_AmbientEquator;
    float4 unity_AmbientGround;
    float4 unity_IndirectSpecColor;
    float4 hlslcc_mtx4x4glstate_matrix_projection[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixInvV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    int unity_StereoEyeIndex;
    float4 unity_ShadowColor;
    float4 unity_FogColor;
    float4 unity_FogParams;
    float4 unity_LightmapST;
    float4 unity_DynamicLightmapST;
    float4 unity_SpecCube0_BoxMax;
    float4 unity_SpecCube0_BoxMin;
    float4 unity_SpecCube0_ProbePosition;
    float4 unity_SpecCube0_HDR;
    float4 unity_SpecCube1_BoxMax;
    float4 unity_SpecCube1_BoxMin;
    float4 unity_SpecCube1_ProbePosition;
    float4 unity_SpecCube1_HDR;
    float4 unity_ProbeVolumeParams;
    float4 hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[4];
    float3 unity_ProbeVolumeSizeInv;
    float3 unity_ProbeVolumeMin;
    float4 unity_Lightmap_HDR;
    float4 unity_DynamicLightmap_HDR;
    float4 _LightColor0;
    float4 _SpecColor;
    float4 hlslcc_mtx4x4unity_WorldToLight[4];
    float _Tile;
    float _HeightDisplacement;
    float _NormalScale;
    float4 _ColorTint;
    float _MetallicStrength;
    float _SmoothnessStrength;
    float _EdgeLength;
    float4 _texcoord_ST;
};
struct Mtl_HullIn
{
    Mtl_VertexOut cp[3];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
kernel void patchKernel(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn vertexInput [[ stage_in ]],
    uint2 tID [[ thread_position_in_grid ]],
    ushort2 groupID [[ threadgroup_position_in_grid ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    constant Mtl_KernelPatchInfo &patchInfo [[ buffer(3) ]])
{
#pragma clang diagnostic pop
    Mtl_ControlPoint output;
    const uint numPatchesInThreadGroup = 10;
    const uint patchID = (tID.x / patchInfo.numControlPointsPerPatch);
    const bool patchValid = (patchID < patchInfo.numPatches);
    const uint mtl_BaseInstance = 0;
    const uint mtl_InstanceID = groupID.y - mtl_BaseInstance;
    const uint internalPatchID = mtl_InstanceID * patchInfo.numPatches + patchID;
    const uint patchIDInThreadGroup = (patchID % numPatchesInThreadGroup);
    const uint controlPointID = (tID.x % patchInfo.numControlPointsPerPatch);
    const uint mtl_BaseVertex = 0;
    const uint mtl_VertexID = ((mtl_InstanceID * (patchInfo.numControlPointsPerPatch * patchInfo.numPatches)) + tID.x) - mtl_BaseVertex;
    threadgroup Mtl_HullIn inputGroup[numPatchesInThreadGroup];
    threadgroup Mtl_HullIn &input = inputGroup[patchIDInThreadGroup];
    MTLTriangleTessellationFactorsHalf tessFactor;
    if (patchValid) {
        input.cp[controlPointID] = vertexFunction(vertexInput);
        output.INTERNALTESSPOS0 = input.cp[controlPointID].INTERNALTESSPOS0;
        output.TANGENT0 = input.cp[controlPointID].TANGENT0;
        output.NORMAL0 = input.cp[controlPointID].NORMAL0;
        output.TEXCOORD0 = input.cp[controlPointID].TEXCOORD0;
        output.TEXCOORD1 = input.cp[controlPointID].TEXCOORD1;
        output.TEXCOORD2 = input.cp[controlPointID].TEXCOORD2;
        output.TEXCOORD3 = input.cp[controlPointID].TEXCOORD3;
        output.COLOR0 = input.cp[controlPointID].COLOR0;
    }
    threadgroup_barrier(mem_flags::mem_threadgroup);
    if (!patchValid) {
        return;
    }
    float3 u_xlat0;
    float3 u_xlat1;
    float3 u_xlat2;
    float3 u_xlat3;
    float3 u_xlat4;
    float u_xlat12;
    float u_xlat13;
    // fork_phase2
    {
        u_xlat0.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[1].INTERNALTESSPOS0.yyy;
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[1].INTERNALTESSPOS0.xxx, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[1].INTERNALTESSPOS0.zzz, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[1].INTERNALTESSPOS0.www, u_xlat0.xyz);
        u_xlat1.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[2].INTERNALTESSPOS0.yyy;
        u_xlat1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[2].INTERNALTESSPOS0.xxx, u_xlat1.xyz);
        u_xlat1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[2].INTERNALTESSPOS0.zzz, u_xlat1.xyz);
        u_xlat1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[2].INTERNALTESSPOS0.www, u_xlat1.xyz);
        u_xlat2.xyz = u_xlat0.xyz + u_xlat1.xyz;
        u_xlat2.xyz = fma(u_xlat2.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat12 = dot(u_xlat2.xyz, u_xlat2.xyz);
        u_xlat12 = sqrt(u_xlat12);
        u_xlat12 = u_xlat12 * VGlobals._EdgeLength;
        u_xlat2.xyz = u_xlat0.xyz + (-u_xlat1.xyz);
        u_xlat13 = dot(u_xlat2.xyz, u_xlat2.xyz);
        u_xlat13 = sqrt(u_xlat13);
        u_xlat13 = u_xlat13 * VGlobals._ScreenParams.y;
        u_xlat12 = u_xlat13 / u_xlat12;
        tessFactor.edgeTessellationFactor[0] = max(u_xlat12, 1.0);
        u_xlat2.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[0].INTERNALTESSPOS0.yyy;
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[0].INTERNALTESSPOS0.xxx, u_xlat2.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[0].INTERNALTESSPOS0.zzz, u_xlat2.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[0].INTERNALTESSPOS0.www, u_xlat2.xyz);
        u_xlat3.xyz = u_xlat1.xyz + u_xlat2.xyz;
        u_xlat1.xyz = u_xlat1.xyz + (-u_xlat2.xyz);
        u_xlat12 = dot(u_xlat1.xyz, u_xlat1.xyz);
        u_xlat12 = sqrt(u_xlat12);
        u_xlat12 = u_xlat12 * VGlobals._ScreenParams.y;
        u_xlat1.xyz = fma(u_xlat3.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat1.x = dot(u_xlat1.xyz, u_xlat1.xyz);
        u_xlat1.x = sqrt(u_xlat1.x);
        u_xlat1.x = u_xlat1.x * VGlobals._EdgeLength;
        u_xlat12 = u_xlat12 / u_xlat1.x;
        tessFactor.edgeTessellationFactor[1] = max(u_xlat12, 1.0);
        u_xlat1.xyz = u_xlat0.xyz + u_xlat2.xyz;
        u_xlat0.xyz = (-u_xlat0.xyz) + u_xlat2.xyz;
        u_xlat0.x = dot(u_xlat0.xyz, u_xlat0.xyz);
        u_xlat0.x = sqrt(u_xlat0.x);
        u_xlat0.x = u_xlat0.x * VGlobals._ScreenParams.y;
        u_xlat4.xyz = fma(u_xlat1.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat4.x = dot(u_xlat4.xyz, u_xlat4.xyz);
        u_xlat4.x = sqrt(u_xlat4.x);
        u_xlat4.x = u_xlat4.x * VGlobals._EdgeLength;
        u_xlat0.x = u_xlat0.x / u_xlat4.x;
        tessFactor.edgeTessellationFactor[2] = max(u_xlat0.x, 1.0);
    }
    // join_phase3
    {
        u_xlat0.x = tessFactor.edgeTessellationFactor[0] + tessFactor.edgeTessellationFactor[1];
        u_xlat0.x = u_xlat0.x + tessFactor.edgeTessellationFactor[2];
        tessFactor.insideTessellationFactor = u_xlat0.x * 0.333333343;
    }
    controlPoints[mtl_VertexID] = output;
    tessFactors[internalPatchID] = tessFactor;
}
// SHADER_STAGE_HULL_end
// SHADER_STAGE_DOMAIN_begin
struct Mtl_VertexInPostTess
{
    patch_control_point<Mtl_ControlPointIn> cp;
};
struct Mtl_VertexOutPostTess
{
    float4 mtl_Position [[ position ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float3 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float3 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float3 TEXCOORD3 [[ user(TEXCOORD3) ]];
    float3 TEXCOORD4 [[ user(TEXCOORD4) ]];
    float3 TEXCOORD5 [[ user(TEXCOORD5) ]];
    float4 TEXCOORD6 [[ user(TEXCOORD6) ]];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    sampler sampler_Height [[ sampler (0) ]],
    texture2d<float, access::sample > _Height [[ texture(0) ]] ,
    float3 mtl_TessCoord [[ position_in_patch ]],
    uint patchID [[ patch_id ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    Mtl_VertexInPostTess input [[ stage_in ]])
{
#pragma clang diagnostic pop
    Mtl_VertexOutPostTess output;
    MTLTriangleTessellationFactorsHalf tessFactor;
    tessFactor = tessFactors[patchID];
    float4 u_xlat0;
    float3 u_xlat1;
    float4 u_xlat2;
    float4 u_xlat3;
    float4 u_xlat4;
    float2 u_xlat10;
    float u_xlat16;
    u_xlat0.xy = mtl_TessCoord.yy * input.cp[1].TEXCOORD0.xy;
    u_xlat0.xy = fma(input.cp[0].TEXCOORD0.xy, mtl_TessCoord.xx, u_xlat0.xy);
    u_xlat0.xy = fma(input.cp[2].TEXCOORD0.xy, mtl_TessCoord.zz, u_xlat0.xy);
    u_xlat10.xy = u_xlat0.xy * float2(VGlobals._Tile);
    output.TEXCOORD0.xy = fma(u_xlat0.xy, VGlobals._texcoord_ST.xy, VGlobals._texcoord_ST.zw);
    u_xlat0.xyz = _Height.sample(sampler_Height, u_xlat10.xy, level(1.0)).xyz;
    u_xlat1.xyz = mtl_TessCoord.yyy * input.cp[1].NORMAL0.xyz;
    u_xlat1.xyz = fma(input.cp[0].NORMAL0.xyz, mtl_TessCoord.xxx, u_xlat1.xyz);
    u_xlat1.xyz = fma(input.cp[2].NORMAL0.xyz, mtl_TessCoord.zzz, u_xlat1.xyz);
    u_xlat0.xyz = u_xlat0.xyz * u_xlat1.xyz;
    u_xlat2 = mtl_TessCoord.yyyy * input.cp[1].INTERNALTESSPOS0;
    u_xlat2 = fma(input.cp[0].INTERNALTESSPOS0, mtl_TessCoord.xxxx, u_xlat2);
    u_xlat2 = fma(input.cp[2].INTERNALTESSPOS0, mtl_TessCoord.zzzz, u_xlat2);
    u_xlat0.xyz = fma(u_xlat0.xyz, float3(VGlobals._HeightDisplacement), u_xlat2.xyz);
    u_xlat3 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], u_xlat0.xxxx, u_xlat3);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], u_xlat0.zzzz, u_xlat3);
    u_xlat3 = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat4 = u_xlat3.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat4 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat3.xxxx, u_xlat4);
    u_xlat4 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat3.zzzz, u_xlat4);
    output.mtl_Position = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat3.wwww, u_xlat4);
    u_xlat2.y = dot(u_xlat1.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat2.z = dot(u_xlat1.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat2.x = dot(u_xlat1.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat1.x = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat1.x = rsqrt(u_xlat1.x);
    u_xlat1.xyz = u_xlat1.xxx * u_xlat2.xyz;
    output.TEXCOORD1.z = u_xlat1.y;
    u_xlat3 = mtl_TessCoord.yyyy * input.cp[1].TANGENT0;
    u_xlat3 = fma(input.cp[0].TANGENT0, mtl_TessCoord.xxxx, u_xlat3);
    u_xlat3 = fma(input.cp[2].TANGENT0, mtl_TessCoord.zzzz, u_xlat3);
    u_xlat2.xyz = u_xlat3.yyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].yzx;
    u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].yzx, u_xlat3.xxx, u_xlat2.xyz);
    u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].yzx, u_xlat3.zzz, u_xlat2.xyz);
    u_xlat16 = u_xlat3.w * VGlobals.unity_WorldTransformParams.w;
    u_xlat3.x = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat3.x = rsqrt(u_xlat3.x);
    u_xlat2.xyz = u_xlat2.xyz * u_xlat3.xxx;
    u_xlat3.xyz = u_xlat1.xyz * u_xlat2.xyz;
    u_xlat3.xyz = fma(u_xlat1.zxy, u_xlat2.yzx, (-u_xlat3.xyz));
    u_xlat3.xyz = float3(u_xlat16) * u_xlat3.xyz;
    output.TEXCOORD1.y = u_xlat3.x;
    output.TEXCOORD1.x = u_xlat2.z;
    output.TEXCOORD2.x = u_xlat2.x;
    output.TEXCOORD3.x = u_xlat2.y;
    output.TEXCOORD2.z = u_xlat1.z;
    output.TEXCOORD3.z = u_xlat1.x;
    output.TEXCOORD2.y = u_xlat3.y;
    output.TEXCOORD3.y = u_xlat3.z;
    output.TEXCOORD4.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, u_xlat2.www, u_xlat0.xyz);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3], u_xlat2.wwww, u_xlat0);
    u_xlat1.xyz = u_xlat0.yyy * VGlobals.hlslcc_mtx4x4unity_WorldToLight[1].xyz;
    u_xlat1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_WorldToLight[0].xyz, u_xlat0.xxx, u_xlat1.xyz);
    u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_WorldToLight[2].xyz, u_xlat0.zzz, u_xlat1.xyz);
    output.TEXCOORD5.xyz = fma(VGlobals.hlslcc_mtx4x4unity_WorldToLight[3].xyz, u_xlat0.www, u_xlat0.xyz);
    output.TEXCOORD6 = float4(0.0, 0.0, 0.0, 0.0);
    return output;
}
// SHADER_STAGE_DOMAIN_end
Compilation succeeded with: 

program_source:293:53: warning: writable resources in non-void post-tessellation vertex function
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
                                                    ^
program_source:299:30: note: writable buffer defined here
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
                             ^
program_source:300:48: note: writable buffer defined here
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
                                               ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float4 TEXCOORD0 [[ attribute(3) ]] ;
    float4 TEXCOORD1 [[ attribute(4) ]] ;
    float4 TEXCOORD2 [[ attribute(5) ]] ;
    float4 TEXCOORD3 [[ attribute(6) ]] ;
    float4 COLOR0 [[ attribute(7) ]] ;
};
struct Mtl_VertexOut
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float4 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float4 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float4 TEXCOORD3 [[ user(TEXCOORD3) ]];
    float4 COLOR0 [[ user(COLOR0) ]];
};
static Mtl_VertexOut vertexFunction(
    Mtl_VertexIn input)
{
    Mtl_VertexOut output;
    output.INTERNALTESSPOS0 = input.POSITION0;
    output.TANGENT0 = input.TANGENT0;
    output.NORMAL0.xyz = input.NORMAL0.xyz;
    output.TEXCOORD0 = input.TEXCOORD0;
    output.TEXCOORD1 = input.TEXCOORD1;
    output.TEXCOORD2 = input.TEXCOORD2;
    output.TEXCOORD3 = input.TEXCOORD3;
    output.COLOR0 = input.COLOR0;
    return output;
}
// SHADER_STAGE_HULL_begin
struct Mtl_ControlPoint
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float4 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float4 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float4 TEXCOORD3 [[ user(TEXCOORD3) ]];
    float4 COLOR0 [[ user(COLOR0) ]];
};
struct Mtl_ControlPointIn
{
    float4 INTERNALTESSPOS0 [[ attribute(8) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float4 TEXCOORD0 [[ attribute(3) ]] ;
    float4 TEXCOORD1 [[ attribute(4) ]] ;
    float4 TEXCOORD2 [[ attribute(5) ]] ;
    float4 TEXCOORD3 [[ attribute(6) ]] ;
    float4 COLOR0 [[ attribute(7) ]] ;
};
struct Mtl_KernelPatchInfo
{
    uint numPatches;
    ushort numControlPointsPerPatch;
};
struct VGlobals_Type
{
    float4 _Time;
    float4 _SinTime;
    float4 _CosTime;
    float4 unity_DeltaTime;
    float3 _WorldSpaceCameraPos;
    float4 _ProjectionParams;
    float4 _ScreenParams;
    float4 _ZBufferParams;
    float4 unity_OrthoParams;
    float4 unity_CameraWorldClipPlanes[6];
    float4 hlslcc_mtx4x4unity_CameraProjection[4];
    float4 hlslcc_mtx4x4unity_CameraInvProjection[4];
    float4 hlslcc_mtx4x4unity_WorldToCamera[4];
    float4 hlslcc_mtx4x4unity_CameraToWorld[4];
    float4 _WorldSpaceLightPos0;
    float4 _LightPositionRange;
    float4 _LightProjectionParams;
    float4 unity_4LightPosX0;
    float4 unity_4LightPosY0;
    float4 unity_4LightPosZ0;
    float4 unity_4LightAtten0;
    float4 unity_LightColor[8];
    float4 unity_LightPosition[8];
    float4 unity_LightAtten[8];
    float4 unity_SpotDirection[8];
    float4 unity_SHAr;
    float4 unity_SHAg;
    float4 unity_SHAb;
    float4 unity_SHBr;
    float4 unity_SHBg;
    float4 unity_SHBb;
    float4 unity_SHC;
    float4 unity_OcclusionMaskSelector;
    float4 unity_ProbesOcclusion;
    float3 unity_LightColor0;
    float3 unity_LightColor1;
    float3 unity_LightColor2;
    float3 unity_LightColor3;
    float4 unity_ShadowSplitSpheres[4];
    float4 unity_ShadowSplitSqRadii;
    float4 unity_LightShadowBias;
    float4 _LightSplitsNear;
    float4 _LightSplitsFar;
    float4 hlslcc_mtx4x4unity_WorldToShadow[16];
    float4 _LightShadowData;
    float4 unity_ShadowFadeCenterAndType;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 unity_LODFade;
    float4 unity_WorldTransformParams;
    float4 unity_RenderingLayer;
    float4 hlslcc_mtx4x4glstate_matrix_transpose_modelview0[4];
    float4 glstate_lightmodel_ambient;
    float4 unity_AmbientSky;
    float4 unity_AmbientEquator;
    float4 unity_AmbientGround;
    float4 unity_IndirectSpecColor;
    float4 hlslcc_mtx4x4glstate_matrix_projection[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixInvV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    int unity_StereoEyeIndex;
    float4 unity_ShadowColor;
    float4 unity_FogColor;
    float4 unity_FogParams;
    float4 unity_LightmapST;
    float4 unity_DynamicLightmapST;
    float4 unity_SpecCube0_BoxMax;
    float4 unity_SpecCube0_BoxMin;
    float4 unity_SpecCube0_ProbePosition;
    float4 unity_SpecCube0_HDR;
    float4 unity_SpecCube1_BoxMax;
    float4 unity_SpecCube1_BoxMin;
    float4 unity_SpecCube1_ProbePosition;
    float4 unity_SpecCube1_HDR;
    float4 unity_ProbeVolumeParams;
    float4 hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[4];
    float3 unity_ProbeVolumeSizeInv;
    float3 unity_ProbeVolumeMin;
    float4 unity_Lightmap_HDR;
    float4 unity_DynamicLightmap_HDR;
    float4 _LightColor0;
    float4 _SpecColor;
    float _Tile;
    float _HeightDisplacement;
    float _NormalScale;
    float4 _ColorTint;
    float _MetallicStrength;
    float _SmoothnessStrength;
    float _EdgeLength;
};
struct Mtl_HullIn
{
    Mtl_VertexOut cp[3];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
kernel void patchKernel(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn vertexInput [[ stage_in ]],
    uint2 tID [[ thread_position_in_grid ]],
    ushort2 groupID [[ threadgroup_position_in_grid ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    constant Mtl_KernelPatchInfo &patchInfo [[ buffer(3) ]])
{
#pragma clang diagnostic pop
    Mtl_ControlPoint output;
    const uint numPatchesInThreadGroup = 10;
    const uint patchID = (tID.x / patchInfo.numControlPointsPerPatch);
    const bool patchValid = (patchID < patchInfo.numPatches);
    const uint mtl_BaseInstance = 0;
    const uint mtl_InstanceID = groupID.y - mtl_BaseInstance;
    const uint internalPatchID = mtl_InstanceID * patchInfo.numPatches + patchID;
    const uint patchIDInThreadGroup = (patchID % numPatchesInThreadGroup);
    const uint controlPointID = (tID.x % patchInfo.numControlPointsPerPatch);
    const uint mtl_BaseVertex = 0;
    const uint mtl_VertexID = ((mtl_InstanceID * (patchInfo.numControlPointsPerPatch * patchInfo.numPatches)) + tID.x) - mtl_BaseVertex;
    threadgroup Mtl_HullIn inputGroup[numPatchesInThreadGroup];
    threadgroup Mtl_HullIn &input = inputGroup[patchIDInThreadGroup];
    MTLTriangleTessellationFactorsHalf tessFactor;
    if (patchValid) {
        input.cp[controlPointID] = vertexFunction(vertexInput);
        output.INTERNALTESSPOS0 = input.cp[controlPointID].INTERNALTESSPOS0;
        output.TANGENT0 = input.cp[controlPointID].TANGENT0;
        output.NORMAL0 = input.cp[controlPointID].NORMAL0;
        output.TEXCOORD0 = input.cp[controlPointID].TEXCOORD0;
        output.TEXCOORD1 = input.cp[controlPointID].TEXCOORD1;
        output.TEXCOORD2 = input.cp[controlPointID].TEXCOORD2;
        output.TEXCOORD3 = input.cp[controlPointID].TEXCOORD3;
        output.COLOR0 = input.cp[controlPointID].COLOR0;
    }
    threadgroup_barrier(mem_flags::mem_threadgroup);
    if (!patchValid) {
        return;
    }
    float3 u_xlat0;
    float3 u_xlat1;
    float3 u_xlat2;
    float3 u_xlat3;
    float3 u_xlat4;
    float u_xlat12;
    float u_xlat13;
    // fork_phase2
    {
        u_xlat0.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[1].INTERNALTESSPOS0.yyy;
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[1].INTERNALTESSPOS0.xxx, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[1].INTERNALTESSPOS0.zzz, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[1].INTERNALTESSPOS0.www, u_xlat0.xyz);
        u_xlat1.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[2].INTERNALTESSPOS0.yyy;
        u_xlat1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[2].INTERNALTESSPOS0.xxx, u_xlat1.xyz);
        u_xlat1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[2].INTERNALTESSPOS0.zzz, u_xlat1.xyz);
        u_xlat1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[2].INTERNALTESSPOS0.www, u_xlat1.xyz);
        u_xlat2.xyz = u_xlat0.xyz + u_xlat1.xyz;
        u_xlat2.xyz = fma(u_xlat2.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat12 = dot(u_xlat2.xyz, u_xlat2.xyz);
        u_xlat12 = sqrt(u_xlat12);
        u_xlat12 = u_xlat12 * VGlobals._EdgeLength;
        u_xlat2.xyz = u_xlat0.xyz + (-u_xlat1.xyz);
        u_xlat13 = dot(u_xlat2.xyz, u_xlat2.xyz);
        u_xlat13 = sqrt(u_xlat13);
        u_xlat13 = u_xlat13 * VGlobals._ScreenParams.y;
        u_xlat12 = u_xlat13 / u_xlat12;
        tessFactor.edgeTessellationFactor[0] = max(u_xlat12, 1.0);
        u_xlat2.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[0].INTERNALTESSPOS0.yyy;
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[0].INTERNALTESSPOS0.xxx, u_xlat2.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[0].INTERNALTESSPOS0.zzz, u_xlat2.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[0].INTERNALTESSPOS0.www, u_xlat2.xyz);
        u_xlat3.xyz = u_xlat1.xyz + u_xlat2.xyz;
        u_xlat1.xyz = u_xlat1.xyz + (-u_xlat2.xyz);
        u_xlat12 = dot(u_xlat1.xyz, u_xlat1.xyz);
        u_xlat12 = sqrt(u_xlat12);
        u_xlat12 = u_xlat12 * VGlobals._ScreenParams.y;
        u_xlat1.xyz = fma(u_xlat3.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat1.x = dot(u_xlat1.xyz, u_xlat1.xyz);
        u_xlat1.x = sqrt(u_xlat1.x);
        u_xlat1.x = u_xlat1.x * VGlobals._EdgeLength;
        u_xlat12 = u_xlat12 / u_xlat1.x;
        tessFactor.edgeTessellationFactor[1] = max(u_xlat12, 1.0);
        u_xlat1.xyz = u_xlat0.xyz + u_xlat2.xyz;
        u_xlat0.xyz = (-u_xlat0.xyz) + u_xlat2.xyz;
        u_xlat0.x = dot(u_xlat0.xyz, u_xlat0.xyz);
        u_xlat0.x = sqrt(u_xlat0.x);
        u_xlat0.x = u_xlat0.x * VGlobals._ScreenParams.y;
        u_xlat4.xyz = fma(u_xlat1.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat4.x = dot(u_xlat4.xyz, u_xlat4.xyz);
        u_xlat4.x = sqrt(u_xlat4.x);
        u_xlat4.x = u_xlat4.x * VGlobals._EdgeLength;
        u_xlat0.x = u_xlat0.x / u_xlat4.x;
        tessFactor.edgeTessellationFactor[2] = max(u_xlat0.x, 1.0);
    }
    // join_phase3
    {
        u_xlat0.x = tessFactor.edgeTessellationFactor[0] + tessFactor.edgeTessellationFactor[1];
        u_xlat0.x = u_xlat0.x + tessFactor.edgeTessellationFactor[2];
        tessFactor.insideTessellationFactor = u_xlat0.x * 0.333333343;
    }
    controlPoints[mtl_VertexID] = output;
    tessFactors[internalPatchID] = tessFactor;
}
// SHADER_STAGE_HULL_end
// SHADER_STAGE_DOMAIN_begin
struct Mtl_VertexInPostTess
{
    patch_control_point<Mtl_ControlPointIn> cp;
};
struct Mtl_VertexOutPostTess
{
    float4 mtl_Position [[ position ]];
    float3 TEXCOORD1 [[ user(TEXCOORD1) ]];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    sampler sampler_Height [[ sampler (0) ]],
    texture2d<float, access::sample > _Height [[ texture(0) ]] ,
    float3 mtl_TessCoord [[ position_in_patch ]],
    uint patchID [[ patch_id ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    Mtl_VertexInPostTess input [[ stage_in ]])
{
#pragma clang diagnostic pop
    Mtl_VertexOutPostTess output;
    MTLTriangleTessellationFactorsHalf tessFactor;
    tessFactor = tessFactors[patchID];
    float4 u_xlat0;
    float4 u_xlat1;
    float4 u_xlat2;
    float4 u_xlat3;
    float4 u_xlat4;
    float u_xlat11;
    float u_xlat15;
    bool u_xlatb15;
    u_xlat0.xyz = mtl_TessCoord.yyy * input.cp[1].NORMAL0.xyz;
    u_xlat0.xyz = fma(input.cp[0].NORMAL0.xyz, mtl_TessCoord.xxx, u_xlat0.xyz);
    u_xlat0.xyz = fma(input.cp[2].NORMAL0.xyz, mtl_TessCoord.zzz, u_xlat0.xyz);
    u_xlat1.x = dot(u_xlat0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat1.y = dot(u_xlat0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat1.z = dot(u_xlat0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat15 = dot(u_xlat1.xyz, u_xlat1.xyz);
    u_xlat15 = rsqrt(u_xlat15);
    u_xlat1.xyz = float3(u_xlat15) * u_xlat1.xyz;
    u_xlat2.xy = mtl_TessCoord.yy * input.cp[1].TEXCOORD0.xy;
    u_xlat2.xy = fma(input.cp[0].TEXCOORD0.xy, mtl_TessCoord.xx, u_xlat2.xy);
    u_xlat2.xy = fma(input.cp[2].TEXCOORD0.xy, mtl_TessCoord.zz, u_xlat2.xy);
    u_xlat2.xy = u_xlat2.xy * float2(VGlobals._Tile);
    u_xlat2.xyz = _Height.sample(sampler_Height, u_xlat2.xy, level(1.0)).xyz;
    u_xlat0.xyz = u_xlat0.xyz * u_xlat2.xyz;
    u_xlat2 = mtl_TessCoord.yyyy * input.cp[1].INTERNALTESSPOS0;
    u_xlat2 = fma(input.cp[0].INTERNALTESSPOS0, mtl_TessCoord.xxxx, u_xlat2);
    u_xlat2 = fma(input.cp[2].INTERNALTESSPOS0, mtl_TessCoord.zzzz, u_xlat2);
    u_xlat0.xyz = fma(u_xlat0.xyz, float3(VGlobals._HeightDisplacement), u_xlat2.xyz);
    u_xlat3 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], u_xlat0.xxxx, u_xlat3);
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], u_xlat0.zzzz, u_xlat3);
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3], u_xlat2.wwww, u_xlat3);
    u_xlat2.xyz = fma((-u_xlat3.xyz), VGlobals._WorldSpaceLightPos0.www, VGlobals._WorldSpaceLightPos0.xyz);
    u_xlat15 = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat15 = rsqrt(u_xlat15);
    u_xlat2.xyz = float3(u_xlat15) * u_xlat2.xyz;
    u_xlat15 = dot(u_xlat1.xyz, u_xlat2.xyz);
    u_xlat15 = fma((-u_xlat15), u_xlat15, 1.0);
    u_xlat15 = sqrt(u_xlat15);
    u_xlat15 = u_xlat15 * VGlobals.unity_LightShadowBias.z;
    u_xlat1.xyz = fma((-u_xlat1.xyz), float3(u_xlat15), u_xlat3.xyz);
    u_xlatb15 = VGlobals.unity_LightShadowBias.z!=0.0;
    u_xlat1.xyz = (bool(u_xlatb15)) ? u_xlat1.xyz : u_xlat3.xyz;
    u_xlat4 = u_xlat1.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat4 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat1.xxxx, u_xlat4);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat1.zzzz, u_xlat4);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat3.wwww, u_xlat1);
    u_xlat15 = VGlobals.unity_LightShadowBias.x / u_xlat1.w;
    u_xlat15 = min(u_xlat15, 0.0);
    u_xlat15 = max(u_xlat15, -1.0);
    u_xlat15 = u_xlat15 + u_xlat1.z;
    u_xlat11 = min(u_xlat1.w, u_xlat15);
    output.mtl_Position.xyw = u_xlat1.xyw;
    u_xlat1.x = (-u_xlat15) + u_xlat11;
    output.mtl_Position.z = fma(VGlobals.unity_LightShadowBias.y, u_xlat1.x, u_xlat15);
    u_xlat1.xyz = u_xlat0.yyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz;
    u_xlat0.xyw = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, u_xlat0.xxx, u_xlat1.xyz);
    u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, u_xlat0.zzz, u_xlat0.xyw);
    output.TEXCOORD1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, u_xlat2.www, u_xlat0.xyz);
    return output;
}
// SHADER_STAGE_DOMAIN_end
Compilation succeeded with: 

program_source:299:53: warning: writable resources in non-void post-tessellation vertex function
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
                                                    ^
program_source:305:30: note: writable buffer defined here
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
                             ^
program_source:306:48: note: writable buffer defined here
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
                                               ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float4 TEXCOORD0 [[ attribute(3) ]] ;
    float4 TEXCOORD1 [[ attribute(4) ]] ;
    float4 TEXCOORD2 [[ attribute(5) ]] ;
    float4 TEXCOORD3 [[ attribute(6) ]] ;
    float4 COLOR0 [[ attribute(7) ]] ;
};
struct Mtl_VertexOut
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float4 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float4 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float4 TEXCOORD3 [[ user(TEXCOORD3) ]];
    float4 COLOR0 [[ user(COLOR0) ]];
};
static Mtl_VertexOut vertexFunction(
    Mtl_VertexIn input)
{
    Mtl_VertexOut output;
    output.INTERNALTESSPOS0 = input.POSITION0;
    output.TANGENT0 = input.TANGENT0;
    output.NORMAL0.xyz = input.NORMAL0.xyz;
    output.TEXCOORD0 = input.TEXCOORD0;
    output.TEXCOORD1 = input.TEXCOORD1;
    output.TEXCOORD2 = input.TEXCOORD2;
    output.TEXCOORD3 = input.TEXCOORD3;
    output.COLOR0 = input.COLOR0;
    return output;
}
// SHADER_STAGE_HULL_begin
struct Mtl_ControlPoint
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float4 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float4 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float4 TEXCOORD3 [[ user(TEXCOORD3) ]];
    float4 COLOR0 [[ user(COLOR0) ]];
};
struct Mtl_ControlPointIn
{
    float4 INTERNALTESSPOS0 [[ attribute(8) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float4 TEXCOORD0 [[ attribute(3) ]] ;
    float4 TEXCOORD1 [[ attribute(4) ]] ;
    float4 TEXCOORD2 [[ attribute(5) ]] ;
    float4 TEXCOORD3 [[ attribute(6) ]] ;
    float4 COLOR0 [[ attribute(7) ]] ;
};
struct Mtl_KernelPatchInfo
{
    uint numPatches;
    ushort numControlPointsPerPatch;
};
struct VGlobals_Type
{
    float4 _Time;
    float4 _SinTime;
    float4 _CosTime;
    float4 unity_DeltaTime;
    float3 _WorldSpaceCameraPos;
    float4 _ProjectionParams;
    float4 _ScreenParams;
    float4 _ZBufferParams;
    float4 unity_OrthoParams;
    float4 unity_CameraWorldClipPlanes[6];
    float4 hlslcc_mtx4x4unity_CameraProjection[4];
    float4 hlslcc_mtx4x4unity_CameraInvProjection[4];
    float4 hlslcc_mtx4x4unity_WorldToCamera[4];
    float4 hlslcc_mtx4x4unity_CameraToWorld[4];
    float4 _WorldSpaceLightPos0;
    float4 _LightPositionRange;
    float4 _LightProjectionParams;
    float4 unity_4LightPosX0;
    float4 unity_4LightPosY0;
    float4 unity_4LightPosZ0;
    float4 unity_4LightAtten0;
    float4 unity_LightColor[8];
    float4 unity_LightPosition[8];
    float4 unity_LightAtten[8];
    float4 unity_SpotDirection[8];
    float4 unity_SHAr;
    float4 unity_SHAg;
    float4 unity_SHAb;
    float4 unity_SHBr;
    float4 unity_SHBg;
    float4 unity_SHBb;
    float4 unity_SHC;
    float4 unity_OcclusionMaskSelector;
    float4 unity_ProbesOcclusion;
    float3 unity_LightColor0;
    float3 unity_LightColor1;
    float3 unity_LightColor2;
    float3 unity_LightColor3;
    float4 unity_ShadowSplitSpheres[4];
    float4 unity_ShadowSplitSqRadii;
    float4 unity_LightShadowBias;
    float4 _LightSplitsNear;
    float4 _LightSplitsFar;
    float4 hlslcc_mtx4x4unity_WorldToShadow[16];
    float4 _LightShadowData;
    float4 unity_ShadowFadeCenterAndType;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 unity_LODFade;
    float4 unity_WorldTransformParams;
    float4 unity_RenderingLayer;
    float4 hlslcc_mtx4x4glstate_matrix_transpose_modelview0[4];
    float4 glstate_lightmodel_ambient;
    float4 unity_AmbientSky;
    float4 unity_AmbientEquator;
    float4 unity_AmbientGround;
    float4 unity_IndirectSpecColor;
    float4 hlslcc_mtx4x4glstate_matrix_projection[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixInvV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    int unity_StereoEyeIndex;
    float4 unity_ShadowColor;
    float4 unity_FogColor;
    float4 unity_FogParams;
    float4 unity_LightmapST;
    float4 unity_DynamicLightmapST;
    float4 unity_SpecCube0_BoxMax;
    float4 unity_SpecCube0_BoxMin;
    float4 unity_SpecCube0_ProbePosition;
    float4 unity_SpecCube0_HDR;
    float4 unity_SpecCube1_BoxMax;
    float4 unity_SpecCube1_BoxMin;
    float4 unity_SpecCube1_ProbePosition;
    float4 unity_SpecCube1_HDR;
    float4 unity_ProbeVolumeParams;
    float4 hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[4];
    float3 unity_ProbeVolumeSizeInv;
    float3 unity_ProbeVolumeMin;
    float4 unity_Lightmap_HDR;
    float4 unity_DynamicLightmap_HDR;
    float4 _LightColor0;
    float4 _SpecColor;
    float _Tile;
    float _HeightDisplacement;
    float _NormalScale;
    float4 _ColorTint;
    float _MetallicStrength;
    float _SmoothnessStrength;
    float _EdgeLength;
    float4 _texcoord_ST;
    float4 unity_Ambient;
};
struct Mtl_HullIn
{
    Mtl_VertexOut cp[3];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
kernel void patchKernel(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn vertexInput [[ stage_in ]],
    uint2 tID [[ thread_position_in_grid ]],
    ushort2 groupID [[ threadgroup_position_in_grid ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    constant Mtl_KernelPatchInfo &patchInfo [[ buffer(3) ]])
{
#pragma clang diagnostic pop
    Mtl_ControlPoint output;
    const uint numPatchesInThreadGroup = 10;
    const uint patchID = (tID.x / patchInfo.numControlPointsPerPatch);
    const bool patchValid = (patchID < patchInfo.numPatches);
    const uint mtl_BaseInstance = 0;
    const uint mtl_InstanceID = groupID.y - mtl_BaseInstance;
    const uint internalPatchID = mtl_InstanceID * patchInfo.numPatches + patchID;
    const uint patchIDInThreadGroup = (patchID % numPatchesInThreadGroup);
    const uint controlPointID = (tID.x % patchInfo.numControlPointsPerPatch);
    const uint mtl_BaseVertex = 0;
    const uint mtl_VertexID = ((mtl_InstanceID * (patchInfo.numControlPointsPerPatch * patchInfo.numPatches)) + tID.x) - mtl_BaseVertex;
    threadgroup Mtl_HullIn inputGroup[numPatchesInThreadGroup];
    threadgroup Mtl_HullIn &input = inputGroup[patchIDInThreadGroup];
    MTLTriangleTessellationFactorsHalf tessFactor;
    if (patchValid) {
        input.cp[controlPointID] = vertexFunction(vertexInput);
        output.INTERNALTESSPOS0 = input.cp[controlPointID].INTERNALTESSPOS0;
        output.TANGENT0 = input.cp[controlPointID].TANGENT0;
        output.NORMAL0 = input.cp[controlPointID].NORMAL0;
        output.TEXCOORD0 = input.cp[controlPointID].TEXCOORD0;
        output.TEXCOORD1 = input.cp[controlPointID].TEXCOORD1;
        output.TEXCOORD2 = input.cp[controlPointID].TEXCOORD2;
        output.TEXCOORD3 = input.cp[controlPointID].TEXCOORD3;
        output.COLOR0 = input.cp[controlPointID].COLOR0;
    }
    threadgroup_barrier(mem_flags::mem_threadgroup);
    if (!patchValid) {
        return;
    }
    float3 u_xlat0;
    float3 u_xlat1;
    float3 u_xlat2;
    float3 u_xlat3;
    float3 u_xlat4;
    float u_xlat12;
    float u_xlat13;
    // fork_phase2
    {
        u_xlat0.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[1].INTERNALTESSPOS0.yyy;
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[1].INTERNALTESSPOS0.xxx, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[1].INTERNALTESSPOS0.zzz, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[1].INTERNALTESSPOS0.www, u_xlat0.xyz);
        u_xlat1.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[2].INTERNALTESSPOS0.yyy;
        u_xlat1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[2].INTERNALTESSPOS0.xxx, u_xlat1.xyz);
        u_xlat1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[2].INTERNALTESSPOS0.zzz, u_xlat1.xyz);
        u_xlat1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[2].INTERNALTESSPOS0.www, u_xlat1.xyz);
        u_xlat2.xyz = u_xlat0.xyz + u_xlat1.xyz;
        u_xlat2.xyz = fma(u_xlat2.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat12 = dot(u_xlat2.xyz, u_xlat2.xyz);
        u_xlat12 = sqrt(u_xlat12);
        u_xlat12 = u_xlat12 * VGlobals._EdgeLength;
        u_xlat2.xyz = u_xlat0.xyz + (-u_xlat1.xyz);
        u_xlat13 = dot(u_xlat2.xyz, u_xlat2.xyz);
        u_xlat13 = sqrt(u_xlat13);
        u_xlat13 = u_xlat13 * VGlobals._ScreenParams.y;
        u_xlat12 = u_xlat13 / u_xlat12;
        tessFactor.edgeTessellationFactor[0] = max(u_xlat12, 1.0);
        u_xlat2.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[0].INTERNALTESSPOS0.yyy;
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[0].INTERNALTESSPOS0.xxx, u_xlat2.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[0].INTERNALTESSPOS0.zzz, u_xlat2.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[0].INTERNALTESSPOS0.www, u_xlat2.xyz);
        u_xlat3.xyz = u_xlat1.xyz + u_xlat2.xyz;
        u_xlat1.xyz = u_xlat1.xyz + (-u_xlat2.xyz);
        u_xlat12 = dot(u_xlat1.xyz, u_xlat1.xyz);
        u_xlat12 = sqrt(u_xlat12);
        u_xlat12 = u_xlat12 * VGlobals._ScreenParams.y;
        u_xlat1.xyz = fma(u_xlat3.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat1.x = dot(u_xlat1.xyz, u_xlat1.xyz);
        u_xlat1.x = sqrt(u_xlat1.x);
        u_xlat1.x = u_xlat1.x * VGlobals._EdgeLength;
        u_xlat12 = u_xlat12 / u_xlat1.x;
        tessFactor.edgeTessellationFactor[1] = max(u_xlat12, 1.0);
        u_xlat1.xyz = u_xlat0.xyz + u_xlat2.xyz;
        u_xlat0.xyz = (-u_xlat0.xyz) + u_xlat2.xyz;
        u_xlat0.x = dot(u_xlat0.xyz, u_xlat0.xyz);
        u_xlat0.x = sqrt(u_xlat0.x);
        u_xlat0.x = u_xlat0.x * VGlobals._ScreenParams.y;
        u_xlat4.xyz = fma(u_xlat1.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat4.x = dot(u_xlat4.xyz, u_xlat4.xyz);
        u_xlat4.x = sqrt(u_xlat4.x);
        u_xlat4.x = u_xlat4.x * VGlobals._EdgeLength;
        u_xlat0.x = u_xlat0.x / u_xlat4.x;
        tessFactor.edgeTessellationFactor[2] = max(u_xlat0.x, 1.0);
    }
    // join_phase3
    {
        u_xlat0.x = tessFactor.edgeTessellationFactor[0] + tessFactor.edgeTessellationFactor[1];
        u_xlat0.x = u_xlat0.x + tessFactor.edgeTessellationFactor[2];
        tessFactor.insideTessellationFactor = u_xlat0.x * 0.333333343;
    }
    controlPoints[mtl_VertexID] = output;
    tessFactors[internalPatchID] = tessFactor;
}
// SHADER_STAGE_HULL_end
// SHADER_STAGE_DOMAIN_begin
struct Mtl_VertexInPostTess
{
    patch_control_point<Mtl_ControlPointIn> cp;
};
struct Mtl_VertexOutPostTess
{
    float4 mtl_Position [[ position ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float4 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float4 TEXCOORD3 [[ user(TEXCOORD3) ]];
    float4 TEXCOORD5 [[ user(TEXCOORD5) ]];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    sampler sampler_Height [[ sampler (0) ]],
    texture2d<float, access::sample > _Height [[ texture(0) ]] ,
    float3 mtl_TessCoord [[ position_in_patch ]],
    uint patchID [[ patch_id ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    Mtl_VertexInPostTess input [[ stage_in ]])
{
#pragma clang diagnostic pop
    Mtl_VertexOutPostTess output;
    MTLTriangleTessellationFactorsHalf tessFactor;
    tessFactor = tessFactors[patchID];
    float4 u_xlat0;
    float4 u_xlat1;
    float4 u_xlat2;
    float4 u_xlat3;
    float2 u_xlat9;
    float u_xlat12;
    float u_xlat13;
    u_xlat0 = mtl_TessCoord.yyyy * input.cp[1].INTERNALTESSPOS0;
    u_xlat0 = fma(input.cp[0].INTERNALTESSPOS0, mtl_TessCoord.xxxx, u_xlat0);
    u_xlat0 = fma(input.cp[2].INTERNALTESSPOS0, mtl_TessCoord.zzzz, u_xlat0);
    u_xlat1.xy = mtl_TessCoord.yy * input.cp[1].TEXCOORD0.xy;
    u_xlat1.xy = fma(input.cp[0].TEXCOORD0.xy, mtl_TessCoord.xx, u_xlat1.xy);
    u_xlat1.xy = fma(input.cp[2].TEXCOORD0.xy, mtl_TessCoord.zz, u_xlat1.xy);
    u_xlat9.xy = u_xlat1.xy * float2(VGlobals._Tile);
    output.TEXCOORD0.xy = fma(u_xlat1.xy, VGlobals._texcoord_ST.xy, VGlobals._texcoord_ST.zw);
    u_xlat1.xyz = _Height.sample(sampler_Height, u_xlat9.xy, level(1.0)).xyz;
    u_xlat2.xyz = mtl_TessCoord.yyy * input.cp[1].NORMAL0.xyz;
    u_xlat2.xyz = fma(input.cp[0].NORMAL0.xyz, mtl_TessCoord.xxx, u_xlat2.xyz);
    u_xlat2.xyz = fma(input.cp[2].NORMAL0.xyz, mtl_TessCoord.zzz, u_xlat2.xyz);
    u_xlat1.xyz = u_xlat1.xyz * u_xlat2.xyz;
    u_xlat0.xyz = fma(u_xlat1.xyz, float3(VGlobals._HeightDisplacement), u_xlat0.xyz);
    u_xlat1 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], u_xlat0.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], u_xlat0.zzzz, u_xlat1);
    u_xlat3 = u_xlat1 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, u_xlat0.www, u_xlat1.xyz);
    u_xlat1 = u_xlat3.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat3.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat3.zzzz, u_xlat1);
    output.mtl_Position = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat3.wwww, u_xlat1);
    u_xlat1.y = dot(u_xlat2.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat1.z = dot(u_xlat2.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat1.x = dot(u_xlat2.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat12 = dot(u_xlat1.xyz, u_xlat1.xyz);
    u_xlat12 = rsqrt(u_xlat12);
    u_xlat1.xyz = float3(u_xlat12) * u_xlat1.xyz;
    output.TEXCOORD1.z = u_xlat1.y;
    u_xlat2 = mtl_TessCoord.yyyy * input.cp[1].TANGENT0;
    u_xlat2 = fma(input.cp[0].TANGENT0, mtl_TessCoord.xxxx, u_xlat2);
    u_xlat2 = fma(input.cp[2].TANGENT0, mtl_TessCoord.zzzz, u_xlat2);
    u_xlat3.xyz = u_xlat2.yyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].yzx;
    u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].yzx, u_xlat2.xxx, u_xlat3.xyz);
    u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].yzx, u_xlat2.zzz, u_xlat3.xyz);
    u_xlat12 = u_xlat2.w * VGlobals.unity_WorldTransformParams.w;
    u_xlat13 = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat13 = rsqrt(u_xlat13);
    u_xlat2.xyz = float3(u_xlat13) * u_xlat2.xyz;
    u_xlat3.xyz = u_xlat1.xyz * u_xlat2.xyz;
    u_xlat3.xyz = fma(u_xlat1.zxy, u_xlat2.yzx, (-u_xlat3.xyz));
    u_xlat3.xyz = float3(u_xlat12) * u_xlat3.xyz;
    output.TEXCOORD1.y = u_xlat3.x;
    output.TEXCOORD1.w = u_xlat0.x;
    output.TEXCOORD1.x = u_xlat2.z;
    output.TEXCOORD2.w = u_xlat0.y;
    output.TEXCOORD3.w = u_xlat0.z;
    output.TEXCOORD2.x = u_xlat2.x;
    output.TEXCOORD3.x = u_xlat2.y;
    output.TEXCOORD2.z = u_xlat1.z;
    output.TEXCOORD3.z = u_xlat1.x;
    output.TEXCOORD2.y = u_xlat3.y;
    output.TEXCOORD3.y = u_xlat3.z;
    output.TEXCOORD5 = float4(0.0, 0.0, 0.0, 0.0);
    return output;
}
// SHADER_STAGE_DOMAIN_end
Compilation succeeded with: 

program_source:303:53: warning: writable resources in non-void post-tessellation vertex function
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
                                                    ^
program_source:309:30: note: writable buffer defined here
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
                             ^
program_source:310:48: note: writable buffer defined here
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
                                               ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float4 TEXCOORD0 [[ attribute(3) ]] ;
    float4 TEXCOORD1 [[ attribute(4) ]] ;
    float4 TEXCOORD2 [[ attribute(5) ]] ;
    float4 TEXCOORD3 [[ attribute(6) ]] ;
    float4 COLOR0 [[ attribute(7) ]] ;
};
struct Mtl_VertexOut
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float4 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float4 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float4 TEXCOORD3 [[ user(TEXCOORD3) ]];
    float4 COLOR0 [[ user(COLOR0) ]];
};
static Mtl_VertexOut vertexFunction(
    Mtl_VertexIn input)
{
    Mtl_VertexOut output;
    output.INTERNALTESSPOS0 = input.POSITION0;
    output.TANGENT0 = input.TANGENT0;
    output.NORMAL0.xyz = input.NORMAL0.xyz;
    output.TEXCOORD0 = input.TEXCOORD0;
    output.TEXCOORD1 = input.TEXCOORD1;
    output.TEXCOORD2 = input.TEXCOORD2;
    output.TEXCOORD3 = input.TEXCOORD3;
    output.COLOR0 = input.COLOR0;
    return output;
}
// SHADER_STAGE_HULL_begin
struct Mtl_ControlPoint
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float4 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float4 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float4 TEXCOORD3 [[ user(TEXCOORD3) ]];
    float4 COLOR0 [[ user(COLOR0) ]];
};
struct Mtl_ControlPointIn
{
    float4 INTERNALTESSPOS0 [[ attribute(8) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float4 TEXCOORD0 [[ attribute(3) ]] ;
    float4 TEXCOORD1 [[ attribute(4) ]] ;
    float4 TEXCOORD2 [[ attribute(5) ]] ;
    float4 TEXCOORD3 [[ attribute(6) ]] ;
    float4 COLOR0 [[ attribute(7) ]] ;
};
struct Mtl_KernelPatchInfo
{
    uint numPatches;
    ushort numControlPointsPerPatch;
};
struct VGlobals_Type
{
    float4 _Time;
    float4 _SinTime;
    float4 _CosTime;
    float4 unity_DeltaTime;
    float3 _WorldSpaceCameraPos;
    float4 _ProjectionParams;
    float4 _ScreenParams;
    float4 _ZBufferParams;
    float4 unity_OrthoParams;
    float4 unity_CameraWorldClipPlanes[6];
    float4 hlslcc_mtx4x4unity_CameraProjection[4];
    float4 hlslcc_mtx4x4unity_CameraInvProjection[4];
    float4 hlslcc_mtx4x4unity_WorldToCamera[4];
    float4 hlslcc_mtx4x4unity_CameraToWorld[4];
    float4 _WorldSpaceLightPos0;
    float4 _LightPositionRange;
    float4 _LightProjectionParams;
    float4 unity_4LightPosX0;
    float4 unity_4LightPosY0;
    float4 unity_4LightPosZ0;
    float4 unity_4LightAtten0;
    float4 unity_LightColor[8];
    float4 unity_LightPosition[8];
    float4 unity_LightAtten[8];
    float4 unity_SpotDirection[8];
    float4 unity_SHAr;
    float4 unity_SHAg;
    float4 unity_SHAb;
    float4 unity_SHBr;
    float4 unity_SHBg;
    float4 unity_SHBb;
    float4 unity_SHC;
    float4 unity_OcclusionMaskSelector;
    float4 unity_ProbesOcclusion;
    float3 unity_LightColor0;
    float3 unity_LightColor1;
    float3 unity_LightColor2;
    float3 unity_LightColor3;
    float4 unity_ShadowSplitSpheres[4];
    float4 unity_ShadowSplitSqRadii;
    float4 unity_LightShadowBias;
    float4 _LightSplitsNear;
    float4 _LightSplitsFar;
    float4 hlslcc_mtx4x4unity_WorldToShadow[16];
    float4 _LightShadowData;
    float4 unity_ShadowFadeCenterAndType;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 unity_LODFade;
    float4 unity_WorldTransformParams;
    float4 unity_RenderingLayer;
    float4 hlslcc_mtx4x4glstate_matrix_transpose_modelview0[4];
    float4 glstate_lightmodel_ambient;
    float4 unity_AmbientSky;
    float4 unity_AmbientEquator;
    float4 unity_AmbientGround;
    float4 unity_IndirectSpecColor;
    float4 hlslcc_mtx4x4glstate_matrix_projection[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixInvV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    int unity_StereoEyeIndex;
    float4 unity_ShadowColor;
    float4 unity_FogColor;
    float4 unity_FogParams;
    float4 unity_LightmapST;
    float4 unity_DynamicLightmapST;
    float4 unity_SpecCube0_BoxMax;
    float4 unity_SpecCube0_BoxMin;
    float4 unity_SpecCube0_ProbePosition;
    float4 unity_SpecCube0_HDR;
    float4 unity_SpecCube1_BoxMax;
    float4 unity_SpecCube1_BoxMin;
    float4 unity_SpecCube1_ProbePosition;
    float4 unity_SpecCube1_HDR;
    float4 unity_ProbeVolumeParams;
    float4 hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[4];
    float3 unity_ProbeVolumeSizeInv;
    float3 unity_ProbeVolumeMin;
    float4 unity_Lightmap_HDR;
    float4 unity_DynamicLightmap_HDR;
    float4 _LightColor0;
    float4 _SpecColor;
    float _Tile;
    float _HeightDisplacement;
    float _NormalScale;
    float4 _ColorTint;
    float _MetallicStrength;
    float _SmoothnessStrength;
    float _EdgeLength;
    bool4 unity_MetaVertexControl;
    bool4 unity_MetaFragmentControl;
    int unity_VisualizationMode;
    float unity_OneOverOutputBoost;
    float unity_MaxOutputValue;
    float unity_UseLinearSpace;
    float4 _texcoord_ST;
};
struct Mtl_HullIn
{
    Mtl_VertexOut cp[3];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
kernel void patchKernel(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn vertexInput [[ stage_in ]],
    uint2 tID [[ thread_position_in_grid ]],
    ushort2 groupID [[ threadgroup_position_in_grid ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    constant Mtl_KernelPatchInfo &patchInfo [[ buffer(3) ]])
{
#pragma clang diagnostic pop
    Mtl_ControlPoint output;
    const uint numPatchesInThreadGroup = 10;
    const uint patchID = (tID.x / patchInfo.numControlPointsPerPatch);
    const bool patchValid = (patchID < patchInfo.numPatches);
    const uint mtl_BaseInstance = 0;
    const uint mtl_InstanceID = groupID.y - mtl_BaseInstance;
    const uint internalPatchID = mtl_InstanceID * patchInfo.numPatches + patchID;
    const uint patchIDInThreadGroup = (patchID % numPatchesInThreadGroup);
    const uint controlPointID = (tID.x % patchInfo.numControlPointsPerPatch);
    const uint mtl_BaseVertex = 0;
    const uint mtl_VertexID = ((mtl_InstanceID * (patchInfo.numControlPointsPerPatch * patchInfo.numPatches)) + tID.x) - mtl_BaseVertex;
    threadgroup Mtl_HullIn inputGroup[numPatchesInThreadGroup];
    threadgroup Mtl_HullIn &input = inputGroup[patchIDInThreadGroup];
    MTLTriangleTessellationFactorsHalf tessFactor;
    if (patchValid) {
        input.cp[controlPointID] = vertexFunction(vertexInput);
        output.INTERNALTESSPOS0 = input.cp[controlPointID].INTERNALTESSPOS0;
        output.TANGENT0 = input.cp[controlPointID].TANGENT0;
        output.NORMAL0 = input.cp[controlPointID].NORMAL0;
        output.TEXCOORD0 = input.cp[controlPointID].TEXCOORD0;
        output.TEXCOORD1 = input.cp[controlPointID].TEXCOORD1;
        output.TEXCOORD2 = input.cp[controlPointID].TEXCOORD2;
        output.TEXCOORD3 = input.cp[controlPointID].TEXCOORD3;
        output.COLOR0 = input.cp[controlPointID].COLOR0;
    }
    threadgroup_barrier(mem_flags::mem_threadgroup);
    if (!patchValid) {
        return;
    }
    float3 u_xlat0;
    float3 u_xlat1;
    float3 u_xlat2;
    float3 u_xlat3;
    float3 u_xlat4;
    float u_xlat12;
    float u_xlat13;
    // fork_phase2
    {
        u_xlat0.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[1].INTERNALTESSPOS0.yyy;
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[1].INTERNALTESSPOS0.xxx, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[1].INTERNALTESSPOS0.zzz, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[1].INTERNALTESSPOS0.www, u_xlat0.xyz);
        u_xlat1.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[2].INTERNALTESSPOS0.yyy;
        u_xlat1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[2].INTERNALTESSPOS0.xxx, u_xlat1.xyz);
        u_xlat1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[2].INTERNALTESSPOS0.zzz, u_xlat1.xyz);
        u_xlat1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[2].INTERNALTESSPOS0.www, u_xlat1.xyz);
        u_xlat2.xyz = u_xlat0.xyz + u_xlat1.xyz;
        u_xlat2.xyz = fma(u_xlat2.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat12 = dot(u_xlat2.xyz, u_xlat2.xyz);
        u_xlat12 = sqrt(u_xlat12);
        u_xlat12 = u_xlat12 * VGlobals._EdgeLength;
        u_xlat2.xyz = u_xlat0.xyz + (-u_xlat1.xyz);
        u_xlat13 = dot(u_xlat2.xyz, u_xlat2.xyz);
        u_xlat13 = sqrt(u_xlat13);
        u_xlat13 = u_xlat13 * VGlobals._ScreenParams.y;
        u_xlat12 = u_xlat13 / u_xlat12;
        tessFactor.edgeTessellationFactor[0] = max(u_xlat12, 1.0);
        u_xlat2.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[0].INTERNALTESSPOS0.yyy;
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[0].INTERNALTESSPOS0.xxx, u_xlat2.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[0].INTERNALTESSPOS0.zzz, u_xlat2.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[0].INTERNALTESSPOS0.www, u_xlat2.xyz);
        u_xlat3.xyz = u_xlat1.xyz + u_xlat2.xyz;
        u_xlat1.xyz = u_xlat1.xyz + (-u_xlat2.xyz);
        u_xlat12 = dot(u_xlat1.xyz, u_xlat1.xyz);
        u_xlat12 = sqrt(u_xlat12);
        u_xlat12 = u_xlat12 * VGlobals._ScreenParams.y;
        u_xlat1.xyz = fma(u_xlat3.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat1.x = dot(u_xlat1.xyz, u_xlat1.xyz);
        u_xlat1.x = sqrt(u_xlat1.x);
        u_xlat1.x = u_xlat1.x * VGlobals._EdgeLength;
        u_xlat12 = u_xlat12 / u_xlat1.x;
        tessFactor.edgeTessellationFactor[1] = max(u_xlat12, 1.0);
        u_xlat1.xyz = u_xlat0.xyz + u_xlat2.xyz;
        u_xlat0.xyz = (-u_xlat0.xyz) + u_xlat2.xyz;
        u_xlat0.x = dot(u_xlat0.xyz, u_xlat0.xyz);
        u_xlat0.x = sqrt(u_xlat0.x);
        u_xlat0.x = u_xlat0.x * VGlobals._ScreenParams.y;
        u_xlat4.xyz = fma(u_xlat1.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat4.x = dot(u_xlat4.xyz, u_xlat4.xyz);
        u_xlat4.x = sqrt(u_xlat4.x);
        u_xlat4.x = u_xlat4.x * VGlobals._EdgeLength;
        u_xlat0.x = u_xlat0.x / u_xlat4.x;
        tessFactor.edgeTessellationFactor[2] = max(u_xlat0.x, 1.0);
    }
    // join_phase3
    {
        u_xlat0.x = tessFactor.edgeTessellationFactor[0] + tessFactor.edgeTessellationFactor[1];
        u_xlat0.x = u_xlat0.x + tessFactor.edgeTessellationFactor[2];
        tessFactor.insideTessellationFactor = u_xlat0.x * 0.333333343;
    }
    controlPoints[mtl_VertexID] = output;
    tessFactors[internalPatchID] = tessFactor;
}
// SHADER_STAGE_HULL_end
// SHADER_STAGE_DOMAIN_begin
struct Mtl_VertexInPostTess
{
    patch_control_point<Mtl_ControlPointIn> cp;
};
struct Mtl_VertexOutPostTess
{
    float4 mtl_Position [[ position ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float4 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float4 TEXCOORD3 [[ user(TEXCOORD3) ]];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    sampler sampler_Height [[ sampler (0) ]],
    texture2d<float, access::sample > _Height [[ texture(0) ]] ,
    float3 mtl_TessCoord [[ position_in_patch ]],
    uint patchID [[ patch_id ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    Mtl_VertexInPostTess input [[ stage_in ]])
{
#pragma clang diagnostic pop
    Mtl_VertexOutPostTess output;
    MTLTriangleTessellationFactorsHalf tessFactor;
    tessFactor = tessFactors[patchID];
    float4 u_xlat0;
    float4 u_xlat1;
    float4 u_xlat2;
    float3 u_xlat3;
    float3 u_xlat4;
    float2 u_xlat13;
    float u_xlat15;
    bool u_xlatb15;
    u_xlat0.xy = mtl_TessCoord.yy * input.cp[1].TEXCOORD2.xy;
    u_xlat0.xy = fma(input.cp[0].TEXCOORD2.xy, mtl_TessCoord.xx, u_xlat0.xy);
    u_xlat0.xy = fma(input.cp[2].TEXCOORD2.xy, mtl_TessCoord.zz, u_xlat0.xy);
    u_xlat0.xy = fma(u_xlat0.xy, VGlobals.unity_DynamicLightmapST.xy, VGlobals.unity_DynamicLightmapST.zw);
    u_xlat1.xy = mtl_TessCoord.yy * input.cp[1].TEXCOORD1.xy;
    u_xlat1.xy = fma(input.cp[0].TEXCOORD1.xy, mtl_TessCoord.xx, u_xlat1.xy);
    u_xlat1.xy = fma(input.cp[2].TEXCOORD1.xy, mtl_TessCoord.zz, u_xlat1.xy);
    u_xlat1.xy = fma(u_xlat1.xy, VGlobals.unity_LightmapST.xy, VGlobals.unity_LightmapST.zw);
    u_xlat2 = mtl_TessCoord.yyyy * input.cp[1].INTERNALTESSPOS0;
    u_xlat2 = fma(input.cp[0].INTERNALTESSPOS0, mtl_TessCoord.xxxx, u_xlat2);
    u_xlat2 = fma(input.cp[2].INTERNALTESSPOS0, mtl_TessCoord.zzzz, u_xlat2);
    u_xlat3.xy = mtl_TessCoord.yy * input.cp[1].TEXCOORD0.xy;
    u_xlat3.xy = fma(input.cp[0].TEXCOORD0.xy, mtl_TessCoord.xx, u_xlat3.xy);
    u_xlat3.xy = fma(input.cp[2].TEXCOORD0.xy, mtl_TessCoord.zz, u_xlat3.xy);
    u_xlat13.xy = u_xlat3.xy * float2(VGlobals._Tile);
    output.TEXCOORD0.xy = fma(u_xlat3.xy, VGlobals._texcoord_ST.xy, VGlobals._texcoord_ST.zw);
    u_xlat3.xyz = _Height.sample(sampler_Height, u_xlat13.xy, level(1.0)).xyz;
    u_xlat4.xyz = mtl_TessCoord.yyy * input.cp[1].NORMAL0.xyz;
    u_xlat4.xyz = fma(input.cp[0].NORMAL0.xyz, mtl_TessCoord.xxx, u_xlat4.xyz);
    u_xlat4.xyz = fma(input.cp[2].NORMAL0.xyz, mtl_TessCoord.zzz, u_xlat4.xyz);
    u_xlat3.xyz = u_xlat3.xyz * u_xlat4.xyz;
    u_xlat2.xyz = fma(u_xlat3.xyz, float3(VGlobals._HeightDisplacement), u_xlat2.xyz);
    u_xlatb15 = 0.0<u_xlat2.z;
    u_xlat1.z = u_xlatb15 ? 9.99999975e-05 : float(0.0);
    u_xlat1.xyz = (VGlobals.unity_MetaVertexControl.x) ? u_xlat1.xyz : u_xlat2.xyz;
    u_xlatb15 = 0.0<u_xlat1.z;
    u_xlat0.z = u_xlatb15 ? 9.99999975e-05 : float(0.0);
    u_xlat0.xyz = (VGlobals.unity_MetaVertexControl.y) ? u_xlat0.xyz : u_xlat1.xyz;
    u_xlat1 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat0.xxxx, u_xlat1);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat0.zzzz, u_xlat1);
    output.mtl_Position = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_MatrixVP[3];
    u_xlat0.xyz = u_xlat2.yyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz;
    u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, u_xlat2.xxx, u_xlat0.xyz);
    u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, u_xlat2.zzz, u_xlat0.xyz);
    u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, u_xlat2.www, u_xlat0.xyz);
    output.TEXCOORD1.w = u_xlat0.x;
    u_xlat1.y = dot(u_xlat4.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat1.z = dot(u_xlat4.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat1.x = dot(u_xlat4.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat0.x = dot(u_xlat1.xyz, u_xlat1.xyz);
    u_xlat0.x = rsqrt(u_xlat0.x);
    u_xlat1.xyz = u_xlat0.xxx * u_xlat1.xyz;
    output.TEXCOORD1.z = u_xlat1.y;
    u_xlat2 = mtl_TessCoord.yyyy * input.cp[1].TANGENT0;
    u_xlat2 = fma(input.cp[0].TANGENT0, mtl_TessCoord.xxxx, u_xlat2);
    u_xlat2 = fma(input.cp[2].TANGENT0, mtl_TessCoord.zzzz, u_xlat2);
    u_xlat3.xyz = u_xlat2.yyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].yzx;
    u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].yzx, u_xlat2.xxx, u_xlat3.xyz);
    u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].yzx, u_xlat2.zzz, u_xlat3.xyz);
    u_xlat0.x = u_xlat2.w * VGlobals.unity_WorldTransformParams.w;
    u_xlat15 = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat15 = rsqrt(u_xlat15);
    u_xlat2.xyz = float3(u_xlat15) * u_xlat2.xyz;
    u_xlat3.xyz = u_xlat1.xyz * u_xlat2.xyz;
    u_xlat3.xyz = fma(u_xlat1.zxy, u_xlat2.yzx, (-u_xlat3.xyz));
    u_xlat3.xyz = u_xlat0.xxx * u_xlat3.xyz;
    output.TEXCOORD1.y = u_xlat3.x;
    output.TEXCOORD1.x = u_xlat2.z;
    output.TEXCOORD2.w = u_xlat0.y;
    output.TEXCOORD3.w = u_xlat0.z;
    output.TEXCOORD2.x = u_xlat2.x;
    output.TEXCOORD3.x = u_xlat2.y;
    output.TEXCOORD2.z = u_xlat1.z;
    output.TEXCOORD3.z = u_xlat1.x;
    output.TEXCOORD2.y = u_xlat3.y;
    output.TEXCOORD3.y = u_xlat3.z;
    return output;
}
// SHADER_STAGE_DOMAIN_end
Refreshing native plugins compatible for Editor in 181.92 ms, found 2 plugins.
Preloading 0 native plugins for Editor in 0.00 ms.
Unloading 3375 Unused Serialized files (Serialized files now loaded: 0)
Unloading 20 unused Assets / (0.6 MB). Loaded Objects now: 3925.
Memory consumption went from 136.5 MB to 135.9 MB.
Total: 6.783977 ms (FindLiveObjects: 0.499378 ms CreateObjectMapping: 0.529881 ms MarkObjects: 5.203752 ms  DeleteObjects: 0.549425 ms)

AssetImportParameters requested are different than current active one (requested -> active):
  custom:video-decoder-ogg-theora: a1e56fd34408186e4bbccfd4996cb3dc -> 
  custom:container-muxer-webm: aa71ff27fc2769a1b78a27578f13a17b -> 
  custom:container-demuxer-webm: 4f35f7cbe854078d1ac9338744f61a02 -> 
  custom:video-encoder-webm-vp8: eb34c28f22e8b96e1ab97ce403110664 -> 
  custom:framework-osx-AVFoundation: b23960f63f64bdc6ff669e2cdcee2391 -> 
  custom:audio-encoder-webm-vorbis: bf7c407c2cedff20999df2af8eb42d56 -> 
  custom:container-demuxer-ogg: 62fdf1f143b41e24485cea50d1cbac27 -> 
  custom:video-decoder-webm-vp8: 9c59270c3fd7afecdb556c50c9e8de78 -> 
  custom:audio-decoder-ogg-vorbis: bf7c407c2cedff20999df2af8eb42d56 -> 
========================================================================
Received Prepare
Registering precompiled user dll's ...
Registered in 0.003464 seconds.
Begin MonoManager ReloadAssembly
Symbol file LoadedFromMemory doesn't match image /Users/kamilaamendolagine/Desktop/Staugen Raug v2 - Prefab - Map 1.01/Library/PackageCache/com.unity.visualscripting@1.7.8/Editor/VisualScripting.Core/Dependencies/YamlDotNet/Unity.VisualScripting.YamlDotNet.dll
Symbol file LoadedFromMemory doesn't match image /Users/kamilaamendolagine/Desktop/Staugen Raug v2 - Prefab - Map 1.01/Library/PackageCache/com.unity.visualscripting@1.7.8/Editor/VisualScripting.Core/Dependencies/DotNetZip/Unity.VisualScripting.IonicZip.dll
Native extension for OSXStandalone target not found
Native extension for WebGL target not found
Refreshing native plugins compatible for Editor in 0.81 ms, found 2 plugins.
Preloading 0 native plugins for Editor in 0.00 ms.
Mono: successfully reloaded assembly
- Completed reload, in  1.679 seconds
Domain Reload Profiling:
	ReloadAssembly (1680ms)
		BeginReloadAssembly (227ms)
			ExecutionOrderSort (0ms)
			DisableScriptedObjects (10ms)
			BackupInstance (0ms)
			ReleaseScriptingObjects (0ms)
			CreateAndSetChildDomain (104ms)
		EndReloadAssembly (1280ms)
			LoadAssemblies (97ms)
			RebuildTransferFunctionScriptingTraits (0ms)
			SetupTypeCache (500ms)
			ReleaseScriptCaches (2ms)
			RebuildScriptCaches (73ms)
			SetupLoadedEditorAssemblies (530ms)
				LogAssemblyErrors (0ms)
				InitializePlatformSupportModulesInManaged (16ms)
				SetLoadedEditorAssemblies (1ms)
				RefreshPlugins (1ms)
				BeforeProcessingInitializeOnLoad (83ms)
				ProcessInitializeOnLoadAttributes (388ms)
				ProcessInitializeOnLoadMethodAttributes (38ms)
				AfterProcessingInitializeOnLoad (4ms)
				EditorAssembliesLoaded (0ms)
			ExecutionOrderSort2 (0ms)
			AwakeInstancesAfterBackupRestoration (7ms)
Platform modules already initialized, skipping
Compilation succeeded with: 

program_source:299:53: warning: writable resources in non-void post-tessellation vertex function
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
                                                    ^
program_source:305:30: note: writable buffer defined here
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
                             ^
program_source:306:48: note: writable buffer defined here
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
                                               ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float4 TEXCOORD0 [[ attribute(3) ]] ;
    float4 TEXCOORD1 [[ attribute(4) ]] ;
    float4 TEXCOORD2 [[ attribute(5) ]] ;
    float4 TEXCOORD3 [[ attribute(6) ]] ;
    float4 COLOR0 [[ attribute(7) ]] ;
};
struct Mtl_VertexOut
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float4 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float4 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float4 TEXCOORD3 [[ user(TEXCOORD3) ]];
    float4 COLOR0 [[ user(COLOR0) ]];
};
static Mtl_VertexOut vertexFunction(
    Mtl_VertexIn input)
{
    Mtl_VertexOut output;
    output.INTERNALTESSPOS0 = input.POSITION0;
    output.TANGENT0 = input.TANGENT0;
    output.NORMAL0.xyz = input.NORMAL0.xyz;
    output.TEXCOORD0 = input.TEXCOORD0;
    output.TEXCOORD1 = input.TEXCOORD1;
    output.TEXCOORD2 = input.TEXCOORD2;
    output.TEXCOORD3 = input.TEXCOORD3;
    output.COLOR0 = input.COLOR0;
    return output;
}
// SHADER_STAGE_HULL_begin
struct Mtl_ControlPoint
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float4 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float4 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float4 TEXCOORD3 [[ user(TEXCOORD3) ]];
    float4 COLOR0 [[ user(COLOR0) ]];
};
struct Mtl_ControlPointIn
{
    float4 INTERNALTESSPOS0 [[ attribute(8) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float4 TEXCOORD0 [[ attribute(3) ]] ;
    float4 TEXCOORD1 [[ attribute(4) ]] ;
    float4 TEXCOORD2 [[ attribute(5) ]] ;
    float4 TEXCOORD3 [[ attribute(6) ]] ;
    float4 COLOR0 [[ attribute(7) ]] ;
};
struct Mtl_KernelPatchInfo
{
    uint numPatches;
    ushort numControlPointsPerPatch;
};
struct VGlobals_Type
{
    float4 _Time;
    float4 _SinTime;
    float4 _CosTime;
    float4 unity_DeltaTime;
    float3 _WorldSpaceCameraPos;
    float4 _ProjectionParams;
    float4 _ScreenParams;
    float4 _ZBufferParams;
    float4 unity_OrthoParams;
    float4 unity_CameraWorldClipPlanes[6];
    float4 hlslcc_mtx4x4unity_CameraProjection[4];
    float4 hlslcc_mtx4x4unity_CameraInvProjection[4];
    float4 hlslcc_mtx4x4unity_WorldToCamera[4];
    float4 hlslcc_mtx4x4unity_CameraToWorld[4];
    float4 _WorldSpaceLightPos0;
    float4 _LightPositionRange;
    float4 _LightProjectionParams;
    float4 unity_4LightPosX0;
    float4 unity_4LightPosY0;
    float4 unity_4LightPosZ0;
    float4 unity_4LightAtten0;
    float4 unity_LightColor[8];
    float4 unity_LightPosition[8];
    float4 unity_LightAtten[8];
    float4 unity_SpotDirection[8];
    float4 unity_SHAr;
    float4 unity_SHAg;
    float4 unity_SHAb;
    float4 unity_SHBr;
    float4 unity_SHBg;
    float4 unity_SHBb;
    float4 unity_SHC;
    float4 unity_OcclusionMaskSelector;
    float4 unity_ProbesOcclusion;
    float3 unity_LightColor0;
    float3 unity_LightColor1;
    float3 unity_LightColor2;
    float3 unity_LightColor3;
    float4 unity_ShadowSplitSpheres[4];
    float4 unity_ShadowSplitSqRadii;
    float4 unity_LightShadowBias;
    float4 _LightSplitsNear;
    float4 _LightSplitsFar;
    float4 hlslcc_mtx4x4unity_WorldToShadow[16];
    float4 _LightShadowData;
    float4 unity_ShadowFadeCenterAndType;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 unity_LODFade;
    float4 unity_WorldTransformParams;
    float4 unity_RenderingLayer;
    float4 hlslcc_mtx4x4glstate_matrix_transpose_modelview0[4];
    float4 glstate_lightmodel_ambient;
    float4 unity_AmbientSky;
    float4 unity_AmbientEquator;
    float4 unity_AmbientGround;
    float4 unity_IndirectSpecColor;
    float4 hlslcc_mtx4x4glstate_matrix_projection[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixInvV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    int unity_StereoEyeIndex;
    float4 unity_ShadowColor;
    float4 unity_FogColor;
    float4 unity_FogParams;
    float4 unity_LightmapST;
    float4 unity_DynamicLightmapST;
    float4 unity_SpecCube0_BoxMax;
    float4 unity_SpecCube0_BoxMin;
    float4 unity_SpecCube0_ProbePosition;
    float4 unity_SpecCube0_HDR;
    float4 unity_SpecCube1_BoxMax;
    float4 unity_SpecCube1_BoxMin;
    float4 unity_SpecCube1_ProbePosition;
    float4 unity_SpecCube1_HDR;
    float4 unity_ProbeVolumeParams;
    float4 hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[4];
    float3 unity_ProbeVolumeSizeInv;
    float3 unity_ProbeVolumeMin;
    float4 unity_Lightmap_HDR;
    float4 unity_DynamicLightmap_HDR;
    float4 _LightColor0;
    float4 _SpecColor;
    float _Tile;
    float _HeightDisplacement;
    float _NormalScale;
    float4 _ColorTint;
    float _MetallicStrength;
    float _SmoothnessStrength;
    float _EdgeLength;
    float4 _texcoord_ST;
};
struct Mtl_HullIn
{
    Mtl_VertexOut cp[3];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
kernel void patchKernel(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn vertexInput [[ stage_in ]],
    uint2 tID [[ thread_position_in_grid ]],
    ushort2 groupID [[ threadgroup_position_in_grid ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    constant Mtl_KernelPatchInfo &patchInfo [[ buffer(3) ]])
{
#pragma clang diagnostic pop
    Mtl_ControlPoint output;
    const uint numPatchesInThreadGroup = 10;
    const uint patchID = (tID.x / patchInfo.numControlPointsPerPatch);
    const bool patchValid = (patchID < patchInfo.numPatches);
    const uint mtl_BaseInstance = 0;
    const uint mtl_InstanceID = groupID.y - mtl_BaseInstance;
    const uint internalPatchID = mtl_InstanceID * patchInfo.numPatches + patchID;
    const uint patchIDInThreadGroup = (patchID % numPatchesInThreadGroup);
    const uint controlPointID = (tID.x % patchInfo.numControlPointsPerPatch);
    const uint mtl_BaseVertex = 0;
    const uint mtl_VertexID = ((mtl_InstanceID * (patchInfo.numControlPointsPerPatch * patchInfo.numPatches)) + tID.x) - mtl_BaseVertex;
    threadgroup Mtl_HullIn inputGroup[numPatchesInThreadGroup];
    threadgroup Mtl_HullIn &input = inputGroup[patchIDInThreadGroup];
    MTLTriangleTessellationFactorsHalf tessFactor;
    if (patchValid) {
        input.cp[controlPointID] = vertexFunction(vertexInput);
        output.INTERNALTESSPOS0 = input.cp[controlPointID].INTERNALTESSPOS0;
        output.TANGENT0 = input.cp[controlPointID].TANGENT0;
        output.NORMAL0 = input.cp[controlPointID].NORMAL0;
        output.TEXCOORD0 = input.cp[controlPointID].TEXCOORD0;
        output.TEXCOORD1 = input.cp[controlPointID].TEXCOORD1;
        output.TEXCOORD2 = input.cp[controlPointID].TEXCOORD2;
        output.TEXCOORD3 = input.cp[controlPointID].TEXCOORD3;
        output.COLOR0 = input.cp[controlPointID].COLOR0;
    }
    threadgroup_barrier(mem_flags::mem_threadgroup);
    if (!patchValid) {
        return;
    }
    float3 u_xlat0;
    float3 u_xlat1;
    float3 u_xlat2;
    float3 u_xlat3;
    float3 u_xlat4;
    float u_xlat12;
    float u_xlat13;
    // fork_phase2
    {
        u_xlat0.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[1].INTERNALTESSPOS0.yyy;
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[1].INTERNALTESSPOS0.xxx, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[1].INTERNALTESSPOS0.zzz, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[1].INTERNALTESSPOS0.www, u_xlat0.xyz);
        u_xlat1.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[2].INTERNALTESSPOS0.yyy;
        u_xlat1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[2].INTERNALTESSPOS0.xxx, u_xlat1.xyz);
        u_xlat1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[2].INTERNALTESSPOS0.zzz, u_xlat1.xyz);
        u_xlat1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[2].INTERNALTESSPOS0.www, u_xlat1.xyz);
        u_xlat2.xyz = u_xlat0.xyz + u_xlat1.xyz;
        u_xlat2.xyz = fma(u_xlat2.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat12 = dot(u_xlat2.xyz, u_xlat2.xyz);
        u_xlat12 = sqrt(u_xlat12);
        u_xlat12 = u_xlat12 * VGlobals._EdgeLength;
        u_xlat2.xyz = u_xlat0.xyz + (-u_xlat1.xyz);
        u_xlat13 = dot(u_xlat2.xyz, u_xlat2.xyz);
        u_xlat13 = sqrt(u_xlat13);
        u_xlat13 = u_xlat13 * VGlobals._ScreenParams.y;
        u_xlat12 = u_xlat13 / u_xlat12;
        tessFactor.edgeTessellationFactor[0] = max(u_xlat12, 1.0);
        u_xlat2.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[0].INTERNALTESSPOS0.yyy;
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[0].INTERNALTESSPOS0.xxx, u_xlat2.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[0].INTERNALTESSPOS0.zzz, u_xlat2.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[0].INTERNALTESSPOS0.www, u_xlat2.xyz);
        u_xlat3.xyz = u_xlat1.xyz + u_xlat2.xyz;
        u_xlat1.xyz = u_xlat1.xyz + (-u_xlat2.xyz);
        u_xlat12 = dot(u_xlat1.xyz, u_xlat1.xyz);
        u_xlat12 = sqrt(u_xlat12);
        u_xlat12 = u_xlat12 * VGlobals._ScreenParams.y;
        u_xlat1.xyz = fma(u_xlat3.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat1.x = dot(u_xlat1.xyz, u_xlat1.xyz);
        u_xlat1.x = sqrt(u_xlat1.x);
        u_xlat1.x = u_xlat1.x * VGlobals._EdgeLength;
        u_xlat12 = u_xlat12 / u_xlat1.x;
        tessFactor.edgeTessellationFactor[1] = max(u_xlat12, 1.0);
        u_xlat1.xyz = u_xlat0.xyz + u_xlat2.xyz;
        u_xlat0.xyz = (-u_xlat0.xyz) + u_xlat2.xyz;
        u_xlat0.x = dot(u_xlat0.xyz, u_xlat0.xyz);
        u_xlat0.x = sqrt(u_xlat0.x);
        u_xlat0.x = u_xlat0.x * VGlobals._ScreenParams.y;
        u_xlat4.xyz = fma(u_xlat1.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat4.x = dot(u_xlat4.xyz, u_xlat4.xyz);
        u_xlat4.x = sqrt(u_xlat4.x);
        u_xlat4.x = u_xlat4.x * VGlobals._EdgeLength;
        u_xlat0.x = u_xlat0.x / u_xlat4.x;
        tessFactor.edgeTessellationFactor[2] = max(u_xlat0.x, 1.0);
    }
    // join_phase3
    {
        u_xlat0.x = tessFactor.edgeTessellationFactor[0] + tessFactor.edgeTessellationFactor[1];
        u_xlat0.x = u_xlat0.x + tessFactor.edgeTessellationFactor[2];
        tessFactor.insideTessellationFactor = u_xlat0.x * 0.333333343;
    }
    controlPoints[mtl_VertexID] = output;
    tessFactors[internalPatchID] = tessFactor;
}
// SHADER_STAGE_HULL_end
// SHADER_STAGE_DOMAIN_begin
struct Mtl_VertexInPostTess
{
    patch_control_point<Mtl_ControlPointIn> cp;
};
struct Mtl_VertexOutPostTess
{
    float4 mtl_Position [[ position ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float4 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float4 TEXCOORD3 [[ user(TEXCOORD3) ]];
    float4 TEXCOORD6 [[ user(TEXCOORD6) ]];
    float4 TEXCOORD7 [[ user(TEXCOORD7) ]];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    sampler sampler_Height [[ sampler (0) ]],
    texture2d<float, access::sample > _Height [[ texture(0) ]] ,
    float3 mtl_TessCoord [[ position_in_patch ]],
    uint patchID [[ patch_id ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    Mtl_VertexInPostTess input [[ stage_in ]])
{
#pragma clang diagnostic pop
    Mtl_VertexOutPostTess output;
    MTLTriangleTessellationFactorsHalf tessFactor;
    tessFactor = tessFactors[patchID];
    float4 u_xlat0;
    float4 u_xlat1;
    float4 u_xlat2;
    float4 u_xlat3;
    float2 u_xlat9;
    float u_xlat12;
    float u_xlat13;
    u_xlat0 = mtl_TessCoord.yyyy * input.cp[1].INTERNALTESSPOS0;
    u_xlat0 = fma(input.cp[0].INTERNALTESSPOS0, mtl_TessCoord.xxxx, u_xlat0);
    u_xlat0 = fma(input.cp[2].INTERNALTESSPOS0, mtl_TessCoord.zzzz, u_xlat0);
    u_xlat1.xy = mtl_TessCoord.yy * input.cp[1].TEXCOORD0.xy;
    u_xlat1.xy = fma(input.cp[0].TEXCOORD0.xy, mtl_TessCoord.xx, u_xlat1.xy);
    u_xlat1.xy = fma(input.cp[2].TEXCOORD0.xy, mtl_TessCoord.zz, u_xlat1.xy);
    u_xlat9.xy = u_xlat1.xy * float2(VGlobals._Tile);
    output.TEXCOORD0.xy = fma(u_xlat1.xy, VGlobals._texcoord_ST.xy, VGlobals._texcoord_ST.zw);
    u_xlat1.xyz = _Height.sample(sampler_Height, u_xlat9.xy, level(1.0)).xyz;
    u_xlat2.xyz = mtl_TessCoord.yyy * input.cp[1].NORMAL0.xyz;
    u_xlat2.xyz = fma(input.cp[0].NORMAL0.xyz, mtl_TessCoord.xxx, u_xlat2.xyz);
    u_xlat2.xyz = fma(input.cp[2].NORMAL0.xyz, mtl_TessCoord.zzz, u_xlat2.xyz);
    u_xlat1.xyz = u_xlat1.xyz * u_xlat2.xyz;
    u_xlat0.xyz = fma(u_xlat1.xyz, float3(VGlobals._HeightDisplacement), u_xlat0.xyz);
    u_xlat1 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], u_xlat0.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], u_xlat0.zzzz, u_xlat1);
    u_xlat3 = u_xlat1 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, u_xlat0.www, u_xlat1.xyz);
    u_xlat1 = u_xlat3.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat3.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat3.zzzz, u_xlat1);
    output.mtl_Position = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat3.wwww, u_xlat1);
    u_xlat1.y = dot(u_xlat2.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat1.z = dot(u_xlat2.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat1.x = dot(u_xlat2.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat12 = dot(u_xlat1.xyz, u_xlat1.xyz);
    u_xlat12 = rsqrt(u_xlat12);
    u_xlat1.xyz = float3(u_xlat12) * u_xlat1.xyz;
    output.TEXCOORD1.z = u_xlat1.y;
    u_xlat2 = mtl_TessCoord.yyyy * input.cp[1].TANGENT0;
    u_xlat2 = fma(input.cp[0].TANGENT0, mtl_TessCoord.xxxx, u_xlat2);
    u_xlat2 = fma(input.cp[2].TANGENT0, mtl_TessCoord.zzzz, u_xlat2);
    u_xlat3.xyz = u_xlat2.yyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].yzx;
    u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].yzx, u_xlat2.xxx, u_xlat3.xyz);
    u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].yzx, u_xlat2.zzz, u_xlat3.xyz);
    u_xlat12 = u_xlat2.w * VGlobals.unity_WorldTransformParams.w;
    u_xlat13 = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat13 = rsqrt(u_xlat13);
    u_xlat2.xyz = float3(u_xlat13) * u_xlat2.xyz;
    u_xlat3.xyz = u_xlat1.xyz * u_xlat2.xyz;
    u_xlat3.xyz = fma(u_xlat1.zxy, u_xlat2.yzx, (-u_xlat3.xyz));
    u_xlat3.xyz = float3(u_xlat12) * u_xlat3.xyz;
    output.TEXCOORD1.y = u_xlat3.x;
    output.TEXCOORD1.w = u_xlat0.x;
    output.TEXCOORD1.x = u_xlat2.z;
    output.TEXCOORD2.w = u_xlat0.y;
    output.TEXCOORD3.w = u_xlat0.z;
    output.TEXCOORD2.x = u_xlat2.x;
    output.TEXCOORD3.x = u_xlat2.y;
    output.TEXCOORD2.z = u_xlat1.z;
    output.TEXCOORD3.z = u_xlat1.x;
    output.TEXCOORD2.y = u_xlat3.y;
    output.TEXCOORD3.y = u_xlat3.z;
    output.TEXCOORD6 = float4(0.0, 0.0, 0.0, 0.0);
    output.TEXCOORD7 = float4(0.0, 0.0, 0.0, 0.0);
    return output;
}
// SHADER_STAGE_DOMAIN_end
Compilation succeeded with: 

program_source:301:53: warning: writable resources in non-void post-tessellation vertex function
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
                                                    ^
program_source:307:30: note: writable buffer defined here
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
                             ^
program_source:308:48: note: writable buffer defined here
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
                                               ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float4 TEXCOORD0 [[ attribute(3) ]] ;
    float4 TEXCOORD1 [[ attribute(4) ]] ;
    float4 TEXCOORD2 [[ attribute(5) ]] ;
    float4 TEXCOORD3 [[ attribute(6) ]] ;
    float4 COLOR0 [[ attribute(7) ]] ;
};
struct Mtl_VertexOut
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float4 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float4 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float4 TEXCOORD3 [[ user(TEXCOORD3) ]];
    float4 COLOR0 [[ user(COLOR0) ]];
};
static Mtl_VertexOut vertexFunction(
    Mtl_VertexIn input)
{
    Mtl_VertexOut output;
    output.INTERNALTESSPOS0 = input.POSITION0;
    output.TANGENT0 = input.TANGENT0;
    output.NORMAL0.xyz = input.NORMAL0.xyz;
    output.TEXCOORD0 = input.TEXCOORD0;
    output.TEXCOORD1 = input.TEXCOORD1;
    output.TEXCOORD2 = input.TEXCOORD2;
    output.TEXCOORD3 = input.TEXCOORD3;
    output.COLOR0 = input.COLOR0;
    return output;
}
// SHADER_STAGE_HULL_begin
struct Mtl_ControlPoint
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float4 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float4 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float4 TEXCOORD3 [[ user(TEXCOORD3) ]];
    float4 COLOR0 [[ user(COLOR0) ]];
};
struct Mtl_ControlPointIn
{
    float4 INTERNALTESSPOS0 [[ attribute(8) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float4 TEXCOORD0 [[ attribute(3) ]] ;
    float4 TEXCOORD1 [[ attribute(4) ]] ;
    float4 TEXCOORD2 [[ attribute(5) ]] ;
    float4 TEXCOORD3 [[ attribute(6) ]] ;
    float4 COLOR0 [[ attribute(7) ]] ;
};
struct Mtl_KernelPatchInfo
{
    uint numPatches;
    ushort numControlPointsPerPatch;
};
struct VGlobals_Type
{
    float4 _Time;
    float4 _SinTime;
    float4 _CosTime;
    float4 unity_DeltaTime;
    float3 _WorldSpaceCameraPos;
    float4 _ProjectionParams;
    float4 _ScreenParams;
    float4 _ZBufferParams;
    float4 unity_OrthoParams;
    float4 unity_CameraWorldClipPlanes[6];
    float4 hlslcc_mtx4x4unity_CameraProjection[4];
    float4 hlslcc_mtx4x4unity_CameraInvProjection[4];
    float4 hlslcc_mtx4x4unity_WorldToCamera[4];
    float4 hlslcc_mtx4x4unity_CameraToWorld[4];
    float4 _WorldSpaceLightPos0;
    float4 _LightPositionRange;
    float4 _LightProjectionParams;
    float4 unity_4LightPosX0;
    float4 unity_4LightPosY0;
    float4 unity_4LightPosZ0;
    float4 unity_4LightAtten0;
    float4 unity_LightColor[8];
    float4 unity_LightPosition[8];
    float4 unity_LightAtten[8];
    float4 unity_SpotDirection[8];
    float4 unity_SHAr;
    float4 unity_SHAg;
    float4 unity_SHAb;
    float4 unity_SHBr;
    float4 unity_SHBg;
    float4 unity_SHBb;
    float4 unity_SHC;
    float4 unity_OcclusionMaskSelector;
    float4 unity_ProbesOcclusion;
    float3 unity_LightColor0;
    float3 unity_LightColor1;
    float3 unity_LightColor2;
    float3 unity_LightColor3;
    float4 unity_ShadowSplitSpheres[4];
    float4 unity_ShadowSplitSqRadii;
    float4 unity_LightShadowBias;
    float4 _LightSplitsNear;
    float4 _LightSplitsFar;
    float4 hlslcc_mtx4x4unity_WorldToShadow[16];
    float4 _LightShadowData;
    float4 unity_ShadowFadeCenterAndType;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 unity_LODFade;
    float4 unity_WorldTransformParams;
    float4 unity_RenderingLayer;
    float4 hlslcc_mtx4x4glstate_matrix_transpose_modelview0[4];
    float4 glstate_lightmodel_ambient;
    float4 unity_AmbientSky;
    float4 unity_AmbientEquator;
    float4 unity_AmbientGround;
    float4 unity_IndirectSpecColor;
    float4 hlslcc_mtx4x4glstate_matrix_projection[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixInvV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    int unity_StereoEyeIndex;
    float4 unity_ShadowColor;
    float4 unity_FogColor;
    float4 unity_FogParams;
    float4 unity_LightmapST;
    float4 unity_DynamicLightmapST;
    float4 unity_SpecCube0_BoxMax;
    float4 unity_SpecCube0_BoxMin;
    float4 unity_SpecCube0_ProbePosition;
    float4 unity_SpecCube0_HDR;
    float4 unity_SpecCube1_BoxMax;
    float4 unity_SpecCube1_BoxMin;
    float4 unity_SpecCube1_ProbePosition;
    float4 unity_SpecCube1_HDR;
    float4 unity_ProbeVolumeParams;
    float4 hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[4];
    float3 unity_ProbeVolumeSizeInv;
    float3 unity_ProbeVolumeMin;
    float4 unity_Lightmap_HDR;
    float4 unity_DynamicLightmap_HDR;
    float4 _LightColor0;
    float4 _SpecColor;
    float4 hlslcc_mtx4x4unity_WorldToLight[4];
    float _Tile;
    float _HeightDisplacement;
    float _NormalScale;
    float4 _ColorTint;
    float _MetallicStrength;
    float _SmoothnessStrength;
    float _EdgeLength;
    float4 _texcoord_ST;
};
struct Mtl_HullIn
{
    Mtl_VertexOut cp[3];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
kernel void patchKernel(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn vertexInput [[ stage_in ]],
    uint2 tID [[ thread_position_in_grid ]],
    ushort2 groupID [[ threadgroup_position_in_grid ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    constant Mtl_KernelPatchInfo &patchInfo [[ buffer(3) ]])
{
#pragma clang diagnostic pop
    Mtl_ControlPoint output;
    const uint numPatchesInThreadGroup = 10;
    const uint patchID = (tID.x / patchInfo.numControlPointsPerPatch);
    const bool patchValid = (patchID < patchInfo.numPatches);
    const uint mtl_BaseInstance = 0;
    const uint mtl_InstanceID = groupID.y - mtl_BaseInstance;
    const uint internalPatchID = mtl_InstanceID * patchInfo.numPatches + patchID;
    const uint patchIDInThreadGroup = (patchID % numPatchesInThreadGroup);
    const uint controlPointID = (tID.x % patchInfo.numControlPointsPerPatch);
    const uint mtl_BaseVertex = 0;
    const uint mtl_VertexID = ((mtl_InstanceID * (patchInfo.numControlPointsPerPatch * patchInfo.numPatches)) + tID.x) - mtl_BaseVertex;
    threadgroup Mtl_HullIn inputGroup[numPatchesInThreadGroup];
    threadgroup Mtl_HullIn &input = inputGroup[patchIDInThreadGroup];
    MTLTriangleTessellationFactorsHalf tessFactor;
    if (patchValid) {
        input.cp[controlPointID] = vertexFunction(vertexInput);
        output.INTERNALTESSPOS0 = input.cp[controlPointID].INTERNALTESSPOS0;
        output.TANGENT0 = input.cp[controlPointID].TANGENT0;
        output.NORMAL0 = input.cp[controlPointID].NORMAL0;
        output.TEXCOORD0 = input.cp[controlPointID].TEXCOORD0;
        output.TEXCOORD1 = input.cp[controlPointID].TEXCOORD1;
        output.TEXCOORD2 = input.cp[controlPointID].TEXCOORD2;
        output.TEXCOORD3 = input.cp[controlPointID].TEXCOORD3;
        output.COLOR0 = input.cp[controlPointID].COLOR0;
    }
    threadgroup_barrier(mem_flags::mem_threadgroup);
    if (!patchValid) {
        return;
    }
    float3 u_xlat0;
    float3 u_xlat1;
    float3 u_xlat2;
    float3 u_xlat3;
    float3 u_xlat4;
    float u_xlat12;
    float u_xlat13;
    // fork_phase2
    {
        u_xlat0.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[1].INTERNALTESSPOS0.yyy;
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[1].INTERNALTESSPOS0.xxx, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[1].INTERNALTESSPOS0.zzz, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[1].INTERNALTESSPOS0.www, u_xlat0.xyz);
        u_xlat1.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[2].INTERNALTESSPOS0.yyy;
        u_xlat1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[2].INTERNALTESSPOS0.xxx, u_xlat1.xyz);
        u_xlat1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[2].INTERNALTESSPOS0.zzz, u_xlat1.xyz);
        u_xlat1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[2].INTERNALTESSPOS0.www, u_xlat1.xyz);
        u_xlat2.xyz = u_xlat0.xyz + u_xlat1.xyz;
        u_xlat2.xyz = fma(u_xlat2.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat12 = dot(u_xlat2.xyz, u_xlat2.xyz);
        u_xlat12 = sqrt(u_xlat12);
        u_xlat12 = u_xlat12 * VGlobals._EdgeLength;
        u_xlat2.xyz = u_xlat0.xyz + (-u_xlat1.xyz);
        u_xlat13 = dot(u_xlat2.xyz, u_xlat2.xyz);
        u_xlat13 = sqrt(u_xlat13);
        u_xlat13 = u_xlat13 * VGlobals._ScreenParams.y;
        u_xlat12 = u_xlat13 / u_xlat12;
        tessFactor.edgeTessellationFactor[0] = max(u_xlat12, 1.0);
        u_xlat2.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[0].INTERNALTESSPOS0.yyy;
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[0].INTERNALTESSPOS0.xxx, u_xlat2.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[0].INTERNALTESSPOS0.zzz, u_xlat2.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[0].INTERNALTESSPOS0.www, u_xlat2.xyz);
        u_xlat3.xyz = u_xlat1.xyz + u_xlat2.xyz;
        u_xlat1.xyz = u_xlat1.xyz + (-u_xlat2.xyz);
        u_xlat12 = dot(u_xlat1.xyz, u_xlat1.xyz);
        u_xlat12 = sqrt(u_xlat12);
        u_xlat12 = u_xlat12 * VGlobals._ScreenParams.y;
        u_xlat1.xyz = fma(u_xlat3.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat1.x = dot(u_xlat1.xyz, u_xlat1.xyz);
        u_xlat1.x = sqrt(u_xlat1.x);
        u_xlat1.x = u_xlat1.x * VGlobals._EdgeLength;
        u_xlat12 = u_xlat12 / u_xlat1.x;
        tessFactor.edgeTessellationFactor[1] = max(u_xlat12, 1.0);
        u_xlat1.xyz = u_xlat0.xyz + u_xlat2.xyz;
        u_xlat0.xyz = (-u_xlat0.xyz) + u_xlat2.xyz;
        u_xlat0.x = dot(u_xlat0.xyz, u_xlat0.xyz);
        u_xlat0.x = sqrt(u_xlat0.x);
        u_xlat0.x = u_xlat0.x * VGlobals._ScreenParams.y;
        u_xlat4.xyz = fma(u_xlat1.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat4.x = dot(u_xlat4.xyz, u_xlat4.xyz);
        u_xlat4.x = sqrt(u_xlat4.x);
        u_xlat4.x = u_xlat4.x * VGlobals._EdgeLength;
        u_xlat0.x = u_xlat0.x / u_xlat4.x;
        tessFactor.edgeTessellationFactor[2] = max(u_xlat0.x, 1.0);
    }
    // join_phase3
    {
        u_xlat0.x = tessFactor.edgeTessellationFactor[0] + tessFactor.edgeTessellationFactor[1];
        u_xlat0.x = u_xlat0.x + tessFactor.edgeTessellationFactor[2];
        tessFactor.insideTessellationFactor = u_xlat0.x * 0.333333343;
    }
    controlPoints[mtl_VertexID] = output;
    tessFactors[internalPatchID] = tessFactor;
}
// SHADER_STAGE_HULL_end
// SHADER_STAGE_DOMAIN_begin
struct Mtl_VertexInPostTess
{
    patch_control_point<Mtl_ControlPointIn> cp;
};
struct Mtl_VertexOutPostTess
{
    float4 mtl_Position [[ position ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float3 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float3 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float3 TEXCOORD3 [[ user(TEXCOORD3) ]];
    float3 TEXCOORD4 [[ user(TEXCOORD4) ]];
    float3 TEXCOORD5 [[ user(TEXCOORD5) ]];
    float4 TEXCOORD6 [[ user(TEXCOORD6) ]];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    sampler sampler_Height [[ sampler (0) ]],
    texture2d<float, access::sample > _Height [[ texture(0) ]] ,
    float3 mtl_TessCoord [[ position_in_patch ]],
    uint patchID [[ patch_id ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    Mtl_VertexInPostTess input [[ stage_in ]])
{
#pragma clang diagnostic pop
    Mtl_VertexOutPostTess output;
    MTLTriangleTessellationFactorsHalf tessFactor;
    tessFactor = tessFactors[patchID];
    float4 u_xlat0;
    float3 u_xlat1;
    float4 u_xlat2;
    float4 u_xlat3;
    float4 u_xlat4;
    float2 u_xlat10;
    float u_xlat16;
    u_xlat0.xy = mtl_TessCoord.yy * input.cp[1].TEXCOORD0.xy;
    u_xlat0.xy = fma(input.cp[0].TEXCOORD0.xy, mtl_TessCoord.xx, u_xlat0.xy);
    u_xlat0.xy = fma(input.cp[2].TEXCOORD0.xy, mtl_TessCoord.zz, u_xlat0.xy);
    u_xlat10.xy = u_xlat0.xy * float2(VGlobals._Tile);
    output.TEXCOORD0.xy = fma(u_xlat0.xy, VGlobals._texcoord_ST.xy, VGlobals._texcoord_ST.zw);
    u_xlat0.xyz = _Height.sample(sampler_Height, u_xlat10.xy, level(1.0)).xyz;
    u_xlat1.xyz = mtl_TessCoord.yyy * input.cp[1].NORMAL0.xyz;
    u_xlat1.xyz = fma(input.cp[0].NORMAL0.xyz, mtl_TessCoord.xxx, u_xlat1.xyz);
    u_xlat1.xyz = fma(input.cp[2].NORMAL0.xyz, mtl_TessCoord.zzz, u_xlat1.xyz);
    u_xlat0.xyz = u_xlat0.xyz * u_xlat1.xyz;
    u_xlat2 = mtl_TessCoord.yyyy * input.cp[1].INTERNALTESSPOS0;
    u_xlat2 = fma(input.cp[0].INTERNALTESSPOS0, mtl_TessCoord.xxxx, u_xlat2);
    u_xlat2 = fma(input.cp[2].INTERNALTESSPOS0, mtl_TessCoord.zzzz, u_xlat2);
    u_xlat0.xyz = fma(u_xlat0.xyz, float3(VGlobals._HeightDisplacement), u_xlat2.xyz);
    u_xlat3 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], u_xlat0.xxxx, u_xlat3);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], u_xlat0.zzzz, u_xlat3);
    u_xlat3 = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat4 = u_xlat3.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat4 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat3.xxxx, u_xlat4);
    u_xlat4 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat3.zzzz, u_xlat4);
    output.mtl_Position = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat3.wwww, u_xlat4);
    u_xlat2.y = dot(u_xlat1.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat2.z = dot(u_xlat1.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat2.x = dot(u_xlat1.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat1.x = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat1.x = rsqrt(u_xlat1.x);
    u_xlat1.xyz = u_xlat1.xxx * u_xlat2.xyz;
    output.TEXCOORD1.z = u_xlat1.y;
    u_xlat3 = mtl_TessCoord.yyyy * input.cp[1].TANGENT0;
    u_xlat3 = fma(input.cp[0].TANGENT0, mtl_TessCoord.xxxx, u_xlat3);
    u_xlat3 = fma(input.cp[2].TANGENT0, mtl_TessCoord.zzzz, u_xlat3);
    u_xlat2.xyz = u_xlat3.yyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].yzx;
    u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].yzx, u_xlat3.xxx, u_xlat2.xyz);
    u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].yzx, u_xlat3.zzz, u_xlat2.xyz);
    u_xlat16 = u_xlat3.w * VGlobals.unity_WorldTransformParams.w;
    u_xlat3.x = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat3.x = rsqrt(u_xlat3.x);
    u_xlat2.xyz = u_xlat2.xyz * u_xlat3.xxx;
    u_xlat3.xyz = u_xlat1.xyz * u_xlat2.xyz;
    u_xlat3.xyz = fma(u_xlat1.zxy, u_xlat2.yzx, (-u_xlat3.xyz));
    u_xlat3.xyz = float3(u_xlat16) * u_xlat3.xyz;
    output.TEXCOORD1.y = u_xlat3.x;
    output.TEXCOORD1.x = u_xlat2.z;
    output.TEXCOORD2.x = u_xlat2.x;
    output.TEXCOORD3.x = u_xlat2.y;
    output.TEXCOORD2.z = u_xlat1.z;
    output.TEXCOORD3.z = u_xlat1.x;
    output.TEXCOORD2.y = u_xlat3.y;
    output.TEXCOORD3.y = u_xlat3.z;
    output.TEXCOORD4.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, u_xlat2.www, u_xlat0.xyz);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3], u_xlat2.wwww, u_xlat0);
    u_xlat1.xyz = u_xlat0.yyy * VGlobals.hlslcc_mtx4x4unity_WorldToLight[1].xyz;
    u_xlat1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_WorldToLight[0].xyz, u_xlat0.xxx, u_xlat1.xyz);
    u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_WorldToLight[2].xyz, u_xlat0.zzz, u_xlat1.xyz);
    output.TEXCOORD5.xyz = fma(VGlobals.hlslcc_mtx4x4unity_WorldToLight[3].xyz, u_xlat0.www, u_xlat0.xyz);
    output.TEXCOORD6 = float4(0.0, 0.0, 0.0, 0.0);
    return output;
}
// SHADER_STAGE_DOMAIN_end
Compilation succeeded with: 

program_source:293:53: warning: writable resources in non-void post-tessellation vertex function
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
                                                    ^
program_source:299:30: note: writable buffer defined here
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
                             ^
program_source:300:48: note: writable buffer defined here
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
                                               ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float4 TEXCOORD0 [[ attribute(3) ]] ;
    float4 TEXCOORD1 [[ attribute(4) ]] ;
    float4 TEXCOORD2 [[ attribute(5) ]] ;
    float4 TEXCOORD3 [[ attribute(6) ]] ;
    float4 COLOR0 [[ attribute(7) ]] ;
};
struct Mtl_VertexOut
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float4 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float4 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float4 TEXCOORD3 [[ user(TEXCOORD3) ]];
    float4 COLOR0 [[ user(COLOR0) ]];
};
static Mtl_VertexOut vertexFunction(
    Mtl_VertexIn input)
{
    Mtl_VertexOut output;
    output.INTERNALTESSPOS0 = input.POSITION0;
    output.TANGENT0 = input.TANGENT0;
    output.NORMAL0.xyz = input.NORMAL0.xyz;
    output.TEXCOORD0 = input.TEXCOORD0;
    output.TEXCOORD1 = input.TEXCOORD1;
    output.TEXCOORD2 = input.TEXCOORD2;
    output.TEXCOORD3 = input.TEXCOORD3;
    output.COLOR0 = input.COLOR0;
    return output;
}
// SHADER_STAGE_HULL_begin
struct Mtl_ControlPoint
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float4 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float4 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float4 TEXCOORD3 [[ user(TEXCOORD3) ]];
    float4 COLOR0 [[ user(COLOR0) ]];
};
struct Mtl_ControlPointIn
{
    float4 INTERNALTESSPOS0 [[ attribute(8) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float4 TEXCOORD0 [[ attribute(3) ]] ;
    float4 TEXCOORD1 [[ attribute(4) ]] ;
    float4 TEXCOORD2 [[ attribute(5) ]] ;
    float4 TEXCOORD3 [[ attribute(6) ]] ;
    float4 COLOR0 [[ attribute(7) ]] ;
};
struct Mtl_KernelPatchInfo
{
    uint numPatches;
    ushort numControlPointsPerPatch;
};
struct VGlobals_Type
{
    float4 _Time;
    float4 _SinTime;
    float4 _CosTime;
    float4 unity_DeltaTime;
    float3 _WorldSpaceCameraPos;
    float4 _ProjectionParams;
    float4 _ScreenParams;
    float4 _ZBufferParams;
    float4 unity_OrthoParams;
    float4 unity_CameraWorldClipPlanes[6];
    float4 hlslcc_mtx4x4unity_CameraProjection[4];
    float4 hlslcc_mtx4x4unity_CameraInvProjection[4];
    float4 hlslcc_mtx4x4unity_WorldToCamera[4];
    float4 hlslcc_mtx4x4unity_CameraToWorld[4];
    float4 _WorldSpaceLightPos0;
    float4 _LightPositionRange;
    float4 _LightProjectionParams;
    float4 unity_4LightPosX0;
    float4 unity_4LightPosY0;
    float4 unity_4LightPosZ0;
    float4 unity_4LightAtten0;
    float4 unity_LightColor[8];
    float4 unity_LightPosition[8];
    float4 unity_LightAtten[8];
    float4 unity_SpotDirection[8];
    float4 unity_SHAr;
    float4 unity_SHAg;
    float4 unity_SHAb;
    float4 unity_SHBr;
    float4 unity_SHBg;
    float4 unity_SHBb;
    float4 unity_SHC;
    float4 unity_OcclusionMaskSelector;
    float4 unity_ProbesOcclusion;
    float3 unity_LightColor0;
    float3 unity_LightColor1;
    float3 unity_LightColor2;
    float3 unity_LightColor3;
    float4 unity_ShadowSplitSpheres[4];
    float4 unity_ShadowSplitSqRadii;
    float4 unity_LightShadowBias;
    float4 _LightSplitsNear;
    float4 _LightSplitsFar;
    float4 hlslcc_mtx4x4unity_WorldToShadow[16];
    float4 _LightShadowData;
    float4 unity_ShadowFadeCenterAndType;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 unity_LODFade;
    float4 unity_WorldTransformParams;
    float4 unity_RenderingLayer;
    float4 hlslcc_mtx4x4glstate_matrix_transpose_modelview0[4];
    float4 glstate_lightmodel_ambient;
    float4 unity_AmbientSky;
    float4 unity_AmbientEquator;
    float4 unity_AmbientGround;
    float4 unity_IndirectSpecColor;
    float4 hlslcc_mtx4x4glstate_matrix_projection[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixInvV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    int unity_StereoEyeIndex;
    float4 unity_ShadowColor;
    float4 unity_FogColor;
    float4 unity_FogParams;
    float4 unity_LightmapST;
    float4 unity_DynamicLightmapST;
    float4 unity_SpecCube0_BoxMax;
    float4 unity_SpecCube0_BoxMin;
    float4 unity_SpecCube0_ProbePosition;
    float4 unity_SpecCube0_HDR;
    float4 unity_SpecCube1_BoxMax;
    float4 unity_SpecCube1_BoxMin;
    float4 unity_SpecCube1_ProbePosition;
    float4 unity_SpecCube1_HDR;
    float4 unity_ProbeVolumeParams;
    float4 hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[4];
    float3 unity_ProbeVolumeSizeInv;
    float3 unity_ProbeVolumeMin;
    float4 unity_Lightmap_HDR;
    float4 unity_DynamicLightmap_HDR;
    float4 _LightColor0;
    float4 _SpecColor;
    float _Tile;
    float _HeightDisplacement;
    float _NormalScale;
    float4 _ColorTint;
    float _MetallicStrength;
    float _SmoothnessStrength;
    float _EdgeLength;
};
struct Mtl_HullIn
{
    Mtl_VertexOut cp[3];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
kernel void patchKernel(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn vertexInput [[ stage_in ]],
    uint2 tID [[ thread_position_in_grid ]],
    ushort2 groupID [[ threadgroup_position_in_grid ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    constant Mtl_KernelPatchInfo &patchInfo [[ buffer(3) ]])
{
#pragma clang diagnostic pop
    Mtl_ControlPoint output;
    const uint numPatchesInThreadGroup = 10;
    const uint patchID = (tID.x / patchInfo.numControlPointsPerPatch);
    const bool patchValid = (patchID < patchInfo.numPatches);
    const uint mtl_BaseInstance = 0;
    const uint mtl_InstanceID = groupID.y - mtl_BaseInstance;
    const uint internalPatchID = mtl_InstanceID * patchInfo.numPatches + patchID;
    const uint patchIDInThreadGroup = (patchID % numPatchesInThreadGroup);
    const uint controlPointID = (tID.x % patchInfo.numControlPointsPerPatch);
    const uint mtl_BaseVertex = 0;
    const uint mtl_VertexID = ((mtl_InstanceID * (patchInfo.numControlPointsPerPatch * patchInfo.numPatches)) + tID.x) - mtl_BaseVertex;
    threadgroup Mtl_HullIn inputGroup[numPatchesInThreadGroup];
    threadgroup Mtl_HullIn &input = inputGroup[patchIDInThreadGroup];
    MTLTriangleTessellationFactorsHalf tessFactor;
    if (patchValid) {
        input.cp[controlPointID] = vertexFunction(vertexInput);
        output.INTERNALTESSPOS0 = input.cp[controlPointID].INTERNALTESSPOS0;
        output.TANGENT0 = input.cp[controlPointID].TANGENT0;
        output.NORMAL0 = input.cp[controlPointID].NORMAL0;
        output.TEXCOORD0 = input.cp[controlPointID].TEXCOORD0;
        output.TEXCOORD1 = input.cp[controlPointID].TEXCOORD1;
        output.TEXCOORD2 = input.cp[controlPointID].TEXCOORD2;
        output.TEXCOORD3 = input.cp[controlPointID].TEXCOORD3;
        output.COLOR0 = input.cp[controlPointID].COLOR0;
    }
    threadgroup_barrier(mem_flags::mem_threadgroup);
    if (!patchValid) {
        return;
    }
    float3 u_xlat0;
    float3 u_xlat1;
    float3 u_xlat2;
    float3 u_xlat3;
    float3 u_xlat4;
    float u_xlat12;
    float u_xlat13;
    // fork_phase2
    {
        u_xlat0.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[1].INTERNALTESSPOS0.yyy;
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[1].INTERNALTESSPOS0.xxx, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[1].INTERNALTESSPOS0.zzz, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[1].INTERNALTESSPOS0.www, u_xlat0.xyz);
        u_xlat1.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[2].INTERNALTESSPOS0.yyy;
        u_xlat1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[2].INTERNALTESSPOS0.xxx, u_xlat1.xyz);
        u_xlat1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[2].INTERNALTESSPOS0.zzz, u_xlat1.xyz);
        u_xlat1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[2].INTERNALTESSPOS0.www, u_xlat1.xyz);
        u_xlat2.xyz = u_xlat0.xyz + u_xlat1.xyz;
        u_xlat2.xyz = fma(u_xlat2.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat12 = dot(u_xlat2.xyz, u_xlat2.xyz);
        u_xlat12 = sqrt(u_xlat12);
        u_xlat12 = u_xlat12 * VGlobals._EdgeLength;
        u_xlat2.xyz = u_xlat0.xyz + (-u_xlat1.xyz);
        u_xlat13 = dot(u_xlat2.xyz, u_xlat2.xyz);
        u_xlat13 = sqrt(u_xlat13);
        u_xlat13 = u_xlat13 * VGlobals._ScreenParams.y;
        u_xlat12 = u_xlat13 / u_xlat12;
        tessFactor.edgeTessellationFactor[0] = max(u_xlat12, 1.0);
        u_xlat2.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[0].INTERNALTESSPOS0.yyy;
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[0].INTERNALTESSPOS0.xxx, u_xlat2.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[0].INTERNALTESSPOS0.zzz, u_xlat2.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[0].INTERNALTESSPOS0.www, u_xlat2.xyz);
        u_xlat3.xyz = u_xlat1.xyz + u_xlat2.xyz;
        u_xlat1.xyz = u_xlat1.xyz + (-u_xlat2.xyz);
        u_xlat12 = dot(u_xlat1.xyz, u_xlat1.xyz);
        u_xlat12 = sqrt(u_xlat12);
        u_xlat12 = u_xlat12 * VGlobals._ScreenParams.y;
        u_xlat1.xyz = fma(u_xlat3.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat1.x = dot(u_xlat1.xyz, u_xlat1.xyz);
        u_xlat1.x = sqrt(u_xlat1.x);
        u_xlat1.x = u_xlat1.x * VGlobals._EdgeLength;
        u_xlat12 = u_xlat12 / u_xlat1.x;
        tessFactor.edgeTessellationFactor[1] = max(u_xlat12, 1.0);
        u_xlat1.xyz = u_xlat0.xyz + u_xlat2.xyz;
        u_xlat0.xyz = (-u_xlat0.xyz) + u_xlat2.xyz;
        u_xlat0.x = dot(u_xlat0.xyz, u_xlat0.xyz);
        u_xlat0.x = sqrt(u_xlat0.x);
        u_xlat0.x = u_xlat0.x * VGlobals._ScreenParams.y;
        u_xlat4.xyz = fma(u_xlat1.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat4.x = dot(u_xlat4.xyz, u_xlat4.xyz);
        u_xlat4.x = sqrt(u_xlat4.x);
        u_xlat4.x = u_xlat4.x * VGlobals._EdgeLength;
        u_xlat0.x = u_xlat0.x / u_xlat4.x;
        tessFactor.edgeTessellationFactor[2] = max(u_xlat0.x, 1.0);
    }
    // join_phase3
    {
        u_xlat0.x = tessFactor.edgeTessellationFactor[0] + tessFactor.edgeTessellationFactor[1];
        u_xlat0.x = u_xlat0.x + tessFactor.edgeTessellationFactor[2];
        tessFactor.insideTessellationFactor = u_xlat0.x * 0.333333343;
    }
    controlPoints[mtl_VertexID] = output;
    tessFactors[internalPatchID] = tessFactor;
}
// SHADER_STAGE_HULL_end
// SHADER_STAGE_DOMAIN_begin
struct Mtl_VertexInPostTess
{
    patch_control_point<Mtl_ControlPointIn> cp;
};
struct Mtl_VertexOutPostTess
{
    float4 mtl_Position [[ position ]];
    float3 TEXCOORD1 [[ user(TEXCOORD1) ]];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    sampler sampler_Height [[ sampler (0) ]],
    texture2d<float, access::sample > _Height [[ texture(0) ]] ,
    float3 mtl_TessCoord [[ position_in_patch ]],
    uint patchID [[ patch_id ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    Mtl_VertexInPostTess input [[ stage_in ]])
{
#pragma clang diagnostic pop
    Mtl_VertexOutPostTess output;
    MTLTriangleTessellationFactorsHalf tessFactor;
    tessFactor = tessFactors[patchID];
    float4 u_xlat0;
    float4 u_xlat1;
    float4 u_xlat2;
    float4 u_xlat3;
    float4 u_xlat4;
    float u_xlat11;
    float u_xlat15;
    bool u_xlatb15;
    u_xlat0.xyz = mtl_TessCoord.yyy * input.cp[1].NORMAL0.xyz;
    u_xlat0.xyz = fma(input.cp[0].NORMAL0.xyz, mtl_TessCoord.xxx, u_xlat0.xyz);
    u_xlat0.xyz = fma(input.cp[2].NORMAL0.xyz, mtl_TessCoord.zzz, u_xlat0.xyz);
    u_xlat1.x = dot(u_xlat0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat1.y = dot(u_xlat0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat1.z = dot(u_xlat0.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat15 = dot(u_xlat1.xyz, u_xlat1.xyz);
    u_xlat15 = rsqrt(u_xlat15);
    u_xlat1.xyz = float3(u_xlat15) * u_xlat1.xyz;
    u_xlat2.xy = mtl_TessCoord.yy * input.cp[1].TEXCOORD0.xy;
    u_xlat2.xy = fma(input.cp[0].TEXCOORD0.xy, mtl_TessCoord.xx, u_xlat2.xy);
    u_xlat2.xy = fma(input.cp[2].TEXCOORD0.xy, mtl_TessCoord.zz, u_xlat2.xy);
    u_xlat2.xy = u_xlat2.xy * float2(VGlobals._Tile);
    u_xlat2.xyz = _Height.sample(sampler_Height, u_xlat2.xy, level(1.0)).xyz;
    u_xlat0.xyz = u_xlat0.xyz * u_xlat2.xyz;
    u_xlat2 = mtl_TessCoord.yyyy * input.cp[1].INTERNALTESSPOS0;
    u_xlat2 = fma(input.cp[0].INTERNALTESSPOS0, mtl_TessCoord.xxxx, u_xlat2);
    u_xlat2 = fma(input.cp[2].INTERNALTESSPOS0, mtl_TessCoord.zzzz, u_xlat2);
    u_xlat0.xyz = fma(u_xlat0.xyz, float3(VGlobals._HeightDisplacement), u_xlat2.xyz);
    u_xlat3 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], u_xlat0.xxxx, u_xlat3);
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], u_xlat0.zzzz, u_xlat3);
    u_xlat3 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3], u_xlat2.wwww, u_xlat3);
    u_xlat2.xyz = fma((-u_xlat3.xyz), VGlobals._WorldSpaceLightPos0.www, VGlobals._WorldSpaceLightPos0.xyz);
    u_xlat15 = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat15 = rsqrt(u_xlat15);
    u_xlat2.xyz = float3(u_xlat15) * u_xlat2.xyz;
    u_xlat15 = dot(u_xlat1.xyz, u_xlat2.xyz);
    u_xlat15 = fma((-u_xlat15), u_xlat15, 1.0);
    u_xlat15 = sqrt(u_xlat15);
    u_xlat15 = u_xlat15 * VGlobals.unity_LightShadowBias.z;
    u_xlat1.xyz = fma((-u_xlat1.xyz), float3(u_xlat15), u_xlat3.xyz);
    u_xlatb15 = VGlobals.unity_LightShadowBias.z!=0.0;
    u_xlat1.xyz = (bool(u_xlatb15)) ? u_xlat1.xyz : u_xlat3.xyz;
    u_xlat4 = u_xlat1.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat4 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat1.xxxx, u_xlat4);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat1.zzzz, u_xlat4);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat3.wwww, u_xlat1);
    u_xlat15 = VGlobals.unity_LightShadowBias.x / u_xlat1.w;
    u_xlat15 = min(u_xlat15, 0.0);
    u_xlat15 = max(u_xlat15, -1.0);
    u_xlat15 = u_xlat15 + u_xlat1.z;
    u_xlat11 = min(u_xlat1.w, u_xlat15);
    output.mtl_Position.xyw = u_xlat1.xyw;
    u_xlat1.x = (-u_xlat15) + u_xlat11;
    output.mtl_Position.z = fma(VGlobals.unity_LightShadowBias.y, u_xlat1.x, u_xlat15);
    u_xlat1.xyz = u_xlat0.yyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz;
    u_xlat0.xyw = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, u_xlat0.xxx, u_xlat1.xyz);
    u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, u_xlat0.zzz, u_xlat0.xyw);
    output.TEXCOORD1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, u_xlat2.www, u_xlat0.xyz);
    return output;
}
// SHADER_STAGE_DOMAIN_end
Compilation succeeded with: 

program_source:299:53: warning: writable resources in non-void post-tessellation vertex function
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
                                                    ^
program_source:305:30: note: writable buffer defined here
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
                             ^
program_source:306:48: note: writable buffer defined here
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
                                               ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float4 TEXCOORD0 [[ attribute(3) ]] ;
    float4 TEXCOORD1 [[ attribute(4) ]] ;
    float4 TEXCOORD2 [[ attribute(5) ]] ;
    float4 TEXCOORD3 [[ attribute(6) ]] ;
    float4 COLOR0 [[ attribute(7) ]] ;
};
struct Mtl_VertexOut
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float4 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float4 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float4 TEXCOORD3 [[ user(TEXCOORD3) ]];
    float4 COLOR0 [[ user(COLOR0) ]];
};
static Mtl_VertexOut vertexFunction(
    Mtl_VertexIn input)
{
    Mtl_VertexOut output;
    output.INTERNALTESSPOS0 = input.POSITION0;
    output.TANGENT0 = input.TANGENT0;
    output.NORMAL0.xyz = input.NORMAL0.xyz;
    output.TEXCOORD0 = input.TEXCOORD0;
    output.TEXCOORD1 = input.TEXCOORD1;
    output.TEXCOORD2 = input.TEXCOORD2;
    output.TEXCOORD3 = input.TEXCOORD3;
    output.COLOR0 = input.COLOR0;
    return output;
}
// SHADER_STAGE_HULL_begin
struct Mtl_ControlPoint
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float4 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float4 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float4 TEXCOORD3 [[ user(TEXCOORD3) ]];
    float4 COLOR0 [[ user(COLOR0) ]];
};
struct Mtl_ControlPointIn
{
    float4 INTERNALTESSPOS0 [[ attribute(8) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float4 TEXCOORD0 [[ attribute(3) ]] ;
    float4 TEXCOORD1 [[ attribute(4) ]] ;
    float4 TEXCOORD2 [[ attribute(5) ]] ;
    float4 TEXCOORD3 [[ attribute(6) ]] ;
    float4 COLOR0 [[ attribute(7) ]] ;
};
struct Mtl_KernelPatchInfo
{
    uint numPatches;
    ushort numControlPointsPerPatch;
};
struct VGlobals_Type
{
    float4 _Time;
    float4 _SinTime;
    float4 _CosTime;
    float4 unity_DeltaTime;
    float3 _WorldSpaceCameraPos;
    float4 _ProjectionParams;
    float4 _ScreenParams;
    float4 _ZBufferParams;
    float4 unity_OrthoParams;
    float4 unity_CameraWorldClipPlanes[6];
    float4 hlslcc_mtx4x4unity_CameraProjection[4];
    float4 hlslcc_mtx4x4unity_CameraInvProjection[4];
    float4 hlslcc_mtx4x4unity_WorldToCamera[4];
    float4 hlslcc_mtx4x4unity_CameraToWorld[4];
    float4 _WorldSpaceLightPos0;
    float4 _LightPositionRange;
    float4 _LightProjectionParams;
    float4 unity_4LightPosX0;
    float4 unity_4LightPosY0;
    float4 unity_4LightPosZ0;
    float4 unity_4LightAtten0;
    float4 unity_LightColor[8];
    float4 unity_LightPosition[8];
    float4 unity_LightAtten[8];
    float4 unity_SpotDirection[8];
    float4 unity_SHAr;
    float4 unity_SHAg;
    float4 unity_SHAb;
    float4 unity_SHBr;
    float4 unity_SHBg;
    float4 unity_SHBb;
    float4 unity_SHC;
    float4 unity_OcclusionMaskSelector;
    float4 unity_ProbesOcclusion;
    float3 unity_LightColor0;
    float3 unity_LightColor1;
    float3 unity_LightColor2;
    float3 unity_LightColor3;
    float4 unity_ShadowSplitSpheres[4];
    float4 unity_ShadowSplitSqRadii;
    float4 unity_LightShadowBias;
    float4 _LightSplitsNear;
    float4 _LightSplitsFar;
    float4 hlslcc_mtx4x4unity_WorldToShadow[16];
    float4 _LightShadowData;
    float4 unity_ShadowFadeCenterAndType;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 unity_LODFade;
    float4 unity_WorldTransformParams;
    float4 unity_RenderingLayer;
    float4 hlslcc_mtx4x4glstate_matrix_transpose_modelview0[4];
    float4 glstate_lightmodel_ambient;
    float4 unity_AmbientSky;
    float4 unity_AmbientEquator;
    float4 unity_AmbientGround;
    float4 unity_IndirectSpecColor;
    float4 hlslcc_mtx4x4glstate_matrix_projection[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixInvV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    int unity_StereoEyeIndex;
    float4 unity_ShadowColor;
    float4 unity_FogColor;
    float4 unity_FogParams;
    float4 unity_LightmapST;
    float4 unity_DynamicLightmapST;
    float4 unity_SpecCube0_BoxMax;
    float4 unity_SpecCube0_BoxMin;
    float4 unity_SpecCube0_ProbePosition;
    float4 unity_SpecCube0_HDR;
    float4 unity_SpecCube1_BoxMax;
    float4 unity_SpecCube1_BoxMin;
    float4 unity_SpecCube1_ProbePosition;
    float4 unity_SpecCube1_HDR;
    float4 unity_ProbeVolumeParams;
    float4 hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[4];
    float3 unity_ProbeVolumeSizeInv;
    float3 unity_ProbeVolumeMin;
    float4 unity_Lightmap_HDR;
    float4 unity_DynamicLightmap_HDR;
    float4 _LightColor0;
    float4 _SpecColor;
    float _Tile;
    float _HeightDisplacement;
    float _NormalScale;
    float4 _ColorTint;
    float _MetallicStrength;
    float _SmoothnessStrength;
    float _EdgeLength;
    float4 _texcoord_ST;
    float4 unity_Ambient;
};
struct Mtl_HullIn
{
    Mtl_VertexOut cp[3];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
kernel void patchKernel(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn vertexInput [[ stage_in ]],
    uint2 tID [[ thread_position_in_grid ]],
    ushort2 groupID [[ threadgroup_position_in_grid ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    constant Mtl_KernelPatchInfo &patchInfo [[ buffer(3) ]])
{
#pragma clang diagnostic pop
    Mtl_ControlPoint output;
    const uint numPatchesInThreadGroup = 10;
    const uint patchID = (tID.x / patchInfo.numControlPointsPerPatch);
    const bool patchValid = (patchID < patchInfo.numPatches);
    const uint mtl_BaseInstance = 0;
    const uint mtl_InstanceID = groupID.y - mtl_BaseInstance;
    const uint internalPatchID = mtl_InstanceID * patchInfo.numPatches + patchID;
    const uint patchIDInThreadGroup = (patchID % numPatchesInThreadGroup);
    const uint controlPointID = (tID.x % patchInfo.numControlPointsPerPatch);
    const uint mtl_BaseVertex = 0;
    const uint mtl_VertexID = ((mtl_InstanceID * (patchInfo.numControlPointsPerPatch * patchInfo.numPatches)) + tID.x) - mtl_BaseVertex;
    threadgroup Mtl_HullIn inputGroup[numPatchesInThreadGroup];
    threadgroup Mtl_HullIn &input = inputGroup[patchIDInThreadGroup];
    MTLTriangleTessellationFactorsHalf tessFactor;
    if (patchValid) {
        input.cp[controlPointID] = vertexFunction(vertexInput);
        output.INTERNALTESSPOS0 = input.cp[controlPointID].INTERNALTESSPOS0;
        output.TANGENT0 = input.cp[controlPointID].TANGENT0;
        output.NORMAL0 = input.cp[controlPointID].NORMAL0;
        output.TEXCOORD0 = input.cp[controlPointID].TEXCOORD0;
        output.TEXCOORD1 = input.cp[controlPointID].TEXCOORD1;
        output.TEXCOORD2 = input.cp[controlPointID].TEXCOORD2;
        output.TEXCOORD3 = input.cp[controlPointID].TEXCOORD3;
        output.COLOR0 = input.cp[controlPointID].COLOR0;
    }
    threadgroup_barrier(mem_flags::mem_threadgroup);
    if (!patchValid) {
        return;
    }
    float3 u_xlat0;
    float3 u_xlat1;
    float3 u_xlat2;
    float3 u_xlat3;
    float3 u_xlat4;
    float u_xlat12;
    float u_xlat13;
    // fork_phase2
    {
        u_xlat0.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[1].INTERNALTESSPOS0.yyy;
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[1].INTERNALTESSPOS0.xxx, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[1].INTERNALTESSPOS0.zzz, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[1].INTERNALTESSPOS0.www, u_xlat0.xyz);
        u_xlat1.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[2].INTERNALTESSPOS0.yyy;
        u_xlat1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[2].INTERNALTESSPOS0.xxx, u_xlat1.xyz);
        u_xlat1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[2].INTERNALTESSPOS0.zzz, u_xlat1.xyz);
        u_xlat1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[2].INTERNALTESSPOS0.www, u_xlat1.xyz);
        u_xlat2.xyz = u_xlat0.xyz + u_xlat1.xyz;
        u_xlat2.xyz = fma(u_xlat2.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat12 = dot(u_xlat2.xyz, u_xlat2.xyz);
        u_xlat12 = sqrt(u_xlat12);
        u_xlat12 = u_xlat12 * VGlobals._EdgeLength;
        u_xlat2.xyz = u_xlat0.xyz + (-u_xlat1.xyz);
        u_xlat13 = dot(u_xlat2.xyz, u_xlat2.xyz);
        u_xlat13 = sqrt(u_xlat13);
        u_xlat13 = u_xlat13 * VGlobals._ScreenParams.y;
        u_xlat12 = u_xlat13 / u_xlat12;
        tessFactor.edgeTessellationFactor[0] = max(u_xlat12, 1.0);
        u_xlat2.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[0].INTERNALTESSPOS0.yyy;
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[0].INTERNALTESSPOS0.xxx, u_xlat2.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[0].INTERNALTESSPOS0.zzz, u_xlat2.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[0].INTERNALTESSPOS0.www, u_xlat2.xyz);
        u_xlat3.xyz = u_xlat1.xyz + u_xlat2.xyz;
        u_xlat1.xyz = u_xlat1.xyz + (-u_xlat2.xyz);
        u_xlat12 = dot(u_xlat1.xyz, u_xlat1.xyz);
        u_xlat12 = sqrt(u_xlat12);
        u_xlat12 = u_xlat12 * VGlobals._ScreenParams.y;
        u_xlat1.xyz = fma(u_xlat3.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat1.x = dot(u_xlat1.xyz, u_xlat1.xyz);
        u_xlat1.x = sqrt(u_xlat1.x);
        u_xlat1.x = u_xlat1.x * VGlobals._EdgeLength;
        u_xlat12 = u_xlat12 / u_xlat1.x;
        tessFactor.edgeTessellationFactor[1] = max(u_xlat12, 1.0);
        u_xlat1.xyz = u_xlat0.xyz + u_xlat2.xyz;
        u_xlat0.xyz = (-u_xlat0.xyz) + u_xlat2.xyz;
        u_xlat0.x = dot(u_xlat0.xyz, u_xlat0.xyz);
        u_xlat0.x = sqrt(u_xlat0.x);
        u_xlat0.x = u_xlat0.x * VGlobals._ScreenParams.y;
        u_xlat4.xyz = fma(u_xlat1.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat4.x = dot(u_xlat4.xyz, u_xlat4.xyz);
        u_xlat4.x = sqrt(u_xlat4.x);
        u_xlat4.x = u_xlat4.x * VGlobals._EdgeLength;
        u_xlat0.x = u_xlat0.x / u_xlat4.x;
        tessFactor.edgeTessellationFactor[2] = max(u_xlat0.x, 1.0);
    }
    // join_phase3
    {
        u_xlat0.x = tessFactor.edgeTessellationFactor[0] + tessFactor.edgeTessellationFactor[1];
        u_xlat0.x = u_xlat0.x + tessFactor.edgeTessellationFactor[2];
        tessFactor.insideTessellationFactor = u_xlat0.x * 0.333333343;
    }
    controlPoints[mtl_VertexID] = output;
    tessFactors[internalPatchID] = tessFactor;
}
// SHADER_STAGE_HULL_end
// SHADER_STAGE_DOMAIN_begin
struct Mtl_VertexInPostTess
{
    patch_control_point<Mtl_ControlPointIn> cp;
};
struct Mtl_VertexOutPostTess
{
    float4 mtl_Position [[ position ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float4 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float4 TEXCOORD3 [[ user(TEXCOORD3) ]];
    float4 TEXCOORD5 [[ user(TEXCOORD5) ]];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    sampler sampler_Height [[ sampler (0) ]],
    texture2d<float, access::sample > _Height [[ texture(0) ]] ,
    float3 mtl_TessCoord [[ position_in_patch ]],
    uint patchID [[ patch_id ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    Mtl_VertexInPostTess input [[ stage_in ]])
{
#pragma clang diagnostic pop
    Mtl_VertexOutPostTess output;
    MTLTriangleTessellationFactorsHalf tessFactor;
    tessFactor = tessFactors[patchID];
    float4 u_xlat0;
    float4 u_xlat1;
    float4 u_xlat2;
    float4 u_xlat3;
    float2 u_xlat9;
    float u_xlat12;
    float u_xlat13;
    u_xlat0 = mtl_TessCoord.yyyy * input.cp[1].INTERNALTESSPOS0;
    u_xlat0 = fma(input.cp[0].INTERNALTESSPOS0, mtl_TessCoord.xxxx, u_xlat0);
    u_xlat0 = fma(input.cp[2].INTERNALTESSPOS0, mtl_TessCoord.zzzz, u_xlat0);
    u_xlat1.xy = mtl_TessCoord.yy * input.cp[1].TEXCOORD0.xy;
    u_xlat1.xy = fma(input.cp[0].TEXCOORD0.xy, mtl_TessCoord.xx, u_xlat1.xy);
    u_xlat1.xy = fma(input.cp[2].TEXCOORD0.xy, mtl_TessCoord.zz, u_xlat1.xy);
    u_xlat9.xy = u_xlat1.xy * float2(VGlobals._Tile);
    output.TEXCOORD0.xy = fma(u_xlat1.xy, VGlobals._texcoord_ST.xy, VGlobals._texcoord_ST.zw);
    u_xlat1.xyz = _Height.sample(sampler_Height, u_xlat9.xy, level(1.0)).xyz;
    u_xlat2.xyz = mtl_TessCoord.yyy * input.cp[1].NORMAL0.xyz;
    u_xlat2.xyz = fma(input.cp[0].NORMAL0.xyz, mtl_TessCoord.xxx, u_xlat2.xyz);
    u_xlat2.xyz = fma(input.cp[2].NORMAL0.xyz, mtl_TessCoord.zzz, u_xlat2.xyz);
    u_xlat1.xyz = u_xlat1.xyz * u_xlat2.xyz;
    u_xlat0.xyz = fma(u_xlat1.xyz, float3(VGlobals._HeightDisplacement), u_xlat0.xyz);
    u_xlat1 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0], u_xlat0.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2], u_xlat0.zzzz, u_xlat1);
    u_xlat3 = u_xlat1 + VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, u_xlat0.www, u_xlat1.xyz);
    u_xlat1 = u_xlat3.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat3.xxxx, u_xlat1);
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat3.zzzz, u_xlat1);
    output.mtl_Position = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[3], u_xlat3.wwww, u_xlat1);
    u_xlat1.y = dot(u_xlat2.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat1.z = dot(u_xlat2.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat1.x = dot(u_xlat2.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat12 = dot(u_xlat1.xyz, u_xlat1.xyz);
    u_xlat12 = rsqrt(u_xlat12);
    u_xlat1.xyz = float3(u_xlat12) * u_xlat1.xyz;
    output.TEXCOORD1.z = u_xlat1.y;
    u_xlat2 = mtl_TessCoord.yyyy * input.cp[1].TANGENT0;
    u_xlat2 = fma(input.cp[0].TANGENT0, mtl_TessCoord.xxxx, u_xlat2);
    u_xlat2 = fma(input.cp[2].TANGENT0, mtl_TessCoord.zzzz, u_xlat2);
    u_xlat3.xyz = u_xlat2.yyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].yzx;
    u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].yzx, u_xlat2.xxx, u_xlat3.xyz);
    u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].yzx, u_xlat2.zzz, u_xlat3.xyz);
    u_xlat12 = u_xlat2.w * VGlobals.unity_WorldTransformParams.w;
    u_xlat13 = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat13 = rsqrt(u_xlat13);
    u_xlat2.xyz = float3(u_xlat13) * u_xlat2.xyz;
    u_xlat3.xyz = u_xlat1.xyz * u_xlat2.xyz;
    u_xlat3.xyz = fma(u_xlat1.zxy, u_xlat2.yzx, (-u_xlat3.xyz));
    u_xlat3.xyz = float3(u_xlat12) * u_xlat3.xyz;
    output.TEXCOORD1.y = u_xlat3.x;
    output.TEXCOORD1.w = u_xlat0.x;
    output.TEXCOORD1.x = u_xlat2.z;
    output.TEXCOORD2.w = u_xlat0.y;
    output.TEXCOORD3.w = u_xlat0.z;
    output.TEXCOORD2.x = u_xlat2.x;
    output.TEXCOORD3.x = u_xlat2.y;
    output.TEXCOORD2.z = u_xlat1.z;
    output.TEXCOORD3.z = u_xlat1.x;
    output.TEXCOORD2.y = u_xlat3.y;
    output.TEXCOORD3.y = u_xlat3.z;
    output.TEXCOORD5 = float4(0.0, 0.0, 0.0, 0.0);
    return output;
}
// SHADER_STAGE_DOMAIN_end
Compilation succeeded with: 

program_source:303:53: warning: writable resources in non-void post-tessellation vertex function
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
                                                    ^
program_source:309:30: note: writable buffer defined here
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
                             ^
program_source:310:48: note: writable buffer defined here
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
                                               ^



#include <metal_stdlib>
#include <metal_texture>
using namespace metal;
struct Mtl_VertexIn
{
    float4 POSITION0 [[ attribute(0) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float4 TEXCOORD0 [[ attribute(3) ]] ;
    float4 TEXCOORD1 [[ attribute(4) ]] ;
    float4 TEXCOORD2 [[ attribute(5) ]] ;
    float4 TEXCOORD3 [[ attribute(6) ]] ;
    float4 COLOR0 [[ attribute(7) ]] ;
};
struct Mtl_VertexOut
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float4 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float4 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float4 TEXCOORD3 [[ user(TEXCOORD3) ]];
    float4 COLOR0 [[ user(COLOR0) ]];
};
static Mtl_VertexOut vertexFunction(
    Mtl_VertexIn input)
{
    Mtl_VertexOut output;
    output.INTERNALTESSPOS0 = input.POSITION0;
    output.TANGENT0 = input.TANGENT0;
    output.NORMAL0.xyz = input.NORMAL0.xyz;
    output.TEXCOORD0 = input.TEXCOORD0;
    output.TEXCOORD1 = input.TEXCOORD1;
    output.TEXCOORD2 = input.TEXCOORD2;
    output.TEXCOORD3 = input.TEXCOORD3;
    output.COLOR0 = input.COLOR0;
    return output;
}
// SHADER_STAGE_HULL_begin
struct Mtl_ControlPoint
{
    float4 INTERNALTESSPOS0 [[ user(INTERNALTESSPOS0) ]];
    float4 TANGENT0 [[ user(TANGENT0) ]];
    float3 NORMAL0 [[ user(NORMAL0) ]];
    float4 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float4 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float4 TEXCOORD3 [[ user(TEXCOORD3) ]];
    float4 COLOR0 [[ user(COLOR0) ]];
};
struct Mtl_ControlPointIn
{
    float4 INTERNALTESSPOS0 [[ attribute(8) ]] ;
    float4 TANGENT0 [[ attribute(1) ]] ;
    float3 NORMAL0 [[ attribute(2) ]] ;
    float4 TEXCOORD0 [[ attribute(3) ]] ;
    float4 TEXCOORD1 [[ attribute(4) ]] ;
    float4 TEXCOORD2 [[ attribute(5) ]] ;
    float4 TEXCOORD3 [[ attribute(6) ]] ;
    float4 COLOR0 [[ attribute(7) ]] ;
};
struct Mtl_KernelPatchInfo
{
    uint numPatches;
    ushort numControlPointsPerPatch;
};
struct VGlobals_Type
{
    float4 _Time;
    float4 _SinTime;
    float4 _CosTime;
    float4 unity_DeltaTime;
    float3 _WorldSpaceCameraPos;
    float4 _ProjectionParams;
    float4 _ScreenParams;
    float4 _ZBufferParams;
    float4 unity_OrthoParams;
    float4 unity_CameraWorldClipPlanes[6];
    float4 hlslcc_mtx4x4unity_CameraProjection[4];
    float4 hlslcc_mtx4x4unity_CameraInvProjection[4];
    float4 hlslcc_mtx4x4unity_WorldToCamera[4];
    float4 hlslcc_mtx4x4unity_CameraToWorld[4];
    float4 _WorldSpaceLightPos0;
    float4 _LightPositionRange;
    float4 _LightProjectionParams;
    float4 unity_4LightPosX0;
    float4 unity_4LightPosY0;
    float4 unity_4LightPosZ0;
    float4 unity_4LightAtten0;
    float4 unity_LightColor[8];
    float4 unity_LightPosition[8];
    float4 unity_LightAtten[8];
    float4 unity_SpotDirection[8];
    float4 unity_SHAr;
    float4 unity_SHAg;
    float4 unity_SHAb;
    float4 unity_SHBr;
    float4 unity_SHBg;
    float4 unity_SHBb;
    float4 unity_SHC;
    float4 unity_OcclusionMaskSelector;
    float4 unity_ProbesOcclusion;
    float3 unity_LightColor0;
    float3 unity_LightColor1;
    float3 unity_LightColor2;
    float3 unity_LightColor3;
    float4 unity_ShadowSplitSpheres[4];
    float4 unity_ShadowSplitSqRadii;
    float4 unity_LightShadowBias;
    float4 _LightSplitsNear;
    float4 _LightSplitsFar;
    float4 hlslcc_mtx4x4unity_WorldToShadow[16];
    float4 _LightShadowData;
    float4 unity_ShadowFadeCenterAndType;
    float4 hlslcc_mtx4x4unity_ObjectToWorld[4];
    float4 hlslcc_mtx4x4unity_WorldToObject[4];
    float4 unity_LODFade;
    float4 unity_WorldTransformParams;
    float4 unity_RenderingLayer;
    float4 hlslcc_mtx4x4glstate_matrix_transpose_modelview0[4];
    float4 glstate_lightmodel_ambient;
    float4 unity_AmbientSky;
    float4 unity_AmbientEquator;
    float4 unity_AmbientGround;
    float4 unity_IndirectSpecColor;
    float4 hlslcc_mtx4x4glstate_matrix_projection[4];
    float4 hlslcc_mtx4x4unity_MatrixV[4];
    float4 hlslcc_mtx4x4unity_MatrixInvV[4];
    float4 hlslcc_mtx4x4unity_MatrixVP[4];
    int unity_StereoEyeIndex;
    float4 unity_ShadowColor;
    float4 unity_FogColor;
    float4 unity_FogParams;
    float4 unity_LightmapST;
    float4 unity_DynamicLightmapST;
    float4 unity_SpecCube0_BoxMax;
    float4 unity_SpecCube0_BoxMin;
    float4 unity_SpecCube0_ProbePosition;
    float4 unity_SpecCube0_HDR;
    float4 unity_SpecCube1_BoxMax;
    float4 unity_SpecCube1_BoxMin;
    float4 unity_SpecCube1_ProbePosition;
    float4 unity_SpecCube1_HDR;
    float4 unity_ProbeVolumeParams;
    float4 hlslcc_mtx4x4unity_ProbeVolumeWorldToObject[4];
    float3 unity_ProbeVolumeSizeInv;
    float3 unity_ProbeVolumeMin;
    float4 unity_Lightmap_HDR;
    float4 unity_DynamicLightmap_HDR;
    float4 _LightColor0;
    float4 _SpecColor;
    float _Tile;
    float _HeightDisplacement;
    float _NormalScale;
    float4 _ColorTint;
    float _MetallicStrength;
    float _SmoothnessStrength;
    float _EdgeLength;
    bool4 unity_MetaVertexControl;
    bool4 unity_MetaFragmentControl;
    int unity_VisualizationMode;
    float unity_OneOverOutputBoost;
    float unity_MaxOutputValue;
    float unity_UseLinearSpace;
    float4 _texcoord_ST;
};
struct Mtl_HullIn
{
    Mtl_VertexOut cp[3];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
kernel void patchKernel(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    Mtl_VertexIn vertexInput [[ stage_in ]],
    uint2 tID [[ thread_position_in_grid ]],
    ushort2 groupID [[ threadgroup_position_in_grid ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    constant Mtl_KernelPatchInfo &patchInfo [[ buffer(3) ]])
{
#pragma clang diagnostic pop
    Mtl_ControlPoint output;
    const uint numPatchesInThreadGroup = 10;
    const uint patchID = (tID.x / patchInfo.numControlPointsPerPatch);
    const bool patchValid = (patchID < patchInfo.numPatches);
    const uint mtl_BaseInstance = 0;
    const uint mtl_InstanceID = groupID.y - mtl_BaseInstance;
    const uint internalPatchID = mtl_InstanceID * patchInfo.numPatches + patchID;
    const uint patchIDInThreadGroup = (patchID % numPatchesInThreadGroup);
    const uint controlPointID = (tID.x % patchInfo.numControlPointsPerPatch);
    const uint mtl_BaseVertex = 0;
    const uint mtl_VertexID = ((mtl_InstanceID * (patchInfo.numControlPointsPerPatch * patchInfo.numPatches)) + tID.x) - mtl_BaseVertex;
    threadgroup Mtl_HullIn inputGroup[numPatchesInThreadGroup];
    threadgroup Mtl_HullIn &input = inputGroup[patchIDInThreadGroup];
    MTLTriangleTessellationFactorsHalf tessFactor;
    if (patchValid) {
        input.cp[controlPointID] = vertexFunction(vertexInput);
        output.INTERNALTESSPOS0 = input.cp[controlPointID].INTERNALTESSPOS0;
        output.TANGENT0 = input.cp[controlPointID].TANGENT0;
        output.NORMAL0 = input.cp[controlPointID].NORMAL0;
        output.TEXCOORD0 = input.cp[controlPointID].TEXCOORD0;
        output.TEXCOORD1 = input.cp[controlPointID].TEXCOORD1;
        output.TEXCOORD2 = input.cp[controlPointID].TEXCOORD2;
        output.TEXCOORD3 = input.cp[controlPointID].TEXCOORD3;
        output.COLOR0 = input.cp[controlPointID].COLOR0;
    }
    threadgroup_barrier(mem_flags::mem_threadgroup);
    if (!patchValid) {
        return;
    }
    float3 u_xlat0;
    float3 u_xlat1;
    float3 u_xlat2;
    float3 u_xlat3;
    float3 u_xlat4;
    float u_xlat12;
    float u_xlat13;
    // fork_phase2
    {
        u_xlat0.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[1].INTERNALTESSPOS0.yyy;
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[1].INTERNALTESSPOS0.xxx, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[1].INTERNALTESSPOS0.zzz, u_xlat0.xyz);
        u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[1].INTERNALTESSPOS0.www, u_xlat0.xyz);
        u_xlat1.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[2].INTERNALTESSPOS0.yyy;
        u_xlat1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[2].INTERNALTESSPOS0.xxx, u_xlat1.xyz);
        u_xlat1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[2].INTERNALTESSPOS0.zzz, u_xlat1.xyz);
        u_xlat1.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[2].INTERNALTESSPOS0.www, u_xlat1.xyz);
        u_xlat2.xyz = u_xlat0.xyz + u_xlat1.xyz;
        u_xlat2.xyz = fma(u_xlat2.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat12 = dot(u_xlat2.xyz, u_xlat2.xyz);
        u_xlat12 = sqrt(u_xlat12);
        u_xlat12 = u_xlat12 * VGlobals._EdgeLength;
        u_xlat2.xyz = u_xlat0.xyz + (-u_xlat1.xyz);
        u_xlat13 = dot(u_xlat2.xyz, u_xlat2.xyz);
        u_xlat13 = sqrt(u_xlat13);
        u_xlat13 = u_xlat13 * VGlobals._ScreenParams.y;
        u_xlat12 = u_xlat13 / u_xlat12;
        tessFactor.edgeTessellationFactor[0] = max(u_xlat12, 1.0);
        u_xlat2.xyz = VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz * input.cp[0].INTERNALTESSPOS0.yyy;
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, input.cp[0].INTERNALTESSPOS0.xxx, u_xlat2.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, input.cp[0].INTERNALTESSPOS0.zzz, u_xlat2.xyz);
        u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, input.cp[0].INTERNALTESSPOS0.www, u_xlat2.xyz);
        u_xlat3.xyz = u_xlat1.xyz + u_xlat2.xyz;
        u_xlat1.xyz = u_xlat1.xyz + (-u_xlat2.xyz);
        u_xlat12 = dot(u_xlat1.xyz, u_xlat1.xyz);
        u_xlat12 = sqrt(u_xlat12);
        u_xlat12 = u_xlat12 * VGlobals._ScreenParams.y;
        u_xlat1.xyz = fma(u_xlat3.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat1.x = dot(u_xlat1.xyz, u_xlat1.xyz);
        u_xlat1.x = sqrt(u_xlat1.x);
        u_xlat1.x = u_xlat1.x * VGlobals._EdgeLength;
        u_xlat12 = u_xlat12 / u_xlat1.x;
        tessFactor.edgeTessellationFactor[1] = max(u_xlat12, 1.0);
        u_xlat1.xyz = u_xlat0.xyz + u_xlat2.xyz;
        u_xlat0.xyz = (-u_xlat0.xyz) + u_xlat2.xyz;
        u_xlat0.x = dot(u_xlat0.xyz, u_xlat0.xyz);
        u_xlat0.x = sqrt(u_xlat0.x);
        u_xlat0.x = u_xlat0.x * VGlobals._ScreenParams.y;
        u_xlat4.xyz = fma(u_xlat1.xyz, float3(0.5, 0.5, 0.5), (-VGlobals._WorldSpaceCameraPos.xyzx.xyz));
        u_xlat4.x = dot(u_xlat4.xyz, u_xlat4.xyz);
        u_xlat4.x = sqrt(u_xlat4.x);
        u_xlat4.x = u_xlat4.x * VGlobals._EdgeLength;
        u_xlat0.x = u_xlat0.x / u_xlat4.x;
        tessFactor.edgeTessellationFactor[2] = max(u_xlat0.x, 1.0);
    }
    // join_phase3
    {
        u_xlat0.x = tessFactor.edgeTessellationFactor[0] + tessFactor.edgeTessellationFactor[1];
        u_xlat0.x = u_xlat0.x + tessFactor.edgeTessellationFactor[2];
        tessFactor.insideTessellationFactor = u_xlat0.x * 0.333333343;
    }
    controlPoints[mtl_VertexID] = output;
    tessFactors[internalPatchID] = tessFactor;
}
// SHADER_STAGE_HULL_end
// SHADER_STAGE_DOMAIN_begin
struct Mtl_VertexInPostTess
{
    patch_control_point<Mtl_ControlPointIn> cp;
};
struct Mtl_VertexOutPostTess
{
    float4 mtl_Position [[ position ]];
    float2 TEXCOORD0 [[ user(TEXCOORD0) ]];
    float4 TEXCOORD1 [[ user(TEXCOORD1) ]];
    float4 TEXCOORD2 [[ user(TEXCOORD2) ]];
    float4 TEXCOORD3 [[ user(TEXCOORD3) ]];
};
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
[[patch(triangle, 3)]] vertex Mtl_VertexOutPostTess xlatMtlMain(
    constant VGlobals_Type& VGlobals [[ buffer(0) ]],
    sampler sampler_Height [[ sampler (0) ]],
    texture2d<float, access::sample > _Height [[ texture(0) ]] ,
    float3 mtl_TessCoord [[ position_in_patch ]],
    uint patchID [[ patch_id ]],
    device Mtl_ControlPoint *controlPoints [[ buffer(1) ]],
    device MTLTriangleTessellationFactorsHalf *tessFactors [[ buffer(2) ]],
    Mtl_VertexInPostTess input [[ stage_in ]])
{
#pragma clang diagnostic pop
    Mtl_VertexOutPostTess output;
    MTLTriangleTessellationFactorsHalf tessFactor;
    tessFactor = tessFactors[patchID];
    float4 u_xlat0;
    float4 u_xlat1;
    float4 u_xlat2;
    float3 u_xlat3;
    float3 u_xlat4;
    float2 u_xlat13;
    float u_xlat15;
    bool u_xlatb15;
    u_xlat0.xy = mtl_TessCoord.yy * input.cp[1].TEXCOORD2.xy;
    u_xlat0.xy = fma(input.cp[0].TEXCOORD2.xy, mtl_TessCoord.xx, u_xlat0.xy);
    u_xlat0.xy = fma(input.cp[2].TEXCOORD2.xy, mtl_TessCoord.zz, u_xlat0.xy);
    u_xlat0.xy = fma(u_xlat0.xy, VGlobals.unity_DynamicLightmapST.xy, VGlobals.unity_DynamicLightmapST.zw);
    u_xlat1.xy = mtl_TessCoord.yy * input.cp[1].TEXCOORD1.xy;
    u_xlat1.xy = fma(input.cp[0].TEXCOORD1.xy, mtl_TessCoord.xx, u_xlat1.xy);
    u_xlat1.xy = fma(input.cp[2].TEXCOORD1.xy, mtl_TessCoord.zz, u_xlat1.xy);
    u_xlat1.xy = fma(u_xlat1.xy, VGlobals.unity_LightmapST.xy, VGlobals.unity_LightmapST.zw);
    u_xlat2 = mtl_TessCoord.yyyy * input.cp[1].INTERNALTESSPOS0;
    u_xlat2 = fma(input.cp[0].INTERNALTESSPOS0, mtl_TessCoord.xxxx, u_xlat2);
    u_xlat2 = fma(input.cp[2].INTERNALTESSPOS0, mtl_TessCoord.zzzz, u_xlat2);
    u_xlat3.xy = mtl_TessCoord.yy * input.cp[1].TEXCOORD0.xy;
    u_xlat3.xy = fma(input.cp[0].TEXCOORD0.xy, mtl_TessCoord.xx, u_xlat3.xy);
    u_xlat3.xy = fma(input.cp[2].TEXCOORD0.xy, mtl_TessCoord.zz, u_xlat3.xy);
    u_xlat13.xy = u_xlat3.xy * float2(VGlobals._Tile);
    output.TEXCOORD0.xy = fma(u_xlat3.xy, VGlobals._texcoord_ST.xy, VGlobals._texcoord_ST.zw);
    u_xlat3.xyz = _Height.sample(sampler_Height, u_xlat13.xy, level(1.0)).xyz;
    u_xlat4.xyz = mtl_TessCoord.yyy * input.cp[1].NORMAL0.xyz;
    u_xlat4.xyz = fma(input.cp[0].NORMAL0.xyz, mtl_TessCoord.xxx, u_xlat4.xyz);
    u_xlat4.xyz = fma(input.cp[2].NORMAL0.xyz, mtl_TessCoord.zzz, u_xlat4.xyz);
    u_xlat3.xyz = u_xlat3.xyz * u_xlat4.xyz;
    u_xlat2.xyz = fma(u_xlat3.xyz, float3(VGlobals._HeightDisplacement), u_xlat2.xyz);
    u_xlatb15 = 0.0<u_xlat2.z;
    u_xlat1.z = u_xlatb15 ? 9.99999975e-05 : float(0.0);
    u_xlat1.xyz = (VGlobals.unity_MetaVertexControl.x) ? u_xlat1.xyz : u_xlat2.xyz;
    u_xlatb15 = 0.0<u_xlat1.z;
    u_xlat0.z = u_xlatb15 ? 9.99999975e-05 : float(0.0);
    u_xlat0.xyz = (VGlobals.unity_MetaVertexControl.y) ? u_xlat0.xyz : u_xlat1.xyz;
    u_xlat1 = u_xlat0.yyyy * VGlobals.hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat1 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[0], u_xlat0.xxxx, u_xlat1);
    u_xlat0 = fma(VGlobals.hlslcc_mtx4x4unity_MatrixVP[2], u_xlat0.zzzz, u_xlat1);
    output.mtl_Position = u_xlat0 + VGlobals.hlslcc_mtx4x4unity_MatrixVP[3];
    u_xlat0.xyz = u_xlat2.yyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].xyz;
    u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].xyz, u_xlat2.xxx, u_xlat0.xyz);
    u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].xyz, u_xlat2.zzz, u_xlat0.xyz);
    u_xlat0.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[3].xyz, u_xlat2.www, u_xlat0.xyz);
    output.TEXCOORD1.w = u_xlat0.x;
    u_xlat1.y = dot(u_xlat4.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat1.z = dot(u_xlat4.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat1.x = dot(u_xlat4.xyz, VGlobals.hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat0.x = dot(u_xlat1.xyz, u_xlat1.xyz);
    u_xlat0.x = rsqrt(u_xlat0.x);
    u_xlat1.xyz = u_xlat0.xxx * u_xlat1.xyz;
    output.TEXCOORD1.z = u_xlat1.y;
    u_xlat2 = mtl_TessCoord.yyyy * input.cp[1].TANGENT0;
    u_xlat2 = fma(input.cp[0].TANGENT0, mtl_TessCoord.xxxx, u_xlat2);
    u_xlat2 = fma(input.cp[2].TANGENT0, mtl_TessCoord.zzzz, u_xlat2);
    u_xlat3.xyz = u_xlat2.yyy * VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[1].yzx;
    u_xlat3.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[0].yzx, u_xlat2.xxx, u_xlat3.xyz);
    u_xlat2.xyz = fma(VGlobals.hlslcc_mtx4x4unity_ObjectToWorld[2].yzx, u_xlat2.zzz, u_xlat3.xyz);
    u_xlat0.x = u_xlat2.w * VGlobals.unity_WorldTransformParams.w;
    u_xlat15 = dot(u_xlat2.xyz, u_xlat2.xyz);
    u_xlat15 = rsqrt(u_xlat15);
    u_xlat2.xyz = float3(u_xlat15) * u_xlat2.xyz;
    u_xlat3.xyz = u_xlat1.xyz * u_xlat2.xyz;
    u_xlat3.xyz = fma(u_xlat1.zxy, u_xlat2.yzx, (-u_xlat3.xyz));
    u_xlat3.xyz = u_xlat0.xxx * u_xlat3.xyz;
    output.TEXCOORD1.y = u_xlat3.x;
    output.TEXCOORD1.x = u_xlat2.z;
    output.TEXCOORD2.w = u_xlat0.y;
    output.TEXCOORD3.w = u_xlat0.z;
    output.TEXCOORD2.x = u_xlat2.x;
    output.TEXCOORD3.x = u_xlat2.y;
    output.TEXCOORD2.z = u_xlat1.z;
    output.TEXCOORD3.z = u_xlat1.x;
    output.TEXCOORD2.y = u_xlat3.y;
    output.TEXCOORD3.y = u_xlat3.z;
    return output;
}
// SHADER_STAGE_DOMAIN_end
Refreshing native plugins compatible for Editor in 1.83 ms, found 2 plugins.
Preloading 0 native plugins for Editor in 0.00 ms.
Unloading 3375 Unused Serialized files (Serialized files now loaded: 0)
Unloading 20 unused Assets / (0.6 MB). Loaded Objects now: 3928.
Memory consumption went from 136.5 MB to 135.9 MB.
Total: 5.152844 ms (FindLiveObjects: 0.344254 ms CreateObjectMapping: 0.265092 ms MarkObjects: 3.962908 ms  DeleteObjects: 0.579327 ms)

AssetImportParameters requested are different than current active one (requested -> active):
  custom:video-decoder-ogg-theora: a1e56fd34408186e4bbccfd4996cb3dc -> 
  custom:container-muxer-webm: aa71ff27fc2769a1b78a27578f13a17b -> 
  custom:container-demuxer-webm: 4f35f7cbe854078d1ac9338744f61a02 -> 
  custom:video-encoder-webm-vp8: eb34c28f22e8b96e1ab97ce403110664 -> 
  custom:framework-osx-AVFoundation: b23960f63f64bdc6ff669e2cdcee2391 -> 
  custom:audio-encoder-webm-vorbis: bf7c407c2cedff20999df2af8eb42d56 -> 
  custom:container-demuxer-ogg: 62fdf1f143b41e24485cea50d1cbac27 -> 
  custom:video-decoder-webm-vp8: 9c59270c3fd7afecdb556c50c9e8de78 -> 
  custom:audio-decoder-ogg-vorbis: bf7c407c2cedff20999df2af8eb42d56 -> 
